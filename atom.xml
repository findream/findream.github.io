<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>findream&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-18T09:36:38.132Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>findream</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>windbg简明教程（2）</title>
    <link href="http://yoursite.com/2018/07/17/windbg%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B(2)/"/>
    <id>http://yoursite.com/2018/07/17/windbg简明教程(2)/</id>
    <published>2018-07-17T07:02:11.000Z</published>
    <updated>2018-07-18T09:36:38.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-windbg命令"><a href="#第一部分-windbg命令" class="headerlink" title="第一部分 windbg命令"></a>第一部分 windbg命令</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windbg命令一共有三大类：标准命令(命令特别短，容易记忆)，元命令(也是windbg内置命令，一般用”.”表示，也成点命令)，拓展命令(利用windbg目录中的dll文件实现的，使用的时候需要加载需要使用的模块)。</p><h2 id="标准命令"><a href="#标准命令" class="headerlink" title="标准命令"></a>标准命令</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一共有大概15中标准命令：</p><ul><li>控制程序目标执行：<ul><li>g:恢复程序运行</li><li>t：跟踪步入(trace into)</li><li>o：跟踪步过(trace over)</li></ul></li><li>观察修改寄存器：r命令</li><li>内存数据：<ul><li>d：查看</li><li>e：编辑</li><li>s：搜索</li></ul></li><li>观察堆栈：k命令</li><li>断点相关：<ul><li>BP：设置软件断点</li><li>BA：设置硬件断点</li><li>BL：列举断点</li><li>BC：清除断点</li><li>BD：禁止断点</li><li>BE：重启断点</li></ul></li><li>显示控制线程：~命令</li><li>显示控制进程：|命令</li><li>显示表达式：？命令，显示C++表达式：？？命令</li><li>用于汇编：a命令，用户反汇编的u命令</li><li>显示段选择子：dg命令</li><li>检查符号命令：x命令，搜索符号：ln命令，显示模块命令：lm命令，ld：加载符号表</li><li>结束调试：q命令</li></ul><h2 id="源命令"><a href="#源命令" class="headerlink" title="源命令"></a>源命令</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源命令一般以”.”开头，所以也称之为点命令。</p><ul><li>控制调试会话和调试目标：<ul><li>重新开始会话：.restart</li><li>放弃调试目标：.abandon</li><li>创建新进程进行调试：.create</li><li>附加进程进行调试：.attach</li><li>打开转储文件：.opendump</li><li>分离调试目标：.detach</li><li>杀死进程：.kill</li></ul></li><li>管理拓展命令模块：<ul><li>加载模块：.load</li><li>卸载模块：.unload和.unloadall</li><li>显示已经加载的模块：.clain</li></ul></li><li>显示转储调试目标：<ul><li>产生转储目标：.dump</li><li>将原始内存数据写入文件：.writemem</li><li>显示调试会话时间：.time</li><li>显示线程时间：.ttime</li><li>列举任务（进程）列表.tlist</li></ul></li></ul><h2 id="拓展命令"><a href="#拓展命令" class="headerlink" title="拓展命令"></a>拓展命令</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拓展命令保存的windbg安装目录下的dll文件里面，具体使用是”![模块名称].[命令名称] [参数]”。一般使用.load命令需要写入模块的绝对路径，使用.loadby只需要写入模块名称即可！</p><h1 id="第二部分-命令提示符"><a href="#第二部分-命令提示符" class="headerlink" title="第二部分 命令提示符"></a>第二部分 命令提示符</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令提示符号是由一系列文字和大于号组成。他一般标识调试对象的状态或者调试环境的状态。</p><h2 id="调试状态"><a href="#调试状态" class="headerlink" title="调试状态"></a>调试状态</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般存在三个调试状态。繁忙，暂无调试对象和等待。<br>    <img src="https://i.imgur.com/14ktkii.png" alt=""><br>    <img src="https://i.imgur.com/ehKXMyu.png" alt=""><br>    <img src="https://i.imgur.com/fakV1jR.png" alt=""></p><h2 id="调试环境状态"><a href="#调试环境状态" class="headerlink" title="调试环境状态"></a>调试环境状态</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当调试器处于等待状态，则windbg显示的是调试环境状态。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上图：第一个0代表的系统号，如果是0代表的是用户态调试，如果是1代表的是内核态调试</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个0表示的是进程号，是第0号进程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三个数字表示的是线程号。</p><h2 id="切换调试对象"><a href="#切换调试对象" class="headerlink" title="切换调试对象"></a>切换调试对象</h2><ul><li>切换系统号：||<system_index> s</system_index></li><li>切换进程号：|<process_index> s</process_index></li><li>切换线程号：~<thread_index> s<br>  <img src="https://i.imgur.com/9UBWdJV.png" alt=""></thread_index></li></ul><h1 id="第三部分-创建调试会话"><a href="#第三部分-创建调试会话" class="headerlink" title="第三部分 创建调试会话"></a>第三部分 创建调试会话</h1><h2 id="附加已运行进程"><a href="#附加已运行进程" class="headerlink" title="附加已运行进程"></a>附加已运行进程</h2><ul><li>file菜单—&gt;attach to a process</li><li>.attach (多个会话)</li></ul><h2 id="创建新进程"><a href="#创建新进程" class="headerlink" title="创建新进程"></a>创建新进程</h2><ul><li>file菜单</li><li>.create xxx.exe</li></ul><h2 id="本地内核调试"><a href="#本地内核调试" class="headerlink" title="本地内核调试"></a>本地内核调试</h2><ul><li>file菜单—&gt;kernel Debug</li><li>.attach -k</li></ul><h2 id="调试转储文件"><a href="#调试转储文件" class="headerlink" title="调试转储文件"></a>调试转储文件</h2><ul><li>file菜单—&gt;open Crash dump</li><li>.opendump</li></ul><h1 id="第四部分-理解上下文"><a href="#第四部分-理解上下文" class="headerlink" title="第四部分 理解上下文"></a>第四部分 理解上下文</h1><h2 id="会话上下文"><a href="#会话上下文" class="headerlink" title="会话上下文"></a>会话上下文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论用户采用的是本地登录还是远程登录，windows都会为其创建一个会话，这就意味着会话是与windows登录是相关的。<strong>会话上下文只有在内核调试才有作用</strong></p><ul><li><p>!session ：查看系统当前会话<br>  <img src="https://i.imgur.com/ZRY6LUQ.png" alt=""></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">kd&gt; !session </div><div class="line">Sessions on <span class="string">machine:</span> <span class="number">1</span>                    <span class="comment">//系统中有1个会话</span></div><div class="line">Valid <span class="string">Sessions:</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span>                     <span class="comment">//有效的会话ID是0</span></div><div class="line">Current Session <span class="number">1</span>                         <span class="comment">//当前会话是1</span></div></pre></td></tr></table></figure></li><li><p>!session -s[会话ID]：修改当前会话</p><p>   <img src="https://i.imgur.com/sZ8bZej.png" alt=""></p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;改变会话后，默认进程页随之改变成新会话中的进程，因此以前缓存的用户空间不在有效。目前会话上下文只有在内核调试时才有意义。</p><ul><li>!sprocess：查看当前会话内部的所有进程<br>   <img src="https://i.imgur.com/GvtTQuo.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有会话都有一个csrss.exe进程(会话管理器进程)，但是该进程不属于任何一个会话。</li></ul><h2 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道一个32位的系统，进程空间为4GB，其中高2GB是系统区域，低2GB是用户区域，但是windows中，系统区域是共享的，但是用户区域是彼此独立的，也就是说，<strong>在内核调试的时候，需要切换进程上下文，但是在用户调试的时候，不需要切换进程上下文。</strong></p><ul><li>!process 0 0:列出所有进程的基本信息，主要是<strong>EPROCESS信息</strong>，这是切换进程上下文的重要信息。<br>  <img src="https://i.imgur.com/LeyExkU.png" alt=""></li><li>.process [EPROCESS]:切换进程上下文。<br>  <img src="https://i.imgur.com/56vzYoz.png" alt=""></li><li>.context：显示页目录基址<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓页目录基址，每个进程用户空间都是基于一个页目录基址的，同时也存在一个进程多个页目录基址，此时使用.process会更加有效！</li></ul><h2 id="寄存器上下文"><a href="#寄存器上下文" class="headerlink" title="寄存器上下文"></a>寄存器上下文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;寄存器存储的是当前线程的数据值，其他线程都存放在内存中，一般在线程切换(线程上下文)或者产生中断(或异常)(异常上下文)会使用寄存器上下文。</p><ul><li>!process [EPROCESS] ：查看进程所有线程信息<br>  <img src="https://i.imgur.com/V2ZAvqX.png" alt=""></li><li>.thread：查看当前线程(我感觉!thread比.thread显示的信息详细很多)<br>  <img src="https://i.imgur.com/JseZyB4.png" alt=""><br>  <img src="https://i.imgur.com/Bn6URkx.png" alt=""></li><li>.thread [THREAD]：修改线程上下文<br>  <img src="https://i.imgur.com/gbN3KAo.png" alt=""></li></ul><h2 id="局部上下文"><a href="#局部上下文" class="headerlink" title="局部上下文"></a>局部上下文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数的局部变量关系着函数执行的顺序和位置，<strong>在调试时，调试器默认显示的是当前函数所对应的局部上下文。</strong></p><ul><li>.frame：显示局部上下文，如下图：显示当前堆栈对于的函数为<strong>RtlpBreakWithStatusInstruction</strong><br>  <img src="https://i.imgur.com/H8bV8me.png" alt=""></li><li>kn：显示帧栈函数列表<br>  <img src="https://i.imgur.com/7gQzK9C.png" alt=""></li><li>.frame [栈函数编号]：切换局部上下文<br>  <img src="https://i.imgur.com/gOp09Pz.png" alt=""></li></ul><h1 id="第五部分-符号与模块"><a href="#第五部分-符号与模块" class="headerlink" title="第五部分 符号与模块"></a>第五部分 符号与模块</h1><h2 id="查看模块信息"><a href="#查看模块信息" class="headerlink" title="查看模块信息"></a>查看模块信息</h2><ul><li>lm :显示当前进程的模块信息<br>  <img src="https://i.imgur.com/3OJtGsP.png" alt=""><ul><li>v：显示详细信息</li><li>m：过滤指定模块名：lm m k*</li><li>o: 过滤已经加载过的模块<br><img src="https://i.imgur.com/yFIysir.png" alt=""></li></ul></li><li>!lmi:可以指定进程名，但是只显示一个模块<br>  <img src="https://i.imgur.com/K9Wbgmm.png" alt=""></li><li>符号类别<br>  <img src="https://i.imgur.com/5jsZPtd.png" alt=""></li></ul><h2 id="查看和分析符号"><a href="#查看和分析符号" class="headerlink" title="查看和分析符号"></a>查看和分析符号</h2><ul><li>x [选项] 模块名!符号名：查看符号信息(支持正则)<ul><li>/a /A: 按地址升序或者降序显示</li><li>/n /N：按名称—</li><li>/z /Z: 按大小</li><li>/t：显示数据类型</li><li>/v：显示符号的类型和大小</li><li>/p: 省略函数名和括号之间的空格，意义不是很大</li></ul></li></ul><h2 id="查看符号"><a href="#查看符号" class="headerlink" title="查看符号"></a>查看符号</h2><ul><li>ln [指定位置符号]：查看指定位置最近的符号<br>  <img src="https://i.imgur.com/SErTVJv.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一部分-windbg命令&quot;&gt;&lt;a href=&quot;#第一部分-windbg命令&quot; class=&quot;headerlink&quot; title=&quot;第一部分 windbg命令&quot;&gt;&lt;/a&gt;第一部分 windbg命令&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;n
      
    
    </summary>
    
      <category term="windows内核" scheme="http://yoursite.com/categories/windows%E5%86%85%E6%A0%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的脱壳思路</title>
    <link href="http://yoursite.com/2018/07/15/%E5%B8%B8%E8%A7%81%E5%A3%B3%E7%9A%84%E8%84%B1%E5%A3%B3%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/2018/07/15/常见壳的脱壳思路/</id>
    <published>2018-07-15T06:02:11.000Z</published>
    <updated>2018-07-16T16:27:58.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;去年暑假，学习了如何脱壳，但是没有深入的了解这一块的知识，现在花费差不多三天的时间总结一下。<br><a id="more"></a></p><h1 id="UPX壳"><a href="#UPX壳" class="headerlink" title="UPX壳"></a>UPX壳</h1><h2 id="单步法"><a href="#单步法" class="headerlink" title="单步法"></a>单步法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序流程不断向下，然后遇到POPAX，接着一个段间跳转后，直达EOP。</p><ul><li>不断向下寻找EOP<br>  <img src="https://i.imgur.com/F2qs8AH.png" alt=""></li><li>使用LoadPe转储文件<ul><li>1）右键修正镜像大小</li><li>2）完整转储文件</li></ul></li><li>利用导入表修复工具去修复导入表<ul><li>1）修改EOP</li><li>2）自动搜索</li><li>3）获取输入表</li><li>4）显示无效函数</li><li>5）修复转储文件<br><img src="https://i.imgur.com/TsxAAK0.png" alt=""></li></ul></li></ul><h2 id="ESP定律法"><a href="#ESP定律法" class="headerlink" title="ESP定律法"></a>ESP定律法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序在运行真正代码前会解密已经压缩过的代码，解压程序将一些关键代码数据压栈，解压完成后，解压程序在将这些代码出栈。在压栈出栈处下硬件断点，如果执行，程序必定断在解压完成后的代码前。这就是ESP定律法，主要利用程序运行中，栈指针保持平衡。</p><ul><li>寻找使用ESP寄存器变化的代码，寻找ESP对应的内存地址，然后在地址上下硬件断点(dd,hr)。<br>  <img src="https://i.imgur.com/TFc7T9k.png" alt=""></li><li>f7跑起来，到达段间跳转<br>  <img src="https://i.imgur.com/fVBLYoo.png" alt=""></li><li>单步一下直达EOP</li><li>利用上一步脱壳的方法脱壳。</li></ul><h2 id="二次内存镜像法"><a href="#二次内存镜像法" class="headerlink" title="二次内存镜像法"></a>二次内存镜像法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一次将断点设置在代码段reloc资源节区是为了让加壳程序执行完解压过程，第二次将断点设置在代码段是为了寻找EOP。</p><ul><li>在代码段的资源节区设置在访问上设置中断(内存访问断点)<br>  <img src="https://i.imgur.com/MnuhKMh.png" alt=""></li><li>在代码段的text代码节区设置内存访问断点<br>  <img src="https://i.imgur.com/kxyT3Yi.png" alt=""></li><li>直达EOP<br>  <img src="https://i.imgur.com/c7q7czO.png" alt=""></li><li>脱壳</li></ul><h2 id="一步直达法"><a href="#一步直达法" class="headerlink" title="一步直达法"></a>一步直达法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法适用于UPX和部分北斗的壳，这部分壳在压缩的时候，使用了POPAP和PUSHAP这两个指令。</p><h1 id="ASPACK壳"><a href="#ASPACK壳" class="headerlink" title="ASPACK壳"></a>ASPACK壳</h1><h2 id="单步法-1"><a href="#单步法-1" class="headerlink" title="单步法"></a>单步法</h2><h2 id="ESP定律法-1"><a href="#ESP定律法-1" class="headerlink" title="ESP定律法"></a>ESP定律法</h2><h2 id="二次内存镜像法-1"><a href="#二次内存镜像法-1" class="headerlink" title="二次内存镜像法"></a>二次内存镜像法</h2><h2 id="一步直达法-1"><a href="#一步直达法-1" class="headerlink" title="一步直达法"></a>一步直达法</h2><h2 id="模拟跟踪法"><a href="#模拟跟踪法" class="headerlink" title="模拟跟踪法"></a>模拟跟踪法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对ASPACK壳</p><ul><li>寻找含有SFX节区的节区，记录其地址xxxxx</li><li>命令下输入tc eip&lt; xxxxxx<br>  <img src="https://i.imgur.com/XhtxvVD.png" alt=""></li></ul><h2 id="SFX法"><a href="#SFX法" class="headerlink" title="SFX法"></a>SFX法</h2><ul><li>设置调试器SFX选项，设置成第二项：块方式跟踪到真正入口点(也有可能是第三个选项)<br>  <img src="https://i.imgur.com/D4lMMts.png" alt=""></li></ul><h1 id="NSPACK"><a href="#NSPACK" class="headerlink" title="NSPACK"></a>NSPACK</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSPACK又名北斗，是病毒木马经常使用的压缩壳，本身使用vc写的。跳入oep的特征是：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">popad</span></div><div class="line"><span class="keyword">popfd</span></div><div class="line"><span class="keyword">jmp</span> xxxxxxxxx</div></pre></td></tr></table></figure></p><h2 id="单步法-2"><a href="#单步法-2" class="headerlink" title="单步法"></a>单步法</h2><h2 id="ESP定律法-2"><a href="#ESP定律法-2" class="headerlink" title="ESP定律法"></a>ESP定律法</h2><h2 id="二次内存镜像法-2"><a href="#二次内存镜像法-2" class="headerlink" title="二次内存镜像法"></a>二次内存镜像法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意，在使用这个方式的时候，由于NSPACK没有压缩资源，也就是没有资源节区，所以直接在text节区下断即可！</p><h2 id="一步直达法-2"><a href="#一步直达法-2" class="headerlink" title="一步直达法"></a>一步直达法</h2><h2 id="模拟跟踪法-1"><a href="#模拟跟踪法-1" class="headerlink" title="模拟跟踪法"></a>模拟跟踪法</h2><h2 id="SFX法-1"><a href="#SFX法-1" class="headerlink" title="SFX法"></a>SFX法</h2><h1 id="FSG壳"><a href="#FSG壳" class="headerlink" title="FSG壳"></a>FSG壳</h1><h2 id="单步法-3"><a href="#单步法-3" class="headerlink" title="单步法"></a>单步法</h2><h2 id="ESP定律法-3"><a href="#ESP定律法-3" class="headerlink" title="ESP定律法"></a>ESP定律法</h2><h2 id="适用于FSG的特殊方法"><a href="#适用于FSG的特殊方法" class="headerlink" title="适用于FSG的特殊方法"></a>适用于FSG的特殊方法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行完popad后，寻找堆栈窗口第四个参数，那个就是oep。<br>    <img src="https://i.imgur.com/ZeoVgwB.png" alt=""><br>    <img src="https://i.imgur.com/eXhv9s1.png" alt=""></p><h2 id="修复FSG造成的导入表丢失问题"><a href="#修复FSG造成的导入表丢失问题" class="headerlink" title="修复FSG造成的导入表丢失问题"></a>修复FSG造成的导入表丢失问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在完成之前的修复后，发现还是无法运行程序，可以考虑修复导入表信息。</p><ul><li>寻找一个导入函数<br>  <img src="https://i.imgur.com/Idskw32.png" alt=""></li><li>前后都是空的，说明这是导入表信息</li><li>在IAT fix中修复，修改RVA和尺寸<br>  <img src="https://i.imgur.com/LivmMsk.png" alt=""></li></ul><h1 id="PECompact2-X"><a href="#PECompact2-X" class="headerlink" title="PECompact2.X"></a>PECompact2.X</h1><h2 id="单步法-4"><a href="#单步法-4" class="headerlink" title="单步法"></a>单步法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个壳用了一个巧妙的方法，把它解压代码放入异常处理例程中了，我们直接跟入处理例程，程序会自动回到用户领空。</p><h2 id="ESP定律法-4"><a href="#ESP定律法-4" class="headerlink" title="ESP定律法"></a>ESP定律法</h2><h2 id="BP-VirtualFree法1"><a href="#BP-VirtualFree法1" class="headerlink" title="BP VirtualFree法1"></a>BP VirtualFree法1</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>这个方法利用了是解密解压缩过程中，需要对内存进行释放。在此下断的好处是能够在程序解压缩之后断下。</strong></p><ul><li>BP VirtualFree下断点</li><li>shift+f9，忽略异常运行(存在异常)</li><li>取消断点，返回到用户领空</li><li>搜索命令：<strong>push 8000</strong></li><li>F4运行到此处，单步即可</li></ul><h2 id="BP-VirtualFree法2"><a href="#BP-VirtualFree法2" class="headerlink" title="BP VirtualFree法2"></a>BP VirtualFree法2</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一次做代码的恢复，第二次更想是IAT的导入。</p><ul><li>BP VirtualFree下断点</li><li>使用两次shift+F9<ul><li>第一次<br><img src="https://i.imgur.com/W3GxMh1.png" alt=""></li><li>第二次<br><img src="https://i.imgur.com/4PQhrw5.png" alt=""></li></ul></li><li>取消断点</li><li>返回用户空间</li><li>单步<br>  <img src="https://i.imgur.com/usTIm4Q.png" alt=""></li></ul><h2 id="bp-VirtualAlloc法1"><a href="#bp-VirtualAlloc法1" class="headerlink" title="bp VirtualAlloc法1"></a>bp VirtualAlloc法1</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在为解压出来的代码分配内存空间，所以可以对VirtualAlloc下断。</p><ul><li>bp VirtualAlloc</li><li>shift+F9</li><li>ALT+F9返回用户代码</li><li>单步</li></ul><h2 id="PECompact使用的特殊方法-1"><a href="#PECompact使用的特殊方法-1" class="headerlink" title="PECompact使用的特殊方法(1)"></a>PECompact使用的特殊方法(1)</h2><ul><li><p>看程序原始入口点</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">5.0040</span>A86D &gt;  B8 <span class="number">74</span>DE4500     mov eax,qqspirit<span class="number">.0045</span>DE74</div></pre></td></tr></table></figure></li><li><p>bp 45DE74 下断</p></li><li>单步<br>  <img src="https://i.imgur.com/a2asdBV.png" alt=""></li></ul><h2 id="最后一次异常法"><a href="#最后一次异常法" class="headerlink" title="最后一次异常法"></a>最后一次异常法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设程序在第m次运行跑飞，我们查看第m-1次的堆栈情况。</p><ul><li>把所有忽略异常取消</li><li>shift+F9运行程序</li><li>取m-1次的堆栈里面的SE函数</li><li>在SE函数开始处下断。</li><li>单步</li></ul><h1 id="EZIP壳"><a href="#EZIP壳" class="headerlink" title="EZIP壳"></a>EZIP壳</h1><h2 id="单步法-5"><a href="#单步法-5" class="headerlink" title="单步法"></a>单步法</h2><h2 id="ESP定律法-5"><a href="#ESP定律法-5" class="headerlink" title="ESP定律法"></a>ESP定律法</h2><h2 id="修复文件"><a href="#修复文件" class="headerlink" title="修复文件"></a>修复文件</h2><ul><li>和上述一样操作</li><li>重新寻找新的RVA和大小<br>  <img src="https://i.imgur.com/l1Gplvs.png" alt=""></li><li>利用LoadPE进行PE合并</li></ul><h1 id="tElock-0-98b1壳"><a href="#tElock-0-98b1壳" class="headerlink" title="tElock 0.98b1壳"></a>tElock 0.98b1壳</h1><h2 id="最后一次异常法-1"><a href="#最后一次异常法-1" class="headerlink" title="最后一次异常法"></a>最后一次异常法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加壳程序通常在程序执行的开始部分采用SEH技术进行异常的处理<strong>为了获取程序控制权，</strong>而最后一次异常是为了将程序控制权交给程序本身，这就是最后一次异常法的基本原理。需要注意一下方面：</p><ul><li>除了关闭调试器的异常选项，还有关闭插件StrongOd的异常选项</li><li>如果在SE句柄函数下断后，一直断不了的话，可以使用SHIFT+F9断下。<br>  <img src="https://i.imgur.com/uuFUal4.png" alt=""></li></ul><h2 id="模拟跟踪法-2"><a href="#模拟跟踪法-2" class="headerlink" title="模拟跟踪法"></a>模拟跟踪法</h2><ul><li>利用最后一次异常法</li><li>使用模拟跟踪法<ul><li>内存中找SFX段，记录段地址xxxxx</li><li>输入tc eip&lt;xxxxx<br><img src="https://i.imgur.com/aWj4xB2.png" alt=""></li></ul></li></ul><h2 id="两次内存镜像法"><a href="#两次内存镜像法" class="headerlink" title="两次内存镜像法"></a>两次内存镜像法</h2><h1 id="exe32pack壳"><a href="#exe32pack壳" class="headerlink" title="exe32pack壳"></a>exe32pack壳</h1><h2 id="ESP定律法-6"><a href="#ESP定律法-6" class="headerlink" title="ESP定律法"></a>ESP定律法</h2><h1 id="WinUpack壳"><a href="#WinUpack壳" class="headerlink" title="WinUpack壳"></a>WinUpack壳</h1><h2 id="单步法-6"><a href="#单步法-6" class="headerlink" title="单步法"></a>单步法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个壳有个特点：程序在完成代码的解压后，并不直接进入oep，而是执行完IAT的重构后，跳转到判断是否完成IAT重构的判断中，然后执行是否跳转OEP。<br>     <img src="https://i.imgur.com/RDlSEvO.png" alt=""><br>     <img src="https://i.imgur.com/djXvlo2.png" alt=""></p><ul><li>根据跳转的条件判断：eax==0的时候跳转成功。设置条件断点即可！！</li></ul><h1 id="常见语言的入口点"><a href="#常见语言的入口点" class="headerlink" title="常见语言的入口点"></a>常见语言的入口点</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">常见语言的入口点：</div><div class="line"></div><div class="line">VB：</div><div class="line"></div><div class="line">004012D4 &gt;  <span class="number">68</span> <span class="number">54474000</span>     <span class="keyword">push</span> QQ个性网.<span class="number">00404754</span></div><div class="line">004012D9    E8 F0FFFFFF     <span class="keyword">call</span> &lt;<span class="keyword">jmp</span>.&amp;MSVBVM60.#<span class="number">100</span>&gt;</div><div class="line">004012DE    <span class="number">0000</span>            <span class="keyword">add</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>],<span class="built_in">al</span></div><div class="line">004012E0    <span class="number">0000</span>            <span class="keyword">add</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>],<span class="built_in">al</span></div><div class="line">004012E2    <span class="number">0000</span>            <span class="keyword">add</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>],<span class="built_in">al</span></div><div class="line">004012E4    <span class="number">3000</span>            <span class="keyword">xor</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>],<span class="built_in">al</span></div><div class="line">004012E6    <span class="number">0000</span>            <span class="keyword">add</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>],<span class="built_in">al</span></div><div class="line">004012E8    <span class="number">48</span>              <span class="keyword">dec</span> <span class="built_in">eax</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="symbol">delphi:</span></div><div class="line"></div><div class="line">004A5C54 &gt;  <span class="number">55</span>              <span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line">004A5C55    8BEC            <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line">004A5C57    83C4 F0         <span class="keyword">add</span> <span class="built_in">esp</span>,-<span class="number">10</span></div><div class="line">004A5C5A    B8 EC594A00     <span class="keyword">mov</span> <span class="built_in">eax</span>,openpro.004A59EC</div><div class="line"></div><div class="line">BC++:</div><div class="line"></div><div class="line"><span class="number">00401678</span> &gt; /EB <span class="number">10</span>           <span class="keyword">jmp</span> short btengine.0040168A</div><div class="line">0040167A   |<span class="number">66</span>:623A         <span class="keyword">bound</span> <span class="built_in">di</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edx</span>]</div><div class="line"><span class="number">0040167D</span>   |<span class="number">43</span>              <span class="keyword">inc</span> <span class="built_in">ebx</span></div><div class="line">0040167E   |2B2B            <span class="keyword">sub</span> <span class="built_in">ebp</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ebx</span>]</div><div class="line"><span class="number">00401680</span>   |<span class="number">48</span>              <span class="keyword">dec</span> <span class="built_in">eax</span></div><div class="line"><span class="number">00401681</span>   |4F              <span class="keyword">dec</span> <span class="built_in">edi</span></div><div class="line"><span class="number">00401682</span>   |4F              <span class="keyword">dec</span> <span class="built_in">edi</span></div><div class="line"><span class="number">00401683</span>   |4B              <span class="keyword">dec</span> <span class="built_in">ebx</span></div><div class="line"><span class="number">00401684</span>   |<span class="number">90</span>              <span class="keyword">nop</span></div><div class="line"><span class="number">00401685</span>  -|E9 <span class="number">98005400</span>     <span class="keyword">jmp</span> <span class="number">00941722</span></div><div class="line">0040168A   \A1 8B005400     <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[54008B]</div><div class="line">0040168F    C1E0 <span class="number">02</span>         <span class="keyword">shl</span> <span class="built_in">eax</span>,<span class="number">2</span></div><div class="line"><span class="number">00401692</span>    A3 8F005400     <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[54008F],<span class="built_in">eax</span></div><div class="line"><span class="number">00401697</span>    <span class="number">52</span>              <span class="keyword">push</span> <span class="built_in">edx</span></div><div class="line"><span class="number">00401698</span>    6A <span class="number">00</span>           <span class="keyword">push</span> <span class="number">0</span></div><div class="line">0040169A    E8 99D01300     <span class="keyword">call</span> &lt;<span class="keyword">jmp</span>.&amp;KERNEL32.GetModuleHandleA&gt;</div><div class="line">0040169F    8BD0            <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">eax</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">VC++:</div><div class="line"></div><div class="line">0040A41E &gt;  <span class="number">55</span>              <span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line">0040A41F    8BEC            <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line">0040A421    6A FF           <span class="keyword">push</span> -<span class="number">1</span></div><div class="line">0040A423    <span class="number">68</span> C8CB4000     <span class="keyword">push</span> 跑跑排行.0040CBC8</div><div class="line">0040A428    <span class="number">68</span> A4A54000     <span class="keyword">push</span> &lt;<span class="keyword">jmp</span>.&amp;MSVCRT._except_handler3&gt;</div><div class="line">0040A42D    <span class="number">64</span>:A1 <span class="number">00000000</span>  <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:[<span class="number">0</span>]</div><div class="line">0040A433    <span class="number">50</span>              <span class="keyword">push</span> <span class="built_in">eax</span></div><div class="line">0040A434    <span class="number">64</span>:<span class="number">8925</span> <span class="number">0000000</span>&gt;<span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:[<span class="number">0</span>],<span class="built_in">esp</span></div><div class="line">0040A43B    83EC <span class="number">68</span>         <span class="keyword">sub</span> <span class="built_in">esp</span>,<span class="number">68</span></div><div class="line">0040A43E    <span class="number">53</span>              <span class="keyword">push</span> <span class="built_in">ebx</span></div><div class="line">0040A43F    <span class="number">56</span>              <span class="keyword">push</span> <span class="built_in">esi</span></div><div class="line">0040A440    <span class="number">57</span>              <span class="keyword">push</span> <span class="built_in">edi</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">MASM(汇编):</div><div class="line"></div><div class="line">004035C9 &gt;  6A <span class="number">00</span>           <span class="keyword">push</span> <span class="number">0</span></div><div class="line">004035CB    E8 A20A0000     <span class="keyword">call</span> &lt;<span class="keyword">jmp</span>.&amp;kernel32.GetModuleHandleA&gt;</div><div class="line">004035D0    A3 5B704000     <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[40705B],<span class="built_in">eax</span></div><div class="line">004035D5    <span class="number">68</span> <span class="number">80000000</span>     <span class="keyword">push</span> <span class="number">80</span></div><div class="line">004035DA    <span class="number">68</span> 2C754000     <span class="keyword">push</span> <span class="number">11.</span>0040752C</div><div class="line">004035DF    FF35 5B704000   <span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[40705B]</div><div class="line">004035E5    E8 820A0000     <span class="keyword">call</span> &lt;<span class="keyword">jmp</span>.&amp;kernel32.GetModuleFileNameA&gt;</div><div class="line">004035EA    E8 <span class="number">87070000</span>     <span class="keyword">call</span> <span class="number">11.</span>00403D76</div><div class="line">004035EF    6A <span class="number">00</span>           <span class="keyword">push</span> <span class="number">0</span></div><div class="line">004035F1    <span class="number">68</span> 0B364000     <span class="keyword">push</span> <span class="number">11.</span>0040360B</div><div class="line">004035F6    6A <span class="number">00</span>           <span class="keyword">push</span> <span class="number">0</span></div><div class="line">004035F8    6A <span class="number">64</span>           <span class="keyword">push</span> <span class="number">64</span></div><div class="line">004035FA    FF35 5B704000   <span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[40705B]</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;去年暑假，学习了如何脱壳，但是没有深入的了解这一块的知识，现在花费差不多三天的时间总结一下。&lt;br&gt;
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术(9) ---文件下载者病毒</title>
    <link href="http://yoursite.com/2018/07/08/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF(9)--%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E8%80%85/"/>
    <id>http://yoursite.com/2018/07/08/病毒分析技术(9)--文件下载者/</id>
    <published>2018-07-08T06:02:11.000Z</published>
    <updated>2018-07-08T11:09:48.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-目录："><a href="#一-目录：" class="headerlink" title="一 目录："></a>一 目录：</h1><ul><li>1.目录</li><li>2.样本信息</li><li>3.行为分析</li><li>4.样本分析</li><li>5.技术上的总结<a id="more"></a></li></ul><h1 id="二-样本分析"><a href="#二-样本分析" class="headerlink" title="二 样本分析"></a>二 样本分析</h1><ul><li>1.样本名称：sample.WSDump.exe</li><li>2.样本md5：25a1eb3d3f8767a86050d16c226f9912</li><li>3.是否加壳：UPX</li><li>4.编写语言：VC++6.0</li><li>5.样本来源：52pojie<a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=697680&amp;extra=page%3D2%26filter%3Dtypeid%26typeid%3D62" title="52pojie" target="_blank" rel="external">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=697680&amp;extra=page%3D2%26filter%3Dtypeid%26typeid%3D62</a></li></ul><h1 id="三-行为分析"><a href="#三-行为分析" class="headerlink" title="三 行为分析"></a>三 行为分析</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;病毒首先创建互斥体121212，和判断自身文件是否存在，如果存在就启用网络套接字以便执行下一步操作。如果不存在则退出程序。<br>    <img src="https://i.imgur.com/Up7dPhZ.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在执行体函数中，程序首先初始化一些服务控制器的状态信息，然后创建”Net CLR”的互斥体，接着枚举二进制资源，加载hra33.dll这个dll文件，接下来分别创建三个线程，执行不同的操作。<br>    <img src="https://i.imgur.com/UfiDvfo.png" alt=""></p><h1 id="四-样本分析"><a href="#四-样本分析" class="headerlink" title="四 样本分析"></a>四 样本分析</h1><h2 id="ExecuteFun"><a href="#ExecuteFun" class="headerlink" title="ExecuteFun"></a>ExecuteFun</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个函数是程序的主要执行部分。</p><ul><li>设置serviceStatus状态<br>  <img src="https://i.imgur.com/FLYazwS.png" alt=""></li><li>更新资源</li><li>加载hra33.dll这个动态链接库文件</li><li>创建三个线程<br>  <img src="https://i.imgur.com/Kj8IAzt.png" alt=""></li></ul><h2 id="UpdateSource"><a href="#UpdateSource" class="headerlink" title="UpdateSource"></a>UpdateSource</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个函数主要是用于更新资源的，但是由于注册表Services.Net CLR不存在导致函数提前退出。<br>    <img src="https://i.imgur.com/PvxVeFO.png" alt=""></p><ul><li>根据Service注册表下Net CLR文件，创建新文件<br>  <img src="https://i.imgur.com/eO39k7g.png" alt=""></li><li>然后利用跟新资源的方式让其像一个可执行文件<br>  <img src="https://i.imgur.com/A91JbCZ.png" alt=""></li></ul><h2 id="Thread-1"><a href="#Thread-1" class="headerlink" title="Thread_1"></a>Thread_1</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用od跟入Thread_1函数。</p><ul><li>获取本地主机的名称和地址<br>  <img src="https://i.imgur.com/4QH59S2.png" alt=""></li><li>获取本地网关<br>  <img src="https://i.imgur.com/uJrXKab.png" alt=""><br>  <img src="https://i.imgur.com/2JGKjbK.png" alt=""></li><li>这里有个病毒作者的错误，本来他想的是如果主机用户是管理员则执行这个判断，但是他直接引用的是字符串，造成判断无效，所有用户都成立<br>  <img src="https://i.imgur.com/7VJTb4v.png" alt=""></li><li>利用上面得到的本地网关地址，和用户名及密码作为参数传入CreateFileAndExecuteFun(emmmm不像是真的)。<br>  <img src="https://i.imgur.com/dk8oKbI.png" alt=""></li></ul><h3 id="CreateFileAndExecuteFun"><a href="#CreateFileAndExecuteFun" class="headerlink" title="CreateFileAndExecuteFun"></a>CreateFileAndExecuteFun</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序先与远程主机利用ipc$漏洞创建一个共享的命名管道，用IPC$,连接者甚至可以与目标主机建立一个空的连接而无需用户名与密码(当然,对方机器必须开了ipc$共享,否则你是连接不上的)，而利用这个空的连接，连接者还可以得到目标主机上的用户列表(不过负责的管理员会禁止导出用户列表的)。还可以访问共享资源,并使用一些字典工具，进行密码探测，以至于获得更高的权限。然后黑客从服务端可以利用nc等软件向主机发送一个shell。</p><ul><li>创建映射方式，以便后期的文件操作，通过WNetAddConnection2A API将共享目录映射为本地磁盘，之后即可按本地文件形式访问文件，最后断开连接。[参考：<a href="http://blog.sina.com.cn/s/blog_672355630102vnwa.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_672355630102vnwa.html</a>]<br>  <img src="https://i.imgur.com/QtFlY04.png" alt=""></li><li>把本地文件复制到共享文件的C-E盘<br>   <img src="https://i.imgur.com/8jUIjNa.png" alt=""></li></ul><h2 id="Thread-2"><a href="#Thread-2" class="headerlink" title="Thread_2"></a>Thread_2</h2><ul><li>获取本地时间和20130221进行比较，如果大于则创建Thread3这个线程执行，<br>  <img src="https://i.imgur.com/SisWINB.png" alt=""><br>  <img src="https://i.imgur.com/UFTq1t2.png" alt=""></li></ul><h2 id="Thread-3"><a href="#Thread-3" class="headerlink" title="Thread_3"></a>Thread_3</h2><ul><li>判断链接192.168.1.107是否正常<br>  <img src="https://i.imgur.com/2pjgCY0.png" alt=""></li><li>利用switch 通过接收不同的指令，来决定执行的操作，如下图<br>  <img src="https://i.imgur.com/PaexMGd.png" alt=""><ul><li>16号：<br><img src="https://i.imgur.com/y4CgGAP.png" alt=""></li><li>18号：<br><img src="https://i.imgur.com/Sm9E6nA.png" alt=""></li><li>20号：<br><img src="https://i.imgur.com/UQHocaf.png" alt=""></li><li>6号：<br><img src="https://i.imgur.com/J1PSmYE.png" alt=""></li><li>2号：<br><img src="https://i.imgur.com/4o89JYA.png" alt=""></li><li>3号：<br><img src="https://i.imgur.com/2Gjuiwp.png" alt=""></li><li>4号：<br><img src="https://i.imgur.com/viggCZX.png" alt=""><h3 id="IsConnectFun"><a href="#IsConnectFun" class="headerlink" title="IsConnectFun()"></a>IsConnectFun()</h3></li></ul></li><li>解Base编码得到IP地址：192.168.1.107:83<br>  <img src="https://i.imgur.com/S6nBGNh.png" alt=""></li></ul><h3 id="GetInformationFun"><a href="#GetInformationFun" class="headerlink" title="GetInformationFun"></a>GetInformationFun</h3><ul><li>识别出当前系统版本信息<br>  <img src="https://i.imgur.com/UITUJTP.png" alt=""></li><li>读取注册表，查看CPU的频率<br>  <img src="https://i.imgur.com/eALSKAq.png" alt=""><br>  <img src="https://i.imgur.com/aw2pDqE.png" alt=""><br>  <img src="https://i.imgur.com/ddttIFX.png" alt=""></li><li>调用 GlobalMemoryStatusEx获取内存信息，<br>  <img src="https://i.imgur.com/UdVhHfo.png" alt=""></li><li>查看网络适配器情况<br>  <img src="https://i.imgur.com/CCkwTgW.png" alt=""></li></ul><h1 id="五-技术上的总结"><a href="#五-技术上的总结" class="headerlink" title="五 技术上的总结"></a>五 技术上的总结</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调试程序比较难的地方在于跟入CreateThread创建的线程中，因为OD是单线程调试器，所以不会直接跟入创建的线程(子线程)中，我们采用Sleep函数来跟入线程函数中。</p><ul><li>找到线程所指向的函数，在函数开头下断</li><li><p>修改调用CreateThread函数下一条语句，写入如下部分</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">push</span> <span class="number">100000</span>  ;将Slepp的参数压入</div><div class="line"><span class="keyword">Call</span> Kernel32.<span class="built_in">Sleep</span></div></pre></td></tr></table></figure></li><li><p>f8执行，函数自动断在线程函数刚刚下断的地方。</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考自：<a href="https://blog.csdn.net/whatday/article/details/9059281" target="_blank" rel="external">https://blog.csdn.net/whatday/article/details/9059281</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于ipc$的使用，参考自<a href="https://blog.csdn.net/smithjackhack/article/details/78559970" target="_blank" rel="external">https://blog.csdn.net/smithjackhack/article/details/78559970</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据文件：<a href="https://pan.baidu.com/s/1SObNJQLCFQ_FVAZFJ5QaSg" target="_blank" rel="external">https://pan.baidu.com/s/1SObNJQLCFQ_FVAZFJ5QaSg</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-目录：&quot;&gt;&lt;a href=&quot;#一-目录：&quot; class=&quot;headerlink&quot; title=&quot;一 目录：&quot;&gt;&lt;/a&gt;一 目录：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.目录&lt;/li&gt;
&lt;li&gt;2.样本信息&lt;/li&gt;
&lt;li&gt;3.行为分析&lt;/li&gt;
&lt;li&gt;4.样本分析&lt;/li&gt;
&lt;li&gt;5.技术上的总结
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令(8)进程管理</title>
    <link href="http://yoursite.com/2018/06/22/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(8)%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/06/22/Linux常见命令(8)进程管理/</id>
    <published>2018-06-22T07:02:11.000Z</published>
    <updated>2018-07-10T02:11:52.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><a id="more"></a><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><ul><li>ps：查看进程信息<ul><li>-le：查看系统内所有进程的详细信息(-l:显示详细信息，-e:显示所有进程)<br><img src="https://i.imgur.com/fMArD9p.png" alt=""></li><li>aux:查看系统内所有进程的详细信息<br><img src="https://i.imgur.com/nw0N6nW.png" alt=""></li><li>显示的内容介绍<br><img src="https://i.imgur.com/TfRz0CK.png" alt=""><br><img src="https://i.imgur.com/lrpYYuX.png" alt=""></li></ul></li><li>top：查看系统信息<ul><li>-d：指定刷新时间间隔</li><li>P：以CPU使用率排序(默认)</li><li>M：内存使用率</li><li>N：以PID排序<br><img src="https://i.imgur.com/vmkHY7T.png" alt=""><br><img src="https://i.imgur.com/0xRwOhM.png" alt=""><br><img src="https://i.imgur.com/noyZqLF.png" alt=""><br><img src="https://i.imgur.com/ol87Tg3.png" alt=""></li></ul></li><li>pstree：查看进程树<ul><li>-p：罗列进程树<br><img src="https://i.imgur.com/B17g579.png" alt=""><h2 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h2></li></ul></li><li>kill [信号] [PID]：杀死指定进程<br>  <img src="https://i.imgur.com/D5K7o8W.png" alt=""><ul><li>重启进程-1<br><img src="https://i.imgur.com/qIXs2a4.png" alt=""></li><li>正常结束-15</li><li>强制结束-9  </li></ul></li><li>killall [选项] [信号] [PID]：按照进程名杀死进程<br>  <img src="https://i.imgur.com/IE7XUzK.png" alt=""><br>  <img src="https://i.imgur.com/99l2LwH.png" alt=""></li><li>pkill [选项] [信号] [进程名]：按照进程名杀死进程<ul><li>-t 终端号：按照终端号剔除用户</li></ul></li><li>实例1：<ul><li>w：查看登录用户<br><img src="https://i.imgur.com/Z3YvsOk.png" alt=""></li><li>pkill -t [终端号]:剔除用户<br><img src="https://i.imgur.com/iVqIu6a.png" alt=""><h1 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h1></li></ul></li><li>jobs:查看后台命令<br>  <img src="https://i.imgur.com/HgQWJgN.png" alt=""></li><li>fg %工作号：将后台执行的命令恢复到前台<br>  <img src="https://i.imgur.com/TzCBD31.png" alt=""><br>  <img src="https://i.imgur.com/0sJgDGQ.png" alt=""></li><li>bg %工作号：将后台执行的命令恢复到后台<h1 id="系统资源查看"><a href="#系统资源查看" class="headerlink" title="系统资源查看"></a>系统资源查看</h1></li><li>vmstat[间隔] [次数] ：查看系统资源<br>  <img src="https://i.imgur.com/pFSGGZK.png" alt=""></li><li>dmesg：查看开机内核信息(查看软硬件信息)<br>  <img src="https://i.imgur.com/mMiooza.png" alt=""></li><li>free：查看内存使用状态<ul><li>k</li><li>m</li><li>g </li></ul></li><li>uptime：看时间</li><li>uname：查看系统内核信息<ul><li>-a：所有信息</li><li>-r：内核版本</li><li>-s：内核名称<br><img src="https://i.imgur.com/0upkqqI.png" alt=""></li></ul></li><li>file /bin/ls:判断操作系统位数(间接)<br>  <img src="https://i.imgur.com/YGNrOk6.png" alt=""></li><li>lsb_release -a:查看系统发行版本<br>  <img src="https://i.imgur.com/D8jJCIe.png" alt=""></li><li>lsof [选项]：列出进程使用或者打开的文件<ul><li>-c [字符串]：</li><li>-u [uid]:</li><li>-p [pid]:<br><img src="https://i.imgur.com/DAeJlxL.png" alt=""><h1 id="系统定时任务"><a href="#系统定时任务" class="headerlink" title="系统定时任务"></a>系统定时任务</h1></li></ul></li><li>crontab </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程管理&quot;&gt;&lt;a href=&quot;#进程管理&quot; class=&quot;headerlink&quot; title=&quot;进程管理&quot;&gt;&lt;/a&gt;进程管理&lt;/h1&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令(7)shell</title>
    <link href="http://yoursite.com/2018/06/10/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(7)shell%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/06/10/Linux常见命令(7)shell编程/</id>
    <published>2018-06-10T07:02:11.000Z</published>
    <updated>2018-07-10T02:11:27.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-shell中的正则表达式"><a href="#1-shell中的正则表达式" class="headerlink" title="1 shell中的正则表达式"></a>1 shell中的正则表达式</h1><h1 id="2-字符截取命令"><a href="#2-字符截取命令" class="headerlink" title="2 字符截取命令"></a>2 字符截取命令</h1><a id="more"></a><h2 id="常见的字符串截取命令"><a href="#常见的字符串截取命令" class="headerlink" title="常见的字符串截取命令"></a>常见的字符串截取命令</h2><ul><li>grep：截取行</li><li>cut：截取列</li><li>printf</li><li>awk</li><li>sed</li></ul><h2 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h2><ul><li>cut [选项] [文件名]：用于提取指定列的信息<ul><li>-d:指定分割符(默认分隔符是tab)</li><li>-f：指定列号</li></ul></li><li>例子1：-f<br>  <img src="https://i.imgur.com/jQxcAHP.png" alt=""></li><li>例子2：-f -d<br>  <img src="https://i.imgur.com/28qDT9k.png" alt=""></li><li>例子3：为什么会产生这种情况呢？红线画出来的是因为分隔符是空格，默认的是tab<br>  <img src="https://i.imgur.com/cEjiJ4B.png" alt=""></li></ul><h2 id="printf命令"><a href="#printf命令" class="headerlink" title="printf命令"></a>printf命令</h2><ul><li>printf [输出类型/格式(转义符)] 内容<ul><li>%ns:输出n个字符串。默认数据类型</li><li>%ni：输出n个数，但是不进行ASCII转化</li><li>%n.mf:输出浮点数</li></ul></li><li>[建议]：最好应该像C语言一样，给数据类型加上双引号，尤其是在存在多个格式化输出的时候。</li><li>例子1：printf %s 12345<br>  <img src="https://i.imgur.com/OIRafQp.png" alt=""></li><li>例子2：printf %s %s %s \n 1 2 3<br>  <img src="https://i.imgur.com/uNaSyUx.png" alt=""></li></ul><h2 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h2><ul><li>awk [条件1] [‘{动作1}’] [条件2] [‘{动作2}’] [filename]</li><li>例子1：awk ‘{printf $1 “\t” $2 “\n”}’ TestAwk.txt<br>  <img src="https://i.imgur.com/urLV4Vp.png" alt=""></li><li>例子2：<br>  <img src="https://i.imgur.com/WrAuwiS.png" alt=""></li><li>例子3：BEGIN（大写）：用于提前输出 <ul><li>awk ‘BEGIN{print “TEST TEST\n”}{print $2 “\t” $3}’ TestAwk.txt<br><img src="https://i.imgur.com/OwW72HG.png" alt=""></li></ul></li><li>例子4：FS指定分隔符<ul><li>awk ‘BEGIN{FS=”:”}{print $1 “\t” $2}’ /etc/passwd<br><img src="https://i.imgur.com/VzdNYY5.png" alt=""></li></ul></li><li>例子5：END：所有动作执行完毕后，在执行END动作</li></ul><h2 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h2><ul><li>sed [选项] [‘动作’] filename<ul><li>选项-n:只将sed处理过的内容打印出来</li><li>选项-e:允许对结果执行多个sed动作</li><li>选项-i：将修改回写入文件。</li><li>动作’a \’：在当前行后添加一行<br><img src="https://i.imgur.com/dDHWMUi.png" alt=""></li><li>动作’i \’:在当前行插入一行或者多行<br><img src="https://i.imgur.com/lBriTb0.png" alt=""></li><li>动作’c \’:用c后面的字符串替换原来的行<br><img src="https://i.imgur.com/aK6dSpL.png" alt=""></li><li>动作d:删除指定行<br><img src="https://i.imgur.com/HCLWc8n.png" alt=""></li><li>动作p：输出指定行<br><img src="https://i.imgur.com/rw33CCn.png" alt=""><br><img src="https://i.imgur.com/L9ruq8C.png" alt=""></li><li>动作s:字符替换’行范围s/旧子串/新字串g’(不加行范围就是默认全局)<br><img src="https://i.imgur.com/lCCyaOa.png" alt=""></li></ul></li></ul><h1 id="3-字符处理命令"><a href="#3-字符处理命令" class="headerlink" title="3 字符处理命令"></a>3 字符处理命令</h1><h2 id="1-排序命令"><a href="#1-排序命令" class="headerlink" title="1 排序命令"></a>1 排序命令</h2><ul><li>sort [选项] filename<br>  <img src="https://i.imgur.com/Q0ocx9F.png" alt=""><ul><li>-f:忽略大小写<br><img src="https://i.imgur.com/sohnG65.png" alt=""></li><li>-n:按照数值型排序，默认使用的是字符串排序</li><li>-r:反向排序<br><img src="https://i.imgur.com/spocohO.png" alt=""></li><li>-t:指定分隔符，默认使用的是tab</li><li>-k [m,n]:指定字段范围。m-n列<br><img src="https://i.imgur.com/Jba3W5I.png" alt=""></li></ul></li></ul><h2 id="2-统计命令"><a href="#2-统计命令" class="headerlink" title="2 统计命令"></a>2 统计命令</h2><h3 id="wc命令统计"><a href="#wc命令统计" class="headerlink" title="wc命令统计"></a>wc命令统计</h3><ul><li>wc [选项] filename<br>  <img src="https://i.imgur.com/AcfN7sj.png" alt=""><ul><li>-l:统计行数<br><img src="https://i.imgur.com/upAiJJv.png" alt=""></li><li>-w:统计单词数<br><img src="https://i.imgur.com/hnhrT9l.png" alt=""></li><li>-m:统计字符数<br><img src="https://i.imgur.com/BgPnQGC.png" alt=""></li></ul></li></ul><h3 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h3><p>   test命令主要用于文件测试，字符串测试，数值测试</p><ul><li>test [选项] [项目]<ul><li>-e：文件或者目录是否存在</li><li>-f：文件是否存在</li><li>-d：目录是否存在</li><li>-w：写权限</li><li>-r：读权限</li><li>-x：执行权限</li><li>-nt</li><li>-ot</li><li>-ef </li><li>-eq：等于</li><li>-ne：不等于</li><li>-lt：小于</li><li>-le:小于等于</li><li>-gt：大于</li><li>-ge：大于等于</li><li>！：取反，[ ! -f /etc/passwd],主要中间要有间隔</li><li>-a：逻辑与，[-f /etc/passwd -a -d /etc]</li><li>-o：逻辑或，[-f /etc/passwd -o -d /etc]</li></ul></li></ul><h1 id="4-分支与循环"><a href="#4-分支与循环" class="headerlink" title="4 分支与循环"></a>4 分支与循环</h1><h2 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1 if语句"></a>1 if语句</h2><ul><li><p>单if：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>[条件]</div><div class="line">   <span class="keyword">then</span></div><div class="line">      [执行体]</div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure></li><li><p>双if</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>[条件]</div><div class="line">    <span class="keyword">then</span></div><div class="line">       [执行体]</div><div class="line">    <span class="keyword">else</span> </div><div class="line">       [执行体]</div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure></li><li><p>例子：<br>  <img src="https://i.imgur.com/2pPiouT.png" alt=""></p></li><li>多if<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>[条件]</div><div class="line">   <span class="keyword">then</span></div><div class="line">      [执行体]</div><div class="line">   <span class="keyword">elif</span></div><div class="line">      [执行体]</div><div class="line">   <span class="keyword">else</span></div><div class="line">      [执行体]</div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure></li></ul><h2 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> $x <span class="keyword">in</span></div><div class="line">     分支<span class="number">1</span> )</div><div class="line">            [<span class="meta">执行体</span>]</div><div class="line">            ；；</div><div class="line">     分支<span class="number">2</span> ）</div><div class="line">            [<span class="meta">执行体</span>]</div><div class="line">            ；；</div><div class="line">     分支* )</div><div class="line">            [<span class="meta">执行体</span>]</div><div class="line">            ；；</div><div class="line">esac</div></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><ul><li><p>No 1 </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for i in <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></div><div class="line">     do </div><div class="line">         [循环体]  # i依次遍历<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span></div><div class="line">     done</div></pre></td></tr></table></figure></li><li><p>例子1：<br>  <img src="https://i.imgur.com/SMbOcVN.png" alt=""></p></li><li><p>No 2：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>((<span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;<span class="number">100</span>;<span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>))</div><div class="line">   do </div><div class="line">      [循环体]</div><div class="line">   done</div></pre></td></tr></table></figure></li><li><p>例子2：<br>  <img src="https://i.imgur.com/YUwr4Bu.png" alt=""></p></li></ul><h2 id="while和until循环"><a href="#while和until循环" class="headerlink" title="while和until循环"></a>while和until循环</h2><ul><li><p>while循环：判断条件为真，循环执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>[ 测试条件 ]</div><div class="line">    <span class="keyword">do</span> </div><div class="line">       [循环体]</div><div class="line">    <span class="keyword">done</span></div></pre></td></tr></table></figure></li><li><p>例子 1<br>  <img src="https://i.imgur.com/OZLpAgc.png" alt=""></p></li><li><p>until循环：判断条件为假，循环执行</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">until <span class="string">[ 测试条件 ]</span></div><div class="line">    do </div><div class="line">         <span class="string">[循环体]</span></div><div class="line">    done</div></pre></td></tr></table></figure></li><li><p>例子2<br>  <img src="https://i.imgur.com/FGskRVO.png" alt=""></p></li></ul><h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><ul><li>break[n]:n指的是跳出n层循环，默认是1</li><li>cntinue[n]:n指的是跳出n层循环，默认是1</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-shell中的正则表达式&quot;&gt;&lt;a href=&quot;#1-shell中的正则表达式&quot; class=&quot;headerlink&quot; title=&quot;1 shell中的正则表达式&quot;&gt;&lt;/a&gt;1 shell中的正则表达式&lt;/h1&gt;&lt;h1 id=&quot;2-字符截取命令&quot;&gt;&lt;a href=&quot;#2-字符截取命令&quot; class=&quot;headerlink&quot; title=&quot;2 字符截取命令&quot;&gt;&lt;/a&gt;2 字符截取命令&lt;/h1&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>注册表</title>
    <link href="http://yoursite.com/2018/06/04/%E3%80%8AWindows%20Internals%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/06/04/《Windows Internals》第四章_注册表/</id>
    <published>2018-06-04T07:02:11.000Z</published>
    <updated>2018-06-09T09:26:59.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注册表用法"><a href="#注册表用法" class="headerlink" title="注册表用法"></a>注册表用法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册表的配置数据主要在四个时间点被修改。</p><ul><li>由于引导配置数据库(BCD)存在于注册表储巢中，所以在初始化引导过程中，引导加载器需要读入配置信息和引导设备驱动程序的列表。</li><li>在内核引导的过程中，内核要读取系统的相关设置信息(存放在注册表中)，这些信息包含了加载的驱动程序，系统组件，已经系统行为的配置。</li><li>在windows登录过程中，Explorer和windows组件读取用户配置信息。</li><li>应用程序启动过程中，读取系统全局配置信息。</li><li>其他时间：在调用API修改注册表的时候，注册表也提供异步回调机制，这是优先接收注册表变化的方法。<strong>系统不建议使用轮询的方法检测注册表的修改。</strong><a id="more"></a><h2 id="注册表的数据类型"><a href="#注册表的数据类型" class="headerlink" title="注册表的数据类型"></a>注册表的数据类型</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册表的结构类似于一个文件系统的结构。只不过注册表包含的是键和值，一般的我们把键看做目录，值看做文件。例如\trade\mark中，trade表示的是键，mark表示的是值。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册表的值有多种数据类型，常见的数据类型是REG_DWORD(存储大部分的整形和布尔类型)，REG_BINARY(存储的是超过32位的整数类型，例如加密口令)，REG_SZ(存储的是字符串)。<strong>其中还有特殊的是REG_LINK，</strong>REG_LINK存储的是一个链接类型，标明这个数据类型可以让一个键指向另一个键。例如\ROOT1\LINK指向的是ROOT2\REGKEY，其中REGKEY存储的值是REGVALUE，则对于REGVALUE有两个路径可以访问：\ROOT1\LINK\REGVALUE或者\ROOT2\REGKEY\REGVALUE。<strong>windows中六个注册表根有三个是链接，他们指向的是三个非连接的跟腱中的子健。</strong></p><h2 id="注册表的逻辑结构"><a href="#注册表的逻辑结构" class="headerlink" title="注册表的逻辑结构"></a>注册表的逻辑结构</h2><h3 id="HKEY-CURRENT-USER"><a href="#HKEY-CURRENT-USER" class="headerlink" title="HKEY_CURRENT_USER:"></a>HKEY_CURRENT_USER:</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存储和当前登录用户相关的数据(包含用户参数和软件配置信息)，指向当前登录用户的用户轮廓，位于磁盘下的\Users\用户名\Ntuser.dat文件中。是HKEY_USERS下对应的当前登录用户的子健。**当一个用户登录系统，首先会创建HKCU，然后把HKCU映射到HKEY_USERS/<currentuser>中<br>     <img src="https://i.imgur.com/Ej3n9P0.png" alt=""><br>     <img src="https://i.imgur.com/8yfnMK3.png" alt=""><br>     <img src="https://i.imgur.com/nUG2rw4.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是关于HKEY_CURRENT_USER的子健信息。<br>    <img src="https://i.imgur.com/4Ffc53E.png" alt=""></currentuser></p><h3 id="HKEY-USERS："><a href="#HKEY-USERS：" class="headerlink" title="HKEY_USERS："></a>HKEY_USERS：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含所有已加载用户轮廓的子健，他不是一个链接。但是他包含了一个名为HKU.DEFAULTD的链接。当有新用户登录的时候，系统依赖Users\Default的轮廓为该用户创建一个新的轮廓。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册表HKLM\Software\Microsoft\Windows Nt\CurrentVersion\ProfileList\ProfilesDirectory中的ProfilesDirectory保存的是系统中存在的用户轮廓列表。每个轮廓存放在ProfileList键下面。<br>     <img src="https://i.imgur.com/FaGauvF.png" alt=""><br>     <img src="https://i.imgur.com/RwudfZI.png" alt=""><br>     <img src="https://i.imgur.com/qn84dGf.png" alt=""></p><h3 id="HKEY-CLASS-ROOT："><a href="#HKEY-CLASS-ROOT：" class="headerlink" title="HKEY_CLASS_ROOT："></a>HKEY_CLASS_ROOT：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含的是文件关联和COM注册信息以及UAC虚拟化注册表根。<strong>其中HKCR下的根键保存的是文件拓展名关联，UAC虚拟化注册表位于VirtualStore键下面，其他键包含的是注册在系统中的COM对象的详细配置信息</strong><br>    <img src="https://i.imgur.com/zVBGxJo.png" alt=""><br>    <img src="https://i.imgur.com/5nvD88p.png" alt=""><br>    <img src="https://i.imgur.com/b6R9joX.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HKCR是由HKLM\SOFTWARE\Classes(系统全局)和HKEY_USERS\<sid>\SOFTWARE\Classes(用户)组合的视图。将用户注册表信息和系统全局注册表信息分开，保证了系统的安全性，避免非特权用户访问并修改系统全局信息。</sid></p><h3 id="HKEY-LOCAL-MACHINE"><a href="#HKEY-LOCAL-MACHINE" class="headerlink" title="HKEY_LOCAL_MACHINE:"></a>HKEY_LOCAL_MACHINE:</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含了机器的全局设置，包括了BCD00000000,COMPONENTS,HARDWARE,SAM,SECURITY,SOFTWARE,SYSTEM,该注册表不是一个链接。<br>    <img src="https://i.imgur.com/CdpuB0E.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HKLM\BCD0000000保存的是引导配置数据库，这是作为一个注册表储巢加载进来的。<br>     <img src="https://i.imgur.com/vullJ3m.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HKLM\CONPONENTS保存的是关于CBS(基于组件的服务)，当系统组件需要更新，安装或者卸载的时候，保存在这个键下的信息将要被用到。当然为了优化系统资源，CBS栈在服务一个请求的时候只是被动态的加载到系统。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\HKLM\HARDWARE维护了当前系统中的遗留硬件，以及一些硬件设备到其驱动程序的映射关系描述信息。<br>     <img src="https://i.imgur.com/GOH6nDp.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HKLM\SAM存放的是用户账户和组的信息，SAM的安全描述符一般被设置成管理员无法访问(system可以访问)<br>     <img src="https://i.imgur.com/cSYnQsX.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HKLM\SECURITY存放的是系统全局的安全设置和用户权限分配，HKLM\SAM是HKLM\SECURITY\SAM下的SERURITY子键，默认情况下无法查看HKLM\SECURITY和HKLM\SAM的内容<br>     <img src="https://i.imgur.com/jhyfMBE.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HKLM\OTFWARE存放是系统全局配置信息和第三方应用程序的全局设置。<br>     <img src="https://i.imgur.com/bZGzLA6.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HKLM\SYSTEM保存的是引导系统所需要的全局信息，例如下载的驱动程序或者启动的服务。这些信息对于系统的启动十分重要。<br>     <img src="https://i.imgur.com/VYoWIov.png" alt=""></p><h3 id="HKEY-CURRENT-CONFIG"><a href="#HKEY-CURRENT-CONFIG" class="headerlink" title="HKEY_CURRENT_CONFIG:"></a>HKEY_CURRENT_CONFIG:</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保存的是当前的硬件配置信息，是HKLM\SYSTEM\CurrentControlSet\Hardware Profiles\Current下的子健，</p><h3 id="HKEY-PERFORMACHE-DATA"><a href="#HKEY-PERFORMACHE-DATA" class="headerlink" title="HKEY_PERFORMACHE_DATA:"></a>HKEY_PERFORMACHE_DATA:</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该项是一个性能计数器，不是一个链接。在注册表编辑器中无法找到，只有试用RegQueryValueEx函数去获取性能信息。<strong>性能信息并不是保存在注册表中，RegQueryValueEx函数只是利用该键获得从性能数据提供者那里提供的信息</strong></p><h2 id="事务性注册表"><a href="#事务性注册表" class="headerlink" title="事务性注册表"></a>事务性注册表</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>事务性注册表的封闭性：</strong>当使用RegCreateKeyTransacted以实物的方式创建一个注册表的时候，之后的所有操作必须是以事物方式运行，而且此过程是对事物外部不可见。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>事物的隔离性：</strong>事物是相互隔离的，在一个事物内部所做的修改，在该事物被提交之前，在该事物外部是不可见的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>事物的低优先级：</strong>一个非事物任务的写会导致事物内部的写操作失败。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>提交生效：</strong>事物只有提交之后才会立即生效。</p><h2 id="注册表的内部机理"><a href="#注册表的内部机理" class="headerlink" title="注册表的内部机理"></a>注册表的内部机理</h2><h3 id="储巢"><a href="#储巢" class="headerlink" title="储巢"></a>储巢</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册表是一组称为储巢的独立文件，每一个储巢包含了一个注册表数，有一个键作为该树的根，子键或者值存储在根的下面，但是注册表编辑器所显示的根键和储巢里面的根键不是相互关联的。<strong>除了用户轮廓，其他轮廓路径都被编码进了配置管理器中，当加载储巢的时候，配置管理器会在HKLM\SYSTEM\CurrentControlSet\Control\Hivelist子键下记录每个储巢的路径。</strong>并将这些储巢链接起来，以便建立其注册表结构。<br>    <img src="https://i.imgur.com/qPYSrU9.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下图是注册表路径和储巢路径对应图，其中有一项是易失储巢。标明这个储巢是易变的，并没有对应的文件，由操作系统在内存中加载并且管理。其中著名的例子就是HKLM\HARDWARE.这个储巢保存的系统物理设备和设备资源的信息。<strong>每次引导的时候会进行资源分配和硬件检测。</strong><br>    <img src="https://i.imgur.com/HvKm3TD.png" alt=""></p><h3 id="注册表符号链接"><a href="#注册表符号链接" class="headerlink" title="注册表符号链接"></a>注册表符号链接</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册表符号链接一个种使配置管理器将键与键链接起来的<strong>特殊键，</strong>符号链接在外部是利用CreateRegKey函数指定REG_GREATE_LINK标志创建起来的，</p><h3 id="储巢结构"><a href="#储巢结构" class="headerlink" title="储巢结构"></a>储巢结构</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们从全局来把握一下注册表的储巢结构，在了解储巢结构之前，我们需要了解一下几个概念。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>块：</strong>配置管理器从逻辑上将一个储巢分成一些称为块的分配单元。每个块的大小是4096字节。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>基本块：</strong>一个储巢的第一个块称为基本块，基本块包含了有关该储巢的全局信息。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>巢室：</strong>一个巢室包含了所存储的注册表键的基本数据结构，之所以称为巢室，是因为巢室是存储注册表键的内容的容器。一个巢室包含了一个键，一个值，一个安全描述符，一列子键，一列子值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>巢箱：</strong>新巢室正好拓展到下一个块或者页面的大小，说白了就是巢室的箱子(多个巢室组成了巢箱)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>巢室索引：</strong> 详见巢室映射表<br>    <img src="https://i.imgur.com/9GzNlgc.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;巢室开始的四个字节表示的是该巢室数据类型。一共有五种巢室的基本数据类型：键巢室，值巢室，子键列表巢室，值列表巢室，安全描述符巢室。</p><ul><li>键巢室：包含了一个注册表键的巢室</li><li>值巢室：包含了一个键的值得巢室</li><li>子键列表巢室：包含了<strong>许多子键巢室的索引</strong>的巢室</li><li>值列表巢室：包含了<strong>许多值巢室的索引</strong>的巢室，是父键的所有值</li><li>安全描述符巢室：包含了一个安全描述符的巢室<br>   <img src="https://i.imgur.com/W352lyG.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>windows选择利用巢箱的结构来拓展巢室</strong>，当一个巢室要被添加到储巢的时候，系统创建一个巢箱来容纳巢室，这导致了系统分配和释放巢箱的频率比使用巢室要慢的多。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置管理器会将储巢整个读入，同时也会象磁盘碎片管理的方式，合并诸多空巢箱，当储巢尾部的巢箱变为空闲的时候才会缩短该储巢。</li></ul><h3 id="巢室映射表"><a href="#巢室映射表" class="headerlink" title="巢室映射表"></a>巢室映射表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册表被映射如内存是不连续的，配置管理器采用的是和虚拟内存映射到物理内存地址的策略。<strong>和windows的分段内存管理机制一样</strong>，windows使用连续的内存代表一个巢箱，这样一个巢箱内部所有的巢室都出现在一个视图中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windows使用<strong>巢室索引</strong>来实现映射策略，巢室索引有三个域：目录索引，表索引，字节偏移。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【重点】①windows将目录索引解释成一个巢室的映射表目录的索引，也就是说根据这个索引才能找到巢室映射目录表的地址。②巢室映射表目录有1024个，每个目录项指向的是一个映射表，利用第二个域–表索引，根据巢室映射表找到巢室所在巢箱的偏移，③根据第三个域找到巢室的偏移。</p><h3 id="注册表名字空间和操作"><a href="#注册表名字空间和操作" class="headerlink" title="注册表名字空间和操作"></a>注册表名字空间和操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>键对象：</strong>当打开或创建一个注册表键的时候，对象管理器会给应用程序分配一个句柄让程序通过此句柄引用该键。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>键控制块：</strong>每次打开注册表键的时候，配置管理器也会分配一个键控制块，用于保存键名称，巢室索引，和一个标志(表示键的句柄被关闭后，配置管理器是否应该删除该键句柄所引用的键巢室)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系：键对象指向他对应的键控制块，如果两个应用程序打开一个注册表键的时候，会产生两个不同的键对象，这两个键对象指向同一个键控制块，(因为键控制块包含了键的名称等唯一信息)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用键控制块的引用个数来决定是否删除该键控制块，如果引用计数为0的时候，说明这个键控制块不再被需要了。</p><h3 id="【实验】查看键控制块"><a href="#【实验】查看键控制块" class="headerlink" title="【实验】查看键控制块"></a>【实验】查看键控制块</h3><ul><li>!reg openkeys:查看系统中已经被分配的键控制块。<br>  <img src="https://i.imgur.com/QeXMV6u.png" alt=""></li><li>!reg findkcb:查看一个已经打开的kcb<br>  <img src="https://i.imgur.com/vH16dDH.png" alt=""></li><li>!reg kcb:查看具体的kcb内容<br>  <img src="https://i.imgur.com/Q9CaD3C.png" alt=""></li></ul><h3 id="稳定可靠的存储"><a href="#稳定可靠的存储" class="headerlink" title="稳定可靠的存储"></a>稳定可靠的存储</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用双日志方案，将脏数据累加写入同一个日志文件，如果不发生错误，只写入某一个文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于写脏数据到日志文件，使用了双序列号模式，延时写出器首先更新日志文件一个序列号，然后在写入脏数据，此时发生意外，系统在引导时，配置管理器肯定会注意到序列号不一致，触发储巢回滚。如果写入日志成功，在写另一个序列号。保证两个序列号一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;注册表用法&quot;&gt;&lt;a href=&quot;#注册表用法&quot; class=&quot;headerlink&quot; title=&quot;注册表用法&quot;&gt;&lt;/a&gt;注册表用法&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;注册表的配置数据主要在四个时间点被修改。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于引导配置数据库(BCD)存在于注册表储巢中，所以在初始化引导过程中，引导加载器需要读入配置信息和引导设备驱动程序的列表。&lt;/li&gt;
&lt;li&gt;在内核引导的过程中，内核要读取系统的相关设置信息(存放在注册表中)，这些信息包含了加载的驱动程序，系统组件，已经系统行为的配置。&lt;/li&gt;
&lt;li&gt;在windows登录过程中，Explorer和windows组件读取用户配置信息。&lt;/li&gt;
&lt;li&gt;应用程序启动过程中，读取系统全局配置信息。&lt;/li&gt;
&lt;li&gt;其他时间：在调用API修改注册表的时候，注册表也提供异步回调机制，这是优先接收注册表变化的方法。&lt;strong&gt;系统不建议使用轮询的方法检测注册表的修改。&lt;/strong&gt;
    
    </summary>
    
      <category term="windows系统" scheme="http://yoursite.com/categories/windows%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>GCTF解析</title>
    <link href="http://yoursite.com/2018/05/26/GCTF/"/>
    <id>http://yoursite.com/2018/05/26/GCTF/</id>
    <published>2018-05-26T06:02:11.000Z</published>
    <updated>2018-05-26T09:22:36.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h1><h2 id="Hackme"><a href="#Hackme" class="headerlink" title="Hackme"></a>Hackme</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个ELF的逆向题，IDA打开，发现流程如下：输入字符串，然后经过一个函数的加密，利用这个函数返回出来的数值，对该数值以22取余数，得到索引，得到Hex数组里面的数据，然后经过第一个循环得到V16，再用V16和输入的字符串异或，然后把结果和Hex比较即可。<a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">__int64 __<span class="function">fastcall <span class="title">sub_400F8E</span><span class="params">(__int64 a1, __int64 a2)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  __int64 v2; <span class="comment">// rdx</span></div><div class="line">  __int64 v3; <span class="comment">// rcx</span></div><div class="line">  __int64 v4; <span class="comment">// r8</span></div><div class="line">  __int64 v5; <span class="comment">// r9</span></div><div class="line">  <span class="keyword">int</span> v6; <span class="comment">// eax</span></div><div class="line">  <span class="keyword">char</span> InputString[<span class="number">136</span>]; <span class="comment">// [rsp+10h] [rbp-B0h]</span></div><div class="line">  <span class="keyword">int</span> v9; <span class="comment">// [rsp+98h] [rbp-28h]</span></div><div class="line">  <span class="keyword">char</span> v10; <span class="comment">// [rsp+9Fh] [rbp-21h]</span></div><div class="line">  <span class="keyword">int</span> v11; <span class="comment">// [rsp+A0h] [rbp-20h]</span></div><div class="line">  <span class="keyword">unsigned</span> __int8 flag; <span class="comment">// [rsp+A6h] [rbp-1Ah]</span></div><div class="line">  <span class="keyword">char</span> Hex; <span class="comment">// [rsp+A7h] [rbp-19h]</span></div><div class="line">  <span class="keyword">int</span> v14; <span class="comment">// [rsp+A8h] [rbp-18h]</span></div><div class="line">  <span class="keyword">int</span> v15; <span class="comment">// [rsp+ACh] [rbp-14h]</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v16; <span class="comment">// [rsp+B0h] [rbp-10h]</span></div><div class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+B4h] [rbp-Ch]</span></div><div class="line">  _BOOL4 v18; <span class="comment">// [rsp+B8h] [rbp-8h]</span></div><div class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+BCh] [rbp-4h]</span></div><div class="line">  Printf((<span class="keyword">unsigned</span> __int64)<span class="string">"Give me the password: "</span>);</div><div class="line">  <span class="built_in">scanf</span>((__int64)<span class="string">"%s"</span>);</div><div class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; InputString[i]; ++i )</div><div class="line">    ;</div><div class="line">  v18 = i == <span class="number">22</span>;</div><div class="line">  v17 = <span class="number">10</span>;</div><div class="line">  <span class="keyword">do</span></div><div class="line">  &#123;</div><div class="line">    v6 = sub_406D90((__int64)<span class="string">"%s"</span>, (__int64)InputString, v2, v3, v4, v5);<span class="comment">// 固定数据</span></div><div class="line">    v3 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(v6 % <span class="number">22</span>);               <span class="comment">// 对22取余</span></div><div class="line">    v14 = v6 % <span class="number">22</span>;                              <span class="comment">// 对22取余</span></div><div class="line">    v16 = <span class="number">0</span>;                                    <span class="comment">// 初始化为0</span></div><div class="line">    Hex = Hex_Arr[v6 % <span class="number">22</span>];                     <span class="comment">// 取16进制数组里面的值</span></div><div class="line">    flag = InputString[v6 % <span class="number">22</span>];</div><div class="line">    v11 = v6 % <span class="number">22</span> + <span class="number">1</span>;                          <span class="comment">// 对22取余后+1，作为循环控制条件</span></div><div class="line">    v15 = <span class="number">0</span>;                                    <span class="comment">// 从0开始计数</span></div><div class="line">    <span class="keyword">while</span> ( v15 &lt; v11 )                         <span class="comment">// 数值运算</span></div><div class="line">    &#123;</div><div class="line">      ++v15;</div><div class="line">      v16 = <span class="number">1828812941</span> * v16 + <span class="number">12345</span>;</div><div class="line">    &#125;</div><div class="line">    v2 = v16;                                   <span class="comment">// 运算结果交给V2</span></div><div class="line">    v10 = v16 ^ flag;</div><div class="line">    <span class="keyword">if</span> ( Hex != ((<span class="keyword">unsigned</span> __int8)v16 ^ flag) ) <span class="comment">// 运算十次，只要相等就行了</span></div><div class="line">      v18 = <span class="number">0</span>;                                  <span class="comment">// 关于写注册机：根据上面的flag，我们知道：只需要Hex==v16^flag就行，</span></div><div class="line">                                                <span class="comment">// 由于异或是可逆的，所以flag=v16^Hex</span></div><div class="line">    --v17;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> ( v17 );                                <span class="comment">// 十次循环</span></div><div class="line">  <span class="keyword">if</span> ( v18 )</div><div class="line">    v9 = Printf((<span class="keyword">unsigned</span> __int64)<span class="string">"Congras\n"</span>);</div><div class="line">  <span class="keyword">else</span></div><div class="line">    v9 = Printf((<span class="keyword">unsigned</span> __int64)<span class="string">"Oh no!\n"</span>);</div><div class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sub_406D90返回的结果却是很麻烦，可以推测他应该是一个固定的数据。我们数了一下，Hex_Arr数组的长度是22，然后又对22取余，我们可以推测出，这应该是一个长度转化的函数。写出注册机：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">char *Hex_Arr="<span class="tag">\<span class="name">x</span></span>5f<span class="tag">\<span class="name">xf</span></span>2<span class="tag">\<span class="name">x</span></span>5e<span class="tag">\<span class="name">x</span></span>8b<span class="tag">\<span class="name">x</span></span>4e<span class="tag">\<span class="name">x</span></span>0e<span class="tag">\<span class="name">xa</span></span>3<span class="tag">\<span class="name">xaa</span></span><span class="tag">\<span class="name">xc</span></span>7<span class="tag">\<span class="name">x</span></span>93<span class="tag">\<span class="name">x</span></span>81<span class="tag">\<span class="name">x</span></span>3d<span class="tag">\<span class="name">x</span></span>5f<span class="tag">\<span class="name">x</span></span>74<span class="tag">\<span class="name">xa</span></span>3<span class="tag">\<span class="name">x</span></span>09"</div><div class="line">        "<span class="tag">\<span class="name">x</span></span>91<span class="tag">\<span class="name">x</span></span>2b<span class="tag">\<span class="name">x</span></span>49<span class="tag">\<span class="name">x</span></span>28<span class="tag">\<span class="name">x</span></span>93<span class="tag">\<span class="name">x</span></span>67"; </div><div class="line">int main(int agrv,char* agrc[])</div><div class="line">&#123;</div><div class="line">int i;</div><div class="line">for(i=0;i&lt;22;i++)</div><div class="line">&#123;</div><div class="line">char Hex=Hex_Arr[i];</div><div class="line">int v11=i+1;</div><div class="line">int v15=0;</div><div class="line">int v16=0;</div><div class="line">char flag;</div><div class="line">while ( v15 &lt; v11 )                         // 数值运算</div><div class="line">    &#123;</div><div class="line">      ++v15;</div><div class="line">      v16 = 1828812941 * v16 + 12345;</div><div class="line">    &#125;</div><div class="line">flag=char(v16)^Hex</div><div class="line">    printf("<span class="comment">%c",);</span></div><div class="line">&#125;</div><div class="line">printf("<span class="tag">\<span class="name">n</span></span>");</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="test-pyc"><a href="#test-pyc" class="headerlink" title="test.pyc"></a>test.pyc</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分别利用<a href="http://tools.bugscaner.com/decompyle/和https://tool.lu/pyc这两个网站对pyc文件进行反编译，得到如下效果。我们发现加密函数应该第二个代码块" target="_blank" rel="external">http://tools.bugscaner.com/decompyle/和https://tool.lu/pyc这两个网站对pyc文件进行反编译，得到如下效果。我们发现加密函数应该第二个代码块</a>,<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">str = <span class="string">'jYygTOy'</span> + <span class="string">'cmNycWNyYmM1Ujf'</span></div><div class="line"><span class="keyword">import</span> base64</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flag1</span><span class="params">()</span>:</span></div><div class="line">    code = str[::<span class="number">-3</span>]</div><div class="line">    result = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> code:</div><div class="line">        ss = ord(i) - <span class="number">1</span></div><div class="line">        result += chr(ss)</div><div class="line">    <span class="keyword">print</span> result[::<span class="number">-1</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flag2</span><span class="params">()</span>:</span></div><div class="line">    code = str[::<span class="number">-2</span>]</div><div class="line">    result = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> code:</div><div class="line">        ss = ord(i) - <span class="number">1</span></div><div class="line">        result += chr(ss)</div><div class="line">    <span class="keyword">print</span> result[::<span class="number">-2</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flag3</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line">// WARNING: Decompyle incomplete</div><div class="line">flag1()</div></pre></td></tr></table></figure></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flag3</span><span class="params">()</span></span><span class="symbol">:</span></div><div class="line">    code = str[<span class="symbol">:</span><span class="symbol">:-</span><span class="number">1</span>]     <span class="comment">#[开始：结束：步长],倒叙排序</span></div><div class="line">    result = <span class="string">''</span>          <span class="comment">#初始化result</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="symbol">code:</span></div><div class="line">        ss = ord(i) - <span class="number">1</span>   <span class="comment"># ASCII码-1</span></div><div class="line">        result += chr(ss)  <span class="comment">#转化为字符</span></div><div class="line">    print result[<span class="symbol">:</span><span class="symbol">:-</span><span class="number">3</span>]</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用另外一个编译器，得到一个字符串，结合上面的反汇编代码，发现，这是一个base64加密<br>    <img src="https://i.imgur.com/pFmT3Ws.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;得到流程是：一个字符串经过base64加密，然后逆序对每个字符串-1，输出。得到flag</p><h2 id="Debug-exe"><a href="#Debug-exe" class="headerlink" title="Debug.exe"></a>Debug.exe</h2><p><a href="https://findream.github.io/2017/11/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E4%BE%8B%E9%A2%98/" target="_blank" rel="external">https://findream.github.io/2017/11/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E4%BE%8B%E9%A2%98/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;逆向&quot;&gt;&lt;a href=&quot;#逆向&quot; class=&quot;headerlink&quot; title=&quot;逆向&quot;&gt;&lt;/a&gt;逆向&lt;/h1&gt;&lt;h2 id=&quot;Hackme&quot;&gt;&lt;a href=&quot;#Hackme&quot; class=&quot;headerlink&quot; title=&quot;Hackme&quot;&gt;&lt;/a&gt;Hackme&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是一个ELF的逆向题，IDA打开，发现流程如下：输入字符串，然后经过一个函数的加密，利用这个函数返回出来的数值，对该数值以22取余数，得到索引，得到Hex数组里面的数据，然后经过第一个循环得到V16，再用V16和输入的字符串异或，然后把结果和Hex比较即可。
    
    </summary>
    
      <category term="CTF" scheme="http://yoursite.com/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令(6)shell</title>
    <link href="http://yoursite.com/2018/05/25/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(6)shell%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/05/25/Linux常见命令(6)shell基础/</id>
    <published>2018-05-25T07:02:11.000Z</published>
    <updated>2018-06-21T08:48:51.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-shell概述"><a href="#1-shell概述" class="headerlink" title="1 shell概述"></a>1 shell概述</h1><ul><li>特点：<ul><li>1：解释型编程语言</li><li>2：可以直接调用系统命令<a id="more"></a></li></ul></li><li><p>类型：</p><ul><li>1：bshell：sh,Bash,等。Bash作为主流shell</li><li>2：cshell：cshell，tcshell</li></ul></li><li><p>/etc/shells可以看系统支持的shell类型<br>  <img src="https://i.imgur.com/1lj2vYb.png" alt=""></p></li><li><p>输入shell类型就可以编写shell。<br>  <img src="https://i.imgur.com/cGBda5s.png" alt=""></p></li></ul><h1 id="2-shell执行方式"><a href="#2-shell执行方式" class="headerlink" title="2 shell执行方式"></a>2 shell执行方式</h1><ul><li><p>echo [选项] [打印内容] ：打印输出</p><ul><li>-e:支持反斜线的转义字符。</li><li>打印内容有空格的话，需要加<strong>引号</strong>，如果含有！等特殊字符只能加<strong>单引号</strong></li><li>输出颜色：echo -e “\e[1;31m abcd \e[0”重点是：<strong>\e[1为开启颜色输出，\e[0为结束颜色输出</strong></li></ul></li><li><p>执行脚本的两种方法：</p><ul><li>1首先修改脚本权限chmod 755 xxx.sh,然后执行脚本./xxx.sh</li><li>2.bash xxx.sh<br><img src="https://i.imgur.com/ztVqwyN.png" alt=""></li></ul></li><li><p>windows-&gt;linux:使用dos2unix可以把11在windows下编写的shell移到linux造成的格式不匹配问题。</p></li></ul><h1 id="3-shell基本操作"><a href="#3-shell基本操作" class="headerlink" title="3 shell基本操作"></a>3 shell基本操作</h1><ul><li><p>history [参数]：显示历史命令</p><ul><li>-c：清空历史命令</li><li>-w：把缓存的历史命令写入文件</li><li>其配置文件是：/etc/profile</li></ul></li><li><p>alias 别名=”原命令”:设置别名</p><ul><li>alias：显示别名</li><li>优先级：1）路径 2）别名 3）bash命令 4)path环境变量定义的命令。</li><li>临时生效，如果需要永久生效，需要修改配置文件/root/.bashrc<br><img src="https://i.imgur.com/M39BZz1.png" alt=""></li></ul></li><li><p>unalias 别名：删除别名<br>  <img src="https://i.imgur.com/W4nNBW3.png" alt=""></p></li><li><p>快捷键<br>   <img src="https://i.imgur.com/5jIumqy.png" alt=""></p></li></ul><h1 id="4-重定向"><a href="#4-重定向" class="headerlink" title="4 重定向"></a>4 重定向</h1><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><ul><li><blockquote><p> 标准输出到文件</p></blockquote></li><li><blockquote><blockquote><p>标准输出附加到文件</p></blockquote></blockquote></li><li>2&gt; 标准错误输出到文件</li><li>2&gt;&gt; 标准错误输出附加到文件</li><li>&amp;&gt; 同时把错误和正确输出覆盖保存到文件</li><li>&amp;&gt;&gt; 同时把错误和正确输出附加保存到文件</li><li><blockquote><p>success.txt 2&gt; error.txt</p></blockquote></li></ul><h1 id="5-多命令"><a href="#5-多命令" class="headerlink" title="5 多命令"></a>5 多命令</h1><ul><li>“；”分号：顺序执行</li><li>“&amp;&amp;”逻辑与：格式：命令1&amp;&amp;命令2：如果命令1执行成功，则执行命令2；如果命令1执行失败，则不执行命令2</li><li>“||”逻辑或：格式：命令1||命令2：如果命令1执行成功，则不执行命令2；如果命令1执行失败，则执行命令2</li><li>“|“管道符：命令1|命令2：命令1的执行结果作为命令2的输入。</li><li>实例：判断一个命令是否正确？<ul><li>命令 &amp;&amp; yes || no<br> <img src="https://i.imgur.com/YhVRnHH.png" alt=""></li></ul></li></ul><h1 id="6-输入重定向"><a href="#6-输入重定向" class="headerlink" title="6 输入重定向"></a>6 输入重定向</h1><ul><li><p>wc [选项] [文件]</p><ul><li>-d：字符数（统计回车符）</li><li>-w：单词数</li><li>-l：行数</li></ul></li><li><p>命令 &lt; 文件：将文件内容作为命令的输入</p></li><li>命令 &lt; 字符：两个相同字符之间。(说不清，你自己看例子吧)<br>  <img src="https://i.imgur.com/uWtGiE1.png" alt=""></li></ul><h1 id="7-通配符和其他特殊符号"><a href="#7-通配符和其他特殊符号" class="headerlink" title="7 通配符和其他特殊符号"></a>7 通配符和其他特殊符号</h1><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><ul><li>具体常见通配符如下：<br>  <img src="https://i.imgur.com/Fu1ldUl.png" alt=""></li></ul><h2 id="其他特殊符号"><a href="#其他特殊符号" class="headerlink" title="其他特殊符号"></a>其他特殊符号</h2><ul><li>‘’(单引号)：单引号里面所有的特殊字符都没有特殊含义，只是一个符号</li><li>“”(双引号)：双引号内部”$”，”`”(反引)，”\”（转移）以外，其他的特殊符号都不具备特殊含义</li><li>``(反引号)：优先执行系统命令，也就是反引号里面的命令<br>  <img src="https://i.imgur.com/5xPUfsZ.png" alt=""></li><li>$():同反引号</li><li>#：不是第一行，表示注释的意思，#! /bin/bash</li><li>$：用于调用变量</li><li>\：转义符，跟在\之后的特殊符号将失去特殊含义。变成普通符号。多层命令调用也是用<br>  <img src="https://i.imgur.com/XjS2dPS.png" alt=""></li></ul><h1 id="8-用户自定义变量"><a href="#8-用户自定义变量" class="headerlink" title="8 用户自定义变量"></a>8 用户自定义变量</h1><h2 id="bash的变量类型"><a href="#bash的变量类型" class="headerlink" title="bash的变量类型"></a>bash的变量类型</h2><ul><li>用户自定义的变量</li><li>环境变量</li><li>位置参数变量</li><li>预定义变量</li></ul><h2 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h2><ul><li>默认变量变量类型是字符串型。</li><li>利用引号把含有空格的值括起来。<ul><li>EX：name=”wang xing yu”<br><img src="https://i.imgur.com/6gDUSWi.png" alt=""></li></ul></li><li>变量值可以叠加，但是变量需要使”$“或者”${}“包含。<ul><li>EX:a=123,a=”$a”456,echo $a :值为123456<br><img src="https://i.imgur.com/jJXVBho.png" alt=""></li><li>EX:a=123,a=￥{a}456,echo $a :值为123456<br><img src="https://i.imgur.com/U4z2KVE.png" alt=""></li></ul></li><li>可以把命令的结果作为变量值赋给变量，则需要使用反引号或者”$()“包含命令</li><li>set命令：查看系统所有变量</li><li>unset name：删除变量</li></ul><h1 id="9-环境变量"><a href="#9-环境变量" class="headerlink" title="9 环境变量"></a>9 环境变量</h1><h2 id="环境变量概述"><a href="#环境变量概述" class="headerlink" title="环境变量概述"></a>环境变量概述</h2><ul><li>环境变量在当前shell以及其子shell中生效。如果修改配置文件，可以在所有shell中生效</li><li>这种变量中保存的是和操作系统环境相关的数据</li><li>名称不能修改，但是可以写值</li><li>可以添加新的环境变量</li></ul><h2 id="环境变量使用"><a href="#环境变量使用" class="headerlink" title="环境变量使用"></a>环境变量使用</h2><ul><li>export 变量名=变量值：设置新的环境变量<br>  <img src="https://i.imgur.com/pF5xAQr.png" alt=""></li><li>env：查看环境变量<br>  <img src="https://i.imgur.com/llDA7LP.png" alt=""></li><li>unset 变量名：删除环境变量<br>  <img src="https://i.imgur.com/UW15Dj8.png" alt=""></li></ul><h1 id="10-位置参数变量"><a href="#10-位置参数变量" class="headerlink" title="10 位置参数变量"></a>10 位置参数变量</h1><h2 id="位置参数变量概述"><a href="#位置参数变量概述" class="headerlink" title="位置参数变量概述"></a>位置参数变量概述</h2><ul><li>用于向脚本当中传递参数或者数据</li><li>变量名称不能自定义，变量作用固定</li><li>名称不能修改，但是可以写值</li></ul><h2 id="位置参数变量使用"><a href="#位置参数变量使用" class="headerlink" title="位置参数变量使用"></a>位置参数变量使用</h2><ul><li>$n(n为数字)表示运行时参数<ul><li>0：代表shell名称</li><li>1-9：代表1-9个运行参数</li><li>10个以上的参数要用括号括起来：${10}<br><img src="https://i.imgur.com/VvUbhq6.png" alt=""><br><img src="https://i.imgur.com/labnt9w.png" alt=""><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> $((<span class="variable">$1</span>+<span class="variable">$2</span>))</div></pre></td></tr></table></figure></li></ul></li></ul><h1 id="11-预定义变量"><a href="#11-预定义变量" class="headerlink" title="11 预定义变量"></a>11 预定义变量</h1><h2 id="预定义变量概述"><a href="#预定义变量概述" class="headerlink" title="预定义变量概述"></a>预定义变量概述</h2><ul><li>bash已经定义好了</li><li>和位置参数变量作用功能一样</li></ul><h2 id="预定义变量使用"><a href="#预定义变量使用" class="headerlink" title="预定义变量使用"></a>预定义变量使用</h2><ul><li>$*:把所有参数看做整体输出</li><li>$@:将所有参数分开输出</li><li>$#：返回参数的个数</li><li>$?:返回上一条指令是否成功<ul><li>成功：0</li><li>失败：错误代码</li></ul></li><li>$$:返回当前进程PID</li><li>$!:发挥后台进程PID(命令+&amp;：表示命令进入后台运行)</li><li>read命令：读取用户键盘输入<ul><li>-p:显示提示信息</li><li>-t：输入等待时间(秒)</li><li>-n：允许输入字符数，输入n个字符自动执行(不需要回车)</li><li>-s：隐藏输入<br><img src="https://i.imgur.com/IBRplfX.png" alt=""></li></ul></li></ul><h1 id="12-数值运算和运算符"><a href="#12-数值运算和运算符" class="headerlink" title="12 数值运算和运算符"></a>12 数值运算和运算符</h1><h2 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h2><h3 id="第1种方法：-或者"><a href="#第1种方法：-或者" class="headerlink" title="第1种方法：$(())或者$[ ]"></a>第1种方法：$(())或者$[ ]</h3><ul><li>$(( $a+$b ))</li><li>$[$a+$b]<br>  <img src="https://i.imgur.com/pIySbcK.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-shell概述&quot;&gt;&lt;a href=&quot;#1-shell概述&quot; class=&quot;headerlink&quot; title=&quot;1 shell概述&quot;&gt;&lt;/a&gt;1 shell概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;特点：&lt;ul&gt;
&lt;li&gt;1：解释型编程语言&lt;/li&gt;
&lt;li&gt;2：可以直接调用系统命令
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划--编辑距离问题</title>
    <link href="http://yoursite.com/2018/05/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>http://yoursite.com/2018/05/24/动态规划_编辑距离/</id>
    <published>2018-05-24T06:02:11.000Z</published>
    <updated>2018-05-24T11:42:21.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划算法思想"><a href="#动态规划算法思想" class="headerlink" title="动态规划算法思想"></a>动态规划算法思想</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题的决策过程都是之前所有子问题的结合，也就是说每一步求解得问题都是后面阶段求解问题的子问题，每一步决策都将依赖于前面决策的结果。<br><a id="more"></a></p><h2 id="编辑路径问题"><a href="#编辑路径问题" class="headerlink" title="编辑路径问题"></a>编辑路径问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓编辑距离问题，是指一个字符串转化为另一个字符串最少的编辑次数，许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。一般来说，编辑距离越小，两个串的相似度越大。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先用BCD和ACDF举例子，我们利用二维数组来存储编辑字符串所需要的最短的步数，如图，我们先初始化这个二维数组，如图所示：<br>    <img src="https://i.imgur.com/GSJa6Bj.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;已知，看行坐标，第一个字符是A，再看列坐标，第一个字符是B，两个不相等，我们记做1，表示从A–&gt;B,最小需要一步操作(修改)。如图所示：<br>    <img src="https://i.imgur.com/KszA78b.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后A—&gt;BC，<strong>需要在上一步的基础上，</strong>加一个C，才能使得A—&gt;BC，这充分体现了动态规划的基本原则。然后A—&gt;BCD是同样的道理。<br>    <img src="https://i.imgur.com/oSg3Hy9.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着是AC–&gt;B,AC–&gt;BC,AC–&gt;BCD,分别要求的最短路径是2.1.2<br>    <img src="https://i.imgur.com/6julLh7.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同理：补全该图：红色区域是由之前的ACD—&gt;BCD的结果获得而来，因为ACD–&gt;BCD只需要1步，而ACDF—&gt;BCD只需要在去掉F即可。也就是在加一步。<br>      <img src="https://i.imgur.com/CQcUHwy.png" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个是问题的主要代码，首先初始化整个二维数组，然后再次遍历，找个里面三个操作（插入，删除，修改）里面的最好情况。AC–&gt;B,首先需要将A–&gt;B,然后需要删除C。我们可以得到公式：d[2] [1] =d[1] [1]+1，这里加1，是指在前一步的基础上<strong>再加一步</strong>删除。递推出来就是：d[i] [j] =d[i-1] [j]+1,同理插入：c = d[i] [j -1] + 1,如果是修改就看他是否相等了，相等不需要修改，不相等需要加1<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">CalcEditDistance</span><span class="params">(<span class="keyword">char</span> *StrA, <span class="keyword">char</span> *StrB, <span class="keyword">int</span> **d)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> i,j; </div><div class="line"><span class="keyword">int</span> a,b,c,e;</div><div class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(StrA);</div><div class="line"><span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(StrB);</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt;= len1;i++)   <span class="comment">//初始化二维数组 </span></div><div class="line">d[i] = <span class="keyword">new</span> <span class="keyword">int</span>[len2 + <span class="number">1</span>];  </div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt;= len1;i++)   <span class="comment">//初始化第一个字符串的标号 </span></div><div class="line">d[i][<span class="number">0</span>] = i;</div><div class="line"><span class="keyword">for</span> (j = <span class="number">0</span>;j &lt;= len2;j++)   <span class="comment">//初始化第一个字符串的标号 </span></div><div class="line">d[<span class="number">0</span>][j] = j;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">1</span>;i &lt;= len1;i++)   <span class="comment">//循环确定每个规划中三种方法中的最优解。 </span></div><div class="line">&#123;</div><div class="line"><span class="keyword">for</span> (j = <span class="number">1</span>;j &lt;= len2;j++)</div><div class="line">&#123;</div><div class="line">a = StrA[i<span class="number">-1</span>] == StrB[j<span class="number">-1</span>] ? <span class="number">0</span> : <span class="number">1</span>;  <span class="comment">//如果两个字符串相等就是为0 </span></div><div class="line">b = d[i - <span class="number">1</span>][j] + <span class="number">1</span>; <span class="comment">//删除 </span></div><div class="line">c = d[i][j - <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">// 插入 </span></div><div class="line">e = d[i - <span class="number">1</span>][j - <span class="number">1</span>] + a;<span class="comment">//修改 </span></div><div class="line">d[i][j] = FindTripleMin(b, c, e);  <span class="comment">//寻找b，c，e里面的最小值 </span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 返回编辑距离值 ...</span></div><div class="line"><span class="keyword">return</span> d[<span class="built_in">strlen</span>(StrA)][<span class="built_in">strlen</span>(StrB)];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后经过上面三个操作，<strong>注意：这三种操作不直接写入二维数组，</strong>需要一个找到他们直接值最小的，然后把最小的写入数组。这样保证了每次的编辑距离都是最小的。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> FindTripleMin(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)   <span class="comment">//为了保证每次操作次数都是三种情况中间最少的 </span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> t = (a &lt; b) ? a : b;</div><div class="line"><span class="keyword">return</span> ((t &lt; c) ? t : c);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动态规划算法思想&quot;&gt;&lt;a href=&quot;#动态规划算法思想&quot; class=&quot;headerlink&quot; title=&quot;动态规划算法思想&quot;&gt;&lt;/a&gt;动态规划算法思想&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;问题的决策过程都是之前所有子问题的结合，也就是说每一步求解得问题都是后面阶段求解问题的子问题，每一步决策都将依赖于前面决策的结果。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>XCTF嘉年华资格赛</title>
    <link href="http://yoursite.com/2018/05/22/XCTF%E5%98%89%E5%B9%B4%E5%8D%8E%E6%AF%94%E8%B5%9B%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2018/05/22/XCTF嘉年华比赛试题/</id>
    <published>2018-05-21T16:02:11.000Z</published>
    <updated>2018-05-21T17:33:34.054Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>花了两天时间好好把XCTF嘉年华的比赛试题之逆向题好好做了一下，结合前几天练习的Re题来看，windows里面涉及到的加密函数非常的多，外部有时候也会加入常见壳，但是在比赛中不常出现，基本语言为VC，但是里面会出现多种反调试，加密算法应用广泛。但是linux下面的题目很少出现反调试，和加密函数，也没有向windows一样多种逆向技术结合，相对比较容易，下面讲解一下XCTF嘉年华的比赛逆向题(可能也有杂项题)</strong><br><a id="more"></a></p><h2 id="Re1"><a href="#Re1" class="headerlink" title="Re1"></a>Re1</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现这是一个elf的linux题目，直接利用IDA分析。可以知道：首先输入，然后通过atoi()将输入的字符串转化成int类型，**值得注意的是atoi函数只是转化“数字“和”±”,然后过判断，这里过判断非常简单，首先字符串长度为4，然后计算其十位百位和个位，基本的流程已经写好了。<br>    <img src="https://i.imgur.com/VJXdnXd.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是注册机的编写。值得注意的是这个里面可能会产生异常造成程序奔溃，可以选择排除逼近的方法排除这些数据，最终的数据是：9563<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">int v5=<span class="number">0</span>,v6=<span class="number">0</span>;</div><div class="line">for(v5=<span class="number">1000</span>;v5&lt;=<span class="number">9999</span>;v5++)</div><div class="line">&#123;</div><div class="line">v6 = v5 % <span class="number">100</span> / <span class="number">10</span>;</div><div class="line">if(v5 % <span class="number">10</span> + v6 + v5 / <span class="number">1000</span> + v5 % <span class="number">1000</span> / <span class="number">100</span> != <span class="number">23</span></div><div class="line">   ||v6 / (v5 % <span class="number">10</span>) != <span class="number">2</span></div><div class="line">   ||v5 % <span class="number">1000</span> / <span class="number">100</span> - v6 != <span class="number">-1</span></div><div class="line">   ||v5 / <span class="number">1000</span> % v6 != <span class="number">3</span>)</div><div class="line">   continue;</div><div class="line">        else</div><div class="line">   printf(<span class="string">"%d<span class="subst">\n</span>"</span>,v5);</div><div class="line">&#125;</div><div class="line">return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><pre><code>![](https://i.imgur.com/yaxHIkU.png)</code></pre><h2 id="Re2"><a href="#Re2" class="headerlink" title="Re2"></a>Re2</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个比较麻烦的题目，乍一看，里面对于用户名和密码的加密很多，也很麻烦，我看了一下关于SuccessFun函数内部，发现这个函数直接输出flag，同时flag也没有和用户名或者密码有关，但是，里面有一个s数组处于未知状态，不能通过静态计算得出flag，然后我想是否可以把前面对于用户名和密码的求解函数dop掉，这样掉过程序的验证阶段，直接显示flag，但是我又错了。最后看了大佬的wp（<a href="http://blog.r4phael.cn/coding/xctf-carnival-wp），辛辛苦苦把这道题解决，从中也学会了很多东西。" target="_blank" rel="external">http://blog.r4phael.cn/coding/xctf-carnival-wp），辛辛苦苦把这道题解决，从中也学会了很多东西。</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们可以看到sub_400C9A这个函数，函数从0到49循环，然后调用sub_400C41(i)，并以i为参数，这里产生和分析不符合的情况，可以是编译器优化造成的结果。<br>    <img src="https://i.imgur.com/11nQ75U.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后我们看看sub_400c41这个函数，通过思考，我们知道if条件的前面两个条件必定成立，后面两个式子成为if的关键，根据流程，我们可以知道字符长度为a1&gt;&gt;3不等于0，以及a1&gt;&gt;4==0.通过写注册机得知Username长度为8或者12<br>    <img src="https://i.imgur.com/c7DczlZ.png" alt=""><br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">int <span class="built_in">a1</span>,result<span class="comment">;</span></div><div class="line">for(<span class="built_in">a1</span>=<span class="number">0</span><span class="comment">;a1&lt;49;a1++)</span></div><div class="line">&#123;</div><div class="line">result=<span class="built_in">a1</span>&gt;&gt;<span class="number">3</span><span class="comment">;</span></div><div class="line">if(<span class="number">4</span> * (<span class="built_in">a1</span> &gt;&gt; <span class="number">2</span>) != <span class="built_in">a1</span> <span class="title">||</span><span class="number">4</span> * (<span class="built_in">a1</span> &gt;&gt; <span class="number">4</span>) == <span class="built_in">a1</span> &gt;&gt; <span class="number">2</span><span class="title">||</span>!result <span class="title">||</span> <span class="built_in">a1</span> &gt;&gt; <span class="number">4</span>)</div><div class="line">continue<span class="comment">;</span></div><div class="line">else</div><div class="line">printf(<span class="string">"%d\n"</span>,<span class="built_in">a1</span>)<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们看看GetUsernameVal函数，这个函数就是一个解三元一次方程组的函数，具体验证如下：<strong>首先</strong>，把函数分割Username，分成三份，分别是First，Second，Third，然后放到if里面去判断，难点在于如何去计算，考验心细的时候。<strong>接着</strong>，他把转化为hex16进制的字符，分别是First=6163，Second=796c，Third=636f，<strong>由于InterlCPU是小端序显示，也就是说如果实际传输为FEAB12的话，那么小端序显示为21BAEF。</strong>所以用户名是F636C6973616.小插曲，在计算除法的时候，数据太大了，网上计算器无法计算了，所以找一份大数除法代码。<br>    <img src="https://i.imgur.com/3NNqrgo.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp跟入ProUsernameVal函数，发现这是一个严重Username是否符合自定义原则的，函数将a1想做数组的基地址，i作为偏移地址，依次遍历判断Username的每位是否符合要求。应为之前正确求解了，这个函数不是很重要<br>    <img src="https://i.imgur.com/PSUY9c4.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp分析GetpasswdVal函数，<strong>函数先是</strong>验证了passwd的字符类型，如图passwd只能使大小写字母和数字，<strong>接着</strong>，函数用之前的Username做种子，产生为随机值，因为是以固定值做种子，所以产生的随机数也是固定的。然后将Passwd分为10份，分别通过十次和随机数的验证，每个验证过程都是一样的，我们写出前十次产生的随机数，然后带入计算得到Passwd。<br>    <img src="https://i.imgur.com/tPpXIDT.png" alt=""><br>    <img src="https://i.imgur.com/w9hj1a6.png" alt=""><br>    <img src="https://i.imgur.com/tX8QjyA.png" alt=""><br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()&#123;</div><div class="line"><span class="keyword">srand</span>(<span class="number">0x454D3E2E</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">printf</span>(<span class="string">"%0x\n"</span>,<span class="keyword">rand</span>());</div><div class="line">&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp执行程序，输入Username和Passwd，经过等待得到flag，你也可以nop掉sleep函数，避免等待。得到flag是：<br>     <img src="https://i.imgur.com/TLQnlcK.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;花了两天时间好好把XCTF嘉年华的比赛试题之逆向题好好做了一下，结合前几天练习的Re题来看，windows里面涉及到的加密函数非常的多，外部有时候也会加入常见壳，但是在比赛中不常出现，基本语言为VC，但是里面会出现多种反调试，加密算法应用广泛。但是linux下面的题目很少出现反调试，和加密函数，也没有向windows一样多种逆向技术结合，相对比较容易，下面讲解一下XCTF嘉年华的比赛逆向题(可能也有杂项题)&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CTF" scheme="http://yoursite.com/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令(5)权限管理</title>
    <link href="http://yoursite.com/2018/05/20/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(5)%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/20/Linux常见命令(5)权限管理/</id>
    <published>2018-05-20T07:02:11.000Z</published>
    <updated>2018-05-24T07:29:59.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-ACL权限"><a href="#第一部分-ACL权限" class="headerlink" title="第一部分 ACL权限"></a>第一部分 ACL权限</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;忽略所有者，所有组，其他人三个用户类型，只需要把用户对文件的权限分配给用户。ACL权限需要文件所在分区是否支持ACL机制。利用<strong>dumpe2fs -h /dev/sda3</strong>这个命令即可查看。<br><a id="more"></a></p><ul><li>第一步：df -h :查看所有分区信息</li><li>第二歩：dumpe2fs -h /dev/xxx<br>  <img src="https://i.imgur.com/xXz86iD.png" alt=""></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开启ACL</p><ul><li>临时开启ACL权限。mount -o remount,acl /<br>  <img src="https://i.imgur.com/cMxGQ1O.png" alt=""></li><li>永久开启ACL权限：修改/etc/fstab文件，然后重启<br>   <img src="https://i.imgur.com/UrVW9GN.png" alt=""></li></ul><h1 id="第二部分-ACL权限管理"><a href="#第二部分-ACL权限管理" class="headerlink" title="第二部分 ACL权限管理"></a>第二部分 ACL权限管理</h1><ul><li><p>getfacl [文件名]：获取文件ACL权限<br>  <img src="https://i.imgur.com/X11rr4S.png" alt=""></p></li><li><p>setfacl [选项] [u/g:username:权限] [文件名]：给用户/组设定ACL权限。</p><ul><li>-m:添加ACL权限</li><li>-x:删除指定给的ACL权限</li><li>-b：删除所有的ACL权限</li><li>-d：设置默认的ACL权限</li><li>-k：删除默认的ACL权限</li><li>-R：递归设定ACL权限</li></ul></li></ul><ul><li>实例：添加一个文件ACL权限<ul><li>首先创建3个用户test1,test2，st和一个组tgroup。<br><img src="https://i.imgur.com/CkqerBj.png" alt=""></li><li>将两个用户添加到tgroud组中。<br><img src="https://i.imgur.com/AsTl3ai.png" alt=""></li><li>修改文件的所有者和所属组<br><img src="https://i.imgur.com/WIXJEvL.png" alt=""></li><li>修改权限<br><img src="https://i.imgur.com/ia4oSEW.png" alt=""></li><li>设置ACL权限：setfacl -m u:st:rx /tmp/test<br><img src="https://i.imgur.com/Gl9v46W.png" alt=""><br><img src="https://i.imgur.com/5pT77Td.png" alt=""></li><li>通过getfacl命令查看ACL权限<br><img src="https://i.imgur.com/X11rr4S.png" alt=""></li></ul></li></ul><h1 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h1><h1 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h1><h1 id="第五部分-sudo权限"><a href="#第五部分-sudo权限" class="headerlink" title="第五部分 sudo权限"></a>第五部分 sudo权限</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visduo命令通过修改/etc/sudoers文件，对用户进行赋权操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到以下字段：%admin ALL=(ALL) ALL，其中admin代表的是用户名，第一个all代表的是本地linux的地址，第二个ALL是代表可使用的身份，<strong>这个字段可写，可不写，</strong>第三个ALL是授权命令（绝对地址），命令写的短，则使用范围越长，如：shutdown 表示可以执行shutdown所有的命令。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用sudo -l 查看超级用户给我赋予了的命令情况。<br>    <img src="https://i.imgur.com/MQ73Vwj.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是其他用户在执行的时候，必须要写绝对路径。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-ACL权限&quot;&gt;&lt;a href=&quot;#第一部分-ACL权限&quot; class=&quot;headerlink&quot; title=&quot;第一部分 ACL权限&quot;&gt;&lt;/a&gt;第一部分 ACL权限&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;忽略所有者，所有组，其他人三个用户类型，只需要把用户对文件的权限分配给用户。ACL权限需要文件所在分区是否支持ACL机制。利用&lt;strong&gt;dumpe2fs -h /dev/sda3&lt;/strong&gt;这个命令即可查看。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令(4)用户和用户组管理</title>
    <link href="http://yoursite.com/2018/05/17/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(4)%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/17/Linux常见命令(4)用户和用户组管理/</id>
    <published>2018-05-17T07:02:11.000Z</published>
    <updated>2018-05-28T05:14:47.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-用户信息配置文件passwd"><a href="#第一部分-用户信息配置文件passwd" class="headerlink" title="第一部分 用户信息配置文件passwd"></a>第一部分 用户信息配置文件passwd</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户信息文件路径为/etc/passwd,一共有七个字段。分别是用户名称，秘密标志，UID,GID，用户说明，主目录，shell。<br>    <img src="https://i.imgur.com/cpdt8BN.png" alt=""><br><a id="more"></a></p><ul><li>用户名称</li><li>密码标志：x代表设置密码，其他代表没有设置密码</li><li>UID：用户编号，系统唯一标识用户信息的编号，通过修改UID，可以修改权限，例如把UID修改为0，达到管理员权限。<ul><li>0 超级用户</li><li>1-499 系统用户（系统中应用程序的用户，不可删除）</li><li>500-65535 普通用户</li></ul></li><li>GID：组ID<ul><li>初始化组：<ul><li>每个用户只有一个初始化组</li><li>每个用户必须要有初始化组</li><li>可以修改初始化组，但是不建议修改</li></ul></li><li>附加组：<ul><li>每个用户可以有多个附加组，但是拥有附加组的权限</li></ul></li></ul></li><li>用户说明</li><li>主目录：<ul><li>root用户的主目录是/root<br><img src="https://i.imgur.com/hb45jFV.png" alt=""></li><li>普通用户的主目录是/home/usrname<br><img src="https://i.imgur.com/lEYPJmN.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是值得注意的是 sudo -s并不是进入管理员账号，而是获取了管理员的权限，你利用pwd会发现，使用sudo -s，他的工作目录并不是/root，而是/home/username。</li></ul></li><li>shell：用户使用shell解释器的路径</li></ul><h1 id="第二部分-shadow文件"><a href="#第二部分-shadow文件" class="headerlink" title="第二部分 shadow文件"></a>第二部分 shadow文件</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadow文件位于/etc/shadow中（利用man 5 shadow可查），需要root权限才能打开。一共有八个字段，分别是：用户名，加密的密码串，最后一次修改密码的日期(时间戳)，密码有效期，最大密码年龄，警告时间段，密码禁用期，账号过期日期，保留。<br>    <img src="https://i.imgur.com/pmd6SXJ.png" alt=""></p><ul><li>用户名</li><li>加密的密码串：如果这个字段为空的话，说明这个账号不需要使用密码也能登录，使用*表示这个账号已经被锁定。如果是！！表示密码无效/过期，也就是说账户被禁用。</li><li>最后一次修改密码的时间戳：<ul><li>0：表示下次登陆账户时，修改密码</li><li>为空：表示密码年龄的功能被禁用</li></ul></li><li>密码有效期(最小密码年龄)：修改密码之后，要等n时间才能被允许修改密码。<ul><li>0或者为空：表示没有设置密码有效期</li></ul></li><li>最大密码年龄:在最大密码年龄之后必须要修改密码</li><li>警告时间段：在密码到期之前n天，警告必须修改密码</li><li>密码禁用期：过了密码有效期之后，仍可以使用原密码登录的最大期限。过了此期限后，账户不能登录，空字段表示没有强制密码过期。</li><li>账户过期日期：账户没有登录多少天后，账户过期。</li><li>保留<br>  <img src="https://i.imgur.com/LjpkH5X.png" alt=""></li></ul><h1 id="第三部分-group和gshadow组配置文件"><a href="#第三部分-group和gshadow组配置文件" class="headerlink" title="第三部分 group和gshadow组配置文件"></a>第三部分 group和gshadow组配置文件</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group文件在/etc/group,文件下面一共有四个字段，分别是组名，组密码标志，GID，组中的附加用户。</p><ul><li>组名：在linux中，每次新加一个用户，该用户的初始组名也是用户名</li><li>密码标志：存在密码为“x”字段，在etc/gshadow文件下可查看，但是基本都不存在组密码。存在的意义在于：执行了受限的root用户的权限，管理组内的用户。</li><li>GID:</li><li>附加用户：看不到初始用户。只能看附加用户，如果需要查看组的初始用户，先查看passwd中的GID，然后再看group中的GID，就行了。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gshadow文件在/etc/gshadow，有四个字段：组名，组密码，组管理员用户名，组中附加用户。</p><h1 id="第四部分：主目录"><a href="#第四部分：主目录" class="headerlink" title="第四部分：主目录"></a>第四部分：主目录</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户主目录：root用户为/root,权限为550，普通用户为/home/username,权限为700</p><h1 id="第五部分：useradd-添加用户"><a href="#第五部分：useradd-添加用户" class="headerlink" title="第五部分：useradd 添加用户"></a>第五部分：useradd 添加用户</h1><ul><li>useradd [选项] [参数]<ul><li>-u UID:手动指定用户的ID</li><li>-d 主目录：</li><li>-c 用户说明</li><li>-g 组名：指定用户初始组</li><li>-G 组名：指定用户附加组</li><li>-s shell: 指定用户登录shell<br><img src="https://i.imgur.com/tCVCvFw.png" alt=""></li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/etc/default/useradd,作为添加的缺省设置信息的文件。<br>    <img src="https://i.imgur.com/24k4UtE.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/etc/login.defs:存放默认密码信息的文件</p><h1 id="第六部分：passwd-修改设置用户密码"><a href="#第六部分：passwd-修改设置用户密码" class="headerlink" title="第六部分：passwd 修改设置用户密码"></a>第六部分：passwd 修改设置用户密码</h1><ul><li>passwd [选项] [参数]<ul><li>-S 查询用户密码状态(仅root可用)<br><img src="https://i.imgur.com/6NDEo4O.png" alt=""></li><li>-l 暂时锁定用户(仅root可用)<br><img src="https://i.imgur.com/RBiJb6C.png" alt=""></li><li>-u 解锁用户<br><img src="https://i.imgur.com/mtG8CfO.png" alt=""></li><li>–stdin 使用标准化输入，使用shell编程：echo “123” | passwd stdin username</li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root可以修改所有用户密码，但是普通用户只能修改自己的，此时，使用passwd不能加自己的用户名，<strong>即修改密码是只需要输入passwd。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;锁定用户原理是修改/etc/passwd的密码域，在前面添加!!。以至于密码串不正确，造成用户无法登陆。</p><h2 id="第七部分-用户管理相关命令"><a href="#第七部分-用户管理相关命令" class="headerlink" title="第七部分 用户管理相关命令"></a>第七部分 用户管理相关命令</h2><ul><li><p>usermod [选项] [用户]  修改已存在用户信息</p><ul><li>-c 修改用户说明</li><li>-G 修改用户附加组</li><li>-L 暂时锁定用户</li><li>-U 暂时解锁用户</li></ul></li><li><p>change [选项] [参数] 修改用户的密码信息(直接修改/etc/shadow方便)</p></li><li><p>userdel [选项] [用户]</p><ul><li>r:删除主目录</li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;手工删除以下目录：</p><ul><li>/etc/passwd</li><li>/etc/shadow</li><li>/etc/group</li><li>/etc/gshadow</li><li>rm -fr /var/spool/mail/username</li><li><p>rm -rf /var/home/username</p></li><li><p>id [username]:查看用户ID，组ID，等信息<br>  <img src="https://i.imgur.com/UKfNsqK.png" alt=""></p></li><li><p>su [选项] [参数]切换用户命令</p><ul><li>-（减号）：连带切换用户的环境变量</li><li>-c：只是赋予某个用户root权限，以便去执行需要root权限的操作</li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在切换用户的时候，务必添加”-“选项。如果不添加这个选项的话：如图2，你会发现这个的登录账户时wangxingyu但是，利用env查看环境变量的话，还是显示你原来的账户的环境变量，所以你必须要添加这个选项。<br>    <img src="https://i.imgur.com/zfl0RUR.png" alt=""><br>    <img src="https://i.imgur.com/SBgETso.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;su - root -c “useradd test123” 这是一次性利用root的权限去执行某个特殊权限的操作。<br>    <img src="https://i.imgur.com/0Dz6A5b.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Ubuntu以及分支版本切换root账户出现认证失败的情况，输入“sudo passwd root”，产生这类问题原因是因为默认没有设置root用户密码。</p><ul><li>groupadd [选项] [组名] :添加组名<ul><li>-g：规定组ID</li></ul></li></ul><ul><li>groupmod [选项] [组名] <ul><li>-g：修改组ID</li><li>-n: 修改组名：groupmod -n newgroupname oldgroupname</li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要宿便修改</p><ul><li><p>groupdel [组名]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果存在初始用户，次组不能被删除，如果只存在附加用户，此组可以删除。</p></li><li><p>gpasswd [选项] [username] [groupname]：管理组内用户</p><ul><li>-a username：将username 添加groupname</li><li>-d username：将username 从groupname组中删除</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-用户信息配置文件passwd&quot;&gt;&lt;a href=&quot;#第一部分-用户信息配置文件passwd&quot; class=&quot;headerlink&quot; title=&quot;第一部分 用户信息配置文件passwd&quot;&gt;&lt;/a&gt;第一部分 用户信息配置文件passwd&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;用户信息文件路径为/etc/passwd,一共有七个字段。分别是用户名称，秘密标志，UID,GID，用户说明，主目录，shell。&lt;br&gt;    &lt;img src=&quot;https://i.imgur.com/cpdt8BN.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows PE》延迟加载导入表</title>
    <link href="http://yoursite.com/2018/05/14/%E3%80%8Awindows%20PE%E3%80%8B%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/05/14/《windows PE》延迟加载表/</id>
    <published>2018-05-14T11:02:11.000Z</published>
    <updated>2018-06-09T09:27:44.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="1-延迟加载导入的概念及作用"><a href="#1-延迟加载导入的概念及作用" class="headerlink" title="1.延迟加载导入的概念及作用"></a>1.延迟加载导入的概念及作用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;延迟加载导入表和导入表示相互分离的，延迟加载导入表是特殊的导入表，和导入表不同的是，延迟加载导入表所记录的dll不会被操作系统加载，只有在函数被应用程序调用的时候，PE中注册的延迟加载函数才会根据延迟加载导入表的记录，动态加载dll，以及修正导入函数的VA。<br><a id="more"></a></p><h2 id="2-延迟加载的优势"><a href="#2-延迟加载的优势" class="headerlink" title="2.延迟加载的优势"></a>2.延迟加载的优势</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;延迟加载由于没有在程序初始化的时候初始化dll，只是会在应用程序调用某个模块的时候加载该模块，所以使用延迟加载技术的程序拥有更高的初始化速度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过延迟加载的方法，提高了程序的兼容性，原因在于基于延迟加载，所用到的模块不需要在初始化前加载，保证了程序能够运行成功，如果缺少模块或者缺少模<br>块里面的函数造成的异常，可以使得编译器单独处理该某个dll或者某个函数的调用。</p><h1 id="PE中的延迟加载导入表"><a href="#PE中的延迟加载导入表" class="headerlink" title="PE中的延迟加载导入表"></a>PE中的延迟加载导入表</h1><h2 id="1-延迟加载导入表的定位"><a href="#1-延迟加载导入表的定位" class="headerlink" title="1.延迟加载导入表的定位"></a>1.延迟加载导入表的定位</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;延迟加载导入表的描述信息在数目目录的第14个目录项中，定位方法和前面的导入导出表一致。</p><h2 id="2-延迟加载描述符IMAGE-DELAY-IMPORT-DESCRIPTOR"><a href="#2-延迟加载描述符IMAGE-DELAY-IMPORT-DESCRIPTOR" class="headerlink" title="2.延迟加载描述符IMAGE_DELAY_IMPORT_DESCRIPTOR"></a>2.延迟加载描述符IMAGE_DELAY_IMPORT_DESCRIPTOR</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IMAGE_DELAY_IMPORT_DESCRIPTOR的结构如下：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_DELAY_IMPORT_DESCRIPTOR</span> STRUCT </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    DWORD           Attributes;           <span class="comment">// 保留  </span></div><div class="line">    RVA             RVA_DLLName;          <span class="comment">// 指向延迟加载dll的名字字符串的RVA  </span></div><div class="line">    RVA             RVA_ModuleHandle;     <span class="comment">// 指向DLL句柄的RVA   </span></div><div class="line">    RVA             RVA_DelayIAT;         <span class="comment">// RVA of the IAT  </span></div><div class="line">    RVA             RVA_DelayINT;         <span class="comment">// RVA of the INT  </span></div><div class="line">    RVA             RVA_BoundIAT;      <span class="comment">// RVA of the optional bound IAT  </span></div><div class="line">    RVA             RVA_UnloadIAT;     <span class="comment">// RVA of optional copy of original IAT  </span></div><div class="line">    DWORD           dwTimeStamp;       <span class="comment">// 0 if not bound,  </span></div><div class="line">                                       <span class="comment">// 绑定到DLL的时间戳</span></div><div class="line">&#125; ImgDelayDescr, * PImgDelayDescr;</div></pre></td></tr></table></figure></p><ul><li>Attributes：双字，暂时未用到，</li><li>RVA_DLLName：双字，延迟加载dll名称的字符串的地址。</li><li>RVA_ModuleHandle：双字，延迟加载dll的句柄的地址。</li><li>RVA_DelayIAT: 延迟加载导入地址表的RVA</li><li>RVA_DelayINT：延迟加载导入名称表的RVA</li><li>RVA_BoundIAT：延迟绑定导入地址表的RVA，延迟绑定导入地址表是由IMAGE_THUNK_DATA组成的数组。他和最后一项dwTimeStamp用于最后的绑定阶段。</li><li>RVA_UnloadIAT：延迟卸载导入地址表由IMAGE_THUNK_DATA组成的数组，程序使用它来卸载dll(包括函数)，所用到的参数是原来IAT的精确副本。做释放处理需要做一下几个工作<ul><li>1）释放函数/dll</li><li>2）ModuleHandle清零</li><li>3）使用UIAT覆盖IAT。</li></ul></li></ul><h2 id="3-详解延迟加载机制"><a href="#3-详解延迟加载机制" class="headerlink" title="3.详解延迟加载机制"></a>3.详解延迟加载机制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用延迟加载技术的程序，链接器会做一下几个事情：</p><ul><li>1）将函数_delayLoadHelper嵌入到可执行模块</li><li>2）删除可执行文件导入表的相关内容，避免在初始化时候显式加载dll</li><li>3）构造PE相关信息，以便_delayLoadHelper正确的延迟加载函数。</li><li>4）调用_delayLoadHelper函数加载dll或获取调用函数地址。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在_delayLoadHelper函数中，还调用了LoadLibrary加载dll，调用了GetprocessAddress获取函数地址，调用了FreeLibrary去释放dll。</li></ul><h2 id="4-利用windbg查看延迟加载导入表"><a href="#4-利用windbg查看延迟加载导入表" class="headerlink" title="4.利用windbg查看延迟加载导入表"></a>4.利用windbg查看延迟加载导入表</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们首先用windows xp下的explorer程序举例子。</p><ul><li>查看程序加载的模块：<strong>lm m explorer</strong><br>  <img src="https://i.imgur.com/OwrUPxC.png" alt=""></li><li>显示PE文件头：<strong>!dh start_address -f</strong><br>  <img src="https://i.imgur.com/WmC45oC.png" alt=""></li><li>查看延迟加载导入的内存空间:<strong>dd start_address+offset</strong><br>  <img src="https://i.imgur.com/ER4HHJ0.png" alt=""></li><li>比如查看延迟加载导入表第二项的内容dll的ASCII：<strong>da address</strong><br>  <img src="https://i.imgur.com/fvZrYYJ.png" alt=""></li></ul><h2 id="4-延迟导入的两个问题"><a href="#4-延迟导入的两个问题" class="headerlink" title="4.延迟导入的两个问题"></a>4.延迟导入的两个问题</h2><h3 id="1）异常处理"><a href="#1）异常处理" class="headerlink" title="1）异常处理"></a>1）异常处理</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过延迟加载机制，未能成功加载的dll或者由于版本问题，未能成功调用的函数，函数_delayLoadHelper会抛出软件异常（其实是API函数剖出的异常）</p><h3 id="2）dll卸载"><a href="#2）dll卸载" class="headerlink" title="2）dll卸载"></a>2）dll卸载</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不能使用FreeLibrary卸载dll，因为在函数_delayLoadHelper中存在卸载函数，</p><h1 id="3-延迟加载机制在dll注入的实例。"><a href="#3-延迟加载机制在dll注入的实例。" class="headerlink" title="3.延迟加载机制在dll注入的实例。"></a>3.延迟加载机制在dll注入的实例。</h1><p><a href="https://www.anquanke.com/post/id/86919" target="_blank" rel="external">https://www.anquanke.com/post/id/86919</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;h2 id=&quot;1-延迟加载导入的概念及作用&quot;&gt;&lt;a href=&quot;#1-延迟加载导入的概念及作用&quot; class=&quot;headerlink&quot; title=&quot;1.延迟加载导入的概念及作用&quot;&gt;&lt;/a&gt;1.延迟加载导入的概念及作用&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;延迟加载导入表和导入表示相互分离的，延迟加载导入表是特殊的导入表，和导入表不同的是，延迟加载导入表所记录的dll不会被操作系统加载，只有在函数被应用程序调用的时候，PE中注册的延迟加载函数才会根据延迟加载导入表的记录，动态加载dll，以及修正导入函数的VA。&lt;br&gt;
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows PE》重定位表</title>
    <link href="http://yoursite.com/2018/05/14/%E3%80%8Awindows%20PE%E3%80%8B%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/05/14/《windows PE》重定位表/</id>
    <published>2018-05-14T06:02:11.000Z</published>
    <updated>2018-05-28T09:41:22.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识：代码重定位"><a href="#预备知识：代码重定位" class="headerlink" title="预备知识：代码重定位"></a>预备知识：代码重定位</h1><h2 id="重定位的提出"><a href="#重定位的提出" class="headerlink" title="重定位的提出"></a>重定位的提出</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码重定位是把可执行代码从内存的一块区域移动到另外一块地方。但是如果指令中某些操作数没有随着地址的改变而改变，这样势必导致运行出错。如下代码：我们发现全局变量的地址包含在机器码中，而局部变量没有包含绝对地址。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line"><span class="keyword">add</span> <span class="built_in">esp</span>,ffffffc</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [00400FFC]   //全局变量</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">04</span>]     //局部变量</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [evp+<span class="number">08</span>]     //局部变量</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定位信息是在编译时期由编译器生成，并且保存在应用程序中，在程序执行的时候由操作系统予以修正。如果在装载时该位置已经被别的应用程序使用，操作系统会<strong>重新选择一个新的基地址</strong>。此时，就需要对所有重定位信息进行纠正，纠正的依据就是<strong>PE中的重定位表</strong>。<br><a id="more"></a></p><h1 id="PE文件中的重定位表"><a href="#PE文件中的重定位表" class="headerlink" title="PE文件中的重定位表"></a>PE文件中的重定位表</h1><h2 id="1-重定位表的定位"><a href="#1-重定位表的定位" class="headerlink" title="1.重定位表的定位"></a>1.重定位表的定位</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定位表位于数据目录中的第六个数据目录中。位置定位方法和前面的导入表和导出表一样。<br>    <img src="https://i.imgur.com/UqrSU1r.png" alt=""></p><h2 id="2-重定位表项IMAGE-BASE-RELOCATION"><a href="#2-重定位表项IMAGE-BASE-RELOCATION" class="headerlink" title="2.重定位表项IMAGE_BASE_RELOCATION"></a>2.重定位表项IMAGE_BASE_RELOCATION</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和导入表一样，重定位表指针指向的位置是一个数组。<strong>每个数组代表的是每一个内存页的重定位信息。</strong>也就是说每个内存页的重定位信息是不同的。下面是对于IMAGE_BASE_RELOCATION结构体的介绍:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">IMAGE_BASE_RELOCATION STRUC 【基址重定位位于数据目录表的第六项，共<span class="number">8</span>+N字节】</div><div class="line">&#123;</div><div class="line">+<span class="number">00</span> h DWORD VirtualAddress ;重定位数据开始的RVA 地址</div><div class="line">+<span class="number">04</span> h DWORD SizeOfBlock ;重定位块得长度，标识重定向字段个数</div><div class="line">+<span class="number">08</span> h WORD TypeOffset ;重定项位数组相对虚拟RVA,个数动态分配</div><div class="line">&#125;;</div><div class="line">IMAGE_BASE_RELOCATION ENDS</div></pre></td></tr></table></figure></p><ul><li>VirtualAddress:双字，表示的是重定位块的RVA。<strong>本来一个地址需要4个字节，因为一个内存页大小诶1000h,也就是2的12次，所以只需要2个字节即可</strong></li><li>SizeOfBlock：双字，重定位表项中的重定位块的个数。这些数组(表项)可能不是相邻的。</li><li>TypeOffset：表示重定位表项的类型：高四位表示的是类型。低十二位表示的重定位地址。<br>  <img src="https://i.imgur.com/QjFxUnO.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定位块的大小：n*12+4+4</li></ul><h2 id="3-重定位表的结构"><a href="#3-重定位表的结构" class="headerlink" title="3.重定位表的结构"></a>3.重定位表的结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定位表中包含有重定位块，重定位块中包含有重定位表项和前面的VirtualAddress，SizeOfBlock，TypeOffset字段(TypeOffset是一个数组，它的元素个数就是( SizeOfBlock - 8 ) / 2 ，TypeOffset 每一个元素占用两个字节即16位，其中高4位表示重定位类型（一般都为3），低12位表示重定位地址。)。<br>    <img src="https://i.imgur.com/4pZ0mvd.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有的重定位块最终以VirtualAddress字段为0的IMAGE_BASE_RELOCATION结构为结束标志。</p><h2 id="4-实例分析"><a href="#4-实例分析" class="headerlink" title="4.实例分析"></a>4.实例分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下图，我们知道第一个重定位块位于0x1c00，代码起始页面RVA为00001000，块的大小为000000E8。后面的是每个重定位表项的相对位置。根据以下计算公式得到最终的实际地址。<br>VA=基地址(程序基地址)+代码起始页面RVA+<strong>低12位虚拟地址。</strong><br>VA=01000000+00001000+009<br>    <img src="https://i.imgur.com/tLuBjY9.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;预备知识：代码重定位&quot;&gt;&lt;a href=&quot;#预备知识：代码重定位&quot; class=&quot;headerlink&quot; title=&quot;预备知识：代码重定位&quot;&gt;&lt;/a&gt;预备知识：代码重定位&lt;/h1&gt;&lt;h2 id=&quot;重定位的提出&quot;&gt;&lt;a href=&quot;#重定位的提出&quot; class=&quot;headerlink&quot; title=&quot;重定位的提出&quot;&gt;&lt;/a&gt;重定位的提出&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;代码重定位是把可执行代码从内存的一块区域移动到另外一块地方。但是如果指令中某些操作数没有随着地址的改变而改变，这样势必导致运行出错。如下代码：我们发现全局变量的地址包含在机器码中，而局部变量没有包含绝对地址。&lt;br&gt;&lt;figure class=&quot;highlight x86asm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;ebp&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;ebp&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;esp&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;esp&lt;/span&gt;,ffffffc&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;eax&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;dword&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;ptr&lt;/span&gt; [00400FFC]   //全局变量&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;eax&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;dword&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;ptr&lt;/span&gt; [&lt;span class=&quot;built_in&quot;&gt;ebp&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;04&lt;/span&gt;]     //局部变量&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;eax&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;dword&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;ptr&lt;/span&gt; [evp+&lt;span class=&quot;number&quot;&gt;08&lt;/span&gt;]     //局部变量&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;重定位信息是在编译时期由编译器生成，并且保存在应用程序中，在程序执行的时候由操作系统予以修正。如果在装载时该位置已经被别的应用程序使用，操作系统会&lt;strong&gt;重新选择一个新的基地址&lt;/strong&gt;。此时，就需要对所有重定位信息进行纠正，纠正的依据就是&lt;strong&gt;PE中的重定位表&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows PE》导出表</title>
    <link href="http://yoursite.com/2018/05/11/%E3%80%8Awindows%20PE%E3%80%8B%E5%AF%BC%E5%87%BA%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/05/11/《windows PE》导出表/</id>
    <published>2018-05-11T06:02:11.000Z</published>
    <updated>2018-05-28T09:46:11.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-预备知识"><a href="#第一部分-预备知识" class="headerlink" title="第一部分 预备知识"></a>第一部分 预备知识</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导入表主要存在于动态链接库文件中，用于将dll文件中的函数导入到外部，给其他的exe或者dll文件调用。我们在导入表一章中知道了程序在装载过程中，<strong>通过在INT获得的函数地址覆盖到IAT中，</strong>此时，导出表起到了参照和指引的作用。<br><a id="more"></a></p><h1 id="第二部分-导出表数据结构"><a href="#第二部分-导出表数据结构" class="headerlink" title="第二部分 导出表数据结构"></a>第二部分 导出表数据结构</h1><h2 id="1-定位导出表"><a href="#1-定位导出表" class="headerlink" title="1.定位导出表"></a>1.定位导出表</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导出表数据在数据目录的第一个目录中，定位方法和获取导入表的一样。<br>    <img src="https://i.imgur.com/oF80lie.png" alt=""></p><h2 id="2-导出目录IMAGE-EXPORT-DIRECTORY"><a href="#2-导出目录IMAGE-EXPORT-DIRECTORY" class="headerlink" title="2.导出目录IMAGE_EXPORT_DIRECTORY"></a>2.导出目录IMAGE_EXPORT_DIRECTORY</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个结构是导出表描述符，导入表的IMAGE_EXPORT_DIRECTORY只有一个。下面是其详细定义：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> </span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    DWORD   Characteristics;    <span class="comment">// 未使用，总为0     DWORD   TimeDateStamp;              // 文件创建时间戳</span></div><div class="line">    WORD    MajorVersion;       <span class="comment">// 未使用，总为0     WORD    MinorVersion;               // 未使用，总为0</span></div><div class="line">    DWORD   Name;               <span class="comment">// 指向一个代表此 DLL名字的 ASCII字符串的 RVA</span></div><div class="line">    DWORD   Base;               <span class="comment">// 函数的起始序号</span></div><div class="line">    DWORD   NumberOfFunctions;  <span class="comment">// 导出函数的总数    </span></div><div class="line">    DWORD   NumberOfNames;           <span class="comment">// 以名称方式导出的函数的总数    </span></div><div class="line">    DWORD   AddressOfFunctions;      <span class="comment">// 指向输出函数地址的RVA</span></div><div class="line">    DWORD   AddressOfNames;         <span class="comment">// 指向输出函数名字的RVA</span></div><div class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// 指向输出函数序号的RVA</span></div><div class="line">&#125;IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</div></pre></td></tr></table></figure></p><ul><li>Name:文件最初的文件名</li><li>NumberOfFunctions：导出函数的个数</li><li>NumberOfNmaes：导出函数其中有名字的个数，NumberOfNames的值小于NumberOfFunctions</li><li>AddressOfFunctions：该指针指向的是所有导出函数的入口地址的起始。函数地址顺序按照函数的编号排序。</li><li>Base：导出函数编号得起始值，第一个导出函数的编号不是从0开始的，某个导出函数的编号等于base+AddressOfFunctions的所在编号。</li><li>AddressOfName：该值是一个指针，指向的位置是连续的双字节，这些双字节指向的是函数名字符串的地址。</li><li>AddressOfNameOrdinals：指向的是函数数字编号得地址。</li></ul><h2 id="3-导出表的应用"><a href="#3-导出表的应用" class="headerlink" title="3.导出表的应用"></a>3.导出表的应用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导出表常见的主要应用是<strong>对导出表函数的覆盖</strong>和对<strong>dll文件内部函数的导出</strong>。</p><h3 id="3-1-导出函数覆盖"><a href="#3-1-导出函数覆盖" class="headerlink" title="3.1.导出函数覆盖"></a>3.1.导出函数覆盖</h3><ul><li>修改导出表里面函数的地址。</li><li>覆盖函数地址部分函数代码。</li></ul><h3 id="3-2-导出私有函数"><a href="#3-2-导出私有函数" class="headerlink" title="3.2.导出私有函数"></a>3.2.导出私有函数</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-预备知识&quot;&gt;&lt;a href=&quot;#第一部分-预备知识&quot; class=&quot;headerlink&quot; title=&quot;第一部分 预备知识&quot;&gt;&lt;/a&gt;第一部分 预备知识&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;导入表主要存在于动态链接库文件中，用于将dll文件中的函数导入到外部，给其他的exe或者dll文件调用。我们在导入表一章中知道了程序在装载过程中，&lt;strong&gt;通过在INT获得的函数地址覆盖到IAT中，&lt;/strong&gt;此时，导出表起到了参照和指引的作用。&lt;br&gt;
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows PE》导入表</title>
    <link href="http://yoursite.com/2018/05/09/%E3%80%8Awindows%20PE%E3%80%8B%E5%AF%BC%E5%85%A5%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/05/09/《windows PE》导入表/</id>
    <published>2018-05-09T06:02:11.000Z</published>
    <updated>2018-05-28T10:00:41.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-预备知识"><a href="#第一部分-预备知识" class="headerlink" title="第一部分 预备知识"></a>第一部分 预备知识</h1><h2 id="1-函数导入流程"><a href="#1-函数导入流程" class="headerlink" title="1.函数导入流程"></a>1.函数导入流程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序在引用dll库函数的时候，需要从dll里面对所需要的函数进行导入，该导入过程如下：<br><a id="more"></a></p><ul><li>1.将库函数所需要的参数进行压栈。</li><li>2.call一个近地址的用户领空的函数。<br>  <img src="https://i.imgur.com/vAxQ9Wc.png" alt=""></li><li>3.jmp XXXX到dll内部的系统领空。<br>  <img src="https://i.imgur.com/ceEKp7o.png" alt=""></li></ul><h2 id="2-计算RVA对应的FOA"><a href="#2-计算RVA对应的FOA" class="headerlink" title="2.计算RVA对应的FOA"></a>2.计算RVA对应的FOA</h2><ul><li>查看RVA所落在的节区</li><li>计算偏移offset</li><li>计算在文件中的偏移<br>使用工具（PE或者exeinfope）</li></ul><h2 id="3-代码导入"><a href="#3-代码导入" class="headerlink" title="3.代码导入"></a>3.代码导入</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序需要执行dll相关代码，则相关代码指令必须存在于进程地址空间，也就是说，操作系统在加载的时候会根据导入表的描述将需要调用的函数指令加载到进程空间。但是系统不会重复加载同一个dll库，如果多个进程需要使用同一个dll，通过页面调度机制使得两个进程访问同一个动态数据库。</p><h1 id="第二部分-PE导入表"><a href="#第二部分-PE导入表" class="headerlink" title="第二部分 PE导入表"></a>第二部分 PE导入表</h1><h2 id="1-导入表如何定位"><a href="#1-导入表如何定位" class="headerlink" title="1.导入表如何定位"></a>1.导入表如何定位</h2><ul><li>第一步：利用Pe_View，在IMAGE_OPTIONAL_HEADER中DataDirectotion中的IMPORT Table。<br>  <img src="https://i.imgur.com/FIyhmPt.png" alt=""></li><li>第二歩：利用PEID查看文件各个区段的内存偏移和文件偏移，如上图，IMPORTTable的RVA是5000，通过查看PEID，发现位置正好落在idate段，所以，在文件中的偏移是1400<br>   <img src="https://i.imgur.com/3US7VdD.png" alt=""><br>   <img src="https://i.imgur.com/5hhgfTG.png" alt=""></li></ul><h2 id="2-导入表描述符IMAGE-IMPORT-DESCRIPTOR"><a href="#2-导入表描述符IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="2.导入表描述符IMAGE_IMPORT_DESCRIPTOR"></a>2.导入表描述符IMAGE_IMPORT_DESCRIPTOR</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导入表实际上是一个 IMAGE_IMPORT_DESCRIPTOR 结构数组。导入表数据的起始部分是多组导入表描述符结构。每个结构包含PE文件引入函数的一个相关DLL的信息。比如，如果该PE文件从10个不同的DLL中引入函数，那么这个数组就有10个成员。该数组以一个全0的成员结尾。一下是他的数据结构<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">IMAGE_IMPORT_DESCRIPTOR &#123;  </div><div class="line">    <span class="class"><span class="keyword">union</span> &#123;  </span></div><div class="line">        DWORD Characteristics;  </div><div class="line">        DWORD OriginalFirstThunk;     <span class="regexp">//</span>INT(导入名字表)的地址(RVA)桥<span class="number">1</span>  </div><div class="line">    &#125;;  </div><div class="line">    DWORD TimeDateStamp;     <span class="regexp">//</span>时间戳</div><div class="line">    DWORD ForwarderChain;    <span class="regexp">//</span>链表的前一个结构</div><div class="line">    DWORD Name;              <span class="regexp">//</span>指向链接库的指针  </div><div class="line">    DWORD FirstThunk;        <span class="regexp">//</span>(IAT)导入地址表的地址 (RVA)桥<span class="number">2</span>  </div><div class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</div></pre></td></tr></table></figure></p><h2 id="3-导入表的双桥结构"><a href="#3-导入表的双桥结构" class="headerlink" title="3.导入表的双桥结构"></a>3.导入表的双桥结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个结构IMAGE_IMPORT_DESCRIPTOR都对应的是一个唯一的dll文件。以及dll中的每个函数都可以通过”编号-名称”的方式找到，这就是导入表的双桥结构。如下图尽管这个桥对应的INT和IAT的内容是相同的，但是其存储的位置是不同的。<br>    <img src="https://i.imgur.com/pNn2oXb.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OriginalFirstThun指向的数组中每一项为一个结构，此结构的名称是IMAGE_THUNK_DATA。该结构实际上只是一个双字，但在不同的时刻却拥有不同的解释。该字段有两种解释：这个值是INT的地址，INT（Import Name Table）是一个存储了库文件函数名称的表。在装载的时候，PE装载器读取OriginalFirstThun获得INT，然后通过函数名称去获取函数的地址</p><ul><li>双字最高位为0，表示导入符号是一个数值，该数值是一个RVA。</li><li>双字最高位为1，表示导入符号是一个名称。<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct _IMAGE_IMPORT_BY_NAME &#123;  </div><div class="line">    <span class="type">WORD</span> <span class="type">Hint</span>;        //对dll中的每个函数进行标号，该值不是必须的</div><div class="line">    <span class="type">BYTE</span> <span class="type">Name</span>[1];     //函数名称  </div><div class="line">&#125; <span class="type">IMAGE_IMPORT_BY_NAME</span>, *<span class="type">PIMAGE_IMPORT_BY_NAME</span>;</div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FirstThunk指向的是IAT表，也是IMAGE_THUNK_DATA，但是对于程序的装载，并不使用IAT进行函数的寻址，在通过INT寻址之后，将找到的地址填充到IAT中。后期需要用到函数的时候，可以使用GetProcAddressAPI函数进行获取。</p><h2 id="4-导入函数地址表-IAT"><a href="#4-导入函数地址表-IAT" class="headerlink" title="4.导入函数地址表(IAT)"></a>4.导入函数地址表(IAT)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导入函数地址表位于数据目录的第十三个目录。用户程序通过该表的jmp指令无条件跳转到dll函数的VA处。因为该表中存着<strong>同一个dll</strong>不同的函数的VA地址，所以每个函数地址都是以”00”作为区分的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导入表和导入地址表是由紧密联系的。通过桥2可以定位到程序的IAT。在内存中，桥1可以找到<strong>调用函数的名称和函数的标号。</strong>桥2可以找到该函数指令代码在<strong>内存空间的地址</strong></p><h2 id="5-程序的装载过程。"><a href="#5-程序的装载过程。" class="headerlink" title="5.程序的装载过程。"></a>5.程序的装载过程。</h2><ul><li>第一步：PE加载器读取结构体成员的值，IMAGE_IMPORT_DESCRIPTOR.Name成员找到库名称，然后将库文件加载到内存中来。</li><li>第二歩：PE加载器读取OriginalFirstThunk值获得INT地址，然后依次读取INT各项的值，根据函数的标号获取函数的地址。</li><li>第三步：将获取的函数的地址填充到IAT表中。</li></ul><h1 id="第三部分：绑定导入"><a href="#第三部分：绑定导入" class="headerlink" title="第三部分：绑定导入"></a>第三部分：绑定导入</h1><h2 id="1-绑定导入机制"><a href="#1-绑定导入机制" class="headerlink" title="1.绑定导入机制"></a>1.绑定导入机制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windows在装载程序的时候，PE装载器负责对IAT中的地址进行修正工作。绑定导入的目的在于使用软件或者人工的方法，<strong>在程序装载之前，修正IAT表内的函数地址，</strong>从而提高加载数据。同样的，微软在引入绑定导入机制也考虑到了由于各种原因导致dll没有加载到目标地址，所以同时引入了<strong>错误检测机制</strong>，如果检测到此类错误，PE加载器则会接管IAT修正工作。加载器遍历INT，计算新的函数地址，由于同时要用道INT和IAT，<strong>所以：单桥结构无法使用静态绑定机制。</strong></p><h2 id="2-绑定导入表的定位和其数据结构"><a href="#2-绑定导入表的定位和其数据结构" class="headerlink" title="2.绑定导入表的定位和其数据结构"></a>2.绑定导入表的定位和其数据结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绑定地址表位于数据目录的第十二的项目，利用RVA-FOA转化，可以定位到文件在绑定导入表的地址。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绑定导入数据由IMAGE_BOUND_IMPORT_DESCRIPTOR结构组成，每个模块拥有一个该结构。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">IMAGE_BOUND_IMPORT_DESCRIPTOR struct</div><div class="line">&#123;</div><div class="line">TimeDateStamp <span class="comment">;时间戳</span></div><div class="line">    OffsetDllNmae  <span class="comment">;指向dll'的名称，</span></div><div class="line">    NumberOfModuleForWarderRefs   <span class="comment">;ModuleForWarderRefs数目</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>NumberOfModuleForWarderRefs描述的是IMAGE_BOUND_ModuleForWarderRefs结构体的数目，该结构体存在的原因是<strong>为了让dll模块保持向前兼容，使得模块继续保持原来函数的定义</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-预备知识&quot;&gt;&lt;a href=&quot;#第一部分-预备知识&quot; class=&quot;headerlink&quot; title=&quot;第一部分 预备知识&quot;&gt;&lt;/a&gt;第一部分 预备知识&lt;/h1&gt;&lt;h2 id=&quot;1-函数导入流程&quot;&gt;&lt;a href=&quot;#1-函数导入流程&quot; class=&quot;headerlink&quot; title=&quot;1.函数导入流程&quot;&gt;&lt;/a&gt;1.函数导入流程&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;程序在引用dll库函数的时候，需要从dll里面对所需要的函数进行导入，该导入过程如下：&lt;br&gt;
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令(3)软件包管理</title>
    <link href="http://yoursite.com/2018/05/07/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(3)%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/07/Linux常见命令(3)软件包管理/</id>
    <published>2018-05-07T07:02:11.000Z</published>
    <updated>2018-06-09T09:28:32.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-软件包管理简介"><a href="#第一部分-软件包管理简介" class="headerlink" title="第一部分 软件包管理简介"></a>第一部分 软件包管理简介</h1><h2 id="apt-管理软件包"><a href="#apt-管理软件包" class="headerlink" title="apt :管理软件包"></a>apt :管理软件包</h2><ul><li>apt [选项] [packagename]、<ul><li>apt-cache search packagename:搜索软件包<br><img src="https://i.imgur.com/18SSiEf.png" alt=""></li><li>apt-cache show packagename：显示软件包的信息<br><img src="https://i.imgur.com/7wW91NW.png" alt=""></li><li>sudo apt-get install packagename :安装软件<br><img src="https://i.imgur.com/XBO502b.png" alt=""></li><li>sudo apt-get install –reinstall packagename:重新安装软件<a id="more"></a><img src="https://i.imgur.com/7aUdrXq.png" alt=""></li><li>sudo apt-get remove packagename 删除包/卸载软件<br><img src="https://i.imgur.com/tkxvwEg.png" alt=""></li><li>sudo apt-get remove package –purge 删除包，包括删除配置文件等</li><li>sudo apt-get autoremove packagename 自动卸载软件但保留其配置文件</li><li>sudo apt-get -f install packagename:修复安装<br><img src="https://i.imgur.com/Rm6Wh66.png" alt=""></li><li>sudo apt-get update:更新源<br><img src="https://i.imgur.com/9Ecj4j7.png" alt=""></li><li>sudo apt-get upgrade:更新所有软件<br><img src="https://i.imgur.com/1wfzSk5.png" alt=""></li></ul></li></ul><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><ul><li>获取tar.gz源文件</li><li>tar -zxvf xxx.tar.gz 解压tar文件</li><li>./configure —&gt;makefile</li><li>make 编译</li><li>make install</li><li>service fuwu start:开启服务</li><li>/etc/init.d/fuwu start</li><li>测试：看进程</li><li>服务配置</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-软件包管理简介&quot;&gt;&lt;a href=&quot;#第一部分-软件包管理简介&quot; class=&quot;headerlink&quot; title=&quot;第一部分 软件包管理简介&quot;&gt;&lt;/a&gt;第一部分 软件包管理简介&lt;/h1&gt;&lt;h2 id=&quot;apt-管理软件包&quot;&gt;&lt;a href=&quot;#apt-管理软件包&quot; class=&quot;headerlink&quot; title=&quot;apt :管理软件包&quot;&gt;&lt;/a&gt;apt :管理软件包&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;apt [选项] [packagename]、&lt;ul&gt;
&lt;li&gt;apt-cache search packagename:搜索软件包&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/18SSiEf.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;apt-cache show packagename：显示软件包的信息&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/7wW91NW.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;sudo apt-get install packagename :安装软件&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/XBO502b.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;sudo apt-get install –reinstall packagename:重新安装软件
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows PE》PE文件头</title>
    <link href="http://yoursite.com/2018/05/07/%E3%80%8Awindows%20PE%E3%80%8BPE%E6%96%87%E4%BB%B6%E5%A4%B4/"/>
    <id>http://yoursite.com/2018/05/07/《windows PE》PE文件头/</id>
    <published>2018-05-07T06:02:11.000Z</published>
    <updated>2018-05-07T07:46:14.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-预备知识"><a href="#第一部分-预备知识" class="headerlink" title="第一部分 预备知识"></a>第一部分 预备知识</h1><h2 id="四类地址"><a href="#四类地址" class="headerlink" title="四类地址"></a>四类地址</h2><ul><li>虚拟地址（VA）</li><li>相对虚拟内存地址（RVA）</li><li>文件偏移地址（FOA）</li><li>特殊地址<a id="more"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟地址：PE文件被加载到内存，PE对应的进程拥有了4GB的空间，这个空间存在的地址就是虚拟地址。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对虚拟地址：相对与基地址的偏移量，RVA的存在是由于dll（模块）的基地址的不同而产生的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件偏移地址：文件中某个位置距离文件头的偏移量。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特殊位置，不细考究。</li></ul><h2 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据目录记录的是整个PE结构中存在的数据类型。</p><h2 id="节"><a href="#节" class="headerlink" title="节"></a>节</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节就是存放不同的类型的数据，不同的节区有不同的访问权限。</p><h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><ul><li>内存对齐</li><li>文件对齐</li><li>资源数据对齐<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存对齐：windows中，内存属性的基本单位是页，在32位系统是4KB(1000h)，在64位系统中是8kb。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件对齐：为了提高磁盘利用率，把一个物理扇区作为一个对齐粒度的大小，也就是12字节（200H）,这是每个数据段都是200H的整数倍的原因。<br><img src="/home/findream/桌面/QQ截图20180507125335.png" alt=""> </li></ul><h1 id="第二部分-32位windows系统的PE结构"><a href="#第二部分-32位windows系统的PE结构" class="headerlink" title="第二部分 32位windows系统的PE结构"></a>第二部分 32位windows系统的PE结构</h1><h2 id="定位标准的PE头"><a href="#定位标准的PE头" class="headerlink" title="定位标准的PE头"></a>定位标准的PE头</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于DOS stub是一个不确定的长度，所以导致DOS头也是一个不确定的长度，这时候，<strong>我们采用e_lfanew字段来定位后续的PE结构位置。该字段是一个偏移量。</strong>PE头的定位遵循一下公式：PE_Start=DOS_MZ+IMAGE_HANDER.e_lfanew.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PE文件结构:<br><img src="http://oxnvtxe03.bkt.clouddn.com/2018-05-07%2013-09-51%20%E5%88%9B%E5%BB%BA%E7%9A%84%E6%88%AA%E5%9B%BE.png" alt=""> </p><h1 id="第三部分-PE文件头部解析"><a href="#第三部分-PE文件头部解析" class="headerlink" title="第三部分 PE文件头部解析"></a>第三部分 PE文件头部解析</h1><h2 id="DOS-MZ头"><a href="#DOS-MZ头" class="headerlink" title="DOS MZ头"></a>DOS MZ头</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MZ头下有两个需要知道的成员。一个是<strong>e_magic</strong> ,一个是<strong>e_lfanew</strong></p><h2 id="PE头标志-Signature"><a href="#PE头标志-Signature" class="headerlink" title="PE头标志 Signature"></a>PE头标志 Signature</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signature标志位于DOS_STUB之后，该标志位于e_lfanew所指向的位置。内容固定，对应的ASCII是”PE\0\0”。<br><img src="http://oxnvtxe03.bkt.clouddn.com/2018-05-07%2013-33-18%20%E5%88%9B%E5%BB%BA%E7%9A%84%E6%88%AA%E5%9B%BE.png" alt=""> </p><h2 id="标准PE头-IMAGE-FILE-HEADER"><a href="#标准PE头-IMAGE-FILE-HEADER" class="headerlink" title="标准PE头 IMAGE_FILE_HEADER"></a>标准PE头 IMAGE_FILE_HEADER</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;位置：在PE文件头标志的后面，位于e_lfanew+4的位置。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大小：占据了20个字节。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：他记录了PE文件的全局属性（运行的平台，PE文件的类型，文件中存在的节区总数）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是FILE_HEADER的成员信息：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">        WORD    Machine;     <span class="comment">//运行平台</span></div><div class="line">        WORD    NumberOfSections;     <span class="comment">//节区数量</span></div><div class="line">        DWORD   TimeDateStamp;        <span class="comment">//创建时间</span></div><div class="line">        DWORD   PointerToSymbolTable;    <span class="comment">//指向符号表</span></div><div class="line">        DWORD   NumberOfSymbols;     <span class="comment">//符号表符号数</span></div><div class="line">        WORD    SizeOfOptionalHeader;    <span class="comment">//拓展头长度</span></div><div class="line">        WORD    Characteristics;        <span class="comment">//文件属性</span></div><div class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</div></pre></td></tr></table></figure></p><ul><li>Machime:该文件的运行平台，是x86、x64还是I64等等，可以是下面值里的某一个。</li><li>TimeDateStamp：PE文件的创建时间，一般有连接器填写</li><li>NumberOfSections：该PE文件中有多少个节，也就是节表中的项数</li><li>SizeOfOptionalHeader：紧随其后的可选头的大小。</li></ul><h2 id="拓展PE头IMAGE-OPTIONAL-HEADER32"><a href="#拓展PE头IMAGE-OPTIONAL-HEADER32" class="headerlink" title="拓展PE头IMAGE_OPTIONAL_HEADER32"></a>拓展PE头IMAGE_OPTIONAL_HEADER32</h2><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> </span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">        <span class="comment">// Standard fields.        </span></div><div class="line">        WORD    Magic;              <span class="comment">// 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）   </span></div><div class="line">        BYTE    MajorLinkerVersion;     <span class="comment">// 链接程序的主版本号   </span></div><div class="line">        BYTE    MinorLinkerVersion;     <span class="comment">// 链接程序的次版本号   </span></div><div class="line">        DWORD   SizeOfCode;         <span class="comment">// 所有含代码的节的总大小   </span></div><div class="line">        DWORD   SizeOfInitializedData;          <span class="comment">// 所有含已初始化数据的节的总大小   </span></div><div class="line">        DWORD   SizeOfUninitializedData;        <span class="comment">// 所有含未初始化数据的节的大小   </span></div><div class="line">        DWORD   AddressOfEntryPoint;        <span class="comment">// 程序执行入口RVA   </span></div><div class="line">        DWORD   BaseOfCode;         <span class="comment">// 代码的区块的起始RVA   </span></div><div class="line">        DWORD   BaseOfData;         <span class="comment">// 数据的区块的起始RVA   </span></div><div class="line">        <span class="comment">// NT additional fields.    以下是属于NT结构增加的领域。   </span></div><div class="line">        DWORD   ImageBase;          <span class="comment">// 程序的首选装载地址   </span></div><div class="line">        DWORD   SectionAlignment;       <span class="comment">// 内存中的区块的对齐大小   </span></div><div class="line">        DWORD   FileAlignment;          <span class="comment">// 文件中的区块的对齐大小   </span></div><div class="line">        WORD    MajorOperatingSystemVersion;    <span class="comment">// 要求操作系统最低版本号的主版本号   </span></div><div class="line">        WORD    MinorOperatingSystemVersion;    <span class="comment">// 要求操作系统最低版本号的副版本号   </span></div><div class="line">        WORD    MajorImageVersion;      <span class="comment">// 可运行于操作系统的主版本号   </span></div><div class="line">        WORD    MinorImageVersion;      <span class="comment">// 可运行于操作系统的次版本号   </span></div><div class="line">        WORD    MajorSubsystemVersion;      <span class="comment">// 要求最低子系统版本的主版本号   </span></div><div class="line">        WORD    MinorSubsystemVersion;      <span class="comment">// 要求最低子系统版本的次版本号   </span></div><div class="line">        DWORD   Win32VersionValue;      <span class="comment">// 莫须有字段，不被病毒利用的话一般为0   </span></div><div class="line">        DWORD   SizeOfImage;            <span class="comment">// 映像装入内存后的总尺寸   </span></div><div class="line">        DWORD   SizeOfHeaders;          <span class="comment">// 所有头+ 区块表的尺寸大小   </span></div><div class="line">        DWORD   CheckSum;           <span class="comment">// 映像的校检和   </span></div><div class="line">        WORD    Subsystem;          <span class="comment">// 可执行文件期望的子系统   </span></div><div class="line">        WORD    DllCharacteristics;     <span class="comment">// DllMain()函数何时被调用，默认为0   </span></div><div class="line">        DWORD   SizeOfStackReserve;     <span class="comment">// 初始化时的栈大小   </span></div><div class="line">        DWORD   SizeOfStackCommit;      <span class="comment">// 初始化时实际提交的栈大小   </span></div><div class="line">        DWORD   SizeOfHeapReserve;      <span class="comment">// 初始化时保留的堆大小   </span></div><div class="line">        DWORD   SizeOfHeapCommit;       <span class="comment">// 初始化时实际提交的堆大小   </span></div><div class="line">        DWORD   LoaderFlags;            <span class="comment">// 与调试有关，默认为0    </span></div><div class="line">        DWORD   NumberOfRvaAndSizes;        <span class="comment">// 下边数据目录的项数，这个字段自Windows NT 发布以来 一直是16   </span></div><div class="line">        IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];   <span class="comment">// 数据目录表   </span></div><div class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要我们熟悉的是以下几个成员。</p><ul><li>AddressOfEntryPoint;        // 程序执行入口RVA</li><li>BaseOfCode;         // 代码的区块的起始RVA </li><li>DWORD   ImageBase;          // 程序的首选装载地址</li><li>SectionAlignment;       // 内存中的区块的对齐大小</li><li>FileAlignment;          // 文件中的区块的对齐大小</li><li>SizeOfImage;            // 映像装入内存后的总尺寸</li><li>DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];   // 数据目录表</li></ul><h2 id="IMAGE-NT-HEADERS"><a href="#IMAGE-NT-HEADERS" class="headerlink" title="IMAGE_NT_HEADERS"></a>IMAGE_NT_HEADERS</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包括三个部分组成：PE头标志，IMAGE_FILE_HEADER,IMAGE_OPTIOANAL_HEADER.</p><h2 id="数据目录项-IMAGE-DATA-DIRECTORY"><a href="#数据目录项-IMAGE-DATA-DIRECTORY" class="headerlink" title="数据目录项 IMAGE_DATA_DIRECTORY"></a>数据目录项 IMAGE_DATA_DIRECTORY</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NT3.1开始，数据目录一共有16种，使用IMAGE_DATA_DIRECTORY来定义每种数据。<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct _IMAGE_DATA_DIRECTORY &#123;</div><div class="line">        <span class="type">DWORD</span>　<span class="type">VirtualAddress</span>; //相对虚拟地址  </div><div class="line">        <span class="type">DWORD</span>　<span class="type">Size</span>;　　　　　 //大小  </div><div class="line">&#125; <span class="type">IMAGE_DATA_DIRECTORY</span>, *<span class="type">PIMAGE_DATA_DIRECTORY</span>;</div></pre></td></tr></table></figure></p><p>##节表项IMAGE_SECTION_HEADER<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">typedef struct _IMAGE_SECTION_HEADER </div><div class="line">&#123;</div><div class="line">  <span class="keyword">BYTE </span> Name[IMAGE_SIZEOF_SHORT_NAME]<span class="comment">;//节区名称</span></div><div class="line">  union &#123;</div><div class="line">    DWORD PhysicalAddress<span class="comment">;</span></div><div class="line">    DWORD VirtualSize<span class="comment">;    //节区大小</span></div><div class="line">  &#125; Misc<span class="comment">;</span></div><div class="line">  DWORD VirtualAddress<span class="comment">;       //节区的RVA</span></div><div class="line">  DWORD SizeOfRawData<span class="comment">;      //在文件中对齐的尺寸</span></div><div class="line">  DWORD PointerToRawData<span class="comment">;   //在文件中的偏移</span></div><div class="line">  DWORD PointerToRelocations<span class="comment">;    //指向重定位表的指针</span></div><div class="line"> DWORD PointerToLinenumbers<span class="comment">;</span></div><div class="line">  WORD  NumberOfRelocations<span class="comment">;     //重定位表的数目</span></div><div class="line">  WORD  NumberOfLinenumbers<span class="comment">;</span></div><div class="line">  DWORD Characteristics<span class="comment">;       //节区表的属性</span></div><div class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER<span class="comment">;</span></div></pre></td></tr></table></figure></p><h1 id="第三部分-详细解析PE文件头字段"><a href="#第三部分-详细解析PE文件头字段" class="headerlink" title="第三部分 详细解析PE文件头字段"></a>第三部分 详细解析PE文件头字段</h1><h2 id="IMAGE-FILE-HEADER字段"><a href="#IMAGE-FILE-HEADER字段" class="headerlink" title="IMAGE_FILE_HEADER字段"></a>IMAGE_FILE_HEADER字段</h2><ul><li>Machine:<ul><li>位置：+0004H,</li><li>大小：单字</li><li>作用：查看文件可以在那种机器上运行。</li></ul></li><li>NumberOfSection：<ul><li>位置：+0006h</li><li>大小：单字</li><li>作用：文件中存在的节区的数目，数值不能小于1，但是节区数可以为0.</li></ul></li><li>TimeDateStamp <ul><li>位置：+0008h</li><li>大小：双字</li><li>作用：编译时间，压缩时被修改。</li></ul></li><li>SizeofOptionalHeader<ul><li>位置：+0014h</li><li>大小：单字</li><li>作用：指向的是OptionalHeader的大小。默认是00e0H，在64位是00f0H</li></ul></li><li>Character<ul><li>位置：+0016h</li><li>大小：单字</li><li>作用：标志这PE文件的类型，如果这个值是010fh的话，表示这是一个EXE文件，如果值是210eh，表示这个值是DLL文件。</li></ul></li></ul><h2 id="IMAGE-OPTIONAL-HEADER字段"><a href="#IMAGE-OPTIONAL-HEADER字段" class="headerlink" title="IMAGE_OPTIONAL_HEADER字段"></a>IMAGE_OPTIONAL_HEADER字段</h2><ul><li>Magic：表示该文件的类型：如果是010Bh，表示文件是32位，如果是0107H，表示文件是ROM，如果是020BH，表示文件是64位PE</li><li>AddressOfEntryPoint ：表示启动代码距离PE加载后的初始位置的偏移量，如果病毒需要在程序中启动恶意代码，则需要修改这一成员的数值。但是对于DLL文件，这一成员你的数值为0，因为不存在入口点。</li><li>BaseOfCode：代码段的起始RVA，但是不一定是程序的入口点。</li><li>ImageBase：PE文件的加载基地址。exe文件通常是00400000.</li><li>SizeOfImade：表示内存中整个PE文件的映射尺寸。</li><li>DllCharacteristics：DLL文件属性，但是不单纯是针对DLL文件，对于所有PE文件同样有效。</li><li>DataDirectory：目录数据，表示不同的节区的基本属性（RVA和size）。</li></ul><h2 id="IMAGE-SECTION-HEADER"><a href="#IMAGE-SECTION-HEADER" class="headerlink" title="IMAGE_SECTION_HEADER"></a>IMAGE_SECTION_HEADER</h2><ul><li>Name[IMAGE_SIZEOF_SHORT_NAME]： 八个字节的节去名称。</li><li>VirtualAddress：节区的RVA</li><li>SizeOfRAWDATA：节区对齐后的尺寸</li><li>PointOfRAWDATA：节区数据在文件中的偏移量。</li><li>PointerToRelocations：重定位表的指针</li><li>NumberOfRelocations：重定位表的数目</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-预备知识&quot;&gt;&lt;a href=&quot;#第一部分-预备知识&quot; class=&quot;headerlink&quot; title=&quot;第一部分 预备知识&quot;&gt;&lt;/a&gt;第一部分 预备知识&lt;/h1&gt;&lt;h2 id=&quot;四类地址&quot;&gt;&lt;a href=&quot;#四类地址&quot; class=&quot;headerlink&quot; title=&quot;四类地址&quot;&gt;&lt;/a&gt;四类地址&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;虚拟地址（VA）&lt;/li&gt;
&lt;li&gt;相对虚拟内存地址（RVA）&lt;/li&gt;
&lt;li&gt;文件偏移地址（FOA）&lt;/li&gt;
&lt;li&gt;特殊地址
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>看雪2017CTF</title>
    <link href="http://yoursite.com/2018/05/05/%E7%9C%8B%E9%9B%AACTF2017/"/>
    <id>http://yoursite.com/2018/05/05/看雪CTF2017/</id>
    <published>2018-05-05T03:00:11.000Z</published>
    <updated>2018-05-07T07:45:17.277Z</updated>
    
    <content type="html"><![CDATA[<p>这是看雪2017的CTF的题目，这套题目当时只做出了一题，现在继续做，同样还是根据WP，不断的学习，不断的进步，在现在安全圈子里面浮躁的大背景下，感谢看雪论坛仍然不忘初心，为我们保留了这一块儿净土。<br><a id="more"></a></p><h2 id="Problem-1：-Helllo-CTF"><a href="#Problem-1：-Helllo-CTF" class="headerlink" title="Problem 1： Helllo-CTF"></a>Problem 1： Helllo-CTF</h2><p>首先，使用OD查看字符串，定位到4017F0。<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">00401831 </span> |.  <span class="number">8</span>B4D F8       mov ecx,[local.<span class="number">2</span>]</div><div class="line"><span class="symbol">00401834 </span> |.  <span class="number">51</span>            push ecx                                  ; /s</div><div class="line"><span class="symbol">00401835 </span> |.  E8 <span class="number">5</span>C060000   <span class="keyword">call</span> &lt;jmp.&amp;MSVCRT.strlen&gt;                 ; \strlen</div><div class="line"><span class="number">0040183</span>A  |.  <span class="number">83</span>C4 <span class="number">04</span>       add esp,<span class="number">0</span>x4                               ;  保证有输入</div><div class="line"><span class="number">0040183D</span>  |.  <span class="number">85</span>C0          test eax,eax</div><div class="line"><span class="number">0040183</span>F  |.  <span class="number">75</span> <span class="number">13</span>         jnz Xhello.<span class="number">00401854</span></div><div class="line"><span class="symbol">00401841 </span> |.  <span class="number">6</span>A <span class="number">00</span>         push <span class="number">0</span>x0</div><div class="line"><span class="symbol">00401843 </span> |.  <span class="number">6</span>A <span class="number">00</span>         push <span class="number">0</span>x0</div><div class="line"><span class="symbol">00401845 </span> |.  <span class="number">68</span> <span class="number">98354000</span>   push hello.<span class="number">00403598</span>                       ;  请输入pass!</div><div class="line"><span class="number">0040184</span>A  |.  <span class="number">8</span>B4D FC       mov ecx,[local.<span class="number">1</span>]</div><div class="line"><span class="number">0040184D</span>  |.  E8 C0050000   <span class="keyword">call</span> &lt;jmp.&amp;MFC42.#<span class="number">4224</span>&gt;</div><div class="line"><span class="symbol">00401852 </span> |.  EB <span class="number">21</span>         jmp Xhello.<span class="number">00401875</span></div><div class="line"><span class="symbol">00401854 </span> |&gt;  <span class="number">68</span> <span class="number">80354000</span>   push hello.<span class="number">00403580</span>                       ; /WelcomeToKanXueCtf2017</div><div class="line"><span class="symbol">00401859 </span> |.  <span class="number">8</span>B55 F8       mov edx,[local.<span class="number">2</span>]                         ; |</div><div class="line"><span class="number">0040185</span>C  |.  <span class="number">52</span>            push edx                                  ; |s1</div><div class="line"><span class="number">0040185D</span>  |.  E8 <span class="number">2E060000</span>   <span class="keyword">call</span> &lt;jmp.&amp;MSVCRT.strcmp&gt;                 ; \strcmp</div><div class="line"><span class="symbol">00401862 </span> |.  <span class="number">83</span>C4 <span class="number">08</span>       add esp,<span class="number">0</span>x8                               ;  比较</div><div class="line"><span class="symbol">00401865 </span> |.  <span class="number">85</span>C0          test eax,eax</div></pre></td></tr></table></figure></p><p>第一个函数是比较成功的，第二个函数比较失败的<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">00401867 </span> |. /<span class="number">75</span> <span class="number">07</span>         jnz Xhello.<span class="number">00401870</span>   </div><div class="line"><span class="symbol">00401869 </span> |. |E8 <span class="number">02</span>FFFFFF   <span class="keyword">call</span> hello.<span class="number">00401770</span>     //比较成功</div><div class="line"><span class="number">0040186E</span>  |. |EB <span class="number">05</span>         jmp Xhello.<span class="number">00401875</span></div><div class="line"><span class="symbol">00401870 </span> |&gt; \E8 <span class="number">3</span>BFFFFFF   <span class="keyword">call</span> hello.<span class="number">004017</span>B0     //比较失败</div></pre></td></tr></table></figure></p><h2 id="Problem-2：ctf2017-Fpc"><a href="#Problem-2：ctf2017-Fpc" class="headerlink" title="Problem 2：ctf2017_Fpc"></a>Problem 2：ctf2017_Fpc</h2><p>首先了解一下作者对于这次CM的布局。作者利用scanf的不安全性，精心构造了一个栈溢出的漏洞。我们先来看看这个漏洞的形成机制。</p><ul><li>scanf的缓冲区大小是12个字节。<br>  <img src="https://i.imgur.com/0k44sZm.png" alt=""></li><li><p>如果我们输入的缓冲区大小小于12个字节的话</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0019</span>FF2C   <span class="number">0041</span>B08C  ASCII <span class="string">"%s"</span></div><div class="line"><span class="number">0019</span>FF30   <span class="number">0019</span>FF34  ASCII <span class="string">"123456"</span></div><div class="line"><span class="number">0019</span>FF34   <span class="number">34333231</span></div><div class="line"><span class="number">0019</span>FF38   <span class="number">00003635</span></div><div class="line"><span class="number">0019</span>FF3C   <span class="number">0040100</span>A  返回到 ctf2017_<span class="number">.0040100</span>A 来自 ctf2017_<span class="number">.00413</span>D42</div></pre></td></tr></table></figure></li><li><p>如果等于12个字节的话，返回到scanf函数的下一个地址。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0019</span>FF30   <span class="number">0019</span>FF34  ASCII <span class="string">"123456789ABC"</span></div><div class="line"><span class="number">0019</span>FF34   <span class="number">34333231</span></div><div class="line"><span class="number">0019</span>FF38   <span class="number">38373635</span></div><div class="line"><span class="number">0019</span>FF3C   <span class="number">43424139</span></div><div class="line"><span class="number">0019</span>FF40   <span class="number">00401000</span>  入口地址</div></pre></td></tr></table></figure></li><li><p>如果大于12个字节，超过的字节覆盖返回地址，产生栈溢出漏洞</p></li></ul><p>其次，出题人给出的栈溢出的溢出部分，利用OD或者IDA无法识别成代码的部分，因为反汇编器不可能去识别不加使用的部分为代码，所以这部分会被识别为数据。如图2.2，所以溢出函数在413131这个地址。我们可以得出结论，验证码是XXXXXXXXXXXX11A。<br>    <img src="https://i.imgur.com/j8DJrfd.png" alt=""></p><p>溢出后，发现存在很多花指令。利用OD去跟踪吧。根据多次run跟踪得出以下结论<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">(A-B)</span>*<span class="number">4</span>+A+C=<span class="number">0</span>xEAF<span class="number">917</span>E<span class="number">2</span></div><div class="line"><span class="comment">(A-B)</span>*<span class="number">2</span>+<span class="comment">(A-B)</span>+A+C=<span class="number">0</span>xE<span class="number">8</span>F<span class="number">508</span>C<span class="number">8</span></div><div class="line"><span class="comment">(A-B)</span>*<span class="number">2</span>+<span class="comment">(A-B)</span>+A-C=<span class="number">0</span>xC<span class="number">0</span>A<span class="number">3</span>C<span class="number">68</span></div></pre></td></tr></table></figure></p><p>解得：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">A</span> = <span class="number">0</span>x7473754A</div><div class="line"><span class="attr">B</span> = <span class="number">0</span>x726f6630</div><div class="line"><span class="attr">C</span> = <span class="number">0</span>x6E756630</div></pre></td></tr></table></figure></p><p>小端序显示：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Just<span class="number">0</span>for<span class="number">0</span>fu<span class="symbol">n11</span>A</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是看雪2017的CTF的题目，这套题目当时只做出了一题，现在继续做，同样还是根据WP，不断的学习，不断的进步，在现在安全圈子里面浮躁的大背景下，感谢看雪论坛仍然不忘初心，为我们保留了这一块儿净土。&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令(2)常用命令</title>
    <link href="http://yoursite.com/2018/04/28/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(2)%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/04/28/Linux常见命令(2)其他命令/</id>
    <published>2018-04-28T07:02:11.000Z</published>
    <updated>2018-06-21T10:53:48.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-帮助"><a href="#第一部分-帮助" class="headerlink" title="第一部分 帮助"></a>第一部分 帮助</h1><ul><li>man [命令] /info<ul><li>/ [查询的内容] 查询指定的字符串</li><li>man [配置文件名称] ：显示配置文件的作用。如果直接加绝对路径，显示的是配置文件的内容</li><li>有文件的帮助信息，也有配置文件的帮助信息。如果是man 5 [命令] 查看的是配置文件的帮助信息，如果是man 1 [命令] 显示的是命令的帮助信息【见linux(1) whereis命令】<br><img src="https://i.imgur.com/Z4tFW44.png" alt=""></li></ul></li><li>whatis [命令] ：显示命令作用（简略）//whereis [命令]<br>   <img src="https://i.imgur.com/dzVbLlm.png" alt=""></li><li>apropos [配置文件] ：显示配置文件的作用<br>   <img src="https://i.imgur.com/eoAu5q7.png" alt=""></li><li>命令 -h(–help)</li><li>help [命令] shell内置命令的帮助信息（shell编程中的命令）<ul><li>也可以查看命令的路径<br><img src="https://i.imgur.com/glgYvQ4.png" alt=""><br><img src="https://i.imgur.com/D9fufqV.png" alt=""><a id="more"></a><h1 id="第二部分-用户管理"><a href="#第二部分-用户管理" class="headerlink" title="第二部分 用户管理"></a>第二部分 用户管理</h1></li></ul></li><li>useradd [用户名]  添加用户</li><li>passwd [用户名]   为用户设置密码.</li><li>who 查看当前用户名(tty 本地登录 pts 远程登录)<br>  <img src="https://i.imgur.com/FkdVmdl.png" alt=""></li><li>w 登录用户和登录时间等具体信息<br>  <img src="https://i.imgur.com/S2Mfc4m.png" alt=""></li><li>usermod [选项] [用户ID]<ul><li>-g&lt;群组&gt;：修改用户所属的群组；</li><li>-G&lt;群组&gt;；修改用户所属的附加群组；</li><li>-l&lt;帐号名称&gt;：修改用户帐号名称；</li><li>-L：锁定用户密码，使密码无效；</li><li>-u<uid>：修改用户ID；</uid></li><li></li></ul></li></ul><h1 id="第三部分-压缩解压"><a href="#第三部分-压缩解压" class="headerlink" title="第三部分 压缩解压"></a>第三部分 压缩解压</h1><ul><li>gzip [文件名] ：压缩文件<strong>(只能压缩文件)，并且不保存源文件</strong><br>  <img src="https://i.imgur.com/Gs5rCP3.png" alt=""><ul><li>gunzip /(gzip -d) [压缩文件]：解压缩<br><img src="https://i.imgur.com/5NsHzrX.png" alt=""></li></ul></li><li>tar [选项] [压缩文件名] [目录]  <strong> 针对目录</strong><ul><li>-c 打包    //zcf（选项有顺序关系）</li><li>-v 显示详细信息</li><li>-f 指定文件名</li><li>-z 打包同时压缩<br><img src="https://i.imgur.com/v7PdOkl.png" alt=""></li><li>-cjf 生成 tar.bz2文件</li></ul></li><li>tar<ul><li>-x 解包 [压缩文件]</li><li>-z 解压缩</li><li>其他和压缩一样<br><img src="https://i.imgur.com/3e80H8u.png" alt=""></li><li>-xjf 解压tar.bz2压缩包</li></ul></li><li>zip [选项] [压缩文件] [带压缩文件]<ul><li>-r 压缩目录<br><img src="https://i.imgur.com/r5X4HCj.png" alt=""></li><li>unzip [压缩文件]   解压缩<br><img src="https://i.imgur.com/lbO9Oro.png" alt=""></li></ul></li><li>bzip2 [选项] [带压缩文件]<ul><li>-k 保存源文件<br><img src="https://i.imgur.com/83BBAso.png" alt=""></li><li>压缩比大</li></ul></li><li>bunzip2 [选项] [压缩文件]<ul><li>-k 是否保存压缩包</li></ul></li></ul><h1 id="第四部分-网络命令"><a href="#第四部分-网络命令" class="headerlink" title="第四部分 网络命令"></a>第四部分 网络命令</h1><ul><li>ping 测试网络通畅性<ul><li>-c 数量 ：ping的次数<br><img src="https://i.imgur.com/W9i09Db.png" alt=""></li></ul></li><li>ifconfig <ul><li>[网卡名称] [IP] ：网络配置信息</li></ul></li><li>last 用户登录信息<br>  <img src="https://i.imgur.com/cWxEZzb.png" alt=""></li><li>lastlog<ul><li>-u [用户ID]   </li></ul></li><li>traceroute [主机名]  追踪网络访问跃点<br>  <img src="https://i.imgur.com/A2EtXfT.png" alt=""></li><li><p>netstat 查询网络状态</p><ul><li>-t ：查询TCP协议状态</li><li>-u : UDP协议状态</li><li>-l ：监听</li><li>-r ：路由(网关)</li><li>-n ：显示IP地址及端口 </li><li>-a : 所有选项</li><li>常用实例：<ul><li>netstat -an: 查看本机所有的网络连接</li><li>netstat -tlun:查看本机监听的端口</li><li>netstat -rn:查看本机路由列表</li></ul></li></ul></li><li><p>mount [设备文件名] [挂载点]挂载</p><ul><li>1.创建一个挂载目录（/mnt下）</li><li>2.mount<br><img src="https://i.imgur.com/cMEdqNr.png" alt=""></li><li>3.umount [挂载点/设备文件名]卸载挂载点，但是不能在挂载点下卸载<br><img src="https://i.imgur.com/UlytG1f.png" alt=""></li></ul></li></ul><h1 id="第五部分-关机与重启"><a href="#第五部分-关机与重启" class="headerlink" title="第五部分 关机与重启"></a>第五部分 关机与重启</h1><ul><li>shotdown [选项] [参数]<ul><li>-h：将系统关机</li><li>-r：系统重新启动</li><li>-c：中断关机操作</li><li>-t：设置执行时间(s)</li><li>xx:xx(表示时间):shutdown -h xx:xx 表示xx：xx时关机 </li><li>now：参数表示立刻执行</li></ul></li><li>reboot ：立刻重启</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-帮助&quot;&gt;&lt;a href=&quot;#第一部分-帮助&quot; class=&quot;headerlink&quot; title=&quot;第一部分 帮助&quot;&gt;&lt;/a&gt;第一部分 帮助&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;man [命令] /info&lt;ul&gt;
&lt;li&gt;/ [查询的内容] 查询指定的字符串&lt;/li&gt;
&lt;li&gt;man [配置文件名称] ：显示配置文件的作用。如果直接加绝对路径，显示的是配置文件的内容&lt;/li&gt;
&lt;li&gt;有文件的帮助信息，也有配置文件的帮助信息。如果是man 5 [命令] 查看的是配置文件的帮助信息，如果是man 1 [命令] 显示的是命令的帮助信息【见linux(1) whereis命令】&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/Z4tFW44.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;whatis [命令] ：显示命令作用（简略）//whereis [命令]&lt;br&gt;   &lt;img src=&quot;https://i.imgur.com/dzVbLlm.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;apropos [配置文件] ：显示配置文件的作用&lt;br&gt;   &lt;img src=&quot;https://i.imgur.com/eoAu5q7.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;命令 -h(–help)&lt;/li&gt;
&lt;li&gt;help [命令] shell内置命令的帮助信息（shell编程中的命令）&lt;ul&gt;
&lt;li&gt;也可以查看命令的路径&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/glgYvQ4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/D9fufqV.png&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
</feed>
