<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>findream&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-16T10:01:36.359Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>findream</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux常见命令(4)用户和用户组管理</title>
    <link href="http://yoursite.com/2018/05/15/Linux(4)%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/15/Linux(4)用户和用户组管理/</id>
    <published>2018-05-15T07:02:11.000Z</published>
    <updated>2018-05-16T10:01:36.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-用户信息配置文件passwd"><a href="#第一部分-用户信息配置文件passwd" class="headerlink" title="第一部分 用户信息配置文件passwd"></a>第一部分 用户信息配置文件passwd</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户信息文件路径为/etc/passwd,一共有七个字段。分别是用户名称，秘密标志，UID,GID，用户说明，主目录，shell。<br>    <img src="https://i.imgur.com/cpdt8BN.png" alt=""><br><a id="more"></a></p><ul><li>用户名称</li><li>密码标志：x代表设置密码，其他代表没有设置密码</li><li>UID：用户编号，系统唯一标识用户信息的编号，通过修改UID，可以修改权限，例如把UID修改为0，达到管理员权限。<ul><li>0 超级用户</li><li>1-499 系统用户（系统中应用程序的用户，不可删除）</li><li>500-65535 普通用户</li></ul></li><li>GID：组ID<ul><li>初始化组：<ul><li>每个用户只有一个初始化组</li><li>每个用户必须要有初始化组</li><li>可以修改初始化组，但是不建议修改</li></ul></li><li>附加组：<ul><li>每个用户可以有多个附加组，但是拥有附加组的权限</li></ul></li></ul></li><li>用户说明</li><li>主目录：<ul><li>root用户的主目录是/root<br><img src="https://i.imgur.com/hb45jFV.png" alt=""></li><li>普通用户的主目录是/home/usrname<br><img src="https://i.imgur.com/lEYPJmN.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是值得注意的是 sudo -s并不是进入管理员账号，而是获取了管理员的权限，你利用pwd会发现，使用sudo -s，他的工作目录并不是/root，而是/home/username。</li></ul></li><li>shell：用户使用shell解释器的路径</li></ul><h1 id="第二部分-shadow文件"><a href="#第二部分-shadow文件" class="headerlink" title="第二部分 shadow文件"></a>第二部分 shadow文件</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadow文件位于/etc/shadow中（利用man 5 shadow可查），需要root权限才能打开。一共有八个字段，分别是：用户名，加密的密码串，最后一次修改密码的日期(时间戳)，密码有效期，最大密码年龄，警告时间段，密码禁用期，账号过期日期，保留。<br>    <img src="https://i.imgur.com/pmd6SXJ.png" alt=""></p><ul><li>用户名</li><li>加密的密码串：使用*或者！表示密码无效，也就是说账户被禁用。</li><li>最后一次修改密码的时间戳：<ul><li>0：表示下次登陆账户时，修改密码</li><li>为空：表示密码年龄的功能被禁用</li></ul></li><li>密码有效期(最小密码年龄)：修改密码之后，要等n时间才能被允许修改密码。<ul><li>0或者为空：表示没有设置密码有效期</li></ul></li><li>最大密码年龄:在最大密码年龄之后必须要修改密码</li><li>警告时间段：在密码到期之前n天，警告必须修改密码</li><li>密码禁用期：过了密码有效期之后，仍可以使用原密码登录的最大期限。过了此期限后，账户不能登录，空字段表示没有强制密码过期。</li><li>账户过期日期：</li><li>保留<br>  <img src="https://i.imgur.com/LjpkH5X.png" alt=""></li></ul><h1 id="第三部分-group和gshadow组配置文件"><a href="#第三部分-group和gshadow组配置文件" class="headerlink" title="第三部分 group和gshadow组配置文件"></a>第三部分 group和gshadow组配置文件</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group文件在/etc/group,文件下面一共有四个字段，分别是组名，组密码标志，GID，组中的附加用户。</p><ul><li>组名：在linux中，每次新加一个用户，该用户的初始组名也是用户名</li><li>密码标志：存在密码为“x”字段，在etc/gshadow文件下可查看，但是基本都不存在组密码。存在的意义在于：执行了受限的root用户的权限，管理组内的用户。</li><li>GID:</li><li>附加用户：看不到初始用户。只能看附加用户，如果需要查看组的初始用户，先查看passwd中的GID，然后再看group中的GID，就行了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gshadow文件在/etc/gshadow，有四个字段：组名，组密码，组管理员用户名，组中附加用户。</li></ul><h1 id="第四部分："><a href="#第四部分：" class="headerlink" title="第四部分："></a>第四部分：</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户主目录：root用户为/root,权限为550，普通用户为/home/username,权限为700</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-用户信息配置文件passwd&quot;&gt;&lt;a href=&quot;#第一部分-用户信息配置文件passwd&quot; class=&quot;headerlink&quot; title=&quot;第一部分 用户信息配置文件passwd&quot;&gt;&lt;/a&gt;第一部分 用户信息配置文件passwd&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;用户信息文件路径为/etc/passwd,一共有七个字段。分别是用户名称，秘密标志，UID,GID，用户说明，主目录，shell。&lt;br&gt;    &lt;img src=&quot;https://i.imgur.com/cpdt8BN.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows PE》延迟加载导入表</title>
    <link href="http://yoursite.com/2018/05/14/%E3%80%8Awindows%20PE%E3%80%8B%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/05/14/《windows PE》延迟加载表/</id>
    <published>2018-05-14T11:02:11.000Z</published>
    <updated>2018-05-15T05:34:20.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="1-延迟加载导入的概念及作用"><a href="#1-延迟加载导入的概念及作用" class="headerlink" title="1.延迟加载导入的概念及作用"></a>1.延迟加载导入的概念及作用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;延迟加载导入表和导入表示相互分离的，延迟加载导入表是特殊的导入表，和导入表不同的是，延迟加载导入表所记录的dll不会被操作系统加载，只有在函数被应用程序调用的时候，PE中注册的延迟加载函数才会根据延迟加载导入表的记录，动态加载dll，以及修正导入函数的VA。</p><h2 id="2-延迟加载的优势"><a href="#2-延迟加载的优势" class="headerlink" title="2.延迟加载的优势"></a>2.延迟加载的优势</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;延迟加载由于没有在程序初始化的时候初始化dll，只是会在应用程序调用某个模块的时候加载该模块，所以使用延迟加载技术的程序拥有更高的初始化速度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过延迟加载的方法，提高了程序的兼容性，原因在于基于延迟加载，所用到的模块不需要在初始化前加载，保证了程序能够运行成功，如果缺少模块或者缺少模<br>块里面的函数造成的异常，可以使得编译器单独处理该某个dll或者某个函数的调用。</p><h1 id="PE中的延迟加载导入表"><a href="#PE中的延迟加载导入表" class="headerlink" title="PE中的延迟加载导入表"></a>PE中的延迟加载导入表</h1><h2 id="1-延迟加载导入表的定位"><a href="#1-延迟加载导入表的定位" class="headerlink" title="1.延迟加载导入表的定位"></a>1.延迟加载导入表的定位</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;延迟加载导入表的描述信息在数目目录的第14个目录项中，定位方法和前面的导入导出表一致。</p><h2 id="2-延迟加载描述符IMAGE-DELAY-IMPORT-DESCRIPTOR"><a href="#2-延迟加载描述符IMAGE-DELAY-IMPORT-DESCRIPTOR" class="headerlink" title="2.延迟加载描述符IMAGE_DELAY_IMPORT_DESCRIPTOR"></a>2.延迟加载描述符IMAGE_DELAY_IMPORT_DESCRIPTOR</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IMAGE_DELAY_IMPORT_DESCRIPTOR的结构如下：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_DELAY_IMPORT_DESCRIPTOR</span> STRUCT </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    DWORD           Attributes;           <span class="comment">// 保留  </span></div><div class="line">    RVA             RVA_DLLName;          <span class="comment">// 指向延迟加载dll的名字字符串的RVA  </span></div><div class="line">    RVA             RVA_ModuleHandle;     <span class="comment">// 指向DLL句柄的RVA   </span></div><div class="line">    RVA             RVA_DelayIAT;         <span class="comment">// RVA of the IAT  </span></div><div class="line">    RVA             RVA_DelayINT;         <span class="comment">// RVA of the INT  </span></div><div class="line">    RVA             RVA_BoundIAT;      <span class="comment">// RVA of the optional bound IAT  </span></div><div class="line">    RVA             RVA_UnloadIAT;     <span class="comment">// RVA of optional copy of original IAT  </span></div><div class="line">    DWORD           dwTimeStamp;       <span class="comment">// 0 if not bound,  </span></div><div class="line">                                       <span class="comment">// 绑定到DLL的时间戳</span></div><div class="line">&#125; ImgDelayDescr, * PImgDelayDescr;</div></pre></td></tr></table></figure></p><ul><li>Attributes：双字，暂时未用到，</li><li>RVA_DLLName：双字，延迟加载dll名称的字符串的地址。</li><li>RVA_ModuleHandle：双字，延迟加载dll的句柄的地址。</li><li>RVA_DelayIAT: 延迟加载导入地址表的RVA</li><li>RVA_DelayINT：延迟加载导入名称表的RVA</li><li>RVA_BoundIAT：延迟绑定导入地址表的RVA，延迟绑定导入地址表是由IMAGE_THUNK_DATA组成的数组。他和最后一项dwTimeStamp用于最后的绑定阶段。</li><li>RVA_UnloadIAT：延迟卸载导入地址表由IMAGE_THUNK_DATA组成的数组，程序使用它来卸载dll(包括函数)，所用到的参数是原来IAT的精确副本。做释放处理需要做一下几个工作<ul><li>1）释放函数/dll</li><li>2）ModuleHandle清零</li><li>3）使用UIAT覆盖IAT。</li></ul></li></ul><h2 id="3-详解延迟加载机制"><a href="#3-详解延迟加载机制" class="headerlink" title="3.详解延迟加载机制"></a>3.详解延迟加载机制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用延迟加载技术的程序，链接器会做一下几个事情：</p><ul><li>1）将函数_delayLoadHelper嵌入到可执行模块</li><li>2）删除可执行文件导入表的相关内容，避免在初始化时候显式加载dll</li><li>3）构造PE相关信息，以便_delayLoadHelper正确的延迟加载函数。</li><li>4）调用_delayLoadHelper函数加载dll或获取调用函数地址。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在_delayLoadHelper函数中，还调用了LoadLibrary加载dll，调用了GetprocessAddress获取函数地址，调用了FreeLibrary去释放dll。</li></ul><h2 id="4-利用windbg查看延迟加载导入表"><a href="#4-利用windbg查看延迟加载导入表" class="headerlink" title="4.利用windbg查看延迟加载导入表"></a>4.利用windbg查看延迟加载导入表</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们首先用windows xp下的explorer程序举例子。</p><ul><li>查看程序加载的模块：<strong>lm m explorer</strong><br>  <img src="https://i.imgur.com/OwrUPxC.png" alt=""></li><li>显示PE文件头：<strong>!dh start_address -f</strong><br>  <img src="https://i.imgur.com/WmC45oC.png" alt=""></li><li>查看延迟加载导入的内存空间:<strong>dd start_address+offset</strong><br>  <img src="https://i.imgur.com/ER4HHJ0.png" alt=""></li><li>比如查看延迟加载导入表第二项的内容dll的ASCII：<strong>da address</strong><br>  <img src="https://i.imgur.com/fvZrYYJ.png" alt=""></li></ul><h2 id="4-延迟导入的两个问题"><a href="#4-延迟导入的两个问题" class="headerlink" title="4.延迟导入的两个问题"></a>4.延迟导入的两个问题</h2><h3 id="1）异常处理"><a href="#1）异常处理" class="headerlink" title="1）异常处理"></a>1）异常处理</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过延迟加载机制，未能成功加载的dll或者由于版本问题，未能成功调用的函数，函数_delayLoadHelper会抛出软件异常（其实是API函数剖出的异常）</p><h3 id="2）dll卸载"><a href="#2）dll卸载" class="headerlink" title="2）dll卸载"></a>2）dll卸载</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不能使用FreeLibrary卸载dll，因为在函数_delayLoadHelper中存在卸载函数，</p><h1 id="3-延迟加载机制在dll注入的实例。"><a href="#3-延迟加载机制在dll注入的实例。" class="headerlink" title="3.延迟加载机制在dll注入的实例。"></a>3.延迟加载机制在dll注入的实例。</h1><p><a href="https://www.anquanke.com/post/id/86919" target="_blank" rel="external">https://www.anquanke.com/post/id/86919</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;h2 id=&quot;1-延迟加载导入的概念及作用&quot;&gt;&lt;a href=&quot;#1-延迟加载导入的概念及作用&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows PE》重定位表</title>
    <link href="http://yoursite.com/2018/05/14/%E3%80%8Awindows%20PE%E3%80%8B%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/05/14/《windows PE》重定位表/</id>
    <published>2018-05-14T06:02:11.000Z</published>
    <updated>2018-05-14T11:07:04.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识：代码重定位"><a href="#预备知识：代码重定位" class="headerlink" title="预备知识：代码重定位"></a>预备知识：代码重定位</h1><h2 id="重定位的提出"><a href="#重定位的提出" class="headerlink" title="重定位的提出"></a>重定位的提出</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码重定位是把可执行代码从内存的一块区域移动到另外一块地方。但是如果指令中某些操作数没有随着地址的改变而改变，这样势必导致运行出错。如下代码：我们发现全局变量的地址包含在机器码中，而局部变量没有包含绝对地址。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line"><span class="keyword">add</span> <span class="built_in">esp</span>,ffffffc</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [00400FFC]   //全局变量</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">04</span>]     //局部变量</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [evp+<span class="number">08</span>]     //局部变量</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定位信息是在编译时期由编译器生成，并且保存在应用程序中，在程序执行的时候由操作系统予以修正。如果在装载时该位置已经被别的应用程序使用，操作系统会<strong>重新选择一个新的基地址</strong>。此时，就需要对所有重定位信息进行纠正，纠正的依据就是<strong>PE中的重定位表</strong>。<br><a id="more"></a></p><h1 id="PE文件中的重定位表"><a href="#PE文件中的重定位表" class="headerlink" title="PE文件中的重定位表"></a>PE文件中的重定位表</h1><h2 id="1-重定位表的定位"><a href="#1-重定位表的定位" class="headerlink" title="1.重定位表的定位"></a>1.重定位表的定位</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定位表位于数据目录中的第六个数据目录中。位置定位方法和前面的导入表和导出表一样。<br>    <img src="https://i.imgur.com/UqrSU1r.png" alt=""></p><h2 id="2-重定位表项IMAGE-BASE-RELOCATION"><a href="#2-重定位表项IMAGE-BASE-RELOCATION" class="headerlink" title="2.重定位表项IMAGE_BASE_RELOCATION"></a>2.重定位表项IMAGE_BASE_RELOCATION</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和导入表一样，重定位表指针指向的位置是一个数组。<strong>每个数组代表的是每一个内存页的重定位信息。</strong>也就是说每个内存页的重定位信息是不同的。下面是对于IMAGE_BASE_RELOCATION结构体的介绍:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">IMAGE_BASE_RELOCATION STRUC 【基址重定位位于数据目录表的第六项，共<span class="number">8</span>+N字节】</div><div class="line">&#123;</div><div class="line">+<span class="number">00</span> h DWORD VirtualAddress ;重定位数据开始的RVA 地址</div><div class="line">+<span class="number">04</span> h DWORD SizeOfBlock ;重定位块得长度，标识重定向字段个数</div><div class="line">+<span class="number">08</span> h WORD TypeOffset ;重定项位数组相对虚拟RVA,个数动态分配</div><div class="line">&#125;;</div><div class="line">IMAGE_BASE_RELOCATION ENDS</div></pre></td></tr></table></figure></p><ul><li>VirtualAddress:双字，表示的是重定位块的RVA。<strong>本来一个地址需要4个字节，因为一个内存页大小诶1000h,也就是2的12次，所以只需要2个字节即可</strong></li><li>SizeOfBlock：双字，重定位表项中的重定位块的个数。这些数组(表项)可能不是相邻的。</li><li>TypeOffset：表示重定位表项的类型：高四位表示的是类型。低十二位表示的重定位地址。<br>  <img src="https://i.imgur.com/QjFxUnO.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定位块的大小：n*12+4+4</li></ul><h2 id="3-重定位表的结构"><a href="#3-重定位表的结构" class="headerlink" title="3.重定位表的结构"></a>3.重定位表的结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定位表中包含有重定位块，重定位块中包含有重定位表项和前面的VirtualAddress，SizeOfBlock，TypeOffset字段。<br>    <img src="https://i.imgur.com/4pZ0mvd.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有的重定位块最终以VirtualAddress字段为0的IMAGE_BASE_RELOCATION结构为结束标志。</p><h2 id="4-实例分析"><a href="#4-实例分析" class="headerlink" title="4.实例分析"></a>4.实例分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下图，我们知道第一个重定位块位于0x1c00，代码起始页面RVA为00001000，块的大小为000000E8。后面的是每个重定位表项的相对位置。根据以下计算公式得到最终的实际地址。<br>VA=基地址(程序基地址)+代码起始页面RVA+<strong>低12位虚拟地址。</strong><br>VA=01000000+00001000+009<br>    <img src="https://i.imgur.com/tLuBjY9.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;预备知识：代码重定位&quot;&gt;&lt;a href=&quot;#预备知识：代码重定位&quot; class=&quot;headerlink&quot; title=&quot;预备知识：代码重定位&quot;&gt;&lt;/a&gt;预备知识：代码重定位&lt;/h1&gt;&lt;h2 id=&quot;重定位的提出&quot;&gt;&lt;a href=&quot;#重定位的提出&quot; class=&quot;headerlink&quot; title=&quot;重定位的提出&quot;&gt;&lt;/a&gt;重定位的提出&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;代码重定位是把可执行代码从内存的一块区域移动到另外一块地方。但是如果指令中某些操作数没有随着地址的改变而改变，这样势必导致运行出错。如下代码：我们发现全局变量的地址包含在机器码中，而局部变量没有包含绝对地址。&lt;br&gt;&lt;figure class=&quot;highlight x86asm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;ebp&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;ebp&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;esp&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;esp&lt;/span&gt;,ffffffc&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;eax&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;dword&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;ptr&lt;/span&gt; [00400FFC]   //全局变量&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;eax&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;dword&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;ptr&lt;/span&gt; [&lt;span class=&quot;built_in&quot;&gt;ebp&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;04&lt;/span&gt;]     //局部变量&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;eax&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;dword&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;ptr&lt;/span&gt; [evp+&lt;span class=&quot;number&quot;&gt;08&lt;/span&gt;]     //局部变量&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;重定位信息是在编译时期由编译器生成，并且保存在应用程序中，在程序执行的时候由操作系统予以修正。如果在装载时该位置已经被别的应用程序使用，操作系统会&lt;strong&gt;重新选择一个新的基地址&lt;/strong&gt;。此时，就需要对所有重定位信息进行纠正，纠正的依据就是&lt;strong&gt;PE中的重定位表&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows PE》导出表</title>
    <link href="http://yoursite.com/2018/05/11/%E3%80%8Awindows%20PE%E3%80%8B%E5%AF%BC%E5%87%BA%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/05/11/《windows PE》导出表/</id>
    <published>2018-05-11T06:02:11.000Z</published>
    <updated>2018-05-11T06:00:30.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-预备知识"><a href="#第一部分-预备知识" class="headerlink" title="第一部分 预备知识"></a>第一部分 预备知识</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导入表主要存在于动态链接库文件中，用于将dll文件中的函数导入到外部，给其他的exe或者dll文件调用。我们在导入表一章中知道了程序在装载过程中，通过在INT获得的函数地址覆盖到IAT中，此时，导出表起到了参照和指引的作用。<br><a id="more"></a></p><h1 id="第二部分-导出表数据结构"><a href="#第二部分-导出表数据结构" class="headerlink" title="第二部分 导出表数据结构"></a>第二部分 导出表数据结构</h1><h2 id="1-定位导出表"><a href="#1-定位导出表" class="headerlink" title="1.定位导出表"></a>1.定位导出表</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导出表数据在数据目录的第一个目录中，定位方法和获取导入表的一样。<br>    <img src="https://i.imgur.com/oF80lie.png" alt=""></p><h2 id="2-导出目录IMAGE-EXPORT-DIRECTORY"><a href="#2-导出目录IMAGE-EXPORT-DIRECTORY" class="headerlink" title="2.导出目录IMAGE_EXPORT_DIRECTORY"></a>2.导出目录IMAGE_EXPORT_DIRECTORY</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个结构是导出表描述符，导入表的IMAGE_EXPORT_DIRECTORY只有一个。下面是其详细定义：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> </span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    DWORD   Characteristics;    <span class="comment">// 未使用，总为0     DWORD   TimeDateStamp;              // 文件创建时间戳</span></div><div class="line">    WORD    MajorVersion;       <span class="comment">// 未使用，总为0     WORD    MinorVersion;               // 未使用，总为0</span></div><div class="line">    DWORD   Name;               <span class="comment">// 指向一个代表此 DLL名字的 ASCII字符串的 RVA</span></div><div class="line">    DWORD   Base;               <span class="comment">// 函数的起始序号</span></div><div class="line">    DWORD   NumberOfFunctions;  <span class="comment">// 导出函数的总数    </span></div><div class="line">    DWORD   NumberOfNames;           <span class="comment">// 以名称方式导出的函数的总数    </span></div><div class="line">    DWORD   AddressOfFunctions;      <span class="comment">// 指向输出函数地址的RVA</span></div><div class="line">    DWORD   AddressOfNames;         <span class="comment">// 指向输出函数名字的RVA</span></div><div class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// 指向输出函数序号的RVA</span></div><div class="line">&#125;IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</div></pre></td></tr></table></figure></p><ul><li>Name:文件最初的文件名</li><li>NumberOfFunctions：导出函数的个数</li><li>NumberOfNmaes：导出函数其中有名字的个数，NumberOfNames的值小于NumberOfFunctions</li><li>AddressOfFunctions：该指针指向的是所有导出函数的入口地址的起始。函数地址顺序按照函数的编号排序。</li><li>Base：导出函数编号得起始值，第一个导出函数的编号不是从0开始的，某个导出函数的编号等于base+AddressOfFunctions的所在编号。</li><li>AddressOfName：该值是一个指针，指向的位置是连续的双字节，这些双字节指向的是函数名字符串的地址。</li><li>AddressOfNameOrdinals：指向的是函数数字编号得地址。</li></ul><h2 id="3-导出表的应用"><a href="#3-导出表的应用" class="headerlink" title="3.导出表的应用"></a>3.导出表的应用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导出表常见的主要应用是<strong>对导出表函数的覆盖</strong>和对<strong>dll文件内部函数的导出</strong>。</p><h3 id="3-1-导出函数覆盖"><a href="#3-1-导出函数覆盖" class="headerlink" title="3.1.导出函数覆盖"></a>3.1.导出函数覆盖</h3><ul><li>修改导出表里面函数的地址。</li><li>覆盖函数地址部分函数代码。</li></ul><h3 id="3-2-导出私有函数"><a href="#3-2-导出私有函数" class="headerlink" title="3.2.导出私有函数"></a>3.2.导出私有函数</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-预备知识&quot;&gt;&lt;a href=&quot;#第一部分-预备知识&quot; class=&quot;headerlink&quot; title=&quot;第一部分 预备知识&quot;&gt;&lt;/a&gt;第一部分 预备知识&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;导入表主要存在于动态链接库文件中，用于将dll文件中的函数导入到外部，给其他的exe或者dll文件调用。我们在导入表一章中知道了程序在装载过程中，通过在INT获得的函数地址覆盖到IAT中，此时，导出表起到了参照和指引的作用。&lt;br&gt;
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows PE》导入表</title>
    <link href="http://yoursite.com/2018/05/09/%E3%80%8Awindows%20PE%E3%80%8B%E5%AF%BC%E5%85%A5%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/05/09/《windows PE》导入表/</id>
    <published>2018-05-09T06:02:11.000Z</published>
    <updated>2018-05-10T09:37:59.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-预备知识"><a href="#第一部分-预备知识" class="headerlink" title="第一部分 预备知识"></a>第一部分 预备知识</h1><h2 id="1-函数导入流程"><a href="#1-函数导入流程" class="headerlink" title="1.函数导入流程"></a>1.函数导入流程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序在引用dll库函数的时候，需要从dll里面对所需要的函数进行导入，该导入过程如下：<br><a id="more"></a></p><ul><li>1.将库函数所需要的参数进行压栈。</li><li>2.call一个近地址的用户领空的函数。<br>  <img src="https://i.imgur.com/vAxQ9Wc.png" alt=""></li><li>3.jmp XXXX到dll内部的系统领空。<br>  <img src="https://i.imgur.com/ceEKp7o.png" alt=""></li></ul><h2 id="2-计算RVA对应的FOA"><a href="#2-计算RVA对应的FOA" class="headerlink" title="2.计算RVA对应的FOA"></a>2.计算RVA对应的FOA</h2><ul><li>查看RVA所落在的节区</li><li>计算偏移offset</li><li>计算在文件中的偏移<br>使用工具（PE或者exeinfope）</li></ul><h2 id="3-代码导入"><a href="#3-代码导入" class="headerlink" title="3.代码导入"></a>3.代码导入</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序需要执行dll相关代码，则相关代码指令必须存在于进程地址空间，也就是说，操作系统在加载的时候会根据导入表的描述将需要调用的函数指令加载到进程空间。但是系统不会重复加载同一个dll库，如果多个进程需要使用同一个dll，通过页面调度机制使得两个进程访问同一个动态数据库。</p><h1 id="第二部分-PE导入表"><a href="#第二部分-PE导入表" class="headerlink" title="第二部分 PE导入表"></a>第二部分 PE导入表</h1><h2 id="1-导入表如何定位"><a href="#1-导入表如何定位" class="headerlink" title="1.导入表如何定位"></a>1.导入表如何定位</h2><ul><li>第一步：利用Pe_View，在IMAGE_OPTIONAL_HEADER中DataDirectotion中的IMPORT Table。<br>  <img src="https://i.imgur.com/FIyhmPt.png" alt=""></li><li>第二歩：利用PEID查看文件各个区段的内存偏移和文件偏移，如上图，IMPORTTable的RVA是5000，通过查看PEID，发现位置正好落在idate段，所以，在文件中的偏移是1400<br>   <img src="https://i.imgur.com/3US7VdD.png" alt=""><br>   <img src="https://i.imgur.com/5hhgfTG.png" alt=""></li></ul><h2 id="2-导入表描述符IMAGE-IMPORT-DESCRIPTOR"><a href="#2-导入表描述符IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="2.导入表描述符IMAGE_IMPORT_DESCRIPTOR"></a>2.导入表描述符IMAGE_IMPORT_DESCRIPTOR</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导入表实际上是一个 IMAGE_IMPORT_DESCRIPTOR 结构数组。导入表数据的起始部分是多组导入表描述符结构。每个结构包含PE文件引入函数的一个相关DLL的信息。比如，如果该PE文件从10个不同的DLL中引入函数，那么这个数组就有10个成员。该数组以一个全0的成员结尾。一下是他的数据结构<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">IMAGE_IMPORT_DESCRIPTOR &#123;  </div><div class="line">    <span class="class"><span class="keyword">union</span> &#123;  </span></div><div class="line">        DWORD Characteristics;  </div><div class="line">        DWORD OriginalFirstThunk;     <span class="regexp">//</span>INT(导入名字表)的地址(RVA)桥<span class="number">1</span>  </div><div class="line">    &#125;;  </div><div class="line">    DWORD TimeDateStamp;     <span class="regexp">//</span>时间戳</div><div class="line">    DWORD ForwarderChain;    <span class="regexp">//</span>链表的前一个结构</div><div class="line">    DWORD Name;              <span class="regexp">//</span>指向链接库的指针  </div><div class="line">    DWORD FirstThunk;        <span class="regexp">//</span>(IAT)导入地址表的地址 (RVA)桥<span class="number">2</span>  </div><div class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</div></pre></td></tr></table></figure></p><h2 id="3-导入表的双桥结构"><a href="#3-导入表的双桥结构" class="headerlink" title="3.导入表的双桥结构"></a>3.导入表的双桥结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个结构IMAGE_IMPORT_DESCRIPTOR都对应的是一个唯一的dll文件。以及dll中的每个函数都可以通过”编号-名称”的方式找到，这就是导入表的双桥结构。如下图尽管这个桥对应的INT和IAT的内容是相同的，但是其存储的位置是不同的。<br>    <img src="https://i.imgur.com/pNn2oXb.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OriginalFirstThun指向的数组中每一项为一个结构，此结构的名称是IMAGE_THUNK_DATA。该结构实际上只是一个双字，但在不同的时刻却拥有不同的解释。该字段有两种解释：这个值是INT的地址，INT（Import Name Table）是一个存储了库文件函数名称的表。在装载的时候，PE装载器读取OriginalFirstThun获得INT，然后通过标号去获取函数的地址</p><ul><li>双字最高位为0，表示导入符号是一个数值，该数值是一个RVA。</li><li>双字最高位为1，表示导入符号是一个名称。<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct _IMAGE_IMPORT_BY_NAME &#123;  </div><div class="line">    <span class="type">WORD</span> <span class="type">Hint</span>;        //对dll中的每个函数进行标号，该值不是必须的</div><div class="line">    <span class="type">BYTE</span> <span class="type">Name</span>[1];     //函数名称  </div><div class="line">&#125; <span class="type">IMAGE_IMPORT_BY_NAME</span>, *<span class="type">PIMAGE_IMPORT_BY_NAME</span>;</div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FirstThunk指向的是IAT表，也是IMAGE_THUNK_DATA，但是对于程序的装载，并不使用IAT进行函数的寻址，在通过INT寻址之后，将找到的地址填充到IAT中。后期需要用到函数的时候，可以使用GetProcAddressAPI函数进行获取。</p><h2 id="4-导入函数地址表-IAT"><a href="#4-导入函数地址表-IAT" class="headerlink" title="4.导入函数地址表(IAT)"></a>4.导入函数地址表(IAT)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导入函数地址表位于数据目录的第十三个目录。用户程序通过该表的jmp指令无条件跳转到dll函数的VA处。因为该表中存着<strong>同一个dll</strong>不同的函数的VA地址，所以每个函数地址都是以”00”作为区分的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导入表和导入地址表是由紧密联系的。通过桥2可以定位到程序的IAT。在内存中，桥1可以找到<strong>调用函数的名称和函数的标号。</strong>桥2可以找到该函数指令代码在<strong>内存空间的地址</strong></p><h2 id="5-程序的装载过程。"><a href="#5-程序的装载过程。" class="headerlink" title="5.程序的装载过程。"></a>5.程序的装载过程。</h2><ul><li>第一步：PE加载器读取结构体成员的值，IMAGE_IMPORT_DESCRIPTOR.Name成员找到库名称，然后将库文件加载到内存中来。</li><li>第二歩：PE加载器读取OriginalFirstThunk值获得INT地址，然后依次读取INT各项的值，根据函数的标号获取函数的地址。</li><li>第三步：将获取的函数的地址填充到IAT表中。</li></ul><h1 id="第三部分：绑定导入"><a href="#第三部分：绑定导入" class="headerlink" title="第三部分：绑定导入"></a>第三部分：绑定导入</h1><h2 id="1-绑定导入机制"><a href="#1-绑定导入机制" class="headerlink" title="1.绑定导入机制"></a>1.绑定导入机制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windows在装载程序的时候，PE装载器负责对IAT中的地址进行修正工作。绑定导入的目的在于使用软件或者人工的方法，<strong>在程序装载之前，修正IAT表内的函数地址，</strong>从而提高加载数据。同样的，微软在引入绑定导入机制也考虑到了由于各种原因导致dll没有加载到目标地址，所以同时引入了<strong>错误检测机制</strong>，如果检测到此类错误，PE加载器则会接管IAT修正工作。加载器遍历INT，计算新的函数地址，由于同时要用道INT和IAT，<strong>所以：单桥结构无法使用静态绑定机制。</strong></p><h2 id="2-绑定导入表的定位和其数据结构"><a href="#2-绑定导入表的定位和其数据结构" class="headerlink" title="2.绑定导入表的定位和其数据结构"></a>2.绑定导入表的定位和其数据结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绑定地址表位于数据目录的第十二的项目，利用RVA-FOA转化，可以定位到文件在绑定导入表的地址。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绑定导入数据由IMAGE_BOUND_IMPORT_DESCRIPTOR结构组成，每个模块拥有一个该结构。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">IMAGE_BOUND_IMPORT_DESCRIPTOR struct</div><div class="line">&#123;</div><div class="line">TimeDateStamp <span class="comment">;时间戳</span></div><div class="line">    OffsetDllNmae  <span class="comment">;指向dll'的名称，</span></div><div class="line">    NumberOfModuleForWarderRefs   <span class="comment">;ModuleForWarderRefs数目</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>NumberOfModuleForWarderRefs描述的是IMAGE_BOUND_ModuleForWarderRefs结构体的数目，该结构体存在的原因是<strong>为了让dll模块保持向前兼容，使得模块继续保持原来函数的定义</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-预备知识&quot;&gt;&lt;a href=&quot;#第一部分-预备知识&quot; class=&quot;headerlink&quot; title=&quot;第一部分 预备知识&quot;&gt;&lt;/a&gt;第一部分 预备知识&lt;/h1&gt;&lt;h2 id=&quot;1-函数导入流程&quot;&gt;&lt;a href=&quot;#1-函数导入流程&quot; class=&quot;headerlink&quot; title=&quot;1.函数导入流程&quot;&gt;&lt;/a&gt;1.函数导入流程&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;程序在引用dll库函数的时候，需要从dll里面对所需要的函数进行导入，该导入过程如下：&lt;br&gt;
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows PE》PE文件头</title>
    <link href="http://yoursite.com/2018/05/07/%E3%80%8Awindows%20PE%E3%80%8BPE%E6%96%87%E4%BB%B6%E5%A4%B4/"/>
    <id>http://yoursite.com/2018/05/07/《windows PE》PE文件头/</id>
    <published>2018-05-07T06:02:11.000Z</published>
    <updated>2018-05-07T07:46:14.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-预备知识"><a href="#第一部分-预备知识" class="headerlink" title="第一部分 预备知识"></a>第一部分 预备知识</h1><h2 id="四类地址"><a href="#四类地址" class="headerlink" title="四类地址"></a>四类地址</h2><ul><li>虚拟地址（VA）</li><li>相对虚拟内存地址（RVA）</li><li>文件偏移地址（FOA）</li><li>特殊地址<a id="more"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟地址：PE文件被加载到内存，PE对应的进程拥有了4GB的空间，这个空间存在的地址就是虚拟地址。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对虚拟地址：相对与基地址的偏移量，RVA的存在是由于dll（模块）的基地址的不同而产生的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件偏移地址：文件中某个位置距离文件头的偏移量。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特殊位置，不细考究。</li></ul><h2 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据目录记录的是整个PE结构中存在的数据类型。</p><h2 id="节"><a href="#节" class="headerlink" title="节"></a>节</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节就是存放不同的类型的数据，不同的节区有不同的访问权限。</p><h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><ul><li>内存对齐</li><li>文件对齐</li><li>资源数据对齐<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存对齐：windows中，内存属性的基本单位是页，在32位系统是4KB(1000h)，在64位系统中是8kb。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件对齐：为了提高磁盘利用率，把一个物理扇区作为一个对齐粒度的大小，也就是12字节（200H）,这是每个数据段都是200H的整数倍的原因。<br><img src="/home/findream/桌面/QQ截图20180507125335.png" alt=""> </li></ul><h1 id="第二部分-32位windows系统的PE结构"><a href="#第二部分-32位windows系统的PE结构" class="headerlink" title="第二部分 32位windows系统的PE结构"></a>第二部分 32位windows系统的PE结构</h1><h2 id="定位标准的PE头"><a href="#定位标准的PE头" class="headerlink" title="定位标准的PE头"></a>定位标准的PE头</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于DOS stub是一个不确定的长度，所以导致DOS头也是一个不确定的长度，这时候，<strong>我们采用e_lfanew字段来定位后续的PE结构位置。该字段是一个偏移量。</strong>PE头的定位遵循一下公式：PE_Start=DOS_MZ+IMAGE_HANDER.e_lfanew.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PE文件结构:<br><img src="http://oxnvtxe03.bkt.clouddn.com/2018-05-07%2013-09-51%20%E5%88%9B%E5%BB%BA%E7%9A%84%E6%88%AA%E5%9B%BE.png" alt=""> </p><h1 id="第三部分-PE文件头部解析"><a href="#第三部分-PE文件头部解析" class="headerlink" title="第三部分 PE文件头部解析"></a>第三部分 PE文件头部解析</h1><h2 id="DOS-MZ头"><a href="#DOS-MZ头" class="headerlink" title="DOS MZ头"></a>DOS MZ头</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MZ头下有两个需要知道的成员。一个是<strong>e_magic</strong> ,一个是<strong>e_lfanew</strong></p><h2 id="PE头标志-Signature"><a href="#PE头标志-Signature" class="headerlink" title="PE头标志 Signature"></a>PE头标志 Signature</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signature标志位于DOS_STUB之后，该标志位于e_lfanew所指向的位置。内容固定，对应的ASCII是”PE\0\0”。<br><img src="http://oxnvtxe03.bkt.clouddn.com/2018-05-07%2013-33-18%20%E5%88%9B%E5%BB%BA%E7%9A%84%E6%88%AA%E5%9B%BE.png" alt=""> </p><h2 id="标准PE头-IMAGE-FILE-HEADER"><a href="#标准PE头-IMAGE-FILE-HEADER" class="headerlink" title="标准PE头 IMAGE_FILE_HEADER"></a>标准PE头 IMAGE_FILE_HEADER</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;位置：在PE文件头标志的后面，位于e_lfanew+4的位置。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大小：占据了20个字节。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：他记录了PE文件的全局属性（运行的平台，PE文件的类型，文件中存在的节区总数）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是FILE_HEADER的成员信息：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">        WORD    Machine;     <span class="comment">//运行平台</span></div><div class="line">        WORD    NumberOfSections;     <span class="comment">//节区数量</span></div><div class="line">        DWORD   TimeDateStamp;        <span class="comment">//创建时间</span></div><div class="line">        DWORD   PointerToSymbolTable;    <span class="comment">//指向符号表</span></div><div class="line">        DWORD   NumberOfSymbols;     <span class="comment">//符号表符号数</span></div><div class="line">        WORD    SizeOfOptionalHeader;    <span class="comment">//拓展头长度</span></div><div class="line">        WORD    Characteristics;        <span class="comment">//文件属性</span></div><div class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</div></pre></td></tr></table></figure></p><ul><li>Machime:该文件的运行平台，是x86、x64还是I64等等，可以是下面值里的某一个。</li><li>TimeDateStamp：PE文件的创建时间，一般有连接器填写</li><li>NumberOfSections：该PE文件中有多少个节，也就是节表中的项数</li><li>SizeOfOptionalHeader：紧随其后的可选头的大小。</li></ul><h2 id="拓展PE头IMAGE-OPTIONAL-HEADER32"><a href="#拓展PE头IMAGE-OPTIONAL-HEADER32" class="headerlink" title="拓展PE头IMAGE_OPTIONAL_HEADER32"></a>拓展PE头IMAGE_OPTIONAL_HEADER32</h2><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> </span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">        <span class="comment">// Standard fields.        </span></div><div class="line">        WORD    Magic;              <span class="comment">// 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）   </span></div><div class="line">        BYTE    MajorLinkerVersion;     <span class="comment">// 链接程序的主版本号   </span></div><div class="line">        BYTE    MinorLinkerVersion;     <span class="comment">// 链接程序的次版本号   </span></div><div class="line">        DWORD   SizeOfCode;         <span class="comment">// 所有含代码的节的总大小   </span></div><div class="line">        DWORD   SizeOfInitializedData;          <span class="comment">// 所有含已初始化数据的节的总大小   </span></div><div class="line">        DWORD   SizeOfUninitializedData;        <span class="comment">// 所有含未初始化数据的节的大小   </span></div><div class="line">        DWORD   AddressOfEntryPoint;        <span class="comment">// 程序执行入口RVA   </span></div><div class="line">        DWORD   BaseOfCode;         <span class="comment">// 代码的区块的起始RVA   </span></div><div class="line">        DWORD   BaseOfData;         <span class="comment">// 数据的区块的起始RVA   </span></div><div class="line">        <span class="comment">// NT additional fields.    以下是属于NT结构增加的领域。   </span></div><div class="line">        DWORD   ImageBase;          <span class="comment">// 程序的首选装载地址   </span></div><div class="line">        DWORD   SectionAlignment;       <span class="comment">// 内存中的区块的对齐大小   </span></div><div class="line">        DWORD   FileAlignment;          <span class="comment">// 文件中的区块的对齐大小   </span></div><div class="line">        WORD    MajorOperatingSystemVersion;    <span class="comment">// 要求操作系统最低版本号的主版本号   </span></div><div class="line">        WORD    MinorOperatingSystemVersion;    <span class="comment">// 要求操作系统最低版本号的副版本号   </span></div><div class="line">        WORD    MajorImageVersion;      <span class="comment">// 可运行于操作系统的主版本号   </span></div><div class="line">        WORD    MinorImageVersion;      <span class="comment">// 可运行于操作系统的次版本号   </span></div><div class="line">        WORD    MajorSubsystemVersion;      <span class="comment">// 要求最低子系统版本的主版本号   </span></div><div class="line">        WORD    MinorSubsystemVersion;      <span class="comment">// 要求最低子系统版本的次版本号   </span></div><div class="line">        DWORD   Win32VersionValue;      <span class="comment">// 莫须有字段，不被病毒利用的话一般为0   </span></div><div class="line">        DWORD   SizeOfImage;            <span class="comment">// 映像装入内存后的总尺寸   </span></div><div class="line">        DWORD   SizeOfHeaders;          <span class="comment">// 所有头+ 区块表的尺寸大小   </span></div><div class="line">        DWORD   CheckSum;           <span class="comment">// 映像的校检和   </span></div><div class="line">        WORD    Subsystem;          <span class="comment">// 可执行文件期望的子系统   </span></div><div class="line">        WORD    DllCharacteristics;     <span class="comment">// DllMain()函数何时被调用，默认为0   </span></div><div class="line">        DWORD   SizeOfStackReserve;     <span class="comment">// 初始化时的栈大小   </span></div><div class="line">        DWORD   SizeOfStackCommit;      <span class="comment">// 初始化时实际提交的栈大小   </span></div><div class="line">        DWORD   SizeOfHeapReserve;      <span class="comment">// 初始化时保留的堆大小   </span></div><div class="line">        DWORD   SizeOfHeapCommit;       <span class="comment">// 初始化时实际提交的堆大小   </span></div><div class="line">        DWORD   LoaderFlags;            <span class="comment">// 与调试有关，默认为0    </span></div><div class="line">        DWORD   NumberOfRvaAndSizes;        <span class="comment">// 下边数据目录的项数，这个字段自Windows NT 发布以来 一直是16   </span></div><div class="line">        IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];   <span class="comment">// 数据目录表   </span></div><div class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要我们熟悉的是以下几个成员。</p><ul><li>AddressOfEntryPoint;        // 程序执行入口RVA</li><li>BaseOfCode;         // 代码的区块的起始RVA </li><li>DWORD   ImageBase;          // 程序的首选装载地址</li><li>SectionAlignment;       // 内存中的区块的对齐大小</li><li>FileAlignment;          // 文件中的区块的对齐大小</li><li>SizeOfImage;            // 映像装入内存后的总尺寸</li><li>DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];   // 数据目录表</li></ul><h2 id="IMAGE-NT-HEADERS"><a href="#IMAGE-NT-HEADERS" class="headerlink" title="IMAGE_NT_HEADERS"></a>IMAGE_NT_HEADERS</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包括三个部分组成：PE头标志，IMAGE_FILE_HEADER,IMAGE_OPTIOANAL_HEADER.</p><h2 id="数据目录项-IMAGE-DATA-DIRECTORY"><a href="#数据目录项-IMAGE-DATA-DIRECTORY" class="headerlink" title="数据目录项 IMAGE_DATA_DIRECTORY"></a>数据目录项 IMAGE_DATA_DIRECTORY</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NT3.1开始，数据目录一共有16种，使用IMAGE_DATA_DIRECTORY来定义每种数据。<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct _IMAGE_DATA_DIRECTORY &#123;</div><div class="line">        <span class="type">DWORD</span>　<span class="type">VirtualAddress</span>; //相对虚拟地址  </div><div class="line">        <span class="type">DWORD</span>　<span class="type">Size</span>;　　　　　 //大小  </div><div class="line">&#125; <span class="type">IMAGE_DATA_DIRECTORY</span>, *<span class="type">PIMAGE_DATA_DIRECTORY</span>;</div></pre></td></tr></table></figure></p><p>##节表项IMAGE_SECTION_HEADER<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">typedef struct _IMAGE_SECTION_HEADER </div><div class="line">&#123;</div><div class="line">  <span class="keyword">BYTE </span> Name[IMAGE_SIZEOF_SHORT_NAME]<span class="comment">;//节区名称</span></div><div class="line">  union &#123;</div><div class="line">    DWORD PhysicalAddress<span class="comment">;</span></div><div class="line">    DWORD VirtualSize<span class="comment">;    //节区大小</span></div><div class="line">  &#125; Misc<span class="comment">;</span></div><div class="line">  DWORD VirtualAddress<span class="comment">;       //节区的RVA</span></div><div class="line">  DWORD SizeOfRawData<span class="comment">;      //在文件中对齐的尺寸</span></div><div class="line">  DWORD PointerToRawData<span class="comment">;   //在文件中的偏移</span></div><div class="line">  DWORD PointerToRelocations<span class="comment">;    //指向重定位表的指针</span></div><div class="line"> DWORD PointerToLinenumbers<span class="comment">;</span></div><div class="line">  WORD  NumberOfRelocations<span class="comment">;     //重定位表的数目</span></div><div class="line">  WORD  NumberOfLinenumbers<span class="comment">;</span></div><div class="line">  DWORD Characteristics<span class="comment">;       //节区表的属性</span></div><div class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER<span class="comment">;</span></div></pre></td></tr></table></figure></p><h1 id="第三部分-详细解析PE文件头字段"><a href="#第三部分-详细解析PE文件头字段" class="headerlink" title="第三部分 详细解析PE文件头字段"></a>第三部分 详细解析PE文件头字段</h1><h2 id="IMAGE-FILE-HEADER字段"><a href="#IMAGE-FILE-HEADER字段" class="headerlink" title="IMAGE_FILE_HEADER字段"></a>IMAGE_FILE_HEADER字段</h2><ul><li>Machine:<ul><li>位置：+0004H,</li><li>大小：单字</li><li>作用：查看文件可以在那种机器上运行。</li></ul></li><li>NumberOfSection：<ul><li>位置：+0006h</li><li>大小：单字</li><li>作用：文件中存在的节区的数目，数值不能小于1，但是节区数可以为0.</li></ul></li><li>TimeDateStamp <ul><li>位置：+0008h</li><li>大小：双字</li><li>作用：编译时间，压缩时被修改。</li></ul></li><li>SizeofOptionalHeader<ul><li>位置：+0014h</li><li>大小：单字</li><li>作用：指向的是OptionalHeader的大小。默认是00e0H，在64位是00f0H</li></ul></li><li>Character<ul><li>位置：+0016h</li><li>大小：单字</li><li>作用：标志这PE文件的类型，如果这个值是010fh的话，表示这是一个EXE文件，如果值是210eh，表示这个值是DLL文件。</li></ul></li></ul><h2 id="IMAGE-OPTIONAL-HEADER字段"><a href="#IMAGE-OPTIONAL-HEADER字段" class="headerlink" title="IMAGE_OPTIONAL_HEADER字段"></a>IMAGE_OPTIONAL_HEADER字段</h2><ul><li>Magic：表示该文件的类型：如果是010Bh，表示文件是32位，如果是0107H，表示文件是ROM，如果是020BH，表示文件是64位PE</li><li>AddressOfEntryPoint ：表示启动代码距离PE加载后的初始位置的偏移量，如果病毒需要在程序中启动恶意代码，则需要修改这一成员的数值。但是对于DLL文件，这一成员你的数值为0，因为不存在入口点。</li><li>BaseOfCode：代码段的起始RVA，但是不一定是程序的入口点。</li><li>ImageBase：PE文件的加载基地址。exe文件通常是00400000.</li><li>SizeOfImade：表示内存中整个PE文件的映射尺寸。</li><li>DllCharacteristics：DLL文件属性，但是不单纯是针对DLL文件，对于所有PE文件同样有效。</li><li>DataDirectory：目录数据，表示不同的节区的基本属性（RVA和size）。</li></ul><h2 id="IMAGE-SECTION-HEADER"><a href="#IMAGE-SECTION-HEADER" class="headerlink" title="IMAGE_SECTION_HEADER"></a>IMAGE_SECTION_HEADER</h2><ul><li>Name[IMAGE_SIZEOF_SHORT_NAME]： 八个字节的节去名称。</li><li>VirtualAddress：节区的RVA</li><li>SizeOfRAWDATA：节区对齐后的尺寸</li><li>PointOfRAWDATA：节区数据在文件中的偏移量。</li><li>PointerToRelocations：重定位表的指针</li><li>NumberOfRelocations：重定位表的数目</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-预备知识&quot;&gt;&lt;a href=&quot;#第一部分-预备知识&quot; class=&quot;headerlink&quot; title=&quot;第一部分 预备知识&quot;&gt;&lt;/a&gt;第一部分 预备知识&lt;/h1&gt;&lt;h2 id=&quot;四类地址&quot;&gt;&lt;a href=&quot;#四类地址&quot; class=&quot;headerlink&quot; title=&quot;四类地址&quot;&gt;&lt;/a&gt;四类地址&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;虚拟地址（VA）&lt;/li&gt;
&lt;li&gt;相对虚拟内存地址（RVA）&lt;/li&gt;
&lt;li&gt;文件偏移地址（FOA）&lt;/li&gt;
&lt;li&gt;特殊地址
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>看雪2017CTF</title>
    <link href="http://yoursite.com/2018/05/05/%E7%9C%8B%E9%9B%AACTF2017/"/>
    <id>http://yoursite.com/2018/05/05/看雪CTF2017/</id>
    <published>2018-05-05T03:00:11.000Z</published>
    <updated>2018-05-07T07:45:17.277Z</updated>
    
    <content type="html"><![CDATA[<p>这是看雪2017的CTF的题目，这套题目当时只做出了一题，现在继续做，同样还是根据WP，不断的学习，不断的进步，在现在安全圈子里面浮躁的大背景下，感谢看雪论坛仍然不忘初心，为我们保留了这一块儿净土。<br><a id="more"></a></p><h2 id="Problem-1：-Helllo-CTF"><a href="#Problem-1：-Helllo-CTF" class="headerlink" title="Problem 1： Helllo-CTF"></a>Problem 1： Helllo-CTF</h2><p>首先，使用OD查看字符串，定位到4017F0。<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">00401831 </span> |.  <span class="number">8</span>B4D F8       mov ecx,[local.<span class="number">2</span>]</div><div class="line"><span class="symbol">00401834 </span> |.  <span class="number">51</span>            push ecx                                  ; /s</div><div class="line"><span class="symbol">00401835 </span> |.  E8 <span class="number">5</span>C060000   <span class="keyword">call</span> &lt;jmp.&amp;MSVCRT.strlen&gt;                 ; \strlen</div><div class="line"><span class="number">0040183</span>A  |.  <span class="number">83</span>C4 <span class="number">04</span>       add esp,<span class="number">0</span>x4                               ;  保证有输入</div><div class="line"><span class="number">0040183D</span>  |.  <span class="number">85</span>C0          test eax,eax</div><div class="line"><span class="number">0040183</span>F  |.  <span class="number">75</span> <span class="number">13</span>         jnz Xhello.<span class="number">00401854</span></div><div class="line"><span class="symbol">00401841 </span> |.  <span class="number">6</span>A <span class="number">00</span>         push <span class="number">0</span>x0</div><div class="line"><span class="symbol">00401843 </span> |.  <span class="number">6</span>A <span class="number">00</span>         push <span class="number">0</span>x0</div><div class="line"><span class="symbol">00401845 </span> |.  <span class="number">68</span> <span class="number">98354000</span>   push hello.<span class="number">00403598</span>                       ;  请输入pass!</div><div class="line"><span class="number">0040184</span>A  |.  <span class="number">8</span>B4D FC       mov ecx,[local.<span class="number">1</span>]</div><div class="line"><span class="number">0040184D</span>  |.  E8 C0050000   <span class="keyword">call</span> &lt;jmp.&amp;MFC42.#<span class="number">4224</span>&gt;</div><div class="line"><span class="symbol">00401852 </span> |.  EB <span class="number">21</span>         jmp Xhello.<span class="number">00401875</span></div><div class="line"><span class="symbol">00401854 </span> |&gt;  <span class="number">68</span> <span class="number">80354000</span>   push hello.<span class="number">00403580</span>                       ; /WelcomeToKanXueCtf2017</div><div class="line"><span class="symbol">00401859 </span> |.  <span class="number">8</span>B55 F8       mov edx,[local.<span class="number">2</span>]                         ; |</div><div class="line"><span class="number">0040185</span>C  |.  <span class="number">52</span>            push edx                                  ; |s1</div><div class="line"><span class="number">0040185D</span>  |.  E8 <span class="number">2E060000</span>   <span class="keyword">call</span> &lt;jmp.&amp;MSVCRT.strcmp&gt;                 ; \strcmp</div><div class="line"><span class="symbol">00401862 </span> |.  <span class="number">83</span>C4 <span class="number">08</span>       add esp,<span class="number">0</span>x8                               ;  比较</div><div class="line"><span class="symbol">00401865 </span> |.  <span class="number">85</span>C0          test eax,eax</div></pre></td></tr></table></figure></p><p>第一个函数是比较成功的，第二个函数比较失败的<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">00401867 </span> |. /<span class="number">75</span> <span class="number">07</span>         jnz Xhello.<span class="number">00401870</span>   </div><div class="line"><span class="symbol">00401869 </span> |. |E8 <span class="number">02</span>FFFFFF   <span class="keyword">call</span> hello.<span class="number">00401770</span>     //比较成功</div><div class="line"><span class="number">0040186E</span>  |. |EB <span class="number">05</span>         jmp Xhello.<span class="number">00401875</span></div><div class="line"><span class="symbol">00401870 </span> |&gt; \E8 <span class="number">3</span>BFFFFFF   <span class="keyword">call</span> hello.<span class="number">004017</span>B0     //比较失败</div></pre></td></tr></table></figure></p><h2 id="Problem-2：ctf2017-Fpc"><a href="#Problem-2：ctf2017-Fpc" class="headerlink" title="Problem 2：ctf2017_Fpc"></a>Problem 2：ctf2017_Fpc</h2><p>首先了解一下作者对于这次CM的布局。作者利用scanf的不安全性，精心构造了一个栈溢出的漏洞。我们先来看看这个漏洞的形成机制。</p><ul><li>scanf的缓冲区大小是12个字节。<br>  <img src="https://i.imgur.com/0k44sZm.png" alt=""></li><li><p>如果我们输入的缓冲区大小小于12个字节的话</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0019</span>FF2C   <span class="number">0041</span>B08C  ASCII <span class="string">"%s"</span></div><div class="line"><span class="number">0019</span>FF30   <span class="number">0019</span>FF34  ASCII <span class="string">"123456"</span></div><div class="line"><span class="number">0019</span>FF34   <span class="number">34333231</span></div><div class="line"><span class="number">0019</span>FF38   <span class="number">00003635</span></div><div class="line"><span class="number">0019</span>FF3C   <span class="number">0040100</span>A  返回到 ctf2017_<span class="number">.0040100</span>A 来自 ctf2017_<span class="number">.00413</span>D42</div></pre></td></tr></table></figure></li><li><p>如果等于12个字节的话，返回到scanf函数的下一个地址。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0019</span>FF30   <span class="number">0019</span>FF34  ASCII <span class="string">"123456789ABC"</span></div><div class="line"><span class="number">0019</span>FF34   <span class="number">34333231</span></div><div class="line"><span class="number">0019</span>FF38   <span class="number">38373635</span></div><div class="line"><span class="number">0019</span>FF3C   <span class="number">43424139</span></div><div class="line"><span class="number">0019</span>FF40   <span class="number">00401000</span>  入口地址</div></pre></td></tr></table></figure></li><li><p>如果大于12个字节，超过的字节覆盖返回地址，产生栈溢出漏洞</p></li></ul><p>其次，出题人给出的栈溢出的溢出部分，利用OD或者IDA无法识别成代码的部分，因为反汇编器不可能去识别不加使用的部分为代码，所以这部分会被识别为数据。如图2.2，所以溢出函数在413131这个地址。我们可以得出结论，验证码是XXXXXXXXXXXX11A。<br>    <img src="https://i.imgur.com/j8DJrfd.png" alt=""></p><p>溢出后，发现存在很多花指令。利用OD去跟踪吧。根据多次run跟踪得出以下结论<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">(A-B)</span>*<span class="number">4</span>+A+C=<span class="number">0</span>xEAF<span class="number">917</span>E<span class="number">2</span></div><div class="line"><span class="comment">(A-B)</span>*<span class="number">2</span>+<span class="comment">(A-B)</span>+A+C=<span class="number">0</span>xE<span class="number">8</span>F<span class="number">508</span>C<span class="number">8</span></div><div class="line"><span class="comment">(A-B)</span>*<span class="number">2</span>+<span class="comment">(A-B)</span>+A-C=<span class="number">0</span>xC<span class="number">0</span>A<span class="number">3</span>C<span class="number">68</span></div></pre></td></tr></table></figure></p><p>解得：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">A</span> = <span class="number">0</span>x7473754A</div><div class="line"><span class="attr">B</span> = <span class="number">0</span>x726f6630</div><div class="line"><span class="attr">C</span> = <span class="number">0</span>x6E756630</div></pre></td></tr></table></figure></p><p>小端序显示：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Just<span class="number">0</span>for<span class="number">0</span>fu<span class="symbol">n11</span>A</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是看雪2017的CTF的题目，这套题目当时只做出了一题，现在继续做，同样还是根据WP，不断的学习，不断的进步，在现在安全圈子里面浮躁的大背景下，感谢看雪论坛仍然不忘初心，为我们保留了这一块儿净土。&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令(2)常用命令</title>
    <link href="http://yoursite.com/2018/04/28/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(2)%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/04/28/Linux常见命令(2)其他命令/</id>
    <published>2018-04-28T07:02:11.000Z</published>
    <updated>2018-05-07T09:11:02.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-帮助"><a href="#第一部分-帮助" class="headerlink" title="第一部分 帮助"></a>第一部分 帮助</h1><ul><li>man [命令] /info<ul><li>/ [查询的内容] 查询指定的字符串</li><li>man [配置文件名称] ：显示配置文件的作用。如果直接加绝对路径，显示的是配置文件的内容</li><li>有文件的帮助信息，也有配置文件的帮助信息。如果是man 5 [命令] 查看的是配置文件的帮助信息，如果是man 1 [命令] 显示的是命令的帮助信息【见linux(1) whereis命令】<br><img src="https://i.imgur.com/Z4tFW44.png" alt=""></li></ul></li><li>whatis [命令] ：显示命令作用（简略）//whereis [命令]<br>   <img src="https://i.imgur.com/dzVbLlm.png" alt=""></li><li>apropos [配置文件] ：显示配置文件的作用<br>   <img src="https://i.imgur.com/eoAu5q7.png" alt=""></li><li>命令 -h(–help)</li><li>help [命令] shell内置命令的帮助信息（shell编程中的命令）<ul><li>也可以查看命令的路径<br><img src="https://i.imgur.com/glgYvQ4.png" alt=""><br><img src="https://i.imgur.com/D9fufqV.png" alt=""><a id="more"></a><h1 id="第二部分-用户管理"><a href="#第二部分-用户管理" class="headerlink" title="第二部分 用户管理"></a>第二部分 用户管理</h1></li></ul></li><li>useradd [用户名]  添加用户</li><li>passwd [用户名]   为用户设置密码.</li><li>who 查看当前用户名(tty 本地登录 pts 远程登录)<br>  <img src="https://i.imgur.com/FkdVmdl.png" alt=""></li><li>w 登录用户和登录时间等具体信息<br>  <img src="https://i.imgur.com/S2Mfc4m.png" alt=""></li><li>usermod [选项] [用户ID]<ul><li>-g&lt;群组&gt;：修改用户所属的群组；</li><li>-G&lt;群组&gt;；修改用户所属的附加群组；</li><li>-l&lt;帐号名称&gt;：修改用户帐号名称；</li><li>-L：锁定用户密码，使密码无效；</li><li>-u<uid>：修改用户ID；</uid></li><li></li></ul></li></ul><h1 id="第三部分-压缩解压"><a href="#第三部分-压缩解压" class="headerlink" title="第三部分 压缩解压"></a>第三部分 压缩解压</h1><ul><li>gzip [文件名] ：压缩文件<strong>(只能压缩文件)，并且不保存源文件</strong><br>  <img src="https://i.imgur.com/Gs5rCP3.png" alt=""><ul><li>gunzip /(gzip -d) [压缩文件]：解压缩<br><img src="https://i.imgur.com/5NsHzrX.png" alt=""></li></ul></li><li>tar [选项] [压缩文件名] [目录]  <strong> 针对目录</strong><ul><li>-c 打包    //zcf（选项有顺序关系）</li><li>-v 显示详细信息</li><li>-f 指定文件名</li><li>-z 打包同时压缩<br><img src="https://i.imgur.com/v7PdOkl.png" alt=""></li><li>-cjf 生成 tar.bz2文件</li></ul></li><li>tar<ul><li>-x 解包 [压缩文件]</li><li>-z 解压缩</li><li>其他和压缩一样<br><img src="https://i.imgur.com/3e80H8u.png" alt=""></li><li>-xjf 解压tar.bz2压缩包</li></ul></li><li>zip [选项] [压缩文件] [带压缩文件]<ul><li>-r 压缩目录<br><img src="https://i.imgur.com/r5X4HCj.png" alt=""></li><li>unzip [压缩文件]   解压缩<br><img src="https://i.imgur.com/lbO9Oro.png" alt=""></li></ul></li><li>bzip2 [选项] [带压缩文件]<ul><li>-k 保存源文件<br><img src="https://i.imgur.com/83BBAso.png" alt=""></li><li>压缩比大</li></ul></li><li>bunzip2 [选项] [压缩文件]<ul><li>-k 是否保存压缩包</li></ul></li></ul><h1 id="第四部分-网络命令"><a href="#第四部分-网络命令" class="headerlink" title="第四部分 网络命令"></a>第四部分 网络命令</h1><ul><li>ping 测试网络通畅性<ul><li>-c 数量 ：ping的次数<br><img src="https://i.imgur.com/W9i09Db.png" alt=""></li></ul></li><li>ifconfig [网卡名称] [IP] ：网络配置信息</li><li>last 用户登录信息<br>  <img src="https://i.imgur.com/cWxEZzb.png" alt=""></li><li>lastlog<ul><li>-u [用户ID]   </li></ul></li><li>traceroute [主机名]  追踪网络访问跃点<br>  <img src="https://i.imgur.com/A2EtXfT.png" alt=""></li><li><p>netstat 查询网络状态</p><ul><li>-t ：查询TCP协议状态</li><li>-u : UDP协议状态</li><li>-l ：监听</li><li>-r ：路由(网关)</li><li>-n ：显示IP地址及端口 </li><li>-a : 所有选项</li><li>常用实例：<ul><li>netstat -an: 查看本机所有的网络连接</li><li>netstat -tlun:查看本机监听的端口</li><li>netstat -rn:查看本机路由列表</li></ul></li></ul></li><li><p>mount [设备文件名] [挂载点]挂载</p><ul><li>1.创建一个挂载目录（/mnt下）</li><li>2.mount<br><img src="https://i.imgur.com/cMEdqNr.png" alt=""></li><li>3.umount [挂载点/设备文件名]卸载挂载点，但是不能在挂载点下卸载<br><img src="https://i.imgur.com/UlytG1f.png" alt=""></li></ul></li></ul><h1 id="第五部分-关机与重启"><a href="#第五部分-关机与重启" class="headerlink" title="第五部分 关机与重启"></a>第五部分 关机与重启</h1><ul><li>shotdown [选项] [参数]<ul><li>-h：将系统关机</li><li>-r：系统重新启动</li><li>-c：中断关机操作</li><li>-t：设置执行时间(s)</li><li>xx:xx(表示时间):shutdown -h xx:xx 表示xx：xx时关机 </li><li>now：参数表示立刻执行</li></ul></li><li>reboot ：立刻重启</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-帮助&quot;&gt;&lt;a href=&quot;#第一部分-帮助&quot; class=&quot;headerlink&quot; title=&quot;第一部分 帮助&quot;&gt;&lt;/a&gt;第一部分 帮助&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;man [命令] /info&lt;ul&gt;
&lt;li&gt;/ [查询的内容] 查询指定的字符串&lt;/li&gt;
&lt;li&gt;man [配置文件名称] ：显示配置文件的作用。如果直接加绝对路径，显示的是配置文件的内容&lt;/li&gt;
&lt;li&gt;有文件的帮助信息，也有配置文件的帮助信息。如果是man 5 [命令] 查看的是配置文件的帮助信息，如果是man 1 [命令] 显示的是命令的帮助信息【见linux(1) whereis命令】&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/Z4tFW44.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;whatis [命令] ：显示命令作用（简略）//whereis [命令]&lt;br&gt;   &lt;img src=&quot;https://i.imgur.com/dzVbLlm.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;apropos [配置文件] ：显示配置文件的作用&lt;br&gt;   &lt;img src=&quot;https://i.imgur.com/eoAu5q7.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;命令 -h(–help)&lt;/li&gt;
&lt;li&gt;help [命令] shell内置命令的帮助信息（shell编程中的命令）&lt;ul&gt;
&lt;li&gt;也可以查看命令的路径&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/glgYvQ4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/D9fufqV.png&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>第三章：系统机制-全局标志和内核事件跟踪</title>
    <link href="http://yoursite.com/2018/04/26/%E3%80%8AWindows%20Internals%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0_%E5%85%A8%E5%B1%80%E6%A0%87%E5%BF%97%E5%92%8C%E5%86%85%E6%A0%B8%E4%BA%8B%E4%BB%B6%E8%B7%9F%E8%B8%AA/"/>
    <id>http://yoursite.com/2018/04/26/《Windows Internals》第三章_全局标志和内核事件跟踪/</id>
    <published>2018-04-26T07:02:11.000Z</published>
    <updated>2018-04-27T04:57:36.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-5-Windows全局标志"><a href="#3-5-Windows全局标志" class="headerlink" title="3.5 Windows全局标志"></a>3.5 Windows全局标志</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windows全局标志用于打开windows系统的内部调试，跟踪和验证，保存在HKLM\SYSTEM\CurrentControlSet\Control\Session Manage中的GlobalFlag中，默认值为0。如下是利用windbg查看的GlobalFlag情况<br>      <img src="https://i.imgur.com/pg5gK68.png" alt=""><br><a id="more"></a></p><h1 id="3-8-WOW64"><a href="#3-8-WOW64" class="headerlink" title="3.8 WOW64"></a>3.8 WOW64</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wow64是允许64位windows执行32位应用程序的软件，<strong>他的实现方式是一组用户模式DLL和一些来自内核的支持。</strong>内核支持主要体现在PEB和TEB等数据结构，存在以下几种wow64的dll：</p><ul><li>Wow64.dll：管理进程或者线程，钩取异常分发，基本系统调用，文件和注册表的重定向。</li><li>Wow64Cpu.dll：32位CPU和64位CPU环境的切换。</li><li>Wow64Win.dll: 钩取Win32k.sys导出的GUI系统调用</li><li>IA32Exec.bin和Wowia32.dll：IA环境下的软件仿真，以提高执行效率。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过查看印象文件头部设置的大地址空间感知标志，判断文件是在4GB内存空间还是在8GB内存空间运行。</li></ul><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wow64勾住了所有32位代码和64位代码的转化路径。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在创建进程的时候，经过一下步骤：</p><ul><li>进程管理器会将64位Ntdll.dll和wow64的32位Ntdll.dll装载入进程内存空间，</li><li>如果是32位代码，加载器初始化过程调用WOW64.dll内部的初始化代码，</li><li>然后建立其32位环境的模拟环境，</li><li>CPU切换到32位环境，然后继续执行。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ntdll.dll，User32.dll和Gdi32.dll的特殊32位版本位于\Windows\Syswow64文件夹下。它们调用到Wow64.dll中，而不是发出原生的32位系统调用指令。Wow64转变到原生的64位模式下，并捕获到与系统调用有关的参数（将32位指针转化为64位指针），并发出对应的原生64位系统调用。当原生的系统调用返回时，Wow64把任何输出参数，如果有必要的话，在返回至32位模式之前从64位转换成32位格式。</li></ul><h2 id="异常分发"><a href="#异常分发" class="headerlink" title="异常分发"></a>异常分发</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WOW64通过Ntdll中的KiUserExceptionDispatcher钩取了异常分发过程，</p><h2 id="文件系统重定向"><a href="#文件系统重定向" class="headerlink" title="文件系统重定向"></a>文件系统重定向</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在64位windows中 系统目录仍然是Windows/System32，因为WOw64.dll钩取了所有的系统调用，<strong>他会向所有和路径有关的API函数解释，把所有执行windows/system32的路径重定向位windows/syswow64，</strong>也就是Syswow64其实存放得是32位的应用程序，而system32其实是存放的是64位的应用程序。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是部分目录是不存在重定向的，例如：</p><ul><li>driver\etc</li><li>spool</li><li>catroot</li><li>catroot2</li><li>logfiles</li></ul><h2 id="注册表的重定向"><a href="#注册表的重定向" class="headerlink" title="注册表的重定向"></a>注册表的重定向</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为注册表中，注册的键值可能被后续添加的键值覆盖，这是注册表的重定向存在的必要性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在默认情况下，利用视图来构建一个安全的注册表环境。将64位和32为系统隔离开来。Wow64截获了打开注册表的关键调用，并且重新解释相关路径，并将它们指向注册表的WOW64视图</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;3-5-Windows全局标志&quot;&gt;&lt;a href=&quot;#3-5-Windows全局标志&quot; class=&quot;headerlink&quot; title=&quot;3.5 Windows全局标志&quot;&gt;&lt;/a&gt;3.5 Windows全局标志&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;windows全局标志用于打开windows系统的内部调试，跟踪和验证，保存在HKLM\SYSTEM\CurrentControlSet\Control\Session Manage中的GlobalFlag中，默认值为0。如下是利用windbg查看的GlobalFlag情况&lt;br&gt;      &lt;img src=&quot;https://i.imgur.com/pg5gK68.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="windows系统" scheme="http://yoursite.com/categories/windows%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>第三章：系统机制-映像加载器</title>
    <link href="http://yoursite.com/2018/04/26/%E3%80%8AWindows%20Internals%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0_%E6%98%A0%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://yoursite.com/2018/04/26/《Windows Internals》第三章_映像加载器/</id>
    <published>2018-04-26T07:02:11.000Z</published>
    <updated>2018-04-30T14:49:48.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="映像加载器"><a href="#映像加载器" class="headerlink" title="映像加载器"></a>映像加载器</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当系统中的进程被启动的时候，内核创建一个内核对象表示该进程，并执行各种和内核相关的初始化任务。绝大部分的初始化任务是在内核之外完成的，这些工作是由<strong>映像加载器</strong>完成的。映像加载器驻留在用户模式下的<strong>Ntdll.dll</strong>中，映像加载器完成以下的初始化工作：</p><ul><li>1.初始化其他用户模式，包括堆栈的初始化，TLS和FLS的初始化</li><li>2.解析执行文件的IAT，DLL的导出表</li><li>3.加载卸载DLL，维护模块数据库</li><li>4.启用API集和API重定向<a id="more"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进程创建以后，映像加载器调用特殊的原生API，在一个基于栈中的环境帧中执行。由于加载器并不使用标准的调用进入正在运行的应用程序中，所以，在一个线程的栈痕迹中，永远不会看到加载器的初始化函数出现在调用中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过进行“观察映像加载器”这个实验，我们可以知道，<strong>加载器不一定在程序开始的时候运行，也可以在后续运行过程中，会对一些涉及到延迟加载其他模块的线程请求进行响应。</strong></li></ul><h2 id="进程初始化早期工作"><a href="#进程初始化早期工作" class="headerlink" title="进程初始化早期工作"></a>进程初始化早期工作</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加载器完成早期初始化工作后，开始解析IAT，以及加载Dll,并且根据IAT和导出表，解析导入导出函数，构建模块数据库。</p><h2 id="DLL名称解析"><a href="#DLL名称解析" class="headerlink" title="DLL名称解析"></a>DLL名称解析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原始搜索dll目录的顺序</p><ul><li>应用程序被激发的目录</li><li>当前目录（可以通过SetCurrentDirection修改）</li><li>windows系统目录</li><li>windows子系统目录(16位)</li><li>windows目录</li><li>%PATH%指定的目录（通过SetEnvironmentVariabe修改）</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp；更加安全的dll搜索路径</p><ul><li>knowndll注册表指定的dll路径</li><li>应用程序被激发的目录</li><li>windows系统目录</li><li>windows子系统目录(16位)</li><li>windows目录</li><li>当前目录（可以通过SetCurrentDirection修改）</li><li>%PATH%指定的目录（通过SetEnvironmentVariabe修改）</li></ul><h2 id="已加载的模块数据库"><a href="#已加载的模块数据库" class="headerlink" title="已加载的模块数据库"></a>已加载的模块数据库</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp；加载器维护了一个关于进程加载模块的数据库，存放在PEB中，该数据库被存放在<strong>PEB_LDR-DATA</strong>结构中，在此结构中，记载器维护了3个双向链表。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp；以下是关于PEB_LDR_DATA的结构体。<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">　ULONG Length; <span class="comment">// +0x00</span></div><div class="line">　BOOLEAN Initialized; <span class="comment">// +0x04</span></div><div class="line">　PVOID SsHandle; <span class="comment">// +0x08</span></div><div class="line">　LIST_ENTRY InLoadOrderModuleList; <span class="comment">// +0x0c</span></div><div class="line">　LIST_ENTRY InMemoryOrderModuleList; <span class="comment">// +0x14</span></div><div class="line">　LIST_ENTRY InInitializationOrderModuleList;<span class="comment">// +0x1c</span></div><div class="line">&#125; PEB_LDR_DATA,*PPEB_LDR_DATA; <span class="comment">// +0x24</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp；其中包含了LIST_ENTRY类型三个数据结构，分别是模块加载顺序,内存加载顺序，初始化模块顺序。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　LIST_ENTRY InLoadOrderModuleList; <span class="comment">// +0x0c</span></div><div class="line">　LIST_ENTRY InMemoryOrderModuleList; <span class="comment">// +0x14</span></div><div class="line">　LIST_ENTRY InInitializationOrderModuleList;<span class="comment">// +0x1c</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp；LIST_ENTRY是一个双向链表，这个双链表指向进程装载的模块，结构中的每个指针，指向了一个LDR_DATA_TABLE_ENTRY 的结构<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> &#123;</span></div><div class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Flink</span>;</span></div><div class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Blink</span>;</span></div><div class="line">&#125; LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用windbg，进行以下操作</p><ul><li>!peb:显示peb信息<br>  <img src="https://i.imgur.com/x2bCkq4.png" alt=""></li><li>根据上述知识，我们知道LIST_ENTRY的指针指向的是LDR_DATA_TABLE_ENTRY结构体，由上图，dd 00251ee0，内存数据251f48，指向的是下一个LDR_DATA_TABLE_ENTRY结构体，251eac指向的上一个结构体。<br>  <img src="https://i.imgur.com/8t7YVy4.png" alt=""></li><li>不断的dd 内存，发现，最后一个结构体的下一个结构体，是第一个结构体，这样形成了一个双向循环链表。<br>  <img src="https://i.imgur.com/UPzj6dG.png" alt=""></li></ul><h2 id="导入信息解析"><a href="#导入信息解析" class="headerlink" title="导入信息解析"></a>导入信息解析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据IAT和模块数据库装载Dll，然后进行重定位检测，如果进行了重定位，则解析dll中的重定位信息，当每个dll装载完成后，解析IAT，查找每个导入函数。</p><h2 id="导入过程初始化的后期处理"><a href="#导入过程初始化的后期处理" class="headerlink" title="导入过程初始化的后期处理"></a>导入过程初始化的后期处理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dll等依赖文件被加载入进程后，则应该执行以下操作：</p><ul><li>检查是否为NET应用</li><li>检查程序自身是否要求重定位</li><li>是否使用TLS</li><li>兼容性检测。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;映像加载器&quot;&gt;&lt;a href=&quot;#映像加载器&quot; class=&quot;headerlink&quot; title=&quot;映像加载器&quot;&gt;&lt;/a&gt;映像加载器&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当系统中的进程被启动的时候，内核创建一个内核对象表示该进程，并执行各种和内核相关的初始化任务。绝大部分的初始化任务是在内核之外完成的，这些工作是由&lt;strong&gt;映像加载器&lt;/strong&gt;完成的。映像加载器驻留在用户模式下的&lt;strong&gt;Ntdll.dll&lt;/strong&gt;中，映像加载器完成以下的初始化工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.初始化其他用户模式，包括堆栈的初始化，TLS和FLS的初始化&lt;/li&gt;
&lt;li&gt;2.解析执行文件的IAT，DLL的导出表&lt;/li&gt;
&lt;li&gt;3.加载卸载DLL，维护模块数据库&lt;/li&gt;
&lt;li&gt;4.启用API集和API重定向
    
    </summary>
    
      <category term="windows系统" scheme="http://yoursite.com/categories/windows%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令-文件相关</title>
    <link href="http://yoursite.com/2018/04/14/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(1)%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2018/04/14/Linux常见命令(1)文件相关/</id>
    <published>2018-04-14T07:02:11.000Z</published>
    <updated>2018-05-16T10:03:22.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一部分：文件操作"><a href="#第一部分：文件操作" class="headerlink" title="第一部分：文件操作"></a>第一部分：文件操作</h2><ul><li>查看文件  <strong>ls [选项]</strong><ul><li>-a:查看隐藏文件<br><img src="https://i.imgur.com/kXUvm5N.png" alt=""></li><li>-l:查看详细信息<br><img src="https://i.imgur.com/y6Nk6KF.png" alt=""></li><li>-d:查看指定路径<br><img src="https://i.imgur.com/4ssnuiF.png" alt=""></li><li>-h:查看文件大小（非字节显示）[要和-l参数合用]<br><img src="https://i.imgur.com/OD734Dk.png" alt=""></li><li>-i:查看文件id<br><img src="https://i.imgur.com/WQa7g2f.png" alt=""><a id="more"></a></li></ul></li><li><p>创建目录  <strong>mkdir [目录名]</strong></p><ul><li>-p:递归创建<br><img src="https://i.imgur.com/KLZNntK.png" alt=""><br><img src="https://i.imgur.com/WCbgKOg.png" alt=""></li></ul></li><li><p>切换目录  <strong>cd [目录]</strong></p><ul><li>.. ：回到上级目录</li></ul></li><li><p>删除目录  <strong>rmdir [目录]</strong><br>  <img src="https://i.imgur.com/IdQAxZw.png" alt=""></p><ul><li>-p： 递归删除空目录<br><img src="https://i.imgur.com/VYj8Fww.png" alt=""></li></ul></li><li><p>查看当前目录 <strong>pwd</strong></p></li><li><p>复制文件  <strong>cp [源文件/目录] [目标文件/目录]</strong></p><ul><li>-r:复制目录</li><li>-p:保存被复制文件的属性</li><li>可以改名，在目标文件中修改</li></ul></li><li><p>剪切或者改名   <strong>mv [源文件/目录] [目标文件/目录]</strong></p><ul><li>可以改名</li></ul></li><li><p>删除文件    <strong>rm [文件名称]</strong></p><ul><li>-r 删除目录</li><li>-f 强制执行</li></ul></li><li><p>创建文件   <strong>touch [文件]</strong></p><ul><li>创建带有空格的文件，可以使用“”把文件名引起来</li></ul></li><li><p>查看文件内容  <strong>cat [文件名]</strong></p><ul><li>-n :显示行数</li></ul></li><li><p>查看文件内容 wc [] [文件名]</p><ul><li>-l ：显示行数</li><li>-m ：显示字符数</li><li>-c : 显示字节数</li><li>-L ：显示最长行的长度</li></ul></li><li><p>反向查看文件 <strong>tac [文件名]</strong></p></li><li><p>分页查看文件 <strong> more [文件名]</strong></p><ul><li>空格/f 翻页</li><li>Enter 换行</li><li>Q/q   退出</li></ul></li><li><p>可向上翻页查看文件  <strong> less [文件名]</strong></p><ul><li>PageUp 向上翻页</li><li>上方向键 向上换行</li><li>/ 搜索</li><li>n 搜索下一个</li></ul></li><li><p>查看文件前几行  <strong>head [文件]</strong></p><ul><li>-n 规定行数（默认是10行）</li></ul></li><li><p>查看文件末尾几行 <strong>tail [文件]</strong></p><ul><li>-n 规定行数</li><li>-f 实时显示[查看日志文件]</li></ul></li><li><p>创建文件链接 **ln [选项] [链接目录文件] [链接名]</p><ul><li>-s:创建的是软连接（快捷方式）<br><img src="https://i.imgur.com/gGbO2yy.png" alt=""></li><li>默认：硬链接（读写操作和源文件一样） </li></ul></li></ul><h1 id="第二部分-文件权限"><a href="#第二部分-文件权限" class="headerlink" title="第二部分 文件权限"></a>第二部分 文件权限</h1><ul><li><p>chmod 修改文件或者目录权限</p><ul><li>chmod [{ugoa}{+-=}{rwx}] [目录]<br><img src="https://i.imgur.com/vtqOU5b.png" alt=""></li><li>-R 递归修改</li><li>chmod [{4(r)2(w)1(x)}] [目录/文件]<br><img src="https://i.imgur.com/Mf7UhJ9.png" alt=""></li><li>普通用户即使没有w权限也可以删除root用户创建的文件（对文件的删除的必要条件是对文件所处在目录具有写入权限）</li></ul></li><li><p>chown 修改文件所有者</p><ul><li><p>chown [用户名] [文件/目录]<br><img src="https://i.imgur.com/poHs1KY.png" alt=""></p></li><li><p>useradd [用户名] 创建用户</p></li><li>chgrp [组名] [文件/目录]</li></ul></li><li><p>umask 显示默认权限</p><ul><li>显示的数值是权限的掩码，真实权限是777-该数值，例如数值为022，权限则为755<br><img src="https://i.imgur.com/WfSX6U3.png" alt=""></li><li>-S ：显示具体的权限（rwx）</li><li>umask [权限掩码] ：修改默认的权限数值</li></ul></li></ul><h1 id="第三部分-文件查询"><a href="#第三部分-文件查询" class="headerlink" title="第三部分 文件查询"></a>第三部分 文件查询</h1><ul><li><p>find [范围] [搜索条件] 搜索文件</p><ul><li>-name <ul><li>-name “<em>init</em>”  :文件名中存在init<br><img src="https://i.imgur.com/Bldk7hu.png" alt=""></li><li>-name “inti??”  :文件名前四个为init，后面两个任意<br><img src="https://i.imgur.com/aWJP0MQ.png" alt=""></li><li>-iname：不分大小写</li></ul></li><li>-size 根据文件大小<ul><li>+n 大于n</li><li>-n 小于n</li><li>n 等于n</li></ul></li><li>-cmin -时间   根据修改时间<br><img src="https://i.imgur.com/PLL9v4O.png" alt=""></li><li>-amin -时间    根据访问时间</li><li>-mmin -时间    根据文件内容</li><li>-a ： 表示两个条件都符合</li><li>-o ： 表示多个条件只需要符合一个<br><img src="https://i.imgur.com/ee3VxCC.png" alt=""></li><li>-type  按照文件类型查找<ul><li>-f 文件<br><img src="https://i.imgur.com/Cuei40d.png" alt=""></li><li>-d 目录<br><img src="https://i.imgur.com/5aASlFG.png" alt=""></li><li>-l 链接<br><img src="https://i.imgur.com/N9l3WS3.png" alt=""></li></ul></li><li>-inum  根据i节点来查找</li><li>-exec/-ok   {}\;   调用其他命令。</li></ul></li><li><p>locate [目录/文件] 搜索（需要更新文件数据库）<br>  <img src="https://i.imgur.com/mQKqGiF.png" alt=""></p><ul><li>-i：不区分大小写</li><li>updatedb ：更新数据库</li></ul></li><li><p>which [文件/目录]  ：用于查找系统命令</p><ul><li>查看命令是否带有别名<br><img src="https://i.imgur.com/fKGDysQ.png" alt=""></li></ul></li><li>grep [关键词] [搜索路径]  ：搜索文件内容<ul><li>-i 不区分不大小写<br><img src="https://i.imgur.com/gUlksFp.png" alt=""></li><li>-v 排除指定字符<br><img src="https://i.imgur.com/rwBOdI1.png" alt=""></li></ul></li><li>whereis [命令]<ul><li>查看命令的所在位置，查看配置文件的位置，和帮助文件的文职。一般的文件名是1的是命令的帮助文件，文件名是5的是配置文件的帮助</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一部分：文件操作&quot;&gt;&lt;a href=&quot;#第一部分：文件操作&quot; class=&quot;headerlink&quot; title=&quot;第一部分：文件操作&quot;&gt;&lt;/a&gt;第一部分：文件操作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;查看文件  &lt;strong&gt;ls [选项]&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;-a:查看隐藏文件&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/kXUvm5N.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;-l:查看详细信息&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/y6Nk6KF.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;-d:查看指定路径&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/4ssnuiF.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;-h:查看文件大小（非字节显示）[要和-l参数合用]&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/OD734Dk.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;-i:查看文件id&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/WQa7g2f.png&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术(8) ---芦苇病毒</title>
    <link href="http://yoursite.com/2018/04/14/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF(8)--%E8%8A%A6%E8%8B%87%E7%97%85%E6%AF%92/"/>
    <id>http://yoursite.com/2018/04/14/病毒分析技术(8)--芦苇病毒/</id>
    <published>2018-04-14T06:02:11.000Z</published>
    <updated>2018-04-25T10:50:52.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-目录："><a href="#一-目录：" class="headerlink" title="一 目录："></a>一 目录：</h1><ul><li>1.目录</li><li>2.样本信息</li><li>3.行为分析</li><li>4.样本分析</li><li>5.技术上的总结<a id="more"></a><h1 id="二-样本信息"><a href="#二-样本信息" class="headerlink" title="二 样本信息"></a>二 样本信息</h1></li><li>1.样本名称：芦苇病毒.exe</li><li>2.MD5:c71091507f731c203b6c93bc91adedb6</li><li>3.是否加壳：否</li><li>4.编写语言：Microsoft Visual C++ ver 5.0/6.0</li><li>5.样本来源：卡饭社区病毒样本专栏</li></ul><h1 id="三-行为分析"><a href="#三-行为分析" class="headerlink" title="三 行为分析"></a>三 行为分析</h1><ul><li>1.病毒将自身写入/run注册表项，实现自启</li><li>2.向c盘根目录写入三个文件</li><li>3.向样本同一目录下写入bmp文件，并设置隐藏</li><li>4.执行根目录下文件，error图标，随着鼠标移动而移动</li><li>5.加载windows音频驱动，播放音乐。</li><li>6.调用cmd，执行各种批处理</li><li>7.禁用系统安全选项</li><li>8.小结：这个病毒属于恶作剧病毒，没有采用常见的隐藏自身的行为，而是很大方的告诉用户本机已经中病毒了，也许是作者对自身病毒很有自信，执行大量批处理。</li></ul><h1 id="四-样本分析"><a href="#四-样本分析" class="headerlink" title="四 样本分析"></a>四 样本分析</h1><ul><li>1.省略前面的初始化工作，经过程序od跟踪，进入第一个可以用于病毒执行的函数<br>  <img src="https://i.imgur.com/FY1YLu0.png" alt=""><br>  <img src="https://i.imgur.com/l4KcSze.png" alt=""><br>  <img src="https://i.imgur.com/0nJRrMd.png" alt=""></li><li>2.先把1.bmp传入函数，调用004062F0函数，利用Cfile库来创建文件，其实这个库底层也是调用createfile函数实现的。<br>  <img src="https://i.imgur.com/3gZWzZa.png" alt=""></li><li>3.然后利用DistributeFun函数(自定义)进行函数的分发，原理是根据函数入口表，利用jmp去跳转到对应的函数入口。关于这部分内容文章后期介绍。<br>  <img src="https://i.imgur.com/VgKYU9B.png" alt=""></li><li>4.设置文件安全属性(主要是隐藏)，但是不明白的是为什么要把bmp文件设置隐藏。<br>  <img src="https://i.imgur.com/alHyrbp.png" alt=""></li><li>5.调用sub_463F60利用修改注册表的键值来修改桌面配置信息<br>  <img src="https://i.imgur.com/9v6U9LX.png" alt=""><br>  <img src="https://i.imgur.com/FHryWgf.png" alt=""><br>  <img src="https://i.imgur.com/eW9ZlR6.png" alt=""></li><li>6.加载wdmaud.drv等windows音频驱动文件<br>   <img src="https://i.imgur.com/cWqIOsV.png" alt=""><br>   <img src="https://i.imgur.com/NtqcLOk.png" alt=""></li><li>7.播放音乐<br>   <img src="https://i.imgur.com/53Ck3uI.png" alt=""></li><li>8.在c盘根目录下释放三个文件，分别是drawerror.exe。ghost.exe。main.cpp，<br>   <img src="https://i.imgur.com/hxk47VA.png" alt=""></li><li>9.执行前两个文件。drawerror.exe产生error图标，随着鼠标移动而移动。ghost文件没有实际的操作。<br>   <img src="https://i.imgur.com/X5SIkSb.png" alt=""></li><li>10.关闭windows的安全选项，这些函数都是通过删除注册表子项(如SYSTEM\CurrentControlSet\Control\SafeBoot\Minimal)的方法，阻止用户使用安全选项。<br>  <img src="https://i.imgur.com/5d778EX.png" alt=""></li><li>11.修改注册表，实现开机自启<br>  <img src="https://i.imgur.com/SmAtU9l.png" alt=""><br>  <img src="https://i.imgur.com/TIjRv1g.png" alt=""><br>  <img src="https://i.imgur.com/sdqxBTG.png" alt=""></li><li>12.通过消息分发函数调用cmd.exe 执行批处理（关于DispatchMessage函数的溯源放到本次分析的后续介绍）<ul><li>1）创建C:\cc.ico和1.bat</li><li>2）这是比较有意思的一步，程序通过向注册表HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom\中写入1.bat，同时释放了一个名为ascaris.dll的文件，这是一个关于过UAC的一个方法。原文来自：安全客<a href="http://bobao.360.cn/learning/detail/420.html" target="_blank" rel="external">http://bobao.360.cn/learning/detail/420.html</a></li><li>3）通过注册表HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\AppCertDlls实现隐藏。</li><li>调用cmd.exe执行操作</li><li>把所有exe格式的文件的图标全部替换成释放的cc.ico  </li></ul></li><li>13.关于1.bat功能的介绍<ul><li>assoc .exe=exefile 关联exe文件，使其可以运行。</li></ul></li><li>14.关于ascaris.bat的介绍<ul><li>根据上文，我们知道使用ascaris.bat和ascaris.dll来避开UAC机制，其中ascaris.bat是主要的执行部分//前面有注释。</li><li>1.复制自身</li><li>2.隐藏文件</li><li>3.制造大文件，破坏行为</li><li>4.监视U盘</li><li>5.隐藏文件等</li></ul></li><li>15.关于兵团.bat的介绍<ul><li>遍历磁盘</li><li>创建随机文件<br><img src="https://i.imgur.com/P8RN0yn.png" alt=""></li></ul></li></ul><h1 id="5-技术总结"><a href="#5-技术总结" class="headerlink" title="5 技术总结"></a>5 技术总结</h1><ul><li>1.关于DistributeFun分发函数的介绍<ul><li>首先函数先将目标函数的地址出传入ebx，然后利用跳转表跳入分发函数的入口地址<br><img src="https://i.imgur.com/6pWui9r.png" alt=""></li><li>继续跟入分发函数可以发现，函数内部，进行了一次调用call ebx，这样就把目标函数的实际调用隐藏起来了。<br><img src="https://i.imgur.com/H8L5nUn.png" alt=""></li></ul></li><li>2.关于DispatchMessage消息分发函数的介绍<ul><li>DispatchMessage函数是将消息派发给窗口函数，我们可以利用SPY++来查看消息对应的窗口处理函数，然后在目标的窗口进程下断点，然后就可以开始调试了。<br><img src="https://i.imgur.com/KYbGkF9.png" alt=""></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-目录：&quot;&gt;&lt;a href=&quot;#一-目录：&quot; class=&quot;headerlink&quot; title=&quot;一 目录：&quot;&gt;&lt;/a&gt;一 目录：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.目录&lt;/li&gt;
&lt;li&gt;2.样本信息&lt;/li&gt;
&lt;li&gt;3.行为分析&lt;/li&gt;
&lt;li&gt;4.样本分析&lt;/li&gt;
&lt;li&gt;5.技术上的总结
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>C++Primer 第六章：函数</title>
    <link href="http://yoursite.com/2018/04/11/C++%E7%AC%AC%E5%85%AD%E7%AB%A0_%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/04/11/C++第六章_函数/</id>
    <published>2018-04-11T08:02:11.000Z</published>
    <updated>2018-04-17T08:43:37.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h2><h3 id="6-1-1-局部变量"><a href="#6-1-1-局部变量" class="headerlink" title="6.1.1 局部变量"></a>6.1.1 局部变量</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static是静态修饰符，static变量存放在静态存储区，本次ret的数据对下次函数调用仍然有效。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; count_calls() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">size_t</span> count_calls()</div><div class="line">&#123;</div><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;  <span class="comment">//static局部变量的特点是它位于静态存贮区，</span></div><div class="line">                        <span class="comment">//在函数调用结束后，它的值仍然存在，并可能影响到下一次调用的过程。</span></div><div class="line"><span class="keyword">return</span> ++ctr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><pre><code>![](http://oxnvtxe03.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20180411194941.png)</code></pre><a id="more"></a><h2 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h2><h3 id="6-2-0"><a href="#6-2-0" class="headerlink" title="6.2.0"></a>6.2.0</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次函数调用都会创建形参。并使用传入的实参对形式参数进行初始化。</p><h3 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a>6.2.1 传值参数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用传递：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拷贝传递，如果利用这种传参方法，不会改变实参的数值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指针传参：</p><ul><li>练习6.10<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> count_calls();</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; count_calls() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">size_t</span> count_calls()</div><div class="line">&#123;</div><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;  <span class="comment">//static局部变量的特点是它位于静态存贮区，</span></div><div class="line">                        <span class="comment">//在函数调用结束后，它的值仍然存在，并可能影响到下一次调用的过程。</span></div><div class="line"><span class="keyword">return</span> ++ctr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="6-2-3-传引用参数"><a href="#6-2-3-传引用参数" class="headerlink" title="6.2.3 传引用参数"></a>6.2.3 传引用参数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用的操作是作用在引用的对象上面的，对于函数来说，如果形势参数是引用的话，对引用的更改就是对绑定在引用的对象的更改.</p><ul><li><p>练习6.11</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> Num;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; Num)</div><div class="line">&#123;</div><div class="line">reset(Num);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; Num &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> &amp;Num)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">Num = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>练习6.12</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> Num1, Num2;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; Num1 &gt;&gt; Num2)</div><div class="line">&#123;</div><div class="line">ExchangeNum(Num1, Num2);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; Num1 &lt;&lt; <span class="string">" "</span> &lt;&lt; Num2 &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExchangeNum</span><span class="params">(<span class="keyword">int</span> &amp;Num1, <span class="keyword">int</span> &amp;Num2)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> temp;   <span class="comment">//int</span></div><div class="line">temp = Num1;    <span class="comment">//*Num1Ϊint</span></div><div class="line">Num1 = Num2;</div><div class="line">Num2 = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="6-2-4-数组传参"><a href="#6-2-4-数组传参" class="headerlink" title="6.2.4 数组传参"></a>6.2.4 数组传参</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们为一个函数传入数组时，实际上传递的是一个指向数组首元素地址的指针。所以我们仍然可以把形参写成类似形式。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> [])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> [<span class="number">10</span>])</span></span>;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于数组引用型传参，形参必须是数组的引用，所以，引用形参必须要绑定到对应的实参上面。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//因为&amp;的优先级高。</span></div><div class="line"><span class="built_in">Type</span> Fun(<span class="built_in">int</span> &amp;arr[<span class="number">10</span>]);    <span class="comment">//错误，&amp;arr[]是指引用数组</span></div><div class="line"><span class="built_in">Type</span> Fun(<span class="built_in">int</span> (&amp;arr)[<span class="number">10</span>])   <span class="comment">//正确，对于10个整形变量数组的引用</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于多维数组，知道c++中多维数组是数组的数组，所以函数形参中真正传递的是数组首元素的指针，而这个数组中存放的是各个行的首地址。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printf</span>(<span class="params"><span class="keyword">int</span> (*matrix</span>)[10],<span class="keyword">int</span> RowSize)</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printf</span>(<span class="params"><span class="keyword">int</span> (*matrix</span>)[][10],<span class="keyword">int</span> RowSize)</span>;</div><div class="line"><span class="comment">//强调一下：matrix的两端括号必不可少</span></div><div class="line"><span class="keyword">int</span> *matrix[<span class="number">10</span>]；是<span class="number">10</span>个<span class="keyword">int</span> *的指针</div><div class="line"><span class="keyword">int</span> (*matrix)[<span class="number">10</span>];是指向含有<span class="number">10</span>个<span class="keyword">int</span>型的数组的指针</div></pre></td></tr></table></figure></p><ul><li><p>练习6.21</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> num1, num2,BigerNum;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; num1 &gt;&gt; num2)</div><div class="line">&#123;</div><div class="line">BigerNum=IsBig(num1, &amp;num2);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; BigerNum &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsBig</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> *num2)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">return</span> (num1 &gt; *num2) ? num1 : *num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>练习6.22</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> Num1, Num2;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; Num1 &gt;&gt; Num2)</div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> *pNum1 = &amp;Num1,*pNum2=&amp;Num2;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; pNum1 &lt;&lt; <span class="string">" "</span>&lt;&lt;pNum2&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">ExchangePoint(pNum1, pNum2);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; pNum1 &lt;&lt; <span class="string">" "</span> &lt;&lt; pNum2 &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> *<span class="title">ExchangePoint</span><span class="params">(<span class="keyword">int</span>* &amp;pNum1, <span class="keyword">int</span>* &amp;pNum2)</span>   <span class="comment">//利用引用,对于指针的引用</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> *temp = pNum1;</div><div class="line">pNum1 = pNum2;</div><div class="line">pNum2 = temp;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>练习6.24</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span>(<span class="params"><span class="keyword">const</span> <span class="keyword">int</span> (&amp;ia</span>)[10])  <span class="comment">//数组不能拷贝传入，但是可以利用引用的方法</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span>(size_t i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)</div><div class="line">cout&lt;&lt;ia[i]&lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="main函数的预处理选项"><a href="#main函数的预处理选项" class="headerlink" title="main函数的预处理选项"></a>main函数的预处理选项</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令行参数通过两个可选的形参传入main函数。<strong>可选的实参是从agrv[1]开始，agrv[0]存放的程序名称。</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>;</div></pre></td></tr></table></figure></p><ul><li>练习6.26<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">string</span> str;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != argc; ++i)</div><div class="line">&#123;</div><div class="line">str += argv[i];</div><div class="line">str += <span class="string">" "</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="6-3-返回类型和return-语句"><a href="#6-3-返回类型和return-语句" class="headerlink" title="6.3 返回类型和return 语句"></a>6.3 返回类型和return 语句</h2><h3 id="6-3-1-无返回值类型的函数"><a href="#6-3-1-无返回值类型的函数" class="headerlink" title="6.3.1 无返回值类型的函数"></a>6.3.1 无返回值类型的函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void类型会默认函数体结尾隐式返回return。中部执行return作用类似于循环中的break</p><h3 id="6-3-2-有返回值的函数"><a href="#6-3-2-有返回值的函数" class="headerlink" title="6.3.2 有返回值的函数"></a>6.3.2 有返回值的函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要返回局部变量的指针或者引用，因为一旦函数执行完成，意味着局部变量的引用也指向不再有效的内存区域。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果调用一个返回引用的函数调用，得到的是一个左值，其他都是得到右值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> &amp;<span class="title">get_val</span><span class="params">(<span class="built_in">string</span> &amp;str,<span class="built_in">string</span>::size_type ix)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">return</span> str[ix];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">get_val(s,<span class="number">0</span>)=<span class="string">'A'</span>;   <span class="comment">//将s[0]的值初始化为A</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数可以返回包含花括号包含的值得列表。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;process()</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(exected==actual)</div><div class="line"><span class="keyword">return</span> &#123;<span class="string">"FunctionX"</span>,exected,actual&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>练习6.33<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</div><div class="line">Fun(nums,nums.size()<span class="number">-1</span>);</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,<span class="keyword">int</span> Count)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">if</span> (Count != <span class="number">-1</span>)</div><div class="line">&#123;</div><div class="line"><span class="comment">//Count--;                        他就是不能先减减</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; nums[Count] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">Count--;</div><div class="line">Fun(nums, Count);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;6-1-函数基础&quot;&gt;&lt;a href=&quot;#6-1-函数基础&quot; class=&quot;headerlink&quot; title=&quot;6.1 函数基础&quot;&gt;&lt;/a&gt;6.1 函数基础&lt;/h2&gt;&lt;h3 id=&quot;6-1-1-局部变量&quot;&gt;&lt;a href=&quot;#6-1-1-局部变量&quot; class=&quot;headerlink&quot; title=&quot;6.1.1 局部变量&quot;&gt;&lt;/a&gt;6.1.1 局部变量&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static是静态修饰符，static变量存放在静态存储区，本次ret的数据对下次函数调用仍然有效。&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i != &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; ++i)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; count_calls() &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	system(&lt;span class=&quot;string&quot;&gt;&quot;pause&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; count_calls()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; ctr = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//static局部变量的特点是它位于静态存贮区，&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	                        &lt;span class=&quot;comment&quot;&gt;//在函数调用结束后，它的值仍然存在，并可能影响到下一次调用的过程。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ++ctr;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;![](http://oxnvtxe03.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20180411194941.png)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++Primer 第二章:变量和基本类型</title>
    <link href="http://yoursite.com/2018/04/11/C++%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/04/11/C++第二章_变量和基本类型/</id>
    <published>2018-04-11T07:02:11.000Z</published>
    <updated>2018-04-11T12:20:58.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-4：const限定符"><a href="#2-4：const限定符" class="headerlink" title="2.4：const限定符"></a>2.4：const限定符</h2><h3 id="2-4-0：初始化Const"><a href="#2-4-0：初始化Const" class="headerlink" title="2.4.0：初始化Const"></a>2.4.0：初始化Const</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要限制某个变量的值不能被修改，我们应该使用const限定符，const限定符必须要初始化，如下的定义是错误的。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> n;    <span class="comment">//错误，因为没有被初始化</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const限定符只能在同一个文件使用有效。在编译过程中，编译器会在任何使用const变量的地方，使用常量代替。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只在一个文件中定义const变量，但是需要在多个文件中使用的，需要关键字extern。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> num=<span class="number">1</span>;</div></pre></td></tr></table></figure></p><h3 id="2-4-1-const的引用"><a href="#2-4-1-const的引用" class="headerlink" title="2.4.1:const的引用"></a>2.4.1:const的引用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>对常量的引用：</strong>可以把引用绑定到const对象上的引用。但是对常量的引用不能修改他所绑定的对象。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>对常量的引用可以引用一个非常量的对象。</strong><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> i=<span class="number">42</span>;</div><div class="line"><span class="keyword">const</span> <span class="built_in">int</span> &amp;r1=i;      //允许<span class="keyword">const</span> <span class="built_in">int</span>&amp;绑定在<span class="built_in">int</span>变量上</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用必须和他引用的对象类型一致。如下就是一个<strong>错误</strong>的实例：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> i=<span class="number">42</span>;</div><div class="line"><span class="keyword">const</span> <span class="built_in">int</span> &amp;r1=i;      //允许<span class="keyword">const</span> <span class="built_in">int</span>&amp;绑定在<span class="built_in">int</span>变量上</div><div class="line"><span class="built_in">int</span> &amp;r2=r1；          //错误，试图使用非常量引用指向常量对象，这样做缺少了关于引用修改值得意义。</div></pre></td></tr></table></figure></p><h3 id="2-4-2-指针和const"><a href="#2-4-2-指针和const" class="headerlink" title="2.4.2 指针和const"></a>2.4.2 指针和const</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>指向常量的指针：</strong>不能改变其所指对象的值。<strong>如果想要存放常量对象的地址</strong>，必须使用指向常量的指针，<strong><font color="#DC143C">但是指针指向的对象(就是那个地址)可以改变.</font></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>但是允许指向常量的指针指向一个非常量，这样一来，我们虽然不可以利用执政const指针改变所指向对象的值，但是我们可以通过其他方法改变该对象的值</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi1 = <span class="number">3.14</span>;    <span class="comment">//pi1是一个常量</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> *Ppi1=&amp;pi1；   <span class="comment">//允许，是一个指向常量的指针</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const指针，<strong>指针常量必须初始化，一旦初始化，指针的值（也就是指针指向对象的地址）不能更改了。</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> <span class="built_in">num</span>=<span class="number">0</span>;</div><div class="line"><span class="built_in">int</span> *<span class="keyword">const</span> Pnum=&amp;<span class="built_in">num</span>;  <span class="comment">//Pnum是常量指针，一直指向的是num。</span></div><div class="line"><span class="keyword">const</span> <span class="built_in">double</span> pi=<span class="number">3.14</span>;   <span class="comment">//常量</span></div><div class="line"><span class="keyword">const</span> <span class="built_in">double</span> *<span class="keyword">const</span> Ppi=&amp;pi;  <span class="comment">//指向常量的常量指针。第一个const是修饰的对象，第二份const修饰的是指针。</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于常量指针，还是指向常量的指针，阅读顺序是从左向右阅读<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span>  i;</div><div class="line"><span class="keyword">const</span> <span class="built_in">int</span> x=<span class="number">1</span>;</div><div class="line"><span class="built_in">int</span> *<span class="keyword">const</span> p=&amp;i;   //常量指针，指向对象是一个<span class="built_in">int</span>变量</div><div class="line"><span class="keyword">const</span> <span class="built_in">int</span> *q=&amp;x；  //指针，指向的是<span class="keyword">const</span> <span class="built_in">int</span> 类型的常量</div></pre></td></tr></table></figure></p><h3 id="2-4-3-顶层const"><a href="#2-4-3-顶层const" class="headerlink" title="2.4.3 顶层const"></a>2.4.3 顶层const</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>顶层const：</strong>指针本身就是一个常量，也就是指向的地址不能更改。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>底层const:</strong>指针指向的对象是一个常量。</p><h3 id="2-4-4constexpr和常量表达式"><a href="#2-4-4constexpr和常量表达式" class="headerlink" title="2.4.4constexpr和常量表达式"></a>2.4.4constexpr和常量表达式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常量表达式是指值不会改变并且只有在编译过程中就能得到计算结果了。const是指在程序运行过程中，不能修改值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constexpr用于检测常量表达式。constexpr修饰的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p=<span class="literal">nullptr</span>;     <span class="comment">//是一个指向int常量的指针</span></div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *p=<span class="literal">nullptr</span>    <span class="comment">//是一个指向整数的常量指针。顶层const</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2-4：const限定符&quot;&gt;&lt;a href=&quot;#2-4：const限定符&quot; class=&quot;headerlink&quot; title=&quot;2.4：const限定符&quot;&gt;&lt;/a&gt;2.4：const限定符&lt;/h2&gt;&lt;h3 id=&quot;2-4-0：初始化Const&quot;&gt;&lt;a href=&quot;#2-4-0：初始化Const&quot; class=&quot;headerlink&quot; title=&quot;2.4.0：初始化Const&quot;&gt;&lt;/a&gt;2.4.0：初始化Const&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果需要限制某个变量的值不能被修改，我们应该使用const限定符，const限定符必须要初始化，如下的定义是错误的。&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>2015年强网杯MISC和REV</title>
    <link href="http://yoursite.com/2018/04/09/2015%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF/"/>
    <id>http://yoursite.com/2018/04/09/2015年强网杯/</id>
    <published>2018-04-09T03:00:11.000Z</published>
    <updated>2018-04-09T05:33:34.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来看一下flag格式-BASIC"><a href="#来看一下flag格式-BASIC" class="headerlink" title="来看一下flag格式[BASIC]"></a>来看一下flag格式[BASIC]</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;签到题，不做解释。<br><a id="more"></a></p><h2 id="小苹果-BASIC"><a href="#小苹果-BASIC" class="headerlink" title="小苹果[BASIC]"></a>小苹果[BASIC]</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;听了音乐，发现这里面没有出现杂音，排除了关于摩尔斯电码的可能性。波形杂乱无序，见图1，排除了关于波形的可能性。存在LSB的可能性，不仅仅图片隐写存在LSB技术，在音频中也存在。利用<strong>SilentEye</strong>这个软件解密即可。<br>      <img src="https://i.imgur.com/Ccip6pB.png" alt=""><br>      <img src="https://i.imgur.com/RXuu5d2.png" alt=""></p><h2 id="致敬经典"><a href="#致敬经典" class="headerlink" title="致敬经典"></a>致敬经典</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;放到百度识图上去，发现是恺撒大帝，恺撒密码，但是解密结果不正确，通过查看wp发现这是变种的恺撒密码。如果是奇数的话右移6位，如果是偶数则左移6位。<br>    <img src="https://i.imgur.com/mUjFvGF.jpg" alt=""></p><h2 id="回旋13踢"><a href="#回旋13踢" class="headerlink" title="回旋13踢"></a>回旋13踢</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有改变flag的类型，主要没有改变括号，只可能是恺撒密码，解密即可。</p><h2 id="爆破？"><a href="#爆破？" class="headerlink" title="爆破？"></a>爆破？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既有txt又有zip，不解释首选明文破解。将里面的readme.txt压缩一下，利用AZPR来解密</p><h2 id="小心猪圈"><a href="#小心猪圈" class="headerlink" title="小心猪圈"></a>小心猪圈</h2><ul><li>一看字母+数字，首先想到的是base64解密<br>  <img src="https://i.imgur.com/mmlXlmS.png" alt=""></li><li>这一堆是ASCII编码，<br>  <img src="https://i.imgur.com/GpLlLSk.png" alt=""></li><li>存在=，想到base64，但是解密是乱码，在加一个等号也不行。试试base2<br>  <img src="https://i.imgur.com/hvPsvST.png" alt=""><br>  <img src="https://i.imgur.com/gnDEviO.png" alt=""></li><li>最后发现两个等号，base64解密<br>  <img src="https://i.imgur.com/Uep0THU.png" alt=""></li><li>最后放到猪圈密码解密工具里面解密就行了<br>  <img src="https://i.imgur.com/Y2OSuBJ.png" alt=""><h2 id="单身狗"><a href="#单身狗" class="headerlink" title="单身狗"></a>单身狗</h2></li><li>截取正常的一小块，利用ppt拼好，然后扫扫就行了<br>  <img src="https://i.imgur.com/NDCEMHv.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;来看一下flag格式-BASIC&quot;&gt;&lt;a href=&quot;#来看一下flag格式-BASIC&quot; class=&quot;headerlink&quot; title=&quot;来看一下flag格式[BASIC]&quot;&gt;&lt;/a&gt;来看一下flag格式[BASIC]&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;签到题，不做解释。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>C++Primer 第五章：语句</title>
    <link href="http://yoursite.com/2018/04/08/C++%E7%AC%AC%E4%BA%94%E7%AB%A0_%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2018/04/08/C++第五章_语句/</id>
    <published>2018-04-08T07:02:11.000Z</published>
    <updated>2018-04-09T04:47:48.059Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>例5.16：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VectNum1 = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VectNum2 = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</div><div class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> SmallSize = (VectNum1.size() &gt; VectNum2.size() ? VectNum2.size() : VectNum1.size());</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != SmallSize; i++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (VectNum1[i] != VectNum2[i])</div><div class="line">flag = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>例5.19：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="built_in">string</span> MyString1, MyString2;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入两个字符串"</span>;</div><div class="line"><span class="keyword">do</span></div><div class="line">&#123;</div><div class="line"><span class="built_in">cin</span> &gt;&gt; MyString1 &gt;&gt; MyString2;</div><div class="line">MyString1.size() &gt; MyString2.size() ? <span class="built_in">cout</span> &lt;&lt; MyString2 &lt;&lt;<span class="built_in">endl</span>: <span class="built_in">cout</span> &lt;&lt; MyString1&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入两个字符串"</span>;</div><div class="line">i++;</div><div class="line">&#125; <span class="keyword">while</span> (i != <span class="number">10</span>);</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>例5.20</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">string</span> MyString1, MyString2;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"连续输入两个字符串"</span>;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; MyString1 &gt;&gt; MyString2)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> ((MyString1 == MyString2) &amp;&amp; MyString1[<span class="number">0</span>] &gt;= <span class="string">'A'</span>&amp;&amp;MyString1[<span class="number">0</span>] &lt;= <span class="string">'Z'</span>&amp;&amp;MyString2[<span class="number">0</span>] &gt;= <span class="string">'A'</span>&amp;&amp;MyString2[<span class="number">0</span>] &lt;= <span class="string">'Z'</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; MyString1;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"连续输入两个字符串"</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>例5.24</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;     </div><div class="line">    <span class="keyword">int</span> a,b;  </div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入相除的两个整数："</span>;  </div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">try</span>  </div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"被除数不能为0"</span>);<span class="comment">//runtime_error异常类:只有在运行时才能检测出的问题  </span></div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(a)/b&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//考虑到不可以整除产生小数的情况,先将a强制转化为double类型  </span></div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (runtime_error err)<span class="comment">//err是runtime_error类的一个实例  </span></div><div class="line">        &#123;  </div><div class="line">            <span class="built_in">cout</span> &lt;&lt; err.what() ;实例的成员函数，返回内容由编译其决定  </div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n是否需要重新输入? Enter y or n:"</span> &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">            <span class="keyword">char</span> c;  </div><div class="line">            <span class="built_in">cin</span> &gt;&gt; c;  </div><div class="line">            <span class="keyword">if</span> (!<span class="built_in">cin</span> || c == <span class="string">'n'</span>)  </div><div class="line">                <span class="keyword">break</span>;<span class="comment">//break只能用在开关体或者循环体中  </span></div><div class="line">        &#125;<span class="comment">//简单来说try是检测异常的，如果产生了异常，就throw(抛出)一个异常，然后被catch到，进行异常的处理  </span></div><div class="line">        <span class="comment">//如果没有catch部分，仅有try，仍然会报错  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;例5.16：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;d
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>第三章：系统机制-同步</title>
    <link href="http://yoursite.com/2018/04/08/%E3%80%8AWindows%20Internals%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0_%E5%90%8C%E6%AD%A5/"/>
    <id>http://yoursite.com/2018/04/08/《Windows Internals》第三章_同步/</id>
    <published>2018-04-08T07:02:11.000Z</published>
    <updated>2018-04-09T04:44:36.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-3-同步"><a href="#3-3-同步" class="headerlink" title="3.3 同步"></a>3.3 同步</h1><h2 id="高IRQL的同步"><a href="#高IRQL的同步" class="headerlink" title="高IRQL的同步"></a>高IRQL的同步</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在内核执行的各个阶段，内核必须保证在临界区中同一时刻只有一个处理器在执行，内核必须保证所有线程按照互斥的方法访问这些数据（内核临界区）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于中断的发生，该中断的处理例程需要修改一个全局的数据结构，与此同时，内核恰好在更新该数据结构，违背了互斥的原则（同一时间只有一个处理器访问数据结构）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windows采用了一个比较复杂的方法：首先内核先将处理器的IRQL(中断请求级别)提高到能访问该数据结构的最高的级别，这样就屏蔽了在中断处理例程中使用该资源的中断。<strong>但是这种策略对于单处理器来说是可以的，但是不能阻止多处理器发生中断。</strong> </p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内核用来实现多处理器互斥的机制是自旋锁。自旋锁是一个与某个局部变量相关联的锁原语，在进入临界区之前，内核（处理器）会一直尝试获取相关联的自旋锁，直到成功为止。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自旋锁是通过硬件支持的test-and-set操作来实现的，也即：在一条原子指令内测试并获取锁，这样避免多线对锁的争夺。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个自旋锁都拥有一个IRQL，并且这个IRQL总是在DPC/Dispatch或者更高级别，因为这个原因，如果一个线程拥有自旋锁，则他永远不会被抢占。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何一个试图获取自旋锁的处理器本质上都是处于忙等状态。<strong>因为处理器在进入临界区之前会循环的去获取自旋锁</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用pause汇编指令，插入到忙等的循环中，这条指令告诉处理器他正在执行的部分是自旋锁的获取循环部分。  </p><h2 id="排队的自旋锁"><a href="#排队的自旋锁" class="headerlink" title="排队的自旋锁"></a>排队的自旋锁</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个处理器想要获取被其他处理器持有的自旋锁的时候，他会把自己的标志符放在与该自旋锁关联的队列中，如果当前正持有自旋锁的处理器释放的，则其将自旋锁移交给队列的第一个处理器，如果处理器正在等待一个忙着的自旋锁，他会检查处于该处理器之前的处理器的标志，<strong>而不是检查自旋锁的标志</strong>。<strong>说是排队的自旋锁，还不如说是排队等待自旋锁的处理器</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;锁是留给内核使用的，所以，在设备驱动程序中获取这些排队的自旋锁是不被支持的。</p><h2 id="栈内排队的自旋锁"><a href="#栈内排队的自旋锁" class="headerlink" title="栈内排队的自旋锁"></a>栈内排队的自旋锁</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自旋锁句柄是一个数据结构。包含了<strong>锁的所有权</strong>（要求局部变量的原因所在）和处理器队列等状态信息，由此，<strong>句柄不应该是一个全局变量，往往是一个栈变量，以保证调用线程的局部性。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;3-3-同步&quot;&gt;&lt;a href=&quot;#3-3-同步&quot; class=&quot;headerlink&quot; title=&quot;3.3 同步&quot;&gt;&lt;/a&gt;3.3 同步&lt;/h1&gt;&lt;h2 id=&quot;高IRQL的同步&quot;&gt;&lt;a href=&quot;#高IRQL的同步&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="windows系统" scheme="http://yoursite.com/categories/windows%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>windbg内核调试（1）</title>
    <link href="http://yoursite.com/2018/04/05/windbg%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2018/04/05/windbg使用简明教程（1）/</id>
    <published>2018-04-05T07:02:11.000Z</published>
    <updated>2018-04-06T06:23:29.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置篇："><a href="#配置篇：" class="headerlink" title="配置篇："></a>配置篇：</h2><ul><li><p>1）安装WinDbg，如果要进入内核模式调试的话需要进行如下步骤：</p><ul><li>1）修改虚拟机C盘根目录下配置文件boot.ini</li><li>2）修改虚拟机设置，添加一个串行串口</li><li>3）在宿主主机启动winbdg，进入内核调试，配置如下<br><img src="https://i.imgur.com/A4wPzBq.png" alt=""></li><li>PS：如果遇到Fail Open \.\pipe\com_1，只需要在快捷方式后面添加<strong>“windbg -b -k com:pipe,port=\.\pipe\com_1,resets=0”</strong>即可<br><img src="https://i.imgur.com/8aGsnQY.png" alt=""><a id="more"></a><h2 id="进程篇"><a href="#进程篇" class="headerlink" title="进程篇"></a>进程篇</h2><h3 id="1-查看进程列表"><a href="#1-查看进程列表" class="headerlink" title="1.查看进程列表"></a>1.查看进程列表</h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有多个命令可以显示进程列表，他们主要是：“|”，“.tlist”,“!process”,“!dml_proc”。  </li></ul></li><li><p><font color="#DC143C">| [进程号]</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在用户态下，这个命令显示当前被调试进程的状态信息</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;被调试进程列表。大多数情况下，调试器中只有一个被调试进程，但可以通过.attach或者.create命令同时挂载或创建多个调试对象。当同时对多个进程调试时，进程号是从0开始的整数。</p></li><li><font color="#DC143C">tlist [选项] [模块名]</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在用户模式</strong>下显示系统当前的进程列表，存在两个参数选项：-v:显示进程的详细信息，-c显示当前进程信息。默认是-v<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过“.attach”或者“.create”来创建或者附件多个调试对象<br>   <img src="https://i.imgur.com/7UqOBCF.png" alt=""></li><li><font color="#DC143C">!process:<strong>显示调试器当前运行的进程信息</strong></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这个命令只能在内核调试中使用，如果在用户态中调试，则会出现如下的错误提示。No export prcoess found<br>   <img src="https://i.imgur.com/CgfwHrG.png" alt=""></li><li><font color="#DC143C"><strong>显示当前进程列表（内核态)</strong></font><br>   <img src="https://i.imgur.com/MetSOw4.png" alt=""></li><li><font color="#DC143C"><strong>!process PID:显示PID的详细信息（内核态）</strong></font><br>   <img src="https://i.imgur.com/sAiYXqY.png" alt=""></li><li><p><font color="#DC143C"><strong>!process 0 0 XXX,exe：查找指定进程（用户态中）</strong></font><br>   <img src="https://i.imgur.com/IFDvyGu.png" alt=""><br>   <img src="https://i.imgur.com/Jp3ajSL.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是根据上述命令查看到的信息包含的主要内容。</p></li><li><p>Cid : 进程id</p></li><li>Peb : 进程环境块的地址</li><li>ParentCid : 父进程id</li><li>DirBase : 页目录表 (用于转换虚拟地址和物理地址PDT)</li><li>ObjectTable : 进程的句柄表</li></ul><h3 id="2-进程信息"><a href="#2-进程信息" class="headerlink" title="2.进程信息"></a>2.进程信息</h3><ul><li><font color="#DC143C">!peb[address]:查看指定PEB信息，在内核模式下，address可以通过!process 0 0:来查看。如果!peb不带参数，则指的是当前进程的PEB，在用户模式下，只能查看当前进程的PEB，所以不需要带参数。</font><br>  <img src="https://i.imgur.com/oFRU1Nj.png" alt=""></li><li><font color="#DC143C">dt nt!_PEB[address]:此命令显示系统nt模块中所定义的内核结构体PEB详细内容.</font><br>  <img src="https://i.imgur.com/G81Rqs4.png" alt=""><br>  <img src="https://i.imgur.com/Xbj48Tu.png" alt=""></li></ul><h3 id="3-切换进程"><a href="#3-切换进程" class="headerlink" title="3.切换进程"></a>3.切换进程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>因为进程的地址空间都是相互独立的，所以我们使用dd 0x400000之类的指令是没有意义的。因为我们不确定当前用户地址空间就是我们的目标进程地址空间。因此我们首先要切换到我们想查看的进程上下文。之后才能查看它私有的地址空间。如果不按这个规定的话，有可能得出的结果是很多?????</strong></p><ul><li><font color="#DC143C">.process [process address]:切换当前的进程空间。</font><br>  <img src="https://i.imgur.com/uT5OoeD.png" alt=""></li><li><font color="#DC143C">.context [页目录地址]：如果不使用任何参数，.context命令将显示当前页目录地址。页目录地址就是!process命令中显示的DirBase值。<strong>进程切换后，为了检测是否正确切换，可再用!peb命令检查当前进程的环境信息。</strong></font></li></ul><h3 id="4-加载dll"><a href="#4-加载dll" class="headerlink" title="4.加载dll"></a>4.加载dll</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.peb能显示当前进程所加载的dll，但是.dll能显示当前系统所在加载的dll。<br>    <img src="https://i.imgur.com/aBBULUI.png" alt=""></p><h2 id="线程篇"><a href="#线程篇" class="headerlink" title="线程篇"></a>线程篇</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令”~”能够进行线程相关的操作。不带任何参数的情况下，它列出当前调试进程的线程。<br>    <img src="https://i.imgur.com/QLRZoqm.png" alt=""> </p><h3 id="1-线程冰封"><a href="#1-线程冰封" class="headerlink" title="1.线程冰封"></a>1.线程冰封</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参数f与u分别代表freeze和unfress，前者是指冻住指定线程，后者将被冰冻线程解冻。  </p><ul><li>~2f：暂停该进程的2号线程</li><li>~2u：启动该进程的2号线程</li></ul><h3 id="2-线程切换"><a href="#2-线程切换" class="headerlink" title="2.线程切换"></a>2.线程切换</h3><ul><li>~线程编号（不是TID）：切换线程</li><li>!TEB:查看线程信息块</li><li>~ 线程号 s：在多线程间作切换，需使用~命令的s参数</li><li><strong>~~【线程ID】 s：　注意这个命令中的[]并非可选符，而是命令的一部分。</strong>例如命令：~~[11a0] s，它将当前线程切换到线程ID为0x11a0的线程。线程ID是系统维护的系统唯一的ID值。</li></ul><h3 id="3-遍历线程"><a href="#3-遍历线程" class="headerlink" title="3.遍历线程"></a>3.遍历线程</h3><ul><li>~*k:显示所有线程的栈信息<br>  <img src="https://i.imgur.com/PLIW1aN.png" alt=""></li><li>~*r:显示线程的寄存器信息</li><li>~<em>e -cmd：对线程执行操作：例如：~</em>e k;r就是对线程执行k和r操作。</li></ul><h3 id="查找句柄"><a href="#查找句柄" class="headerlink" title="查找句柄"></a>查找句柄</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用<strong>!handle</strong>来查找句柄。</p><ul><li>!handle &lt;句柄索引&gt;&lt;标志&gt;&lt;进程ID&gt;；句柄索引为0，代表输出所有句柄，为4是输出第一个句柄。<br>  <img src="https://i.imgur.com/hjkBWKp.png" alt=""></li><li>Object标明的是对象的地址。</li><li>Type标明的是句柄的类型。</li><li>HandleCount标明的是引用次数。</li><li>PointerCount标明的是指针指针引用次数。</li></ul><h3 id="异常与事件"><a href="#异常与事件" class="headerlink" title="异常与事件"></a>异常与事件</h3><ul><li>“.lastevent”:显示最近发生的调试事件</li><li>“.exr [mem]”：显示一个异常记录的详细信息<br>  <img src="https://i.imgur.com/VnOEiqm.png" alt=""></li><li>“.exr -1”:显示最近的一条异常信息，可以使用-1代替记录地址。<br>   <img src="https://i.imgur.com/uRnnzeK.png" alt=""></li><li>“!anaylze” :用于分析最近的异常事件，并显示分析结果。<ul><li>-v:显示详细信息。尤其适用于调试错误<br><img src="https://i.imgur.com/F1CAKdp.png" alt=""></li><li>-f:强制所有事件都当成异常来处理</li><li>-hang:这个选项很有用，对于遇到死锁的情况，它会分析原因。在内核环境中，它分析内核锁和DPC栈；在用户环境中，它分析线程的调用栈。用户环境中，调试器只会对当前线程进行分析，所以一定要将线程环境切换到最可能引起问题的那个线程中去，才有帮助。这个参数非常有用，当真的遇到死锁时，它可以救命（另一个分析死锁的有效命令是!locks）</li></ul></li><li>“!error”:此命令和VC里面内置的errlook工具类似。用来根据错误码，查看对应的可读错误信息。微软系统中常用的全局错误码有两套，一套是Win32错误码，通过函数GetLastError()获得的值；另一套是NTSTATUS值。!error命令对这二者都能支持。区别的方法，若错误码后面无参数1，则为Win32错误码；否则就是NTSTATUS错误码。</li><li>“!gle”:　此命令是Get Last Error的缩写。它调用Win32接口函数GetLastError()取得线程的错误值，并打印分析结果。如果带有-all选项，则针对当前进程的所有线程执行GetLastError()操作；否则仅针对当前线程。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;配置篇：&quot;&gt;&lt;a href=&quot;#配置篇：&quot; class=&quot;headerlink&quot; title=&quot;配置篇：&quot;&gt;&lt;/a&gt;配置篇：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1）安装WinDbg，如果要进入内核模式调试的话需要进行如下步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1）修改虚拟机C盘根目录下配置文件boot.ini&lt;/li&gt;
&lt;li&gt;2）修改虚拟机设置，添加一个串行串口&lt;/li&gt;
&lt;li&gt;3）在宿主主机启动winbdg，进入内核调试，配置如下&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/A4wPzBq.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;PS：如果遇到Fail Open \.\pipe\com_1，只需要在快捷方式后面添加&lt;strong&gt;“windbg -b -k com:pipe,port=\.\pipe\com_1,resets=0”&lt;/strong&gt;即可&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/8aGsnQY.png&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="windows内核" scheme="http://yoursite.com/categories/windows%E5%86%85%E6%A0%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>第三章：系统机制-陷阱分发</title>
    <link href="http://yoursite.com/2018/03/31/%E3%80%8AWindows%20Internals%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0_%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/03/31/《Windows Internals》第三章_系统机制/</id>
    <published>2018-03-31T07:02:11.000Z</published>
    <updated>2018-04-08T06:52:39.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-1：陷阱分发"><a href="#3-1：陷阱分发" class="headerlink" title="3.1：陷阱分发"></a>3.1：陷阱分发</h1><h3 id="第三部分：系统服务分发"><a href="#第三部分：系统服务分发" class="headerlink" title="第三部分：系统服务分发"></a>第三部分：系统服务分发</h3><h4 id="系统服务分发"><a href="#系统服务分发" class="headerlink" title="系统服务分发"></a>系统服务分发</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windows用于系统服务分发的指令取决于其执行时所在的处理器。<br><a id="more"></a></p><ul><li>在PentiumII之前的处理器，windows使用int 0x2E陷阱指令，使windows填充IDT（中断描述符表Interrupt Descriptor Table）中的2E表项，使其指向系统服务分发器。<strong>该陷阱导致线程由用户模式转换到内核模式，并且进入系统服务分发器。</strong>EAX指明了所请求的系统服务号，EDX指向的是调用者传递给系统服务的参数表</li><li>在PentiumII以后的处理器，使用的是sysenter指令，windows在引导的时候将<strong>内核服务分发器例程的地址保存在MSR（64位CPU寄存器，可以利用rdmsr或者wdmsr来读写）中</strong>，执行该指令后续操作和上面一致。最后利用sysexit返回用户模式。<br>  <img src="https://i.imgur.com/53Yv1LF.png" alt=""></li><li>X64使用syscall指令，将系统调用号保存在eax中，前四个参数放在寄存器（rcx/rdx/r8/r9）中，剩下的参数在栈中</li><li>IA64使用epc指令</li></ul><h4 id="内核模式下的系统分发"><a href="#内核模式下的系统分发" class="headerlink" title="内核模式下的系统分发"></a>内核模式下的系统分发</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在windows内核模式下，CPU不需要进行中断或者syscall了，因为此时CPU已经运行在特权模式下了，只需要像普通的例程调用一样就好，问题是对于NT的函数大多数没有被导出，无法直接调用。但如果直接像调用API一般直接调用NtOpenProcess之类的系统服务函数时，内核保存的原先模式值仍然是用户模式（进内核之前当然是用户模式咯~），但又检测到传递来的地址是一个内核模式地址（因为在当前内核模式下调用），于是会导致调用失败（STATUS_ACCESS_VIOLATION）。<strong>必须使用ZT函数</strong>因为他们已经被文档化了。请见博客：<a href="https://findream.github.io/2018/01/23/%E5%86%85%E6%A0%B8Nt%E5%92%8CZw%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB/" target="_blank" rel="external">https://findream.github.io/2018/01/23/%E5%86%85%E6%A0%B8Nt%E5%92%8CZw%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB/</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子系统DLL<strong>调用Ntdll.dll中函数（系统调用根本执行的函数）</strong>来实现已经文档化的函数，但是windows USER和GDI函数例外，因为这些函数根本不涉及Ntdll.dll，系统分发指令在user32.dll或者GDI.dll中实现。</p><ul><li>windows内核API调用<ul><li>1）windows应用程序调用Fun()</li><li>2) 调用kernelbase.dll中的Fun()，这是实现调用的核心所在</li><li>3）调用Ntdll.dll中的Fun(),这个Fun去引发系统服务的陷阱，进入内核模式并且把Fun的系统服务号传递给系统服务分发器</li><li>4）系统服务分发器（Ntoskrnl.exe:KiSystemService()）调用Fun执行</li></ul></li><li>USER或者GDI函数<ul><li>1）应用程序中调用USER或者GDI函数</li><li>2）调用User32.dll或者GDI.dll的Fun(),通过systementer进入内核模式，</li><li>3）调用Ntoskrnl.exe的KiSystemService指向Win32k.sys中的服务入口点。</li><li>4）执行服务，并返回</li></ul></li></ul><p>Ring3 —&gt; Ring0 的系统调用：<br>   Kernel32.dll（API）—&gt;ntdll.dll（Nt/Zw）—&gt;用户模式转内核模式—&gt;Ntoskrnl.exe(NT)—&gt;完成I/O请求（原路返回）<br>Ring0 —&gt; Ring0 的系统调用：<br>   Ntoskrnl.exe（Zw）—&gt;Ntoskrnl.exe（Nt）<br>参考文献：<br>windows internals<br><a href="https://www.cnblogs.com/uAreKongqi/p/6597701.html" target="_blank" rel="external">https://www.cnblogs.com/uAreKongqi/p/6597701.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;3-1：陷阱分发&quot;&gt;&lt;a href=&quot;#3-1：陷阱分发&quot; class=&quot;headerlink&quot; title=&quot;3.1：陷阱分发&quot;&gt;&lt;/a&gt;3.1：陷阱分发&lt;/h1&gt;&lt;h3 id=&quot;第三部分：系统服务分发&quot;&gt;&lt;a href=&quot;#第三部分：系统服务分发&quot; class=&quot;headerlink&quot; title=&quot;第三部分：系统服务分发&quot;&gt;&lt;/a&gt;第三部分：系统服务分发&lt;/h3&gt;&lt;h4 id=&quot;系统服务分发&quot;&gt;&lt;a href=&quot;#系统服务分发&quot; class=&quot;headerlink&quot; title=&quot;系统服务分发&quot;&gt;&lt;/a&gt;系统服务分发&lt;/h4&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;windows用于系统服务分发的指令取决于其执行时所在的处理器。&lt;br&gt;
    
    </summary>
    
      <category term="windows系统" scheme="http://yoursite.com/categories/windows%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>C++Primer 第四章：运算符</title>
    <link href="http://yoursite.com/2018/03/30/C++%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2018/03/30/C++第四章_运算符/</id>
    <published>2018-03-30T07:02:11.000Z</published>
    <updated>2018-04-02T07:43:52.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h2><h3 id="4-1-2运算符优先级"><a href="#4-1-2运算符优先级" class="headerlink" title="4.1.2运算符优先级"></a>4.1.2运算符优先级</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算数运算符&gt;关系运算符&gt;逻辑运算符。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">if</span><span class="params">(i!=j&lt;k)</span></span></div><div class="line"><span class="comment">//先比较j和k的大小，计算出来的bool值和i比较是否相等，不相等返回真。</span></div></pre></td></tr></table></figure></p><a id="more"></a><h3 id="4-1-3求值顺序"><a href="#4-1-3求值顺序" class="headerlink" title="4.1.3求值顺序"></a>4.1.3求值顺序</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有四种运算符明确了求值顺序，逻辑与，逻辑或，条件运算符，逗号运算符。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布尔运算符的计算步骤：bool—–&gt; int —–&gt;bool。例如以下代码，首先bool类型被提升到int类型，然后判断是否非0，非0，然后转化为bool类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> a=<span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> b =-a;</div><div class="line"><span class="keyword">bool</span> a=b;</div><div class="line"><span class="comment">//结果a=1</span></div></pre></td></tr></table></figure></p><h2 id="4-3-逻辑和关系运算符"><a href="#4-3-逻辑和关系运算符" class="headerlink" title="4.3 逻辑和关系运算符"></a>4.3 逻辑和关系运算符</h2><h3 id="逻辑与，逻辑或运算符"><a href="#逻辑与，逻辑或运算符" class="headerlink" title="逻辑与，逻辑或运算符"></a>逻辑与，逻辑或运算符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遵循短路求值的策略，一般要先求表达式左侧的，如果成立再求右侧的</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系运算符比较对象并返回bool值，如见下面例子：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int <span class="built_in">i</span>,<span class="built_in">j</span>,k;</div><div class="line"><span class="keyword">if</span>(<span class="built_in">i</span>&lt;<span class="built_in">j</span>&lt;k)</div><div class="line">&#123;//先用i和j比较返回的bool值然后和k比较&#125;</div></pre></td></tr></table></figure></p><h2 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;赋值运算符左侧必须是一个可以修改的对象。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化列表转换（窄化转化），是C11新引入的，目的是使转化更加严格。初始化列表需要遵循以下两个原则：</p><ul><li>1）转化的元素只有一个</li><li>2）<strong>使高精度转化为低精度（精度缺失）</strong><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int k<span class="comment">;</span></div><div class="line"><span class="attribute">k</span>=<span class="number">3.22222</span><span class="comment">;    //正确，转化为3，强制类型转化</span></div><div class="line"><span class="attribute">k</span>=&#123;<span class="number">3.243434</span>e&#125;<span class="comment">;  //错误</span></div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;赋值运算符优先级低，举如下例子：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">if</span><span class="params">(p=getchar()</span></span>!=<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line"><span class="comment">//永远为真，因为有限执行的是getar()!=0,然后是赋值语句，永真</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//应该修改为</span></div><div class="line"><span class="function"><span class="title">if</span><span class="params">((p=getchar()</span></span>)!=<span class="number">0</span>)</div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure></p><ul><li>练习4.14：if(42=i)和if(i=42)执行后发生什么？<ul><li>答：if(42=i)是变量赋值给常量，永假;if(i=42)永真</li></ul></li><li>练习4.15：double dval；int ival；int *pi；dval=ival=pi=0;为什么错误？<ul><li>答：double 可以转化为int ，但是int*不能隐式转化为int或者double，应该修改为<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ival</span>=dval=*pi<span class="comment">;</span></div></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4-5-递增和递减"><a href="#4-5-递增和递减" class="headerlink" title="4.5 递增和递减"></a>4.5 递增和递减</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前置版本和后置版本在不使用迭代器数值的时候在表现上没有太大区别，在内存中的区别主要体现在：前置版本只需要把值+1后直接返回，而后置版本在+1后还需要返回到原始数值（即需要将原始数值保存下来以便返回这个未修改的数值)。<strong>故：建议使用递增递减的前置版本（节省空间）</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后置递增运算符的优先级大于解引用的优先级，<strong>所以：<em>pbeg++等价于</em>(pbeg++)</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;谨防产生未定义的行为，对于一条表达式改变了某个运算对象的值，另一个恰好又用到了这个对象的值，如下：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*beg=toupper<span class="comment">(*beg++)</span>；<span class="comment">//赋值运算两边都用到了同一个变量，且右侧的对象被改变了</span></div><div class="line"><span class="comment">//等价于多种可能：</span></div><div class="line"><span class="comment">(*beg)</span>=tooupper<span class="comment">(*beg)</span>;</div><div class="line"><span class="comment">(*beg++)</span>=tooupper<span class="comment">(*beg)</span>;</div></pre></td></tr></table></figure></p><h2 id="4-6-成员访问运算符"><a href="#4-6-成员访问运算符" class="headerlink" title="4.6 成员访问运算符"></a>4.6 成员访问运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;箭头运算符带有解引用的功能<strong>即：Ptr-&gt;mem 等价于 (*Ptr).mem</strong>，因为<strong>解引用运算符的优先级低于点运算符，所以使用点运算符的时候必须要在解引用运算符两侧加上括号</strong></p><h2 id="4-8-位运算符"><a href="#4-8-位运算符" class="headerlink" title="4.8 位运算符"></a>4.8 位运算符</h2><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><ul><li>左移位运算符：在右侧插入0的二进制位</li><li>右移位运算符：视情况而定：如果是无符号数则在左侧插入值为0的二进制位，如果是有符号数，则在左侧插入符号位的副本（负数）或者值为0的二进制位。</li></ul><h2 id="4-9-sizeof运算符"><a href="#4-9-sizeof运算符" class="headerlink" title="4.9 sizeof运算符"></a>4.9 sizeof运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof 运算符可用于获取类、结构、共用体和其他用户自定义数据类型的大小，sizeof返回的是表达式结果的值，并不是实际计算运算结果的值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sizeof</span>(p);    <span class="comment">//指针所占用的空间的大小</span></div><div class="line"><span class="keyword">sizeof</span>(*p);    <span class="comment">//指针所指向的对象所占用的空间的大小</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof的结果部分依赖于其作用的类型</p><ul><li>对于解引用指针执行sizeof得到指针指向对象所占用的空间大小，不需要指针有效</li><li>对于数组执行sizeof得到的是整个数组所占据的大小，而并不是指针</li></ul><h2 id="4-10-逗号运算符"><a href="#4-10-逗号运算符" class="headerlink" title="4.10 逗号运算符"></a>4.10 逗号运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;逗号运算符的作用是依次执行一系列的运算，取最后一次运算结果作为表达式的结果。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> a=<span class="number">1</span>,v=<span class="number">2</span>,c=<span class="number">3</span>,d=<span class="number">4</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,a+d,v++);  <span class="comment">//结果是5</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="4-11类型转换"><a href="#4-11类型转换" class="headerlink" title="4.11类型转换"></a>4.11类型转换</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;隐式转换：如果两个类型不同的值运算，编译器先是根据转换规则，将运算对象统一后在求值。</p><h3 id="4-11-1-算术转换"><a href="#4-11-1-算术转换" class="headerlink" title="4.11.1 算术转换"></a>4.11.1 算术转换</h3><ul><li>小数据类型转化为大数据类型</li><li>int类型转化为unsigned int</li><li>赋值运算符类型取决于运算符左侧的数据类型<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">3.14+'a';       <span class="string">//</span>字符--&gt;int<span class="params">---</span>&gt;long  double</div><div class="line">flag =dval      <span class="string">//</span>取决于dval是否为0</div><div class="line">ival=dval       <span class="string">//dval</span>切去小数位，保留整数</div><div class="line">ival+usval      <span class="string">//int</span> <span class="params">---</span>&gt;unsigned int</div></pre></td></tr></table></figure></li></ul><h3 id="4-11-2-其他隐式类型转化；"><a href="#4-11-2-其他隐式类型转化；" class="headerlink" title="4.11.2 其他隐式类型转化；"></a>4.11.2 其他隐式类型转化；</h3><ul><li>数组转化为指针</li><li>指针的转化</li><li>转化为布尔类型</li><li>转化为常量<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;j = i;    <span class="comment">//对变量值转化为常量的引用</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *j = &amp;i;   <span class="comment">//将变量的地址转化为const的地址</span></div></pre></td></tr></table></figure></li></ul><h3 id="4-11-3-显式转换"><a href="#4-11-3-显式转换" class="headerlink" title="4.11.3 显式转换"></a>4.11.3 显式转换</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;4-1-基础&quot;&gt;&lt;a href=&quot;#4-1-基础&quot; class=&quot;headerlink&quot; title=&quot;4.1 基础&quot;&gt;&lt;/a&gt;4.1 基础&lt;/h2&gt;&lt;h3 id=&quot;4-1-2运算符优先级&quot;&gt;&lt;a href=&quot;#4-1-2运算符优先级&quot; class=&quot;headerlink&quot; title=&quot;4.1.2运算符优先级&quot;&gt;&lt;/a&gt;4.1.2运算符优先级&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;算数运算符&amp;gt;关系运算符&amp;gt;逻辑运算符。&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(i!=j&amp;lt;k)&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//先比较j和k的大小，计算出来的bool值和i比较是否相等，不相等返回真。&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
  </entry>
  
</feed>
