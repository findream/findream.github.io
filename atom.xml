<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>findream&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-09T09:26:59.012Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>findream</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>注册表</title>
    <link href="http://yoursite.com/2018/06/04/%E3%80%8AWindows%20Internals%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/06/04/《Windows Internals》第四章_注册表/</id>
    <published>2018-06-04T07:02:11.000Z</published>
    <updated>2018-06-09T09:26:59.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注册表用法"><a href="#注册表用法" class="headerlink" title="注册表用法"></a>注册表用法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册表的配置数据主要在四个时间点被修改。</p><ul><li>由于引导配置数据库(BCD)存在于注册表储巢中，所以在初始化引导过程中，引导加载器需要读入配置信息和引导设备驱动程序的列表。</li><li>在内核引导的过程中，内核要读取系统的相关设置信息(存放在注册表中)，这些信息包含了加载的驱动程序，系统组件，已经系统行为的配置。</li><li>在windows登录过程中，Explorer和windows组件读取用户配置信息。</li><li>应用程序启动过程中，读取系统全局配置信息。</li><li>其他时间：在调用API修改注册表的时候，注册表也提供异步回调机制，这是优先接收注册表变化的方法。<strong>系统不建议使用轮询的方法检测注册表的修改。</strong><a id="more"></a><h2 id="注册表的数据类型"><a href="#注册表的数据类型" class="headerlink" title="注册表的数据类型"></a>注册表的数据类型</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册表的结构类似于一个文件系统的结构。只不过注册表包含的是键和值，一般的我们把键看做目录，值看做文件。例如\trade\mark中，trade表示的是键，mark表示的是值。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册表的值有多种数据类型，常见的数据类型是REG_DWORD(存储大部分的整形和布尔类型)，REG_BINARY(存储的是超过32位的整数类型，例如加密口令)，REG_SZ(存储的是字符串)。<strong>其中还有特殊的是REG_LINK，</strong>REG_LINK存储的是一个链接类型，标明这个数据类型可以让一个键指向另一个键。例如\ROOT1\LINK指向的是ROOT2\REGKEY，其中REGKEY存储的值是REGVALUE，则对于REGVALUE有两个路径可以访问：\ROOT1\LINK\REGVALUE或者\ROOT2\REGKEY\REGVALUE。<strong>windows中六个注册表根有三个是链接，他们指向的是三个非连接的跟腱中的子健。</strong></p><h2 id="注册表的逻辑结构"><a href="#注册表的逻辑结构" class="headerlink" title="注册表的逻辑结构"></a>注册表的逻辑结构</h2><h3 id="HKEY-CURRENT-USER"><a href="#HKEY-CURRENT-USER" class="headerlink" title="HKEY_CURRENT_USER:"></a>HKEY_CURRENT_USER:</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存储和当前登录用户相关的数据(包含用户参数和软件配置信息)，指向当前登录用户的用户轮廓，位于磁盘下的\Users\用户名\Ntuser.dat文件中。是HKEY_USERS下对应的当前登录用户的子健。**当一个用户登录系统，首先会创建HKCU，然后把HKCU映射到HKEY_USERS/<currentuser>中<br>     <img src="https://i.imgur.com/Ej3n9P0.png" alt=""><br>     <img src="https://i.imgur.com/8yfnMK3.png" alt=""><br>     <img src="https://i.imgur.com/nUG2rw4.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是关于HKEY_CURRENT_USER的子健信息。<br>    <img src="https://i.imgur.com/4Ffc53E.png" alt=""></currentuser></p><h3 id="HKEY-USERS："><a href="#HKEY-USERS：" class="headerlink" title="HKEY_USERS："></a>HKEY_USERS：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含所有已加载用户轮廓的子健，他不是一个链接。但是他包含了一个名为HKU.DEFAULTD的链接。当有新用户登录的时候，系统依赖Users\Default的轮廓为该用户创建一个新的轮廓。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册表HKLM\Software\Microsoft\Windows Nt\CurrentVersion\ProfileList\ProfilesDirectory中的ProfilesDirectory保存的是系统中存在的用户轮廓列表。每个轮廓存放在ProfileList键下面。<br>     <img src="https://i.imgur.com/FaGauvF.png" alt=""><br>     <img src="https://i.imgur.com/RwudfZI.png" alt=""><br>     <img src="https://i.imgur.com/qn84dGf.png" alt=""></p><h3 id="HKEY-CLASS-ROOT："><a href="#HKEY-CLASS-ROOT：" class="headerlink" title="HKEY_CLASS_ROOT："></a>HKEY_CLASS_ROOT：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含的是文件关联和COM注册信息以及UAC虚拟化注册表根。<strong>其中HKCR下的根键保存的是文件拓展名关联，UAC虚拟化注册表位于VirtualStore键下面，其他键包含的是注册在系统中的COM对象的详细配置信息</strong><br>    <img src="https://i.imgur.com/zVBGxJo.png" alt=""><br>    <img src="https://i.imgur.com/5nvD88p.png" alt=""><br>    <img src="https://i.imgur.com/b6R9joX.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HKCR是由HKLM\SOFTWARE\Classes(系统全局)和HKEY_USERS\<sid>\SOFTWARE\Classes(用户)组合的视图。将用户注册表信息和系统全局注册表信息分开，保证了系统的安全性，避免非特权用户访问并修改系统全局信息。</sid></p><h3 id="HKEY-LOCAL-MACHINE"><a href="#HKEY-LOCAL-MACHINE" class="headerlink" title="HKEY_LOCAL_MACHINE:"></a>HKEY_LOCAL_MACHINE:</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包含了机器的全局设置，包括了BCD00000000,COMPONENTS,HARDWARE,SAM,SECURITY,SOFTWARE,SYSTEM,该注册表不是一个链接。<br>    <img src="https://i.imgur.com/CdpuB0E.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HKLM\BCD0000000保存的是引导配置数据库，这是作为一个注册表储巢加载进来的。<br>     <img src="https://i.imgur.com/vullJ3m.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HKLM\CONPONENTS保存的是关于CBS(基于组件的服务)，当系统组件需要更新，安装或者卸载的时候，保存在这个键下的信息将要被用到。当然为了优化系统资源，CBS栈在服务一个请求的时候只是被动态的加载到系统。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\HKLM\HARDWARE维护了当前系统中的遗留硬件，以及一些硬件设备到其驱动程序的映射关系描述信息。<br>     <img src="https://i.imgur.com/GOH6nDp.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HKLM\SAM存放的是用户账户和组的信息，SAM的安全描述符一般被设置成管理员无法访问(system可以访问)<br>     <img src="https://i.imgur.com/cSYnQsX.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HKLM\SECURITY存放的是系统全局的安全设置和用户权限分配，HKLM\SAM是HKLM\SECURITY\SAM下的SERURITY子键，默认情况下无法查看HKLM\SECURITY和HKLM\SAM的内容<br>     <img src="https://i.imgur.com/jhyfMBE.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HKLM\OTFWARE存放是系统全局配置信息和第三方应用程序的全局设置。<br>     <img src="https://i.imgur.com/bZGzLA6.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HKLM\SYSTEM保存的是引导系统所需要的全局信息，例如下载的驱动程序或者启动的服务。这些信息对于系统的启动十分重要。<br>     <img src="https://i.imgur.com/VYoWIov.png" alt=""></p><h3 id="HKEY-CURRENT-CONFIG"><a href="#HKEY-CURRENT-CONFIG" class="headerlink" title="HKEY_CURRENT_CONFIG:"></a>HKEY_CURRENT_CONFIG:</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保存的是当前的硬件配置信息，是HKLM\SYSTEM\CurrentControlSet\Hardware Profiles\Current下的子健，</p><h3 id="HKEY-PERFORMACHE-DATA"><a href="#HKEY-PERFORMACHE-DATA" class="headerlink" title="HKEY_PERFORMACHE_DATA:"></a>HKEY_PERFORMACHE_DATA:</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该项是一个性能计数器，不是一个链接。在注册表编辑器中无法找到，只有试用RegQueryValueEx函数去获取性能信息。<strong>性能信息并不是保存在注册表中，RegQueryValueEx函数只是利用该键获得从性能数据提供者那里提供的信息</strong></p><h2 id="事务性注册表"><a href="#事务性注册表" class="headerlink" title="事务性注册表"></a>事务性注册表</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>事务性注册表的封闭性：</strong>当使用RegCreateKeyTransacted以实物的方式创建一个注册表的时候，之后的所有操作必须是以事物方式运行，而且此过程是对事物外部不可见。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>事物的隔离性：</strong>事物是相互隔离的，在一个事物内部所做的修改，在该事物被提交之前，在该事物外部是不可见的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>事物的低优先级：</strong>一个非事物任务的写会导致事物内部的写操作失败。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>提交生效：</strong>事物只有提交之后才会立即生效。</p><h2 id="注册表的内部机理"><a href="#注册表的内部机理" class="headerlink" title="注册表的内部机理"></a>注册表的内部机理</h2><h3 id="储巢"><a href="#储巢" class="headerlink" title="储巢"></a>储巢</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册表是一组称为储巢的独立文件，每一个储巢包含了一个注册表数，有一个键作为该树的根，子键或者值存储在根的下面，但是注册表编辑器所显示的根键和储巢里面的根键不是相互关联的。<strong>除了用户轮廓，其他轮廓路径都被编码进了配置管理器中，当加载储巢的时候，配置管理器会在HKLM\SYSTEM\CurrentControlSet\Control\Hivelist子键下记录每个储巢的路径。</strong>并将这些储巢链接起来，以便建立其注册表结构。<br>    <img src="https://i.imgur.com/qPYSrU9.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下图是注册表路径和储巢路径对应图，其中有一项是易失储巢。标明这个储巢是易变的，并没有对应的文件，由操作系统在内存中加载并且管理。其中著名的例子就是HKLM\HARDWARE.这个储巢保存的系统物理设备和设备资源的信息。<strong>每次引导的时候会进行资源分配和硬件检测。</strong><br>    <img src="https://i.imgur.com/HvKm3TD.png" alt=""></p><h3 id="注册表符号链接"><a href="#注册表符号链接" class="headerlink" title="注册表符号链接"></a>注册表符号链接</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册表符号链接一个种使配置管理器将键与键链接起来的<strong>特殊键，</strong>符号链接在外部是利用CreateRegKey函数指定REG_GREATE_LINK标志创建起来的，</p><h3 id="储巢结构"><a href="#储巢结构" class="headerlink" title="储巢结构"></a>储巢结构</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们从全局来把握一下注册表的储巢结构，在了解储巢结构之前，我们需要了解一下几个概念。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>块：</strong>配置管理器从逻辑上将一个储巢分成一些称为块的分配单元。每个块的大小是4096字节。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>基本块：</strong>一个储巢的第一个块称为基本块，基本块包含了有关该储巢的全局信息。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>巢室：</strong>一个巢室包含了所存储的注册表键的基本数据结构，之所以称为巢室，是因为巢室是存储注册表键的内容的容器。一个巢室包含了一个键，一个值，一个安全描述符，一列子键，一列子值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>巢箱：</strong>新巢室正好拓展到下一个块或者页面的大小，说白了就是巢室的箱子(多个巢室组成了巢箱)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>巢室索引：</strong> 详见巢室映射表<br>    <img src="https://i.imgur.com/9GzNlgc.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;巢室开始的四个字节表示的是该巢室数据类型。一共有五种巢室的基本数据类型：键巢室，值巢室，子键列表巢室，值列表巢室，安全描述符巢室。</p><ul><li>键巢室：包含了一个注册表键的巢室</li><li>值巢室：包含了一个键的值得巢室</li><li>子键列表巢室：包含了<strong>许多子键巢室的索引</strong>的巢室</li><li>值列表巢室：包含了<strong>许多值巢室的索引</strong>的巢室，是父键的所有值</li><li>安全描述符巢室：包含了一个安全描述符的巢室<br>   <img src="https://i.imgur.com/W352lyG.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>windows选择利用巢箱的结构来拓展巢室</strong>，当一个巢室要被添加到储巢的时候，系统创建一个巢箱来容纳巢室，这导致了系统分配和释放巢箱的频率比使用巢室要慢的多。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置管理器会将储巢整个读入，同时也会象磁盘碎片管理的方式，合并诸多空巢箱，当储巢尾部的巢箱变为空闲的时候才会缩短该储巢。</li></ul><h3 id="巢室映射表"><a href="#巢室映射表" class="headerlink" title="巢室映射表"></a>巢室映射表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册表被映射如内存是不连续的，配置管理器采用的是和虚拟内存映射到物理内存地址的策略。<strong>和windows的分段内存管理机制一样</strong>，windows使用连续的内存代表一个巢箱，这样一个巢箱内部所有的巢室都出现在一个视图中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windows使用<strong>巢室索引</strong>来实现映射策略，巢室索引有三个域：目录索引，表索引，字节偏移。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【重点】①windows将目录索引解释成一个巢室的映射表目录的索引，也就是说根据这个索引才能找到巢室映射目录表的地址。②巢室映射表目录有1024个，每个目录项指向的是一个映射表，利用第二个域–表索引，根据巢室映射表找到巢室所在巢箱的偏移，③根据第三个域找到巢室的偏移。</p><h3 id="注册表名字空间和操作"><a href="#注册表名字空间和操作" class="headerlink" title="注册表名字空间和操作"></a>注册表名字空间和操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>键对象：</strong>当打开或创建一个注册表键的时候，对象管理器会给应用程序分配一个句柄让程序通过此句柄引用该键。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>键控制块：</strong>每次打开注册表键的时候，配置管理器也会分配一个键控制块，用于保存键名称，巢室索引，和一个标志(表示键的句柄被关闭后，配置管理器是否应该删除该键句柄所引用的键巢室)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系：键对象指向他对应的键控制块，如果两个应用程序打开一个注册表键的时候，会产生两个不同的键对象，这两个键对象指向同一个键控制块，(因为键控制块包含了键的名称等唯一信息)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用键控制块的引用个数来决定是否删除该键控制块，如果引用计数为0的时候，说明这个键控制块不再被需要了。</p><h3 id="【实验】查看键控制块"><a href="#【实验】查看键控制块" class="headerlink" title="【实验】查看键控制块"></a>【实验】查看键控制块</h3><ul><li>!reg openkeys:查看系统中已经被分配的键控制块。<br>  <img src="https://i.imgur.com/QeXMV6u.png" alt=""></li><li>!reg findkcb:查看一个已经打开的kcb<br>  <img src="https://i.imgur.com/vH16dDH.png" alt=""></li><li>!reg kcb:查看具体的kcb内容<br>  <img src="https://i.imgur.com/Q9CaD3C.png" alt=""></li></ul><h3 id="稳定可靠的存储"><a href="#稳定可靠的存储" class="headerlink" title="稳定可靠的存储"></a>稳定可靠的存储</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用双日志方案，将脏数据累加写入同一个日志文件，如果不发生错误，只写入某一个文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于写脏数据到日志文件，使用了双序列号模式，延时写出器首先更新日志文件一个序列号，然后在写入脏数据，此时发生意外，系统在引导时，配置管理器肯定会注意到序列号不一致，触发储巢回滚。如果写入日志成功，在写另一个序列号。保证两个序列号一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;注册表用法&quot;&gt;&lt;a href=&quot;#注册表用法&quot; class=&quot;headerlink&quot; title=&quot;注册表用法&quot;&gt;&lt;/a&gt;注册表用法&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;注册表的配置数据主要在四个时间点被修改。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于引导配置数据库(BCD)存在于注册表储巢中，所以在初始化引导过程中，引导加载器需要读入配置信息和引导设备驱动程序的列表。&lt;/li&gt;
&lt;li&gt;在内核引导的过程中，内核要读取系统的相关设置信息(存放在注册表中)，这些信息包含了加载的驱动程序，系统组件，已经系统行为的配置。&lt;/li&gt;
&lt;li&gt;在windows登录过程中，Explorer和windows组件读取用户配置信息。&lt;/li&gt;
&lt;li&gt;应用程序启动过程中，读取系统全局配置信息。&lt;/li&gt;
&lt;li&gt;其他时间：在调用API修改注册表的时候，注册表也提供异步回调机制，这是优先接收注册表变化的方法。&lt;strong&gt;系统不建议使用轮询的方法检测注册表的修改。&lt;/strong&gt;
    
    </summary>
    
      <category term="windows系统" scheme="http://yoursite.com/categories/windows%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>GCTF解析</title>
    <link href="http://yoursite.com/2018/05/26/GCTF/"/>
    <id>http://yoursite.com/2018/05/26/GCTF/</id>
    <published>2018-05-26T06:02:11.000Z</published>
    <updated>2018-05-26T09:22:36.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h1><h2 id="Hackme"><a href="#Hackme" class="headerlink" title="Hackme"></a>Hackme</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个ELF的逆向题，IDA打开，发现流程如下：输入字符串，然后经过一个函数的加密，利用这个函数返回出来的数值，对该数值以22取余数，得到索引，得到Hex数组里面的数据，然后经过第一个循环得到V16，再用V16和输入的字符串异或，然后把结果和Hex比较即可。<a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">__int64 __<span class="function">fastcall <span class="title">sub_400F8E</span><span class="params">(__int64 a1, __int64 a2)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  __int64 v2; <span class="comment">// rdx</span></div><div class="line">  __int64 v3; <span class="comment">// rcx</span></div><div class="line">  __int64 v4; <span class="comment">// r8</span></div><div class="line">  __int64 v5; <span class="comment">// r9</span></div><div class="line">  <span class="keyword">int</span> v6; <span class="comment">// eax</span></div><div class="line">  <span class="keyword">char</span> InputString[<span class="number">136</span>]; <span class="comment">// [rsp+10h] [rbp-B0h]</span></div><div class="line">  <span class="keyword">int</span> v9; <span class="comment">// [rsp+98h] [rbp-28h]</span></div><div class="line">  <span class="keyword">char</span> v10; <span class="comment">// [rsp+9Fh] [rbp-21h]</span></div><div class="line">  <span class="keyword">int</span> v11; <span class="comment">// [rsp+A0h] [rbp-20h]</span></div><div class="line">  <span class="keyword">unsigned</span> __int8 flag; <span class="comment">// [rsp+A6h] [rbp-1Ah]</span></div><div class="line">  <span class="keyword">char</span> Hex; <span class="comment">// [rsp+A7h] [rbp-19h]</span></div><div class="line">  <span class="keyword">int</span> v14; <span class="comment">// [rsp+A8h] [rbp-18h]</span></div><div class="line">  <span class="keyword">int</span> v15; <span class="comment">// [rsp+ACh] [rbp-14h]</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v16; <span class="comment">// [rsp+B0h] [rbp-10h]</span></div><div class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+B4h] [rbp-Ch]</span></div><div class="line">  _BOOL4 v18; <span class="comment">// [rsp+B8h] [rbp-8h]</span></div><div class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+BCh] [rbp-4h]</span></div><div class="line">  Printf((<span class="keyword">unsigned</span> __int64)<span class="string">"Give me the password: "</span>);</div><div class="line">  <span class="built_in">scanf</span>((__int64)<span class="string">"%s"</span>);</div><div class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; InputString[i]; ++i )</div><div class="line">    ;</div><div class="line">  v18 = i == <span class="number">22</span>;</div><div class="line">  v17 = <span class="number">10</span>;</div><div class="line">  <span class="keyword">do</span></div><div class="line">  &#123;</div><div class="line">    v6 = sub_406D90((__int64)<span class="string">"%s"</span>, (__int64)InputString, v2, v3, v4, v5);<span class="comment">// 固定数据</span></div><div class="line">    v3 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(v6 % <span class="number">22</span>);               <span class="comment">// 对22取余</span></div><div class="line">    v14 = v6 % <span class="number">22</span>;                              <span class="comment">// 对22取余</span></div><div class="line">    v16 = <span class="number">0</span>;                                    <span class="comment">// 初始化为0</span></div><div class="line">    Hex = Hex_Arr[v6 % <span class="number">22</span>];                     <span class="comment">// 取16进制数组里面的值</span></div><div class="line">    flag = InputString[v6 % <span class="number">22</span>];</div><div class="line">    v11 = v6 % <span class="number">22</span> + <span class="number">1</span>;                          <span class="comment">// 对22取余后+1，作为循环控制条件</span></div><div class="line">    v15 = <span class="number">0</span>;                                    <span class="comment">// 从0开始计数</span></div><div class="line">    <span class="keyword">while</span> ( v15 &lt; v11 )                         <span class="comment">// 数值运算</span></div><div class="line">    &#123;</div><div class="line">      ++v15;</div><div class="line">      v16 = <span class="number">1828812941</span> * v16 + <span class="number">12345</span>;</div><div class="line">    &#125;</div><div class="line">    v2 = v16;                                   <span class="comment">// 运算结果交给V2</span></div><div class="line">    v10 = v16 ^ flag;</div><div class="line">    <span class="keyword">if</span> ( Hex != ((<span class="keyword">unsigned</span> __int8)v16 ^ flag) ) <span class="comment">// 运算十次，只要相等就行了</span></div><div class="line">      v18 = <span class="number">0</span>;                                  <span class="comment">// 关于写注册机：根据上面的flag，我们知道：只需要Hex==v16^flag就行，</span></div><div class="line">                                                <span class="comment">// 由于异或是可逆的，所以flag=v16^Hex</span></div><div class="line">    --v17;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> ( v17 );                                <span class="comment">// 十次循环</span></div><div class="line">  <span class="keyword">if</span> ( v18 )</div><div class="line">    v9 = Printf((<span class="keyword">unsigned</span> __int64)<span class="string">"Congras\n"</span>);</div><div class="line">  <span class="keyword">else</span></div><div class="line">    v9 = Printf((<span class="keyword">unsigned</span> __int64)<span class="string">"Oh no!\n"</span>);</div><div class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sub_406D90返回的结果却是很麻烦，可以推测他应该是一个固定的数据。我们数了一下，Hex_Arr数组的长度是22，然后又对22取余，我们可以推测出，这应该是一个长度转化的函数。写出注册机：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">char *Hex_Arr="<span class="tag">\<span class="name">x</span></span>5f<span class="tag">\<span class="name">xf</span></span>2<span class="tag">\<span class="name">x</span></span>5e<span class="tag">\<span class="name">x</span></span>8b<span class="tag">\<span class="name">x</span></span>4e<span class="tag">\<span class="name">x</span></span>0e<span class="tag">\<span class="name">xa</span></span>3<span class="tag">\<span class="name">xaa</span></span><span class="tag">\<span class="name">xc</span></span>7<span class="tag">\<span class="name">x</span></span>93<span class="tag">\<span class="name">x</span></span>81<span class="tag">\<span class="name">x</span></span>3d<span class="tag">\<span class="name">x</span></span>5f<span class="tag">\<span class="name">x</span></span>74<span class="tag">\<span class="name">xa</span></span>3<span class="tag">\<span class="name">x</span></span>09"</div><div class="line">        "<span class="tag">\<span class="name">x</span></span>91<span class="tag">\<span class="name">x</span></span>2b<span class="tag">\<span class="name">x</span></span>49<span class="tag">\<span class="name">x</span></span>28<span class="tag">\<span class="name">x</span></span>93<span class="tag">\<span class="name">x</span></span>67"; </div><div class="line">int main(int agrv,char* agrc[])</div><div class="line">&#123;</div><div class="line">int i;</div><div class="line">for(i=0;i&lt;22;i++)</div><div class="line">&#123;</div><div class="line">char Hex=Hex_Arr[i];</div><div class="line">int v11=i+1;</div><div class="line">int v15=0;</div><div class="line">int v16=0;</div><div class="line">char flag;</div><div class="line">while ( v15 &lt; v11 )                         // 数值运算</div><div class="line">    &#123;</div><div class="line">      ++v15;</div><div class="line">      v16 = 1828812941 * v16 + 12345;</div><div class="line">    &#125;</div><div class="line">flag=char(v16)^Hex</div><div class="line">    printf("<span class="comment">%c",);</span></div><div class="line">&#125;</div><div class="line">printf("<span class="tag">\<span class="name">n</span></span>");</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="test-pyc"><a href="#test-pyc" class="headerlink" title="test.pyc"></a>test.pyc</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分别利用<a href="http://tools.bugscaner.com/decompyle/和https://tool.lu/pyc这两个网站对pyc文件进行反编译，得到如下效果。我们发现加密函数应该第二个代码块" target="_blank" rel="external">http://tools.bugscaner.com/decompyle/和https://tool.lu/pyc这两个网站对pyc文件进行反编译，得到如下效果。我们发现加密函数应该第二个代码块</a>,<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">str = <span class="string">'jYygTOy'</span> + <span class="string">'cmNycWNyYmM1Ujf'</span></div><div class="line"><span class="keyword">import</span> base64</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flag1</span><span class="params">()</span>:</span></div><div class="line">    code = str[::<span class="number">-3</span>]</div><div class="line">    result = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> code:</div><div class="line">        ss = ord(i) - <span class="number">1</span></div><div class="line">        result += chr(ss)</div><div class="line">    <span class="keyword">print</span> result[::<span class="number">-1</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flag2</span><span class="params">()</span>:</span></div><div class="line">    code = str[::<span class="number">-2</span>]</div><div class="line">    result = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> code:</div><div class="line">        ss = ord(i) - <span class="number">1</span></div><div class="line">        result += chr(ss)</div><div class="line">    <span class="keyword">print</span> result[::<span class="number">-2</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flag3</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line">// WARNING: Decompyle incomplete</div><div class="line">flag1()</div></pre></td></tr></table></figure></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flag3</span><span class="params">()</span></span><span class="symbol">:</span></div><div class="line">    code = str[<span class="symbol">:</span><span class="symbol">:-</span><span class="number">1</span>]     <span class="comment">#[开始：结束：步长],倒叙排序</span></div><div class="line">    result = <span class="string">''</span>          <span class="comment">#初始化result</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="symbol">code:</span></div><div class="line">        ss = ord(i) - <span class="number">1</span>   <span class="comment"># ASCII码-1</span></div><div class="line">        result += chr(ss)  <span class="comment">#转化为字符</span></div><div class="line">    print result[<span class="symbol">:</span><span class="symbol">:-</span><span class="number">3</span>]</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用另外一个编译器，得到一个字符串，结合上面的反汇编代码，发现，这是一个base64加密<br>    <img src="https://i.imgur.com/pFmT3Ws.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;得到流程是：一个字符串经过base64加密，然后逆序对每个字符串-1，输出。得到flag</p><h2 id="Debug-exe"><a href="#Debug-exe" class="headerlink" title="Debug.exe"></a>Debug.exe</h2><p><a href="https://findream.github.io/2017/11/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E4%BE%8B%E9%A2%98/" target="_blank" rel="external">https://findream.github.io/2017/11/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E4%BE%8B%E9%A2%98/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;逆向&quot;&gt;&lt;a href=&quot;#逆向&quot; class=&quot;headerlink&quot; title=&quot;逆向&quot;&gt;&lt;/a&gt;逆向&lt;/h1&gt;&lt;h2 id=&quot;Hackme&quot;&gt;&lt;a href=&quot;#Hackme&quot; class=&quot;headerlink&quot; title=&quot;Hackme&quot;&gt;&lt;/a&gt;Hackme&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是一个ELF的逆向题，IDA打开，发现流程如下：输入字符串，然后经过一个函数的加密，利用这个函数返回出来的数值，对该数值以22取余数，得到索引，得到Hex数组里面的数据，然后经过第一个循环得到V16，再用V16和输入的字符串异或，然后把结果和Hex比较即可。
    
    </summary>
    
      <category term="CTF" scheme="http://yoursite.com/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令(6)shell</title>
    <link href="http://yoursite.com/2018/05/25/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(6)shell%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/05/25/Linux常见命令(6)shell基础/</id>
    <published>2018-05-25T07:02:11.000Z</published>
    <updated>2018-06-09T07:12:46.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-shell概述"><a href="#1-shell概述" class="headerlink" title="1 shell概述"></a>1 shell概述</h1><ul><li>特点：<ul><li>1：解释型编程语言</li><li>2：可以直接调用系统命令<a id="more"></a></li></ul></li><li><p>类型：</p><ul><li>1：bshell：sh,Bash,等。Bash作为主流shell</li><li>2：cshell：cshell，tcshell</li></ul></li><li><p>/etc/shells可以看系统支持的shell类型<br>  <img src="https://i.imgur.com/1lj2vYb.png" alt=""></p></li><li><p>输入shell类型就可以编写shell。<br>  <img src="https://i.imgur.com/cGBda5s.png" alt=""></p></li></ul><h1 id="2-shell执行方式"><a href="#2-shell执行方式" class="headerlink" title="2 shell执行方式"></a>2 shell执行方式</h1><ul><li><p>echo [选项] [打印内容] ：打印输出</p><ul><li>-e:支持反斜线的转义字符。</li><li>打印内容有空格的话，需要加<strong>引号</strong>，如果含有！等特殊字符只能加<strong>单引号</strong></li><li>输出颜色：echo -e “\e[1;31m abcd \e[0”重点是：<strong>\e[1为开启颜色输出，\e[0为结束颜色输出</strong></li></ul></li><li><p>执行脚本的两种方法：</p><ul><li>1首先修改脚本权限chmod 755 xxx.sh,然后执行脚本./xxx.sh</li><li>2.bash xxx.sh<br><img src="https://i.imgur.com/ztVqwyN.png" alt=""></li></ul></li><li><p>windows-&gt;linux:使用dos2unix可以把11在windows下编写的shell移到linux造成的格式不匹配问题。</p></li></ul><h1 id="3-shell基本操作"><a href="#3-shell基本操作" class="headerlink" title="3 shell基本操作"></a>3 shell基本操作</h1><ul><li><p>history [参数]：显示历史命令</p><ul><li>-c：清空历史命令</li><li>-w：把缓存的历史命令写入文件</li><li>其配置文件是：/etc/profile</li></ul></li><li><p>alias 别名=”原命令”:设置别名</p><ul><li>alias：显示别名</li><li>优先级：1）路径 2）别名 3）bash命令 4)path环境变量定义的命令。</li><li>临时生效，如果需要永久生效，需要修改配置文件/root/.bashrc<br><img src="https://i.imgur.com/M39BZz1.png" alt=""></li></ul></li><li><p>unalias 别名：删除别名<br>  <img src="https://i.imgur.com/W4nNBW3.png" alt=""></p></li><li><p>快捷键<br>   <img src="https://i.imgur.com/5jIumqy.png" alt=""></p></li></ul><h1 id="4-重定向"><a href="#4-重定向" class="headerlink" title="4 重定向"></a>4 重定向</h1><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><ul><li><blockquote><p> 标准输出到文件</p></blockquote></li><li><blockquote><blockquote><p>标准输出附加到文件</p></blockquote></blockquote></li><li>2&gt; 标准错误输出到文件</li><li>2&gt;&gt; 标准错误输出附加到文件</li><li>&amp;&gt; 同时把错误和正确输出覆盖保存到文件</li><li>&amp;&gt;&gt; 同时把错误和正确输出附加保存到文件</li><li><blockquote><p>success.txt 2&gt; error.txt</p></blockquote></li></ul><h1 id="5-多命令"><a href="#5-多命令" class="headerlink" title="5 多命令"></a>5 多命令</h1><ul><li>“；”分号：顺序执行</li><li>“&amp;&amp;”逻辑与：格式：命令1&amp;&amp;命令2：如果命令1执行成功，则执行命令2；如果命令1执行失败，则不执行命令2</li><li>“||”逻辑或：格式：命令1||命令2：如果命令1执行成功，则不执行命令2；如果命令1执行失败，则执行命令2</li><li>“|“管道符：命令1|命令2：命令1的执行结果作为命令2的输入。</li><li>实例：判断一个命令是否正确？<ul><li>命令 &amp;&amp; yes || no<br> <img src="https://i.imgur.com/YhVRnHH.png" alt=""></li></ul></li></ul><h1 id="6-输入重定向"><a href="#6-输入重定向" class="headerlink" title="6 输入重定向"></a>6 输入重定向</h1><ul><li><p>wc [选项] [文件]</p><ul><li>-d：字符数（统计回车符）</li><li>-w：单词数</li><li>-l：行数</li></ul></li><li><p>命令 &lt; 文件：将文件内容作为命令的输入</p></li><li>命令 &lt; 字符：两个相同字符之间。(说不清，你自己看例子吧)<br>  <img src="https://i.imgur.com/uWtGiE1.png" alt=""></li></ul><h1 id="7-通配符和其他特殊符号"><a href="#7-通配符和其他特殊符号" class="headerlink" title="7 通配符和其他特殊符号"></a>7 通配符和其他特殊符号</h1><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><ul><li>具体常见通配符如下：<br>  <img src="https://i.imgur.com/Fu1ldUl.png" alt=""></li></ul><h2 id="其他特殊符号"><a href="#其他特殊符号" class="headerlink" title="其他特殊符号"></a>其他特殊符号</h2><ul><li>‘’(单引号)：单引号里面所有的特殊字符都没有特殊含义，只是一个符号</li><li>“”(双引号)：双引号内部”$”，”`”(反引)，”\”（转移）以外，其他的特殊符号都不具备特殊含义</li><li>``(反引号)：优先执行系统命令，也就是反引号里面的命令</li><li>$():同反引号</li><li>#：不是第一行，表示注释的意思，#! /bin/bash</li><li>$：用于调用变量</li><li>\：转义符，跟在\之后的特殊符号将失去特殊含义。变成普通符号。</li></ul><h1 id="8-用户自定义变量"><a href="#8-用户自定义变量" class="headerlink" title="8 用户自定义变量"></a>8 用户自定义变量</h1><h2 id="bash的变量类型"><a href="#bash的变量类型" class="headerlink" title="bash的变量类型"></a>bash的变量类型</h2><ul><li>用户自定义的变量</li><li>环境变量</li><li>位置参数变量</li><li>预定义变量</li></ul><h2 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h2><ul><li>默认变量变量类型是字符串型。</li><li>利用引号把含有空格的值括起来。<ul><li>EX：name=”wang xing yu”<br><img src="https://i.imgur.com/6gDUSWi.png" alt=""></li></ul></li><li>变量值可以叠加，但是变量需要使”$“或者”${}“包含。<ul><li>EX:a=123,a=”$a”456,echo $a :值为123456<br><img src="https://i.imgur.com/jJXVBho.png" alt=""></li><li>EX:a=123,a=￥{a}456,echo $a :值为123456<br><img src="https://i.imgur.com/U4z2KVE.png" alt=""></li></ul></li><li>可以把命令的结果作为变量值赋给变量，则需要使用反引号或者”$()“包含命令</li><li>set命令：查看系统所有变量</li><li>unset name：删除变量</li></ul><h1 id="9-环境变量"><a href="#9-环境变量" class="headerlink" title="9 环境变量"></a>9 环境变量</h1><h2 id="环境变量概述"><a href="#环境变量概述" class="headerlink" title="环境变量概述"></a>环境变量概述</h2><ul><li>环境变量在当前shell以及其子shell中生效。如果修改配置文件，可以在所有shell中生效</li><li>这种变量中保存的是和操作系统环境相关的数据</li><li>名称不能修改，但是可以写值</li><li>可以添加新的环境变量</li></ul><h2 id="环境变量使用"><a href="#环境变量使用" class="headerlink" title="环境变量使用"></a>环境变量使用</h2><ul><li>export 变量名=变量值：设置新的环境变量<br>  <img src="https://i.imgur.com/pF5xAQr.png" alt=""></li><li>env：查看环境变量<br>  <img src="https://i.imgur.com/llDA7LP.png" alt=""></li><li>unset 变量名：删除环境变量<br>  <img src="https://i.imgur.com/UW15Dj8.png" alt=""></li></ul><h1 id="10-位置参数变量"><a href="#10-位置参数变量" class="headerlink" title="10 位置参数变量"></a>10 位置参数变量</h1><h2 id="位置参数变量概述"><a href="#位置参数变量概述" class="headerlink" title="位置参数变量概述"></a>位置参数变量概述</h2><ul><li>用于向脚本当中传递参数或者数据</li><li>变量名称不能自定义，变量作用固定</li><li>名称不能修改，但是可以写值</li></ul><h2 id="位置参数变量使用"><a href="#位置参数变量使用" class="headerlink" title="位置参数变量使用"></a>位置参数变量使用</h2><ul><li>$n(n为数字)表示运行时参数<ul><li>0：代表shell名称</li><li>1-9：代表1-9个运行参数</li><li>10个以上的参数要用括号括起来：${10}<br><img src="https://i.imgur.com/VvUbhq6.png" alt=""><br><img src="https://i.imgur.com/labnt9w.png" alt=""><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> $((<span class="variable">$1</span>+<span class="variable">$2</span>))</div></pre></td></tr></table></figure></li></ul></li></ul><h1 id="11-预定义变量"><a href="#11-预定义变量" class="headerlink" title="11 预定义变量"></a>11 预定义变量</h1><h2 id="预定义变量概述"><a href="#预定义变量概述" class="headerlink" title="预定义变量概述"></a>预定义变量概述</h2><ul><li>bash已经定义好了</li><li>和位置参数变量作用功能一样</li></ul><h2 id="预定义变量使用"><a href="#预定义变量使用" class="headerlink" title="预定义变量使用"></a>预定义变量使用</h2><ul><li>$*:把所有参数看做整体输出</li><li>$@:将所有参数分开输出</li><li>$#：返回参数的个数</li><li>$?:返回上一条指令是否成功<ul><li>成功：0</li><li>失败：错误代码</li></ul></li><li>$$:返回当前进程PID</li><li>$!:发挥后台进程PID(命令+&amp;：表示命令进入后台运行)</li><li>read命令：读取用户键盘输入<ul><li>-p:显示提示信息</li><li>-t：输入等待时间(秒)</li><li>-n：允许输入字符数，输入n个字符自动执行(不需要回车)</li><li>-s：隐藏输入<br><img src="https://i.imgur.com/IBRplfX.png" alt=""></li></ul></li></ul><h1 id="12-数值运算和运算符"><a href="#12-数值运算和运算符" class="headerlink" title="12 数值运算和运算符"></a>12 数值运算和运算符</h1><h2 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h2><h3 id="第1种方法：-或者"><a href="#第1种方法：-或者" class="headerlink" title="第1种方法：$(())或者$[ ]"></a>第1种方法：$(())或者$[ ]</h3><ul><li>$(( $a+$b ))</li><li>$[$a+$b]<br>  <img src="https://i.imgur.com/pIySbcK.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-shell概述&quot;&gt;&lt;a href=&quot;#1-shell概述&quot; class=&quot;headerlink&quot; title=&quot;1 shell概述&quot;&gt;&lt;/a&gt;1 shell概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;特点：&lt;ul&gt;
&lt;li&gt;1：解释型编程语言&lt;/li&gt;
&lt;li&gt;2：可以直接调用系统命令
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划--编辑距离问题</title>
    <link href="http://yoursite.com/2018/05/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>http://yoursite.com/2018/05/24/动态规划_编辑距离/</id>
    <published>2018-05-24T06:02:11.000Z</published>
    <updated>2018-05-24T11:42:21.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划算法思想"><a href="#动态规划算法思想" class="headerlink" title="动态规划算法思想"></a>动态规划算法思想</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题的决策过程都是之前所有子问题的结合，也就是说每一步求解得问题都是后面阶段求解问题的子问题，每一步决策都将依赖于前面决策的结果。<br><a id="more"></a></p><h2 id="编辑路径问题"><a href="#编辑路径问题" class="headerlink" title="编辑路径问题"></a>编辑路径问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓编辑距离问题，是指一个字符串转化为另一个字符串最少的编辑次数，许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。一般来说，编辑距离越小，两个串的相似度越大。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先用BCD和ACDF举例子，我们利用二维数组来存储编辑字符串所需要的最短的步数，如图，我们先初始化这个二维数组，如图所示：<br>    <img src="https://i.imgur.com/GSJa6Bj.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;已知，看行坐标，第一个字符是A，再看列坐标，第一个字符是B，两个不相等，我们记做1，表示从A–&gt;B,最小需要一步操作(修改)。如图所示：<br>    <img src="https://i.imgur.com/KszA78b.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后A—&gt;BC，<strong>需要在上一步的基础上，</strong>加一个C，才能使得A—&gt;BC，这充分体现了动态规划的基本原则。然后A—&gt;BCD是同样的道理。<br>    <img src="https://i.imgur.com/oSg3Hy9.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着是AC–&gt;B,AC–&gt;BC,AC–&gt;BCD,分别要求的最短路径是2.1.2<br>    <img src="https://i.imgur.com/6julLh7.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同理：补全该图：红色区域是由之前的ACD—&gt;BCD的结果获得而来，因为ACD–&gt;BCD只需要1步，而ACDF—&gt;BCD只需要在去掉F即可。也就是在加一步。<br>      <img src="https://i.imgur.com/CQcUHwy.png" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个是问题的主要代码，首先初始化整个二维数组，然后再次遍历，找个里面三个操作（插入，删除，修改）里面的最好情况。AC–&gt;B,首先需要将A–&gt;B,然后需要删除C。我们可以得到公式：d[2] [1] =d[1] [1]+1，这里加1，是指在前一步的基础上<strong>再加一步</strong>删除。递推出来就是：d[i] [j] =d[i-1] [j]+1,同理插入：c = d[i] [j -1] + 1,如果是修改就看他是否相等了，相等不需要修改，不相等需要加1<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">CalcEditDistance</span><span class="params">(<span class="keyword">char</span> *StrA, <span class="keyword">char</span> *StrB, <span class="keyword">int</span> **d)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> i,j; </div><div class="line"><span class="keyword">int</span> a,b,c,e;</div><div class="line"><span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(StrA);</div><div class="line"><span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(StrB);</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt;= len1;i++)   <span class="comment">//初始化二维数组 </span></div><div class="line">d[i] = <span class="keyword">new</span> <span class="keyword">int</span>[len2 + <span class="number">1</span>];  </div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt;= len1;i++)   <span class="comment">//初始化第一个字符串的标号 </span></div><div class="line">d[i][<span class="number">0</span>] = i;</div><div class="line"><span class="keyword">for</span> (j = <span class="number">0</span>;j &lt;= len2;j++)   <span class="comment">//初始化第一个字符串的标号 </span></div><div class="line">d[<span class="number">0</span>][j] = j;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">1</span>;i &lt;= len1;i++)   <span class="comment">//循环确定每个规划中三种方法中的最优解。 </span></div><div class="line">&#123;</div><div class="line"><span class="keyword">for</span> (j = <span class="number">1</span>;j &lt;= len2;j++)</div><div class="line">&#123;</div><div class="line">a = StrA[i<span class="number">-1</span>] == StrB[j<span class="number">-1</span>] ? <span class="number">0</span> : <span class="number">1</span>;  <span class="comment">//如果两个字符串相等就是为0 </span></div><div class="line">b = d[i - <span class="number">1</span>][j] + <span class="number">1</span>; <span class="comment">//删除 </span></div><div class="line">c = d[i][j - <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">// 插入 </span></div><div class="line">e = d[i - <span class="number">1</span>][j - <span class="number">1</span>] + a;<span class="comment">//修改 </span></div><div class="line">d[i][j] = FindTripleMin(b, c, e);  <span class="comment">//寻找b，c，e里面的最小值 </span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 返回编辑距离值 ...</span></div><div class="line"><span class="keyword">return</span> d[<span class="built_in">strlen</span>(StrA)][<span class="built_in">strlen</span>(StrB)];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后经过上面三个操作，<strong>注意：这三种操作不直接写入二维数组，</strong>需要一个找到他们直接值最小的，然后把最小的写入数组。这样保证了每次的编辑距离都是最小的。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> FindTripleMin(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)   <span class="comment">//为了保证每次操作次数都是三种情况中间最少的 </span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> t = (a &lt; b) ? a : b;</div><div class="line"><span class="keyword">return</span> ((t &lt; c) ? t : c);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动态规划算法思想&quot;&gt;&lt;a href=&quot;#动态规划算法思想&quot; class=&quot;headerlink&quot; title=&quot;动态规划算法思想&quot;&gt;&lt;/a&gt;动态规划算法思想&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;问题的决策过程都是之前所有子问题的结合，也就是说每一步求解得问题都是后面阶段求解问题的子问题，每一步决策都将依赖于前面决策的结果。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>XCTF嘉年华资格赛</title>
    <link href="http://yoursite.com/2018/05/22/XCTF%E5%98%89%E5%B9%B4%E5%8D%8E%E6%AF%94%E8%B5%9B%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2018/05/22/XCTF嘉年华比赛试题/</id>
    <published>2018-05-21T16:02:11.000Z</published>
    <updated>2018-05-21T17:33:34.054Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>花了两天时间好好把XCTF嘉年华的比赛试题之逆向题好好做了一下，结合前几天练习的Re题来看，windows里面涉及到的加密函数非常的多，外部有时候也会加入常见壳，但是在比赛中不常出现，基本语言为VC，但是里面会出现多种反调试，加密算法应用广泛。但是linux下面的题目很少出现反调试，和加密函数，也没有向windows一样多种逆向技术结合，相对比较容易，下面讲解一下XCTF嘉年华的比赛逆向题(可能也有杂项题)</strong><br><a id="more"></a></p><h2 id="Re1"><a href="#Re1" class="headerlink" title="Re1"></a>Re1</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现这是一个elf的linux题目，直接利用IDA分析。可以知道：首先输入，然后通过atoi()将输入的字符串转化成int类型，**值得注意的是atoi函数只是转化“数字“和”±”,然后过判断，这里过判断非常简单，首先字符串长度为4，然后计算其十位百位和个位，基本的流程已经写好了。<br>    <img src="https://i.imgur.com/VJXdnXd.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是注册机的编写。值得注意的是这个里面可能会产生异常造成程序奔溃，可以选择排除逼近的方法排除这些数据，最终的数据是：9563<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">int v5=<span class="number">0</span>,v6=<span class="number">0</span>;</div><div class="line">for(v5=<span class="number">1000</span>;v5&lt;=<span class="number">9999</span>;v5++)</div><div class="line">&#123;</div><div class="line">v6 = v5 % <span class="number">100</span> / <span class="number">10</span>;</div><div class="line">if(v5 % <span class="number">10</span> + v6 + v5 / <span class="number">1000</span> + v5 % <span class="number">1000</span> / <span class="number">100</span> != <span class="number">23</span></div><div class="line">   ||v6 / (v5 % <span class="number">10</span>) != <span class="number">2</span></div><div class="line">   ||v5 % <span class="number">1000</span> / <span class="number">100</span> - v6 != <span class="number">-1</span></div><div class="line">   ||v5 / <span class="number">1000</span> % v6 != <span class="number">3</span>)</div><div class="line">   continue;</div><div class="line">        else</div><div class="line">   printf(<span class="string">"%d<span class="subst">\n</span>"</span>,v5);</div><div class="line">&#125;</div><div class="line">return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><pre><code>![](https://i.imgur.com/yaxHIkU.png)</code></pre><h2 id="Re2"><a href="#Re2" class="headerlink" title="Re2"></a>Re2</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个比较麻烦的题目，乍一看，里面对于用户名和密码的加密很多，也很麻烦，我看了一下关于SuccessFun函数内部，发现这个函数直接输出flag，同时flag也没有和用户名或者密码有关，但是，里面有一个s数组处于未知状态，不能通过静态计算得出flag，然后我想是否可以把前面对于用户名和密码的求解函数dop掉，这样掉过程序的验证阶段，直接显示flag，但是我又错了。最后看了大佬的wp（<a href="http://blog.r4phael.cn/coding/xctf-carnival-wp），辛辛苦苦把这道题解决，从中也学会了很多东西。" target="_blank" rel="external">http://blog.r4phael.cn/coding/xctf-carnival-wp），辛辛苦苦把这道题解决，从中也学会了很多东西。</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们可以看到sub_400C9A这个函数，函数从0到49循环，然后调用sub_400C41(i)，并以i为参数，这里产生和分析不符合的情况，可以是编译器优化造成的结果。<br>    <img src="https://i.imgur.com/11nQ75U.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后我们看看sub_400c41这个函数，通过思考，我们知道if条件的前面两个条件必定成立，后面两个式子成为if的关键，根据流程，我们可以知道字符长度为a1&gt;&gt;3不等于0，以及a1&gt;&gt;4==0.通过写注册机得知Username长度为8或者12<br>    <img src="https://i.imgur.com/c7DczlZ.png" alt=""><br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">int <span class="built_in">a1</span>,result<span class="comment">;</span></div><div class="line">for(<span class="built_in">a1</span>=<span class="number">0</span><span class="comment">;a1&lt;49;a1++)</span></div><div class="line">&#123;</div><div class="line">result=<span class="built_in">a1</span>&gt;&gt;<span class="number">3</span><span class="comment">;</span></div><div class="line">if(<span class="number">4</span> * (<span class="built_in">a1</span> &gt;&gt; <span class="number">2</span>) != <span class="built_in">a1</span> <span class="title">||</span><span class="number">4</span> * (<span class="built_in">a1</span> &gt;&gt; <span class="number">4</span>) == <span class="built_in">a1</span> &gt;&gt; <span class="number">2</span><span class="title">||</span>!result <span class="title">||</span> <span class="built_in">a1</span> &gt;&gt; <span class="number">4</span>)</div><div class="line">continue<span class="comment">;</span></div><div class="line">else</div><div class="line">printf(<span class="string">"%d\n"</span>,<span class="built_in">a1</span>)<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们看看GetUsernameVal函数，这个函数就是一个解三元一次方程组的函数，具体验证如下：<strong>首先</strong>，把函数分割Username，分成三份，分别是First，Second，Third，然后放到if里面去判断，难点在于如何去计算，考验心细的时候。<strong>接着</strong>，他把转化为hex16进制的字符，分别是First=6163，Second=796c，Third=636f，<strong>由于InterlCPU是小端序显示，也就是说如果实际传输为FEAB12的话，那么小端序显示为21BAEF。</strong>所以用户名是F636C6973616.小插曲，在计算除法的时候，数据太大了，网上计算器无法计算了，所以找一份大数除法代码。<br>    <img src="https://i.imgur.com/3NNqrgo.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp跟入ProUsernameVal函数，发现这是一个严重Username是否符合自定义原则的，函数将a1想做数组的基地址，i作为偏移地址，依次遍历判断Username的每位是否符合要求。应为之前正确求解了，这个函数不是很重要<br>    <img src="https://i.imgur.com/PSUY9c4.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp分析GetpasswdVal函数，<strong>函数先是</strong>验证了passwd的字符类型，如图passwd只能使大小写字母和数字，<strong>接着</strong>，函数用之前的Username做种子，产生为随机值，因为是以固定值做种子，所以产生的随机数也是固定的。然后将Passwd分为10份，分别通过十次和随机数的验证，每个验证过程都是一样的，我们写出前十次产生的随机数，然后带入计算得到Passwd。<br>    <img src="https://i.imgur.com/tPpXIDT.png" alt=""><br>    <img src="https://i.imgur.com/w9hj1a6.png" alt=""><br>    <img src="https://i.imgur.com/tX8QjyA.png" alt=""><br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()&#123;</div><div class="line"><span class="keyword">srand</span>(<span class="number">0x454D3E2E</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">printf</span>(<span class="string">"%0x\n"</span>,<span class="keyword">rand</span>());</div><div class="line">&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp执行程序，输入Username和Passwd，经过等待得到flag，你也可以nop掉sleep函数，避免等待。得到flag是：<br>     <img src="https://i.imgur.com/TLQnlcK.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;花了两天时间好好把XCTF嘉年华的比赛试题之逆向题好好做了一下，结合前几天练习的Re题来看，windows里面涉及到的加密函数非常的多，外部有时候也会加入常见壳，但是在比赛中不常出现，基本语言为VC，但是里面会出现多种反调试，加密算法应用广泛。但是linux下面的题目很少出现反调试，和加密函数，也没有向windows一样多种逆向技术结合，相对比较容易，下面讲解一下XCTF嘉年华的比赛逆向题(可能也有杂项题)&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CTF" scheme="http://yoursite.com/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令(5)权限管理</title>
    <link href="http://yoursite.com/2018/05/20/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(5)%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/20/Linux常见命令(5)权限管理/</id>
    <published>2018-05-20T07:02:11.000Z</published>
    <updated>2018-05-24T07:29:59.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-ACL权限"><a href="#第一部分-ACL权限" class="headerlink" title="第一部分 ACL权限"></a>第一部分 ACL权限</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;忽略所有者，所有组，其他人三个用户类型，只需要把用户对文件的权限分配给用户。ACL权限需要文件所在分区是否支持ACL机制。利用<strong>dumpe2fs -h /dev/sda3</strong>这个命令即可查看。<br><a id="more"></a></p><ul><li>第一步：df -h :查看所有分区信息</li><li>第二歩：dumpe2fs -h /dev/xxx<br>  <img src="https://i.imgur.com/xXz86iD.png" alt=""></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开启ACL</p><ul><li>临时开启ACL权限。mount -o remount,acl /<br>  <img src="https://i.imgur.com/cMxGQ1O.png" alt=""></li><li>永久开启ACL权限：修改/etc/fstab文件，然后重启<br>   <img src="https://i.imgur.com/UrVW9GN.png" alt=""></li></ul><h1 id="第二部分-ACL权限管理"><a href="#第二部分-ACL权限管理" class="headerlink" title="第二部分 ACL权限管理"></a>第二部分 ACL权限管理</h1><ul><li><p>getfacl [文件名]：获取文件ACL权限<br>  <img src="https://i.imgur.com/X11rr4S.png" alt=""></p></li><li><p>setfacl [选项] [u/g:username:权限] [文件名]：给用户/组设定ACL权限。</p><ul><li>-m:添加ACL权限</li><li>-x:删除指定给的ACL权限</li><li>-b：删除所有的ACL权限</li><li>-d：设置默认的ACL权限</li><li>-k：删除默认的ACL权限</li><li>-R：递归设定ACL权限</li></ul></li></ul><ul><li>实例：添加一个文件ACL权限<ul><li>首先创建3个用户test1,test2，st和一个组tgroup。<br><img src="https://i.imgur.com/CkqerBj.png" alt=""></li><li>将两个用户添加到tgroud组中。<br><img src="https://i.imgur.com/AsTl3ai.png" alt=""></li><li>修改文件的所有者和所属组<br><img src="https://i.imgur.com/WIXJEvL.png" alt=""></li><li>修改权限<br><img src="https://i.imgur.com/ia4oSEW.png" alt=""></li><li>设置ACL权限：setfacl -m u:st:rx /tmp/test<br><img src="https://i.imgur.com/Gl9v46W.png" alt=""><br><img src="https://i.imgur.com/5pT77Td.png" alt=""></li><li>通过getfacl命令查看ACL权限<br><img src="https://i.imgur.com/X11rr4S.png" alt=""></li></ul></li></ul><h1 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h1><h1 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h1><h1 id="第五部分-sudo权限"><a href="#第五部分-sudo权限" class="headerlink" title="第五部分 sudo权限"></a>第五部分 sudo权限</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visduo命令通过修改/etc/sudoers文件，对用户进行赋权操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到以下字段：%admin ALL=(ALL) ALL，其中admin代表的是用户名，第一个all代表的是本地linux的地址，第二个ALL是代表可使用的身份，<strong>这个字段可写，可不写，</strong>第三个ALL是授权命令（绝对地址），命令写的短，则使用范围越长，如：shutdown 表示可以执行shutdown所有的命令。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用sudo -l 查看超级用户给我赋予了的命令情况。<br>    <img src="https://i.imgur.com/MQ73Vwj.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是其他用户在执行的时候，必须要写绝对路径。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-ACL权限&quot;&gt;&lt;a href=&quot;#第一部分-ACL权限&quot; class=&quot;headerlink&quot; title=&quot;第一部分 ACL权限&quot;&gt;&lt;/a&gt;第一部分 ACL权限&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;忽略所有者，所有组，其他人三个用户类型，只需要把用户对文件的权限分配给用户。ACL权限需要文件所在分区是否支持ACL机制。利用&lt;strong&gt;dumpe2fs -h /dev/sda3&lt;/strong&gt;这个命令即可查看。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令(4)用户和用户组管理</title>
    <link href="http://yoursite.com/2018/05/17/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(4)%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/17/Linux常见命令(4)用户和用户组管理/</id>
    <published>2018-05-17T07:02:11.000Z</published>
    <updated>2018-05-28T05:14:47.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-用户信息配置文件passwd"><a href="#第一部分-用户信息配置文件passwd" class="headerlink" title="第一部分 用户信息配置文件passwd"></a>第一部分 用户信息配置文件passwd</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户信息文件路径为/etc/passwd,一共有七个字段。分别是用户名称，秘密标志，UID,GID，用户说明，主目录，shell。<br>    <img src="https://i.imgur.com/cpdt8BN.png" alt=""><br><a id="more"></a></p><ul><li>用户名称</li><li>密码标志：x代表设置密码，其他代表没有设置密码</li><li>UID：用户编号，系统唯一标识用户信息的编号，通过修改UID，可以修改权限，例如把UID修改为0，达到管理员权限。<ul><li>0 超级用户</li><li>1-499 系统用户（系统中应用程序的用户，不可删除）</li><li>500-65535 普通用户</li></ul></li><li>GID：组ID<ul><li>初始化组：<ul><li>每个用户只有一个初始化组</li><li>每个用户必须要有初始化组</li><li>可以修改初始化组，但是不建议修改</li></ul></li><li>附加组：<ul><li>每个用户可以有多个附加组，但是拥有附加组的权限</li></ul></li></ul></li><li>用户说明</li><li>主目录：<ul><li>root用户的主目录是/root<br><img src="https://i.imgur.com/hb45jFV.png" alt=""></li><li>普通用户的主目录是/home/usrname<br><img src="https://i.imgur.com/lEYPJmN.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是值得注意的是 sudo -s并不是进入管理员账号，而是获取了管理员的权限，你利用pwd会发现，使用sudo -s，他的工作目录并不是/root，而是/home/username。</li></ul></li><li>shell：用户使用shell解释器的路径</li></ul><h1 id="第二部分-shadow文件"><a href="#第二部分-shadow文件" class="headerlink" title="第二部分 shadow文件"></a>第二部分 shadow文件</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shadow文件位于/etc/shadow中（利用man 5 shadow可查），需要root权限才能打开。一共有八个字段，分别是：用户名，加密的密码串，最后一次修改密码的日期(时间戳)，密码有效期，最大密码年龄，警告时间段，密码禁用期，账号过期日期，保留。<br>    <img src="https://i.imgur.com/pmd6SXJ.png" alt=""></p><ul><li>用户名</li><li>加密的密码串：如果这个字段为空的话，说明这个账号不需要使用密码也能登录，使用*表示这个账号已经被锁定。如果是！！表示密码无效/过期，也就是说账户被禁用。</li><li>最后一次修改密码的时间戳：<ul><li>0：表示下次登陆账户时，修改密码</li><li>为空：表示密码年龄的功能被禁用</li></ul></li><li>密码有效期(最小密码年龄)：修改密码之后，要等n时间才能被允许修改密码。<ul><li>0或者为空：表示没有设置密码有效期</li></ul></li><li>最大密码年龄:在最大密码年龄之后必须要修改密码</li><li>警告时间段：在密码到期之前n天，警告必须修改密码</li><li>密码禁用期：过了密码有效期之后，仍可以使用原密码登录的最大期限。过了此期限后，账户不能登录，空字段表示没有强制密码过期。</li><li>账户过期日期：账户没有登录多少天后，账户过期。</li><li>保留<br>  <img src="https://i.imgur.com/LjpkH5X.png" alt=""></li></ul><h1 id="第三部分-group和gshadow组配置文件"><a href="#第三部分-group和gshadow组配置文件" class="headerlink" title="第三部分 group和gshadow组配置文件"></a>第三部分 group和gshadow组配置文件</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group文件在/etc/group,文件下面一共有四个字段，分别是组名，组密码标志，GID，组中的附加用户。</p><ul><li>组名：在linux中，每次新加一个用户，该用户的初始组名也是用户名</li><li>密码标志：存在密码为“x”字段，在etc/gshadow文件下可查看，但是基本都不存在组密码。存在的意义在于：执行了受限的root用户的权限，管理组内的用户。</li><li>GID:</li><li>附加用户：看不到初始用户。只能看附加用户，如果需要查看组的初始用户，先查看passwd中的GID，然后再看group中的GID，就行了。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gshadow文件在/etc/gshadow，有四个字段：组名，组密码，组管理员用户名，组中附加用户。</p><h1 id="第四部分：主目录"><a href="#第四部分：主目录" class="headerlink" title="第四部分：主目录"></a>第四部分：主目录</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户主目录：root用户为/root,权限为550，普通用户为/home/username,权限为700</p><h1 id="第五部分：useradd-添加用户"><a href="#第五部分：useradd-添加用户" class="headerlink" title="第五部分：useradd 添加用户"></a>第五部分：useradd 添加用户</h1><ul><li>useradd [选项] [参数]<ul><li>-u UID:手动指定用户的ID</li><li>-d 主目录：</li><li>-c 用户说明</li><li>-g 组名：指定用户初始组</li><li>-G 组名：指定用户附加组</li><li>-s shell: 指定用户登录shell<br><img src="https://i.imgur.com/tCVCvFw.png" alt=""></li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/etc/default/useradd,作为添加的缺省设置信息的文件。<br>    <img src="https://i.imgur.com/24k4UtE.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/etc/login.defs:存放默认密码信息的文件</p><h1 id="第六部分：passwd-修改设置用户密码"><a href="#第六部分：passwd-修改设置用户密码" class="headerlink" title="第六部分：passwd 修改设置用户密码"></a>第六部分：passwd 修改设置用户密码</h1><ul><li>passwd [选项] [参数]<ul><li>-S 查询用户密码状态(仅root可用)<br><img src="https://i.imgur.com/6NDEo4O.png" alt=""></li><li>-l 暂时锁定用户(仅root可用)<br><img src="https://i.imgur.com/RBiJb6C.png" alt=""></li><li>-u 解锁用户<br><img src="https://i.imgur.com/mtG8CfO.png" alt=""></li><li>–stdin 使用标准化输入，使用shell编程：echo “123” | passwd stdin username</li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root可以修改所有用户密码，但是普通用户只能修改自己的，此时，使用passwd不能加自己的用户名，<strong>即修改密码是只需要输入passwd。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;锁定用户原理是修改/etc/passwd的密码域，在前面添加!!。以至于密码串不正确，造成用户无法登陆。</p><h2 id="第七部分-用户管理相关命令"><a href="#第七部分-用户管理相关命令" class="headerlink" title="第七部分 用户管理相关命令"></a>第七部分 用户管理相关命令</h2><ul><li><p>usermod [选项] [用户]  修改已存在用户信息</p><ul><li>-c 修改用户说明</li><li>-G 修改用户附加组</li><li>-L 暂时锁定用户</li><li>-U 暂时解锁用户</li></ul></li><li><p>change [选项] [参数] 修改用户的密码信息(直接修改/etc/shadow方便)</p></li><li><p>userdel [选项] [用户]</p><ul><li>r:删除主目录</li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;手工删除以下目录：</p><ul><li>/etc/passwd</li><li>/etc/shadow</li><li>/etc/group</li><li>/etc/gshadow</li><li>rm -fr /var/spool/mail/username</li><li><p>rm -rf /var/home/username</p></li><li><p>id [username]:查看用户ID，组ID，等信息<br>  <img src="https://i.imgur.com/UKfNsqK.png" alt=""></p></li><li><p>su [选项] [参数]切换用户命令</p><ul><li>-（减号）：连带切换用户的环境变量</li><li>-c：只是赋予某个用户root权限，以便去执行需要root权限的操作</li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在切换用户的时候，务必添加”-“选项。如果不添加这个选项的话：如图2，你会发现这个的登录账户时wangxingyu但是，利用env查看环境变量的话，还是显示你原来的账户的环境变量，所以你必须要添加这个选项。<br>    <img src="https://i.imgur.com/zfl0RUR.png" alt=""><br>    <img src="https://i.imgur.com/SBgETso.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;su - root -c “useradd test123” 这是一次性利用root的权限去执行某个特殊权限的操作。<br>    <img src="https://i.imgur.com/0Dz6A5b.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Ubuntu以及分支版本切换root账户出现认证失败的情况，输入“sudo passwd root”，产生这类问题原因是因为默认没有设置root用户密码。</p><ul><li>groupadd [选项] [组名] :添加组名<ul><li>-g：规定组ID</li></ul></li></ul><ul><li>groupmod [选项] [组名] <ul><li>-g：修改组ID</li><li>-n: 修改组名：groupmod -n newgroupname oldgroupname</li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要宿便修改</p><ul><li><p>groupdel [组名]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果存在初始用户，次组不能被删除，如果只存在附加用户，此组可以删除。</p></li><li><p>gpasswd [选项] [username] [groupname]：管理组内用户</p><ul><li>-a username：将username 添加groupname</li><li>-d username：将username 从groupname组中删除</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-用户信息配置文件passwd&quot;&gt;&lt;a href=&quot;#第一部分-用户信息配置文件passwd&quot; class=&quot;headerlink&quot; title=&quot;第一部分 用户信息配置文件passwd&quot;&gt;&lt;/a&gt;第一部分 用户信息配置文件passwd&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;用户信息文件路径为/etc/passwd,一共有七个字段。分别是用户名称，秘密标志，UID,GID，用户说明，主目录，shell。&lt;br&gt;    &lt;img src=&quot;https://i.imgur.com/cpdt8BN.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows PE》延迟加载导入表</title>
    <link href="http://yoursite.com/2018/05/14/%E3%80%8Awindows%20PE%E3%80%8B%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/05/14/《windows PE》延迟加载表/</id>
    <published>2018-05-14T11:02:11.000Z</published>
    <updated>2018-06-09T09:27:44.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="1-延迟加载导入的概念及作用"><a href="#1-延迟加载导入的概念及作用" class="headerlink" title="1.延迟加载导入的概念及作用"></a>1.延迟加载导入的概念及作用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;延迟加载导入表和导入表示相互分离的，延迟加载导入表是特殊的导入表，和导入表不同的是，延迟加载导入表所记录的dll不会被操作系统加载，只有在函数被应用程序调用的时候，PE中注册的延迟加载函数才会根据延迟加载导入表的记录，动态加载dll，以及修正导入函数的VA。<br><a id="more"></a></p><h2 id="2-延迟加载的优势"><a href="#2-延迟加载的优势" class="headerlink" title="2.延迟加载的优势"></a>2.延迟加载的优势</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;延迟加载由于没有在程序初始化的时候初始化dll，只是会在应用程序调用某个模块的时候加载该模块，所以使用延迟加载技术的程序拥有更高的初始化速度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过延迟加载的方法，提高了程序的兼容性，原因在于基于延迟加载，所用到的模块不需要在初始化前加载，保证了程序能够运行成功，如果缺少模块或者缺少模<br>块里面的函数造成的异常，可以使得编译器单独处理该某个dll或者某个函数的调用。</p><h1 id="PE中的延迟加载导入表"><a href="#PE中的延迟加载导入表" class="headerlink" title="PE中的延迟加载导入表"></a>PE中的延迟加载导入表</h1><h2 id="1-延迟加载导入表的定位"><a href="#1-延迟加载导入表的定位" class="headerlink" title="1.延迟加载导入表的定位"></a>1.延迟加载导入表的定位</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;延迟加载导入表的描述信息在数目目录的第14个目录项中，定位方法和前面的导入导出表一致。</p><h2 id="2-延迟加载描述符IMAGE-DELAY-IMPORT-DESCRIPTOR"><a href="#2-延迟加载描述符IMAGE-DELAY-IMPORT-DESCRIPTOR" class="headerlink" title="2.延迟加载描述符IMAGE_DELAY_IMPORT_DESCRIPTOR"></a>2.延迟加载描述符IMAGE_DELAY_IMPORT_DESCRIPTOR</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IMAGE_DELAY_IMPORT_DESCRIPTOR的结构如下：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_DELAY_IMPORT_DESCRIPTOR</span> STRUCT </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    DWORD           Attributes;           <span class="comment">// 保留  </span></div><div class="line">    RVA             RVA_DLLName;          <span class="comment">// 指向延迟加载dll的名字字符串的RVA  </span></div><div class="line">    RVA             RVA_ModuleHandle;     <span class="comment">// 指向DLL句柄的RVA   </span></div><div class="line">    RVA             RVA_DelayIAT;         <span class="comment">// RVA of the IAT  </span></div><div class="line">    RVA             RVA_DelayINT;         <span class="comment">// RVA of the INT  </span></div><div class="line">    RVA             RVA_BoundIAT;      <span class="comment">// RVA of the optional bound IAT  </span></div><div class="line">    RVA             RVA_UnloadIAT;     <span class="comment">// RVA of optional copy of original IAT  </span></div><div class="line">    DWORD           dwTimeStamp;       <span class="comment">// 0 if not bound,  </span></div><div class="line">                                       <span class="comment">// 绑定到DLL的时间戳</span></div><div class="line">&#125; ImgDelayDescr, * PImgDelayDescr;</div></pre></td></tr></table></figure></p><ul><li>Attributes：双字，暂时未用到，</li><li>RVA_DLLName：双字，延迟加载dll名称的字符串的地址。</li><li>RVA_ModuleHandle：双字，延迟加载dll的句柄的地址。</li><li>RVA_DelayIAT: 延迟加载导入地址表的RVA</li><li>RVA_DelayINT：延迟加载导入名称表的RVA</li><li>RVA_BoundIAT：延迟绑定导入地址表的RVA，延迟绑定导入地址表是由IMAGE_THUNK_DATA组成的数组。他和最后一项dwTimeStamp用于最后的绑定阶段。</li><li>RVA_UnloadIAT：延迟卸载导入地址表由IMAGE_THUNK_DATA组成的数组，程序使用它来卸载dll(包括函数)，所用到的参数是原来IAT的精确副本。做释放处理需要做一下几个工作<ul><li>1）释放函数/dll</li><li>2）ModuleHandle清零</li><li>3）使用UIAT覆盖IAT。</li></ul></li></ul><h2 id="3-详解延迟加载机制"><a href="#3-详解延迟加载机制" class="headerlink" title="3.详解延迟加载机制"></a>3.详解延迟加载机制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用延迟加载技术的程序，链接器会做一下几个事情：</p><ul><li>1）将函数_delayLoadHelper嵌入到可执行模块</li><li>2）删除可执行文件导入表的相关内容，避免在初始化时候显式加载dll</li><li>3）构造PE相关信息，以便_delayLoadHelper正确的延迟加载函数。</li><li>4）调用_delayLoadHelper函数加载dll或获取调用函数地址。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在_delayLoadHelper函数中，还调用了LoadLibrary加载dll，调用了GetprocessAddress获取函数地址，调用了FreeLibrary去释放dll。</li></ul><h2 id="4-利用windbg查看延迟加载导入表"><a href="#4-利用windbg查看延迟加载导入表" class="headerlink" title="4.利用windbg查看延迟加载导入表"></a>4.利用windbg查看延迟加载导入表</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们首先用windows xp下的explorer程序举例子。</p><ul><li>查看程序加载的模块：<strong>lm m explorer</strong><br>  <img src="https://i.imgur.com/OwrUPxC.png" alt=""></li><li>显示PE文件头：<strong>!dh start_address -f</strong><br>  <img src="https://i.imgur.com/WmC45oC.png" alt=""></li><li>查看延迟加载导入的内存空间:<strong>dd start_address+offset</strong><br>  <img src="https://i.imgur.com/ER4HHJ0.png" alt=""></li><li>比如查看延迟加载导入表第二项的内容dll的ASCII：<strong>da address</strong><br>  <img src="https://i.imgur.com/fvZrYYJ.png" alt=""></li></ul><h2 id="4-延迟导入的两个问题"><a href="#4-延迟导入的两个问题" class="headerlink" title="4.延迟导入的两个问题"></a>4.延迟导入的两个问题</h2><h3 id="1）异常处理"><a href="#1）异常处理" class="headerlink" title="1）异常处理"></a>1）异常处理</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过延迟加载机制，未能成功加载的dll或者由于版本问题，未能成功调用的函数，函数_delayLoadHelper会抛出软件异常（其实是API函数剖出的异常）</p><h3 id="2）dll卸载"><a href="#2）dll卸载" class="headerlink" title="2）dll卸载"></a>2）dll卸载</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不能使用FreeLibrary卸载dll，因为在函数_delayLoadHelper中存在卸载函数，</p><h1 id="3-延迟加载机制在dll注入的实例。"><a href="#3-延迟加载机制在dll注入的实例。" class="headerlink" title="3.延迟加载机制在dll注入的实例。"></a>3.延迟加载机制在dll注入的实例。</h1><p><a href="https://www.anquanke.com/post/id/86919" target="_blank" rel="external">https://www.anquanke.com/post/id/86919</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;h2 id=&quot;1-延迟加载导入的概念及作用&quot;&gt;&lt;a href=&quot;#1-延迟加载导入的概念及作用&quot; class=&quot;headerlink&quot; title=&quot;1.延迟加载导入的概念及作用&quot;&gt;&lt;/a&gt;1.延迟加载导入的概念及作用&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;延迟加载导入表和导入表示相互分离的，延迟加载导入表是特殊的导入表，和导入表不同的是，延迟加载导入表所记录的dll不会被操作系统加载，只有在函数被应用程序调用的时候，PE中注册的延迟加载函数才会根据延迟加载导入表的记录，动态加载dll，以及修正导入函数的VA。&lt;br&gt;
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows PE》重定位表</title>
    <link href="http://yoursite.com/2018/05/14/%E3%80%8Awindows%20PE%E3%80%8B%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/05/14/《windows PE》重定位表/</id>
    <published>2018-05-14T06:02:11.000Z</published>
    <updated>2018-05-28T09:41:22.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识：代码重定位"><a href="#预备知识：代码重定位" class="headerlink" title="预备知识：代码重定位"></a>预备知识：代码重定位</h1><h2 id="重定位的提出"><a href="#重定位的提出" class="headerlink" title="重定位的提出"></a>重定位的提出</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码重定位是把可执行代码从内存的一块区域移动到另外一块地方。但是如果指令中某些操作数没有随着地址的改变而改变，这样势必导致运行出错。如下代码：我们发现全局变量的地址包含在机器码中，而局部变量没有包含绝对地址。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line"><span class="keyword">add</span> <span class="built_in">esp</span>,ffffffc</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [00400FFC]   //全局变量</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">04</span>]     //局部变量</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [evp+<span class="number">08</span>]     //局部变量</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定位信息是在编译时期由编译器生成，并且保存在应用程序中，在程序执行的时候由操作系统予以修正。如果在装载时该位置已经被别的应用程序使用，操作系统会<strong>重新选择一个新的基地址</strong>。此时，就需要对所有重定位信息进行纠正，纠正的依据就是<strong>PE中的重定位表</strong>。<br><a id="more"></a></p><h1 id="PE文件中的重定位表"><a href="#PE文件中的重定位表" class="headerlink" title="PE文件中的重定位表"></a>PE文件中的重定位表</h1><h2 id="1-重定位表的定位"><a href="#1-重定位表的定位" class="headerlink" title="1.重定位表的定位"></a>1.重定位表的定位</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定位表位于数据目录中的第六个数据目录中。位置定位方法和前面的导入表和导出表一样。<br>    <img src="https://i.imgur.com/UqrSU1r.png" alt=""></p><h2 id="2-重定位表项IMAGE-BASE-RELOCATION"><a href="#2-重定位表项IMAGE-BASE-RELOCATION" class="headerlink" title="2.重定位表项IMAGE_BASE_RELOCATION"></a>2.重定位表项IMAGE_BASE_RELOCATION</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和导入表一样，重定位表指针指向的位置是一个数组。<strong>每个数组代表的是每一个内存页的重定位信息。</strong>也就是说每个内存页的重定位信息是不同的。下面是对于IMAGE_BASE_RELOCATION结构体的介绍:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">IMAGE_BASE_RELOCATION STRUC 【基址重定位位于数据目录表的第六项，共<span class="number">8</span>+N字节】</div><div class="line">&#123;</div><div class="line">+<span class="number">00</span> h DWORD VirtualAddress ;重定位数据开始的RVA 地址</div><div class="line">+<span class="number">04</span> h DWORD SizeOfBlock ;重定位块得长度，标识重定向字段个数</div><div class="line">+<span class="number">08</span> h WORD TypeOffset ;重定项位数组相对虚拟RVA,个数动态分配</div><div class="line">&#125;;</div><div class="line">IMAGE_BASE_RELOCATION ENDS</div></pre></td></tr></table></figure></p><ul><li>VirtualAddress:双字，表示的是重定位块的RVA。<strong>本来一个地址需要4个字节，因为一个内存页大小诶1000h,也就是2的12次，所以只需要2个字节即可</strong></li><li>SizeOfBlock：双字，重定位表项中的重定位块的个数。这些数组(表项)可能不是相邻的。</li><li>TypeOffset：表示重定位表项的类型：高四位表示的是类型。低十二位表示的重定位地址。<br>  <img src="https://i.imgur.com/QjFxUnO.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定位块的大小：n*12+4+4</li></ul><h2 id="3-重定位表的结构"><a href="#3-重定位表的结构" class="headerlink" title="3.重定位表的结构"></a>3.重定位表的结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重定位表中包含有重定位块，重定位块中包含有重定位表项和前面的VirtualAddress，SizeOfBlock，TypeOffset字段(TypeOffset是一个数组，它的元素个数就是( SizeOfBlock - 8 ) / 2 ，TypeOffset 每一个元素占用两个字节即16位，其中高4位表示重定位类型（一般都为3），低12位表示重定位地址。)。<br>    <img src="https://i.imgur.com/4pZ0mvd.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有的重定位块最终以VirtualAddress字段为0的IMAGE_BASE_RELOCATION结构为结束标志。</p><h2 id="4-实例分析"><a href="#4-实例分析" class="headerlink" title="4.实例分析"></a>4.实例分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下图，我们知道第一个重定位块位于0x1c00，代码起始页面RVA为00001000，块的大小为000000E8。后面的是每个重定位表项的相对位置。根据以下计算公式得到最终的实际地址。<br>VA=基地址(程序基地址)+代码起始页面RVA+<strong>低12位虚拟地址。</strong><br>VA=01000000+00001000+009<br>    <img src="https://i.imgur.com/tLuBjY9.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;预备知识：代码重定位&quot;&gt;&lt;a href=&quot;#预备知识：代码重定位&quot; class=&quot;headerlink&quot; title=&quot;预备知识：代码重定位&quot;&gt;&lt;/a&gt;预备知识：代码重定位&lt;/h1&gt;&lt;h2 id=&quot;重定位的提出&quot;&gt;&lt;a href=&quot;#重定位的提出&quot; class=&quot;headerlink&quot; title=&quot;重定位的提出&quot;&gt;&lt;/a&gt;重定位的提出&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;代码重定位是把可执行代码从内存的一块区域移动到另外一块地方。但是如果指令中某些操作数没有随着地址的改变而改变，这样势必导致运行出错。如下代码：我们发现全局变量的地址包含在机器码中，而局部变量没有包含绝对地址。&lt;br&gt;&lt;figure class=&quot;highlight x86asm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;ebp&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;ebp&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;esp&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;esp&lt;/span&gt;,ffffffc&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;eax&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;dword&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;ptr&lt;/span&gt; [00400FFC]   //全局变量&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;eax&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;dword&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;ptr&lt;/span&gt; [&lt;span class=&quot;built_in&quot;&gt;ebp&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;04&lt;/span&gt;]     //局部变量&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;eax&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;dword&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;ptr&lt;/span&gt; [evp+&lt;span class=&quot;number&quot;&gt;08&lt;/span&gt;]     //局部变量&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;重定位信息是在编译时期由编译器生成，并且保存在应用程序中，在程序执行的时候由操作系统予以修正。如果在装载时该位置已经被别的应用程序使用，操作系统会&lt;strong&gt;重新选择一个新的基地址&lt;/strong&gt;。此时，就需要对所有重定位信息进行纠正，纠正的依据就是&lt;strong&gt;PE中的重定位表&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows PE》导出表</title>
    <link href="http://yoursite.com/2018/05/11/%E3%80%8Awindows%20PE%E3%80%8B%E5%AF%BC%E5%87%BA%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/05/11/《windows PE》导出表/</id>
    <published>2018-05-11T06:02:11.000Z</published>
    <updated>2018-05-28T09:46:11.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-预备知识"><a href="#第一部分-预备知识" class="headerlink" title="第一部分 预备知识"></a>第一部分 预备知识</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导入表主要存在于动态链接库文件中，用于将dll文件中的函数导入到外部，给其他的exe或者dll文件调用。我们在导入表一章中知道了程序在装载过程中，<strong>通过在INT获得的函数地址覆盖到IAT中，</strong>此时，导出表起到了参照和指引的作用。<br><a id="more"></a></p><h1 id="第二部分-导出表数据结构"><a href="#第二部分-导出表数据结构" class="headerlink" title="第二部分 导出表数据结构"></a>第二部分 导出表数据结构</h1><h2 id="1-定位导出表"><a href="#1-定位导出表" class="headerlink" title="1.定位导出表"></a>1.定位导出表</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导出表数据在数据目录的第一个目录中，定位方法和获取导入表的一样。<br>    <img src="https://i.imgur.com/oF80lie.png" alt=""></p><h2 id="2-导出目录IMAGE-EXPORT-DIRECTORY"><a href="#2-导出目录IMAGE-EXPORT-DIRECTORY" class="headerlink" title="2.导出目录IMAGE_EXPORT_DIRECTORY"></a>2.导出目录IMAGE_EXPORT_DIRECTORY</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个结构是导出表描述符，导入表的IMAGE_EXPORT_DIRECTORY只有一个。下面是其详细定义：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> </span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    DWORD   Characteristics;    <span class="comment">// 未使用，总为0     DWORD   TimeDateStamp;              // 文件创建时间戳</span></div><div class="line">    WORD    MajorVersion;       <span class="comment">// 未使用，总为0     WORD    MinorVersion;               // 未使用，总为0</span></div><div class="line">    DWORD   Name;               <span class="comment">// 指向一个代表此 DLL名字的 ASCII字符串的 RVA</span></div><div class="line">    DWORD   Base;               <span class="comment">// 函数的起始序号</span></div><div class="line">    DWORD   NumberOfFunctions;  <span class="comment">// 导出函数的总数    </span></div><div class="line">    DWORD   NumberOfNames;           <span class="comment">// 以名称方式导出的函数的总数    </span></div><div class="line">    DWORD   AddressOfFunctions;      <span class="comment">// 指向输出函数地址的RVA</span></div><div class="line">    DWORD   AddressOfNames;         <span class="comment">// 指向输出函数名字的RVA</span></div><div class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// 指向输出函数序号的RVA</span></div><div class="line">&#125;IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</div></pre></td></tr></table></figure></p><ul><li>Name:文件最初的文件名</li><li>NumberOfFunctions：导出函数的个数</li><li>NumberOfNmaes：导出函数其中有名字的个数，NumberOfNames的值小于NumberOfFunctions</li><li>AddressOfFunctions：该指针指向的是所有导出函数的入口地址的起始。函数地址顺序按照函数的编号排序。</li><li>Base：导出函数编号得起始值，第一个导出函数的编号不是从0开始的，某个导出函数的编号等于base+AddressOfFunctions的所在编号。</li><li>AddressOfName：该值是一个指针，指向的位置是连续的双字节，这些双字节指向的是函数名字符串的地址。</li><li>AddressOfNameOrdinals：指向的是函数数字编号得地址。</li></ul><h2 id="3-导出表的应用"><a href="#3-导出表的应用" class="headerlink" title="3.导出表的应用"></a>3.导出表的应用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导出表常见的主要应用是<strong>对导出表函数的覆盖</strong>和对<strong>dll文件内部函数的导出</strong>。</p><h3 id="3-1-导出函数覆盖"><a href="#3-1-导出函数覆盖" class="headerlink" title="3.1.导出函数覆盖"></a>3.1.导出函数覆盖</h3><ul><li>修改导出表里面函数的地址。</li><li>覆盖函数地址部分函数代码。</li></ul><h3 id="3-2-导出私有函数"><a href="#3-2-导出私有函数" class="headerlink" title="3.2.导出私有函数"></a>3.2.导出私有函数</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-预备知识&quot;&gt;&lt;a href=&quot;#第一部分-预备知识&quot; class=&quot;headerlink&quot; title=&quot;第一部分 预备知识&quot;&gt;&lt;/a&gt;第一部分 预备知识&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;导入表主要存在于动态链接库文件中，用于将dll文件中的函数导入到外部，给其他的exe或者dll文件调用。我们在导入表一章中知道了程序在装载过程中，&lt;strong&gt;通过在INT获得的函数地址覆盖到IAT中，&lt;/strong&gt;此时，导出表起到了参照和指引的作用。&lt;br&gt;
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows PE》导入表</title>
    <link href="http://yoursite.com/2018/05/09/%E3%80%8Awindows%20PE%E3%80%8B%E5%AF%BC%E5%85%A5%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/05/09/《windows PE》导入表/</id>
    <published>2018-05-09T06:02:11.000Z</published>
    <updated>2018-05-28T10:00:41.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-预备知识"><a href="#第一部分-预备知识" class="headerlink" title="第一部分 预备知识"></a>第一部分 预备知识</h1><h2 id="1-函数导入流程"><a href="#1-函数导入流程" class="headerlink" title="1.函数导入流程"></a>1.函数导入流程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序在引用dll库函数的时候，需要从dll里面对所需要的函数进行导入，该导入过程如下：<br><a id="more"></a></p><ul><li>1.将库函数所需要的参数进行压栈。</li><li>2.call一个近地址的用户领空的函数。<br>  <img src="https://i.imgur.com/vAxQ9Wc.png" alt=""></li><li>3.jmp XXXX到dll内部的系统领空。<br>  <img src="https://i.imgur.com/ceEKp7o.png" alt=""></li></ul><h2 id="2-计算RVA对应的FOA"><a href="#2-计算RVA对应的FOA" class="headerlink" title="2.计算RVA对应的FOA"></a>2.计算RVA对应的FOA</h2><ul><li>查看RVA所落在的节区</li><li>计算偏移offset</li><li>计算在文件中的偏移<br>使用工具（PE或者exeinfope）</li></ul><h2 id="3-代码导入"><a href="#3-代码导入" class="headerlink" title="3.代码导入"></a>3.代码导入</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序需要执行dll相关代码，则相关代码指令必须存在于进程地址空间，也就是说，操作系统在加载的时候会根据导入表的描述将需要调用的函数指令加载到进程空间。但是系统不会重复加载同一个dll库，如果多个进程需要使用同一个dll，通过页面调度机制使得两个进程访问同一个动态数据库。</p><h1 id="第二部分-PE导入表"><a href="#第二部分-PE导入表" class="headerlink" title="第二部分 PE导入表"></a>第二部分 PE导入表</h1><h2 id="1-导入表如何定位"><a href="#1-导入表如何定位" class="headerlink" title="1.导入表如何定位"></a>1.导入表如何定位</h2><ul><li>第一步：利用Pe_View，在IMAGE_OPTIONAL_HEADER中DataDirectotion中的IMPORT Table。<br>  <img src="https://i.imgur.com/FIyhmPt.png" alt=""></li><li>第二歩：利用PEID查看文件各个区段的内存偏移和文件偏移，如上图，IMPORTTable的RVA是5000，通过查看PEID，发现位置正好落在idate段，所以，在文件中的偏移是1400<br>   <img src="https://i.imgur.com/3US7VdD.png" alt=""><br>   <img src="https://i.imgur.com/5hhgfTG.png" alt=""></li></ul><h2 id="2-导入表描述符IMAGE-IMPORT-DESCRIPTOR"><a href="#2-导入表描述符IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="2.导入表描述符IMAGE_IMPORT_DESCRIPTOR"></a>2.导入表描述符IMAGE_IMPORT_DESCRIPTOR</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导入表实际上是一个 IMAGE_IMPORT_DESCRIPTOR 结构数组。导入表数据的起始部分是多组导入表描述符结构。每个结构包含PE文件引入函数的一个相关DLL的信息。比如，如果该PE文件从10个不同的DLL中引入函数，那么这个数组就有10个成员。该数组以一个全0的成员结尾。一下是他的数据结构<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">IMAGE_IMPORT_DESCRIPTOR &#123;  </div><div class="line">    <span class="class"><span class="keyword">union</span> &#123;  </span></div><div class="line">        DWORD Characteristics;  </div><div class="line">        DWORD OriginalFirstThunk;     <span class="regexp">//</span>INT(导入名字表)的地址(RVA)桥<span class="number">1</span>  </div><div class="line">    &#125;;  </div><div class="line">    DWORD TimeDateStamp;     <span class="regexp">//</span>时间戳</div><div class="line">    DWORD ForwarderChain;    <span class="regexp">//</span>链表的前一个结构</div><div class="line">    DWORD Name;              <span class="regexp">//</span>指向链接库的指针  </div><div class="line">    DWORD FirstThunk;        <span class="regexp">//</span>(IAT)导入地址表的地址 (RVA)桥<span class="number">2</span>  </div><div class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</div></pre></td></tr></table></figure></p><h2 id="3-导入表的双桥结构"><a href="#3-导入表的双桥结构" class="headerlink" title="3.导入表的双桥结构"></a>3.导入表的双桥结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个结构IMAGE_IMPORT_DESCRIPTOR都对应的是一个唯一的dll文件。以及dll中的每个函数都可以通过”编号-名称”的方式找到，这就是导入表的双桥结构。如下图尽管这个桥对应的INT和IAT的内容是相同的，但是其存储的位置是不同的。<br>    <img src="https://i.imgur.com/pNn2oXb.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OriginalFirstThun指向的数组中每一项为一个结构，此结构的名称是IMAGE_THUNK_DATA。该结构实际上只是一个双字，但在不同的时刻却拥有不同的解释。该字段有两种解释：这个值是INT的地址，INT（Import Name Table）是一个存储了库文件函数名称的表。在装载的时候，PE装载器读取OriginalFirstThun获得INT，然后通过函数名称去获取函数的地址</p><ul><li>双字最高位为0，表示导入符号是一个数值，该数值是一个RVA。</li><li>双字最高位为1，表示导入符号是一个名称。<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct _IMAGE_IMPORT_BY_NAME &#123;  </div><div class="line">    <span class="type">WORD</span> <span class="type">Hint</span>;        //对dll中的每个函数进行标号，该值不是必须的</div><div class="line">    <span class="type">BYTE</span> <span class="type">Name</span>[1];     //函数名称  </div><div class="line">&#125; <span class="type">IMAGE_IMPORT_BY_NAME</span>, *<span class="type">PIMAGE_IMPORT_BY_NAME</span>;</div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FirstThunk指向的是IAT表，也是IMAGE_THUNK_DATA，但是对于程序的装载，并不使用IAT进行函数的寻址，在通过INT寻址之后，将找到的地址填充到IAT中。后期需要用到函数的时候，可以使用GetProcAddressAPI函数进行获取。</p><h2 id="4-导入函数地址表-IAT"><a href="#4-导入函数地址表-IAT" class="headerlink" title="4.导入函数地址表(IAT)"></a>4.导入函数地址表(IAT)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导入函数地址表位于数据目录的第十三个目录。用户程序通过该表的jmp指令无条件跳转到dll函数的VA处。因为该表中存着<strong>同一个dll</strong>不同的函数的VA地址，所以每个函数地址都是以”00”作为区分的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导入表和导入地址表是由紧密联系的。通过桥2可以定位到程序的IAT。在内存中，桥1可以找到<strong>调用函数的名称和函数的标号。</strong>桥2可以找到该函数指令代码在<strong>内存空间的地址</strong></p><h2 id="5-程序的装载过程。"><a href="#5-程序的装载过程。" class="headerlink" title="5.程序的装载过程。"></a>5.程序的装载过程。</h2><ul><li>第一步：PE加载器读取结构体成员的值，IMAGE_IMPORT_DESCRIPTOR.Name成员找到库名称，然后将库文件加载到内存中来。</li><li>第二歩：PE加载器读取OriginalFirstThunk值获得INT地址，然后依次读取INT各项的值，根据函数的标号获取函数的地址。</li><li>第三步：将获取的函数的地址填充到IAT表中。</li></ul><h1 id="第三部分：绑定导入"><a href="#第三部分：绑定导入" class="headerlink" title="第三部分：绑定导入"></a>第三部分：绑定导入</h1><h2 id="1-绑定导入机制"><a href="#1-绑定导入机制" class="headerlink" title="1.绑定导入机制"></a>1.绑定导入机制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windows在装载程序的时候，PE装载器负责对IAT中的地址进行修正工作。绑定导入的目的在于使用软件或者人工的方法，<strong>在程序装载之前，修正IAT表内的函数地址，</strong>从而提高加载数据。同样的，微软在引入绑定导入机制也考虑到了由于各种原因导致dll没有加载到目标地址，所以同时引入了<strong>错误检测机制</strong>，如果检测到此类错误，PE加载器则会接管IAT修正工作。加载器遍历INT，计算新的函数地址，由于同时要用道INT和IAT，<strong>所以：单桥结构无法使用静态绑定机制。</strong></p><h2 id="2-绑定导入表的定位和其数据结构"><a href="#2-绑定导入表的定位和其数据结构" class="headerlink" title="2.绑定导入表的定位和其数据结构"></a>2.绑定导入表的定位和其数据结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绑定地址表位于数据目录的第十二的项目，利用RVA-FOA转化，可以定位到文件在绑定导入表的地址。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绑定导入数据由IMAGE_BOUND_IMPORT_DESCRIPTOR结构组成，每个模块拥有一个该结构。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">IMAGE_BOUND_IMPORT_DESCRIPTOR struct</div><div class="line">&#123;</div><div class="line">TimeDateStamp <span class="comment">;时间戳</span></div><div class="line">    OffsetDllNmae  <span class="comment">;指向dll'的名称，</span></div><div class="line">    NumberOfModuleForWarderRefs   <span class="comment">;ModuleForWarderRefs数目</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>NumberOfModuleForWarderRefs描述的是IMAGE_BOUND_ModuleForWarderRefs结构体的数目，该结构体存在的原因是<strong>为了让dll模块保持向前兼容，使得模块继续保持原来函数的定义</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-预备知识&quot;&gt;&lt;a href=&quot;#第一部分-预备知识&quot; class=&quot;headerlink&quot; title=&quot;第一部分 预备知识&quot;&gt;&lt;/a&gt;第一部分 预备知识&lt;/h1&gt;&lt;h2 id=&quot;1-函数导入流程&quot;&gt;&lt;a href=&quot;#1-函数导入流程&quot; class=&quot;headerlink&quot; title=&quot;1.函数导入流程&quot;&gt;&lt;/a&gt;1.函数导入流程&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;程序在引用dll库函数的时候，需要从dll里面对所需要的函数进行导入，该导入过程如下：&lt;br&gt;
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令(3)软件包管理</title>
    <link href="http://yoursite.com/2018/05/07/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(3)%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/07/Linux常见命令(3)软件包管理/</id>
    <published>2018-05-07T07:02:11.000Z</published>
    <updated>2018-06-09T09:28:32.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-软件包管理简介"><a href="#第一部分-软件包管理简介" class="headerlink" title="第一部分 软件包管理简介"></a>第一部分 软件包管理简介</h1><h2 id="apt-管理软件包"><a href="#apt-管理软件包" class="headerlink" title="apt :管理软件包"></a>apt :管理软件包</h2><ul><li>apt [选项] [packagename]、<ul><li>apt-cache search packagename:搜索软件包<br><img src="https://i.imgur.com/18SSiEf.png" alt=""></li><li>apt-cache show packagename：显示软件包的信息<br><img src="https://i.imgur.com/7wW91NW.png" alt=""></li><li>sudo apt-get install packagename :安装软件<br><img src="https://i.imgur.com/XBO502b.png" alt=""></li><li>sudo apt-get install –reinstall packagename:重新安装软件<a id="more"></a><img src="https://i.imgur.com/7aUdrXq.png" alt=""></li><li>sudo apt-get remove packagename 删除包/卸载软件<br><img src="https://i.imgur.com/tkxvwEg.png" alt=""></li><li>sudo apt-get remove package –purge 删除包，包括删除配置文件等</li><li>sudo apt-get autoremove packagename 自动卸载软件但保留其配置文件</li><li>sudo apt-get -f install packagename:修复安装<br><img src="https://i.imgur.com/Rm6Wh66.png" alt=""></li><li>sudo apt-get update:更新源<br><img src="https://i.imgur.com/9Ecj4j7.png" alt=""></li><li>sudo apt-get upgrade:更新所有软件<br><img src="https://i.imgur.com/1wfzSk5.png" alt=""></li></ul></li></ul><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><ul><li>获取tar.gz源文件</li><li>tar -zxvf xxx.tar.gz 解压tar文件</li><li>./configure —&gt;makefile</li><li>make 编译</li><li>make install</li><li>service fuwu start:开启服务</li><li>/etc/init.d/fuwu start</li><li>测试：看进程</li><li>服务配置</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-软件包管理简介&quot;&gt;&lt;a href=&quot;#第一部分-软件包管理简介&quot; class=&quot;headerlink&quot; title=&quot;第一部分 软件包管理简介&quot;&gt;&lt;/a&gt;第一部分 软件包管理简介&lt;/h1&gt;&lt;h2 id=&quot;apt-管理软件包&quot;&gt;&lt;a href=&quot;#apt-管理软件包&quot; class=&quot;headerlink&quot; title=&quot;apt :管理软件包&quot;&gt;&lt;/a&gt;apt :管理软件包&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;apt [选项] [packagename]、&lt;ul&gt;
&lt;li&gt;apt-cache search packagename:搜索软件包&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/18SSiEf.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;apt-cache show packagename：显示软件包的信息&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/7wW91NW.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;sudo apt-get install packagename :安装软件&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/XBO502b.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;sudo apt-get install –reinstall packagename:重新安装软件
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows PE》PE文件头</title>
    <link href="http://yoursite.com/2018/05/07/%E3%80%8Awindows%20PE%E3%80%8BPE%E6%96%87%E4%BB%B6%E5%A4%B4/"/>
    <id>http://yoursite.com/2018/05/07/《windows PE》PE文件头/</id>
    <published>2018-05-07T06:02:11.000Z</published>
    <updated>2018-05-07T07:46:14.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-预备知识"><a href="#第一部分-预备知识" class="headerlink" title="第一部分 预备知识"></a>第一部分 预备知识</h1><h2 id="四类地址"><a href="#四类地址" class="headerlink" title="四类地址"></a>四类地址</h2><ul><li>虚拟地址（VA）</li><li>相对虚拟内存地址（RVA）</li><li>文件偏移地址（FOA）</li><li>特殊地址<a id="more"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟地址：PE文件被加载到内存，PE对应的进程拥有了4GB的空间，这个空间存在的地址就是虚拟地址。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对虚拟地址：相对与基地址的偏移量，RVA的存在是由于dll（模块）的基地址的不同而产生的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件偏移地址：文件中某个位置距离文件头的偏移量。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特殊位置，不细考究。</li></ul><h2 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据目录记录的是整个PE结构中存在的数据类型。</p><h2 id="节"><a href="#节" class="headerlink" title="节"></a>节</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节就是存放不同的类型的数据，不同的节区有不同的访问权限。</p><h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><ul><li>内存对齐</li><li>文件对齐</li><li>资源数据对齐<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存对齐：windows中，内存属性的基本单位是页，在32位系统是4KB(1000h)，在64位系统中是8kb。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件对齐：为了提高磁盘利用率，把一个物理扇区作为一个对齐粒度的大小，也就是12字节（200H）,这是每个数据段都是200H的整数倍的原因。<br><img src="/home/findream/桌面/QQ截图20180507125335.png" alt=""> </li></ul><h1 id="第二部分-32位windows系统的PE结构"><a href="#第二部分-32位windows系统的PE结构" class="headerlink" title="第二部分 32位windows系统的PE结构"></a>第二部分 32位windows系统的PE结构</h1><h2 id="定位标准的PE头"><a href="#定位标准的PE头" class="headerlink" title="定位标准的PE头"></a>定位标准的PE头</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于DOS stub是一个不确定的长度，所以导致DOS头也是一个不确定的长度，这时候，<strong>我们采用e_lfanew字段来定位后续的PE结构位置。该字段是一个偏移量。</strong>PE头的定位遵循一下公式：PE_Start=DOS_MZ+IMAGE_HANDER.e_lfanew.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PE文件结构:<br><img src="http://oxnvtxe03.bkt.clouddn.com/2018-05-07%2013-09-51%20%E5%88%9B%E5%BB%BA%E7%9A%84%E6%88%AA%E5%9B%BE.png" alt=""> </p><h1 id="第三部分-PE文件头部解析"><a href="#第三部分-PE文件头部解析" class="headerlink" title="第三部分 PE文件头部解析"></a>第三部分 PE文件头部解析</h1><h2 id="DOS-MZ头"><a href="#DOS-MZ头" class="headerlink" title="DOS MZ头"></a>DOS MZ头</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MZ头下有两个需要知道的成员。一个是<strong>e_magic</strong> ,一个是<strong>e_lfanew</strong></p><h2 id="PE头标志-Signature"><a href="#PE头标志-Signature" class="headerlink" title="PE头标志 Signature"></a>PE头标志 Signature</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signature标志位于DOS_STUB之后，该标志位于e_lfanew所指向的位置。内容固定，对应的ASCII是”PE\0\0”。<br><img src="http://oxnvtxe03.bkt.clouddn.com/2018-05-07%2013-33-18%20%E5%88%9B%E5%BB%BA%E7%9A%84%E6%88%AA%E5%9B%BE.png" alt=""> </p><h2 id="标准PE头-IMAGE-FILE-HEADER"><a href="#标准PE头-IMAGE-FILE-HEADER" class="headerlink" title="标准PE头 IMAGE_FILE_HEADER"></a>标准PE头 IMAGE_FILE_HEADER</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;位置：在PE文件头标志的后面，位于e_lfanew+4的位置。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大小：占据了20个字节。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：他记录了PE文件的全局属性（运行的平台，PE文件的类型，文件中存在的节区总数）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是FILE_HEADER的成员信息：<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">        WORD    Machine;     <span class="comment">//运行平台</span></div><div class="line">        WORD    NumberOfSections;     <span class="comment">//节区数量</span></div><div class="line">        DWORD   TimeDateStamp;        <span class="comment">//创建时间</span></div><div class="line">        DWORD   PointerToSymbolTable;    <span class="comment">//指向符号表</span></div><div class="line">        DWORD   NumberOfSymbols;     <span class="comment">//符号表符号数</span></div><div class="line">        WORD    SizeOfOptionalHeader;    <span class="comment">//拓展头长度</span></div><div class="line">        WORD    Characteristics;        <span class="comment">//文件属性</span></div><div class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</div></pre></td></tr></table></figure></p><ul><li>Machime:该文件的运行平台，是x86、x64还是I64等等，可以是下面值里的某一个。</li><li>TimeDateStamp：PE文件的创建时间，一般有连接器填写</li><li>NumberOfSections：该PE文件中有多少个节，也就是节表中的项数</li><li>SizeOfOptionalHeader：紧随其后的可选头的大小。</li></ul><h2 id="拓展PE头IMAGE-OPTIONAL-HEADER32"><a href="#拓展PE头IMAGE-OPTIONAL-HEADER32" class="headerlink" title="拓展PE头IMAGE_OPTIONAL_HEADER32"></a>拓展PE头IMAGE_OPTIONAL_HEADER32</h2><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> </span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">        <span class="comment">// Standard fields.        </span></div><div class="line">        WORD    Magic;              <span class="comment">// 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）   </span></div><div class="line">        BYTE    MajorLinkerVersion;     <span class="comment">// 链接程序的主版本号   </span></div><div class="line">        BYTE    MinorLinkerVersion;     <span class="comment">// 链接程序的次版本号   </span></div><div class="line">        DWORD   SizeOfCode;         <span class="comment">// 所有含代码的节的总大小   </span></div><div class="line">        DWORD   SizeOfInitializedData;          <span class="comment">// 所有含已初始化数据的节的总大小   </span></div><div class="line">        DWORD   SizeOfUninitializedData;        <span class="comment">// 所有含未初始化数据的节的大小   </span></div><div class="line">        DWORD   AddressOfEntryPoint;        <span class="comment">// 程序执行入口RVA   </span></div><div class="line">        DWORD   BaseOfCode;         <span class="comment">// 代码的区块的起始RVA   </span></div><div class="line">        DWORD   BaseOfData;         <span class="comment">// 数据的区块的起始RVA   </span></div><div class="line">        <span class="comment">// NT additional fields.    以下是属于NT结构增加的领域。   </span></div><div class="line">        DWORD   ImageBase;          <span class="comment">// 程序的首选装载地址   </span></div><div class="line">        DWORD   SectionAlignment;       <span class="comment">// 内存中的区块的对齐大小   </span></div><div class="line">        DWORD   FileAlignment;          <span class="comment">// 文件中的区块的对齐大小   </span></div><div class="line">        WORD    MajorOperatingSystemVersion;    <span class="comment">// 要求操作系统最低版本号的主版本号   </span></div><div class="line">        WORD    MinorOperatingSystemVersion;    <span class="comment">// 要求操作系统最低版本号的副版本号   </span></div><div class="line">        WORD    MajorImageVersion;      <span class="comment">// 可运行于操作系统的主版本号   </span></div><div class="line">        WORD    MinorImageVersion;      <span class="comment">// 可运行于操作系统的次版本号   </span></div><div class="line">        WORD    MajorSubsystemVersion;      <span class="comment">// 要求最低子系统版本的主版本号   </span></div><div class="line">        WORD    MinorSubsystemVersion;      <span class="comment">// 要求最低子系统版本的次版本号   </span></div><div class="line">        DWORD   Win32VersionValue;      <span class="comment">// 莫须有字段，不被病毒利用的话一般为0   </span></div><div class="line">        DWORD   SizeOfImage;            <span class="comment">// 映像装入内存后的总尺寸   </span></div><div class="line">        DWORD   SizeOfHeaders;          <span class="comment">// 所有头+ 区块表的尺寸大小   </span></div><div class="line">        DWORD   CheckSum;           <span class="comment">// 映像的校检和   </span></div><div class="line">        WORD    Subsystem;          <span class="comment">// 可执行文件期望的子系统   </span></div><div class="line">        WORD    DllCharacteristics;     <span class="comment">// DllMain()函数何时被调用，默认为0   </span></div><div class="line">        DWORD   SizeOfStackReserve;     <span class="comment">// 初始化时的栈大小   </span></div><div class="line">        DWORD   SizeOfStackCommit;      <span class="comment">// 初始化时实际提交的栈大小   </span></div><div class="line">        DWORD   SizeOfHeapReserve;      <span class="comment">// 初始化时保留的堆大小   </span></div><div class="line">        DWORD   SizeOfHeapCommit;       <span class="comment">// 初始化时实际提交的堆大小   </span></div><div class="line">        DWORD   LoaderFlags;            <span class="comment">// 与调试有关，默认为0    </span></div><div class="line">        DWORD   NumberOfRvaAndSizes;        <span class="comment">// 下边数据目录的项数，这个字段自Windows NT 发布以来 一直是16   </span></div><div class="line">        IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];   <span class="comment">// 数据目录表   </span></div><div class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要我们熟悉的是以下几个成员。</p><ul><li>AddressOfEntryPoint;        // 程序执行入口RVA</li><li>BaseOfCode;         // 代码的区块的起始RVA </li><li>DWORD   ImageBase;          // 程序的首选装载地址</li><li>SectionAlignment;       // 内存中的区块的对齐大小</li><li>FileAlignment;          // 文件中的区块的对齐大小</li><li>SizeOfImage;            // 映像装入内存后的总尺寸</li><li>DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];   // 数据目录表</li></ul><h2 id="IMAGE-NT-HEADERS"><a href="#IMAGE-NT-HEADERS" class="headerlink" title="IMAGE_NT_HEADERS"></a>IMAGE_NT_HEADERS</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包括三个部分组成：PE头标志，IMAGE_FILE_HEADER,IMAGE_OPTIOANAL_HEADER.</p><h2 id="数据目录项-IMAGE-DATA-DIRECTORY"><a href="#数据目录项-IMAGE-DATA-DIRECTORY" class="headerlink" title="数据目录项 IMAGE_DATA_DIRECTORY"></a>数据目录项 IMAGE_DATA_DIRECTORY</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NT3.1开始，数据目录一共有16种，使用IMAGE_DATA_DIRECTORY来定义每种数据。<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct _IMAGE_DATA_DIRECTORY &#123;</div><div class="line">        <span class="type">DWORD</span>　<span class="type">VirtualAddress</span>; //相对虚拟地址  </div><div class="line">        <span class="type">DWORD</span>　<span class="type">Size</span>;　　　　　 //大小  </div><div class="line">&#125; <span class="type">IMAGE_DATA_DIRECTORY</span>, *<span class="type">PIMAGE_DATA_DIRECTORY</span>;</div></pre></td></tr></table></figure></p><p>##节表项IMAGE_SECTION_HEADER<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">typedef struct _IMAGE_SECTION_HEADER </div><div class="line">&#123;</div><div class="line">  <span class="keyword">BYTE </span> Name[IMAGE_SIZEOF_SHORT_NAME]<span class="comment">;//节区名称</span></div><div class="line">  union &#123;</div><div class="line">    DWORD PhysicalAddress<span class="comment">;</span></div><div class="line">    DWORD VirtualSize<span class="comment">;    //节区大小</span></div><div class="line">  &#125; Misc<span class="comment">;</span></div><div class="line">  DWORD VirtualAddress<span class="comment">;       //节区的RVA</span></div><div class="line">  DWORD SizeOfRawData<span class="comment">;      //在文件中对齐的尺寸</span></div><div class="line">  DWORD PointerToRawData<span class="comment">;   //在文件中的偏移</span></div><div class="line">  DWORD PointerToRelocations<span class="comment">;    //指向重定位表的指针</span></div><div class="line"> DWORD PointerToLinenumbers<span class="comment">;</span></div><div class="line">  WORD  NumberOfRelocations<span class="comment">;     //重定位表的数目</span></div><div class="line">  WORD  NumberOfLinenumbers<span class="comment">;</span></div><div class="line">  DWORD Characteristics<span class="comment">;       //节区表的属性</span></div><div class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER<span class="comment">;</span></div></pre></td></tr></table></figure></p><h1 id="第三部分-详细解析PE文件头字段"><a href="#第三部分-详细解析PE文件头字段" class="headerlink" title="第三部分 详细解析PE文件头字段"></a>第三部分 详细解析PE文件头字段</h1><h2 id="IMAGE-FILE-HEADER字段"><a href="#IMAGE-FILE-HEADER字段" class="headerlink" title="IMAGE_FILE_HEADER字段"></a>IMAGE_FILE_HEADER字段</h2><ul><li>Machine:<ul><li>位置：+0004H,</li><li>大小：单字</li><li>作用：查看文件可以在那种机器上运行。</li></ul></li><li>NumberOfSection：<ul><li>位置：+0006h</li><li>大小：单字</li><li>作用：文件中存在的节区的数目，数值不能小于1，但是节区数可以为0.</li></ul></li><li>TimeDateStamp <ul><li>位置：+0008h</li><li>大小：双字</li><li>作用：编译时间，压缩时被修改。</li></ul></li><li>SizeofOptionalHeader<ul><li>位置：+0014h</li><li>大小：单字</li><li>作用：指向的是OptionalHeader的大小。默认是00e0H，在64位是00f0H</li></ul></li><li>Character<ul><li>位置：+0016h</li><li>大小：单字</li><li>作用：标志这PE文件的类型，如果这个值是010fh的话，表示这是一个EXE文件，如果值是210eh，表示这个值是DLL文件。</li></ul></li></ul><h2 id="IMAGE-OPTIONAL-HEADER字段"><a href="#IMAGE-OPTIONAL-HEADER字段" class="headerlink" title="IMAGE_OPTIONAL_HEADER字段"></a>IMAGE_OPTIONAL_HEADER字段</h2><ul><li>Magic：表示该文件的类型：如果是010Bh，表示文件是32位，如果是0107H，表示文件是ROM，如果是020BH，表示文件是64位PE</li><li>AddressOfEntryPoint ：表示启动代码距离PE加载后的初始位置的偏移量，如果病毒需要在程序中启动恶意代码，则需要修改这一成员的数值。但是对于DLL文件，这一成员你的数值为0，因为不存在入口点。</li><li>BaseOfCode：代码段的起始RVA，但是不一定是程序的入口点。</li><li>ImageBase：PE文件的加载基地址。exe文件通常是00400000.</li><li>SizeOfImade：表示内存中整个PE文件的映射尺寸。</li><li>DllCharacteristics：DLL文件属性，但是不单纯是针对DLL文件，对于所有PE文件同样有效。</li><li>DataDirectory：目录数据，表示不同的节区的基本属性（RVA和size）。</li></ul><h2 id="IMAGE-SECTION-HEADER"><a href="#IMAGE-SECTION-HEADER" class="headerlink" title="IMAGE_SECTION_HEADER"></a>IMAGE_SECTION_HEADER</h2><ul><li>Name[IMAGE_SIZEOF_SHORT_NAME]： 八个字节的节去名称。</li><li>VirtualAddress：节区的RVA</li><li>SizeOfRAWDATA：节区对齐后的尺寸</li><li>PointOfRAWDATA：节区数据在文件中的偏移量。</li><li>PointerToRelocations：重定位表的指针</li><li>NumberOfRelocations：重定位表的数目</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-预备知识&quot;&gt;&lt;a href=&quot;#第一部分-预备知识&quot; class=&quot;headerlink&quot; title=&quot;第一部分 预备知识&quot;&gt;&lt;/a&gt;第一部分 预备知识&lt;/h1&gt;&lt;h2 id=&quot;四类地址&quot;&gt;&lt;a href=&quot;#四类地址&quot; class=&quot;headerlink&quot; title=&quot;四类地址&quot;&gt;&lt;/a&gt;四类地址&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;虚拟地址（VA）&lt;/li&gt;
&lt;li&gt;相对虚拟内存地址（RVA）&lt;/li&gt;
&lt;li&gt;文件偏移地址（FOA）&lt;/li&gt;
&lt;li&gt;特殊地址
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>看雪2017CTF</title>
    <link href="http://yoursite.com/2018/05/05/%E7%9C%8B%E9%9B%AACTF2017/"/>
    <id>http://yoursite.com/2018/05/05/看雪CTF2017/</id>
    <published>2018-05-05T03:00:11.000Z</published>
    <updated>2018-05-07T07:45:17.277Z</updated>
    
    <content type="html"><![CDATA[<p>这是看雪2017的CTF的题目，这套题目当时只做出了一题，现在继续做，同样还是根据WP，不断的学习，不断的进步，在现在安全圈子里面浮躁的大背景下，感谢看雪论坛仍然不忘初心，为我们保留了这一块儿净土。<br><a id="more"></a></p><h2 id="Problem-1：-Helllo-CTF"><a href="#Problem-1：-Helllo-CTF" class="headerlink" title="Problem 1： Helllo-CTF"></a>Problem 1： Helllo-CTF</h2><p>首先，使用OD查看字符串，定位到4017F0。<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">00401831 </span> |.  <span class="number">8</span>B4D F8       mov ecx,[local.<span class="number">2</span>]</div><div class="line"><span class="symbol">00401834 </span> |.  <span class="number">51</span>            push ecx                                  ; /s</div><div class="line"><span class="symbol">00401835 </span> |.  E8 <span class="number">5</span>C060000   <span class="keyword">call</span> &lt;jmp.&amp;MSVCRT.strlen&gt;                 ; \strlen</div><div class="line"><span class="number">0040183</span>A  |.  <span class="number">83</span>C4 <span class="number">04</span>       add esp,<span class="number">0</span>x4                               ;  保证有输入</div><div class="line"><span class="number">0040183D</span>  |.  <span class="number">85</span>C0          test eax,eax</div><div class="line"><span class="number">0040183</span>F  |.  <span class="number">75</span> <span class="number">13</span>         jnz Xhello.<span class="number">00401854</span></div><div class="line"><span class="symbol">00401841 </span> |.  <span class="number">6</span>A <span class="number">00</span>         push <span class="number">0</span>x0</div><div class="line"><span class="symbol">00401843 </span> |.  <span class="number">6</span>A <span class="number">00</span>         push <span class="number">0</span>x0</div><div class="line"><span class="symbol">00401845 </span> |.  <span class="number">68</span> <span class="number">98354000</span>   push hello.<span class="number">00403598</span>                       ;  请输入pass!</div><div class="line"><span class="number">0040184</span>A  |.  <span class="number">8</span>B4D FC       mov ecx,[local.<span class="number">1</span>]</div><div class="line"><span class="number">0040184D</span>  |.  E8 C0050000   <span class="keyword">call</span> &lt;jmp.&amp;MFC42.#<span class="number">4224</span>&gt;</div><div class="line"><span class="symbol">00401852 </span> |.  EB <span class="number">21</span>         jmp Xhello.<span class="number">00401875</span></div><div class="line"><span class="symbol">00401854 </span> |&gt;  <span class="number">68</span> <span class="number">80354000</span>   push hello.<span class="number">00403580</span>                       ; /WelcomeToKanXueCtf2017</div><div class="line"><span class="symbol">00401859 </span> |.  <span class="number">8</span>B55 F8       mov edx,[local.<span class="number">2</span>]                         ; |</div><div class="line"><span class="number">0040185</span>C  |.  <span class="number">52</span>            push edx                                  ; |s1</div><div class="line"><span class="number">0040185D</span>  |.  E8 <span class="number">2E060000</span>   <span class="keyword">call</span> &lt;jmp.&amp;MSVCRT.strcmp&gt;                 ; \strcmp</div><div class="line"><span class="symbol">00401862 </span> |.  <span class="number">83</span>C4 <span class="number">08</span>       add esp,<span class="number">0</span>x8                               ;  比较</div><div class="line"><span class="symbol">00401865 </span> |.  <span class="number">85</span>C0          test eax,eax</div></pre></td></tr></table></figure></p><p>第一个函数是比较成功的，第二个函数比较失败的<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">00401867 </span> |. /<span class="number">75</span> <span class="number">07</span>         jnz Xhello.<span class="number">00401870</span>   </div><div class="line"><span class="symbol">00401869 </span> |. |E8 <span class="number">02</span>FFFFFF   <span class="keyword">call</span> hello.<span class="number">00401770</span>     //比较成功</div><div class="line"><span class="number">0040186E</span>  |. |EB <span class="number">05</span>         jmp Xhello.<span class="number">00401875</span></div><div class="line"><span class="symbol">00401870 </span> |&gt; \E8 <span class="number">3</span>BFFFFFF   <span class="keyword">call</span> hello.<span class="number">004017</span>B0     //比较失败</div></pre></td></tr></table></figure></p><h2 id="Problem-2：ctf2017-Fpc"><a href="#Problem-2：ctf2017-Fpc" class="headerlink" title="Problem 2：ctf2017_Fpc"></a>Problem 2：ctf2017_Fpc</h2><p>首先了解一下作者对于这次CM的布局。作者利用scanf的不安全性，精心构造了一个栈溢出的漏洞。我们先来看看这个漏洞的形成机制。</p><ul><li>scanf的缓冲区大小是12个字节。<br>  <img src="https://i.imgur.com/0k44sZm.png" alt=""></li><li><p>如果我们输入的缓冲区大小小于12个字节的话</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0019</span>FF2C   <span class="number">0041</span>B08C  ASCII <span class="string">"%s"</span></div><div class="line"><span class="number">0019</span>FF30   <span class="number">0019</span>FF34  ASCII <span class="string">"123456"</span></div><div class="line"><span class="number">0019</span>FF34   <span class="number">34333231</span></div><div class="line"><span class="number">0019</span>FF38   <span class="number">00003635</span></div><div class="line"><span class="number">0019</span>FF3C   <span class="number">0040100</span>A  返回到 ctf2017_<span class="number">.0040100</span>A 来自 ctf2017_<span class="number">.00413</span>D42</div></pre></td></tr></table></figure></li><li><p>如果等于12个字节的话，返回到scanf函数的下一个地址。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0019</span>FF30   <span class="number">0019</span>FF34  ASCII <span class="string">"123456789ABC"</span></div><div class="line"><span class="number">0019</span>FF34   <span class="number">34333231</span></div><div class="line"><span class="number">0019</span>FF38   <span class="number">38373635</span></div><div class="line"><span class="number">0019</span>FF3C   <span class="number">43424139</span></div><div class="line"><span class="number">0019</span>FF40   <span class="number">00401000</span>  入口地址</div></pre></td></tr></table></figure></li><li><p>如果大于12个字节，超过的字节覆盖返回地址，产生栈溢出漏洞</p></li></ul><p>其次，出题人给出的栈溢出的溢出部分，利用OD或者IDA无法识别成代码的部分，因为反汇编器不可能去识别不加使用的部分为代码，所以这部分会被识别为数据。如图2.2，所以溢出函数在413131这个地址。我们可以得出结论，验证码是XXXXXXXXXXXX11A。<br>    <img src="https://i.imgur.com/j8DJrfd.png" alt=""></p><p>溢出后，发现存在很多花指令。利用OD去跟踪吧。根据多次run跟踪得出以下结论<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">(A-B)</span>*<span class="number">4</span>+A+C=<span class="number">0</span>xEAF<span class="number">917</span>E<span class="number">2</span></div><div class="line"><span class="comment">(A-B)</span>*<span class="number">2</span>+<span class="comment">(A-B)</span>+A+C=<span class="number">0</span>xE<span class="number">8</span>F<span class="number">508</span>C<span class="number">8</span></div><div class="line"><span class="comment">(A-B)</span>*<span class="number">2</span>+<span class="comment">(A-B)</span>+A-C=<span class="number">0</span>xC<span class="number">0</span>A<span class="number">3</span>C<span class="number">68</span></div></pre></td></tr></table></figure></p><p>解得：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">A</span> = <span class="number">0</span>x7473754A</div><div class="line"><span class="attr">B</span> = <span class="number">0</span>x726f6630</div><div class="line"><span class="attr">C</span> = <span class="number">0</span>x6E756630</div></pre></td></tr></table></figure></p><p>小端序显示：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Just<span class="number">0</span>for<span class="number">0</span>fu<span class="symbol">n11</span>A</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是看雪2017的CTF的题目，这套题目当时只做出了一题，现在继续做，同样还是根据WP，不断的学习，不断的进步，在现在安全圈子里面浮躁的大背景下，感谢看雪论坛仍然不忘初心，为我们保留了这一块儿净土。&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令(2)常用命令</title>
    <link href="http://yoursite.com/2018/04/28/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(2)%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/04/28/Linux常见命令(2)其他命令/</id>
    <published>2018-04-28T07:02:11.000Z</published>
    <updated>2018-05-07T09:11:02.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-帮助"><a href="#第一部分-帮助" class="headerlink" title="第一部分 帮助"></a>第一部分 帮助</h1><ul><li>man [命令] /info<ul><li>/ [查询的内容] 查询指定的字符串</li><li>man [配置文件名称] ：显示配置文件的作用。如果直接加绝对路径，显示的是配置文件的内容</li><li>有文件的帮助信息，也有配置文件的帮助信息。如果是man 5 [命令] 查看的是配置文件的帮助信息，如果是man 1 [命令] 显示的是命令的帮助信息【见linux(1) whereis命令】<br><img src="https://i.imgur.com/Z4tFW44.png" alt=""></li></ul></li><li>whatis [命令] ：显示命令作用（简略）//whereis [命令]<br>   <img src="https://i.imgur.com/dzVbLlm.png" alt=""></li><li>apropos [配置文件] ：显示配置文件的作用<br>   <img src="https://i.imgur.com/eoAu5q7.png" alt=""></li><li>命令 -h(–help)</li><li>help [命令] shell内置命令的帮助信息（shell编程中的命令）<ul><li>也可以查看命令的路径<br><img src="https://i.imgur.com/glgYvQ4.png" alt=""><br><img src="https://i.imgur.com/D9fufqV.png" alt=""><a id="more"></a><h1 id="第二部分-用户管理"><a href="#第二部分-用户管理" class="headerlink" title="第二部分 用户管理"></a>第二部分 用户管理</h1></li></ul></li><li>useradd [用户名]  添加用户</li><li>passwd [用户名]   为用户设置密码.</li><li>who 查看当前用户名(tty 本地登录 pts 远程登录)<br>  <img src="https://i.imgur.com/FkdVmdl.png" alt=""></li><li>w 登录用户和登录时间等具体信息<br>  <img src="https://i.imgur.com/S2Mfc4m.png" alt=""></li><li>usermod [选项] [用户ID]<ul><li>-g&lt;群组&gt;：修改用户所属的群组；</li><li>-G&lt;群组&gt;；修改用户所属的附加群组；</li><li>-l&lt;帐号名称&gt;：修改用户帐号名称；</li><li>-L：锁定用户密码，使密码无效；</li><li>-u<uid>：修改用户ID；</uid></li><li></li></ul></li></ul><h1 id="第三部分-压缩解压"><a href="#第三部分-压缩解压" class="headerlink" title="第三部分 压缩解压"></a>第三部分 压缩解压</h1><ul><li>gzip [文件名] ：压缩文件<strong>(只能压缩文件)，并且不保存源文件</strong><br>  <img src="https://i.imgur.com/Gs5rCP3.png" alt=""><ul><li>gunzip /(gzip -d) [压缩文件]：解压缩<br><img src="https://i.imgur.com/5NsHzrX.png" alt=""></li></ul></li><li>tar [选项] [压缩文件名] [目录]  <strong> 针对目录</strong><ul><li>-c 打包    //zcf（选项有顺序关系）</li><li>-v 显示详细信息</li><li>-f 指定文件名</li><li>-z 打包同时压缩<br><img src="https://i.imgur.com/v7PdOkl.png" alt=""></li><li>-cjf 生成 tar.bz2文件</li></ul></li><li>tar<ul><li>-x 解包 [压缩文件]</li><li>-z 解压缩</li><li>其他和压缩一样<br><img src="https://i.imgur.com/3e80H8u.png" alt=""></li><li>-xjf 解压tar.bz2压缩包</li></ul></li><li>zip [选项] [压缩文件] [带压缩文件]<ul><li>-r 压缩目录<br><img src="https://i.imgur.com/r5X4HCj.png" alt=""></li><li>unzip [压缩文件]   解压缩<br><img src="https://i.imgur.com/lbO9Oro.png" alt=""></li></ul></li><li>bzip2 [选项] [带压缩文件]<ul><li>-k 保存源文件<br><img src="https://i.imgur.com/83BBAso.png" alt=""></li><li>压缩比大</li></ul></li><li>bunzip2 [选项] [压缩文件]<ul><li>-k 是否保存压缩包</li></ul></li></ul><h1 id="第四部分-网络命令"><a href="#第四部分-网络命令" class="headerlink" title="第四部分 网络命令"></a>第四部分 网络命令</h1><ul><li>ping 测试网络通畅性<ul><li>-c 数量 ：ping的次数<br><img src="https://i.imgur.com/W9i09Db.png" alt=""></li></ul></li><li>ifconfig [网卡名称] [IP] ：网络配置信息</li><li>last 用户登录信息<br>  <img src="https://i.imgur.com/cWxEZzb.png" alt=""></li><li>lastlog<ul><li>-u [用户ID]   </li></ul></li><li>traceroute [主机名]  追踪网络访问跃点<br>  <img src="https://i.imgur.com/A2EtXfT.png" alt=""></li><li><p>netstat 查询网络状态</p><ul><li>-t ：查询TCP协议状态</li><li>-u : UDP协议状态</li><li>-l ：监听</li><li>-r ：路由(网关)</li><li>-n ：显示IP地址及端口 </li><li>-a : 所有选项</li><li>常用实例：<ul><li>netstat -an: 查看本机所有的网络连接</li><li>netstat -tlun:查看本机监听的端口</li><li>netstat -rn:查看本机路由列表</li></ul></li></ul></li><li><p>mount [设备文件名] [挂载点]挂载</p><ul><li>1.创建一个挂载目录（/mnt下）</li><li>2.mount<br><img src="https://i.imgur.com/cMEdqNr.png" alt=""></li><li>3.umount [挂载点/设备文件名]卸载挂载点，但是不能在挂载点下卸载<br><img src="https://i.imgur.com/UlytG1f.png" alt=""></li></ul></li></ul><h1 id="第五部分-关机与重启"><a href="#第五部分-关机与重启" class="headerlink" title="第五部分 关机与重启"></a>第五部分 关机与重启</h1><ul><li>shotdown [选项] [参数]<ul><li>-h：将系统关机</li><li>-r：系统重新启动</li><li>-c：中断关机操作</li><li>-t：设置执行时间(s)</li><li>xx:xx(表示时间):shutdown -h xx:xx 表示xx：xx时关机 </li><li>now：参数表示立刻执行</li></ul></li><li>reboot ：立刻重启</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分-帮助&quot;&gt;&lt;a href=&quot;#第一部分-帮助&quot; class=&quot;headerlink&quot; title=&quot;第一部分 帮助&quot;&gt;&lt;/a&gt;第一部分 帮助&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;man [命令] /info&lt;ul&gt;
&lt;li&gt;/ [查询的内容] 查询指定的字符串&lt;/li&gt;
&lt;li&gt;man [配置文件名称] ：显示配置文件的作用。如果直接加绝对路径，显示的是配置文件的内容&lt;/li&gt;
&lt;li&gt;有文件的帮助信息，也有配置文件的帮助信息。如果是man 5 [命令] 查看的是配置文件的帮助信息，如果是man 1 [命令] 显示的是命令的帮助信息【见linux(1) whereis命令】&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/Z4tFW44.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;whatis [命令] ：显示命令作用（简略）//whereis [命令]&lt;br&gt;   &lt;img src=&quot;https://i.imgur.com/dzVbLlm.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;apropos [配置文件] ：显示配置文件的作用&lt;br&gt;   &lt;img src=&quot;https://i.imgur.com/eoAu5q7.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;命令 -h(–help)&lt;/li&gt;
&lt;li&gt;help [命令] shell内置命令的帮助信息（shell编程中的命令）&lt;ul&gt;
&lt;li&gt;也可以查看命令的路径&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/glgYvQ4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/D9fufqV.png&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>第三章：系统机制-映像加载器</title>
    <link href="http://yoursite.com/2018/04/26/%E3%80%8AWindows%20Internals%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0_%E6%98%A0%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://yoursite.com/2018/04/26/《Windows Internals》第三章_映像加载器/</id>
    <published>2018-04-26T07:02:11.000Z</published>
    <updated>2018-04-30T14:49:48.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="映像加载器"><a href="#映像加载器" class="headerlink" title="映像加载器"></a>映像加载器</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当系统中的进程被启动的时候，内核创建一个内核对象表示该进程，并执行各种和内核相关的初始化任务。绝大部分的初始化任务是在内核之外完成的，这些工作是由<strong>映像加载器</strong>完成的。映像加载器驻留在用户模式下的<strong>Ntdll.dll</strong>中，映像加载器完成以下的初始化工作：</p><ul><li>1.初始化其他用户模式，包括堆栈的初始化，TLS和FLS的初始化</li><li>2.解析执行文件的IAT，DLL的导出表</li><li>3.加载卸载DLL，维护模块数据库</li><li>4.启用API集和API重定向<a id="more"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进程创建以后，映像加载器调用特殊的原生API，在一个基于栈中的环境帧中执行。由于加载器并不使用标准的调用进入正在运行的应用程序中，所以，在一个线程的栈痕迹中，永远不会看到加载器的初始化函数出现在调用中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过进行“观察映像加载器”这个实验，我们可以知道，<strong>加载器不一定在程序开始的时候运行，也可以在后续运行过程中，会对一些涉及到延迟加载其他模块的线程请求进行响应。</strong></li></ul><h2 id="进程初始化早期工作"><a href="#进程初始化早期工作" class="headerlink" title="进程初始化早期工作"></a>进程初始化早期工作</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加载器完成早期初始化工作后，开始解析IAT，以及加载Dll,并且根据IAT和导出表，解析导入导出函数，构建模块数据库。</p><h2 id="DLL名称解析"><a href="#DLL名称解析" class="headerlink" title="DLL名称解析"></a>DLL名称解析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原始搜索dll目录的顺序</p><ul><li>应用程序被激发的目录</li><li>当前目录（可以通过SetCurrentDirection修改）</li><li>windows系统目录</li><li>windows子系统目录(16位)</li><li>windows目录</li><li>%PATH%指定的目录（通过SetEnvironmentVariabe修改）</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp；更加安全的dll搜索路径</p><ul><li>knowndll注册表指定的dll路径</li><li>应用程序被激发的目录</li><li>windows系统目录</li><li>windows子系统目录(16位)</li><li>windows目录</li><li>当前目录（可以通过SetCurrentDirection修改）</li><li>%PATH%指定的目录（通过SetEnvironmentVariabe修改）</li></ul><h2 id="已加载的模块数据库"><a href="#已加载的模块数据库" class="headerlink" title="已加载的模块数据库"></a>已加载的模块数据库</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp；加载器维护了一个关于进程加载模块的数据库，存放在PEB中，该数据库被存放在<strong>PEB_LDR-DATA</strong>结构中，在此结构中，记载器维护了3个双向链表。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp；以下是关于PEB_LDR_DATA的结构体。<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">　ULONG Length; <span class="comment">// +0x00</span></div><div class="line">　BOOLEAN Initialized; <span class="comment">// +0x04</span></div><div class="line">　PVOID SsHandle; <span class="comment">// +0x08</span></div><div class="line">　LIST_ENTRY InLoadOrderModuleList; <span class="comment">// +0x0c</span></div><div class="line">　LIST_ENTRY InMemoryOrderModuleList; <span class="comment">// +0x14</span></div><div class="line">　LIST_ENTRY InInitializationOrderModuleList;<span class="comment">// +0x1c</span></div><div class="line">&#125; PEB_LDR_DATA,*PPEB_LDR_DATA; <span class="comment">// +0x24</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp；其中包含了LIST_ENTRY类型三个数据结构，分别是模块加载顺序,内存加载顺序，初始化模块顺序。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　LIST_ENTRY InLoadOrderModuleList; <span class="comment">// +0x0c</span></div><div class="line">　LIST_ENTRY InMemoryOrderModuleList; <span class="comment">// +0x14</span></div><div class="line">　LIST_ENTRY InInitializationOrderModuleList;<span class="comment">// +0x1c</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsp；LIST_ENTRY是一个双向链表，这个双链表指向进程装载的模块，结构中的每个指针，指向了一个LDR_DATA_TABLE_ENTRY 的结构<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> &#123;</span></div><div class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Flink</span>;</span></div><div class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Blink</span>;</span></div><div class="line">&#125; LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用windbg，进行以下操作</p><ul><li>!peb:显示peb信息<br>  <img src="https://i.imgur.com/x2bCkq4.png" alt=""></li><li>根据上述知识，我们知道LIST_ENTRY的指针指向的是LDR_DATA_TABLE_ENTRY结构体，由上图，dd 00251ee0，内存数据251f48，指向的是下一个LDR_DATA_TABLE_ENTRY结构体，251eac指向的上一个结构体。<br>  <img src="https://i.imgur.com/8t7YVy4.png" alt=""></li><li>不断的dd 内存，发现，最后一个结构体的下一个结构体，是第一个结构体，这样形成了一个双向循环链表。<br>  <img src="https://i.imgur.com/UPzj6dG.png" alt=""></li></ul><h2 id="导入信息解析"><a href="#导入信息解析" class="headerlink" title="导入信息解析"></a>导入信息解析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据IAT和模块数据库装载Dll，然后进行重定位检测，如果进行了重定位，则解析dll中的重定位信息，当每个dll装载完成后，解析IAT，查找每个导入函数。</p><h2 id="导入过程初始化的后期处理"><a href="#导入过程初始化的后期处理" class="headerlink" title="导入过程初始化的后期处理"></a>导入过程初始化的后期处理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dll等依赖文件被加载入进程后，则应该执行以下操作：</p><ul><li>检查是否为NET应用</li><li>检查程序自身是否要求重定位</li><li>是否使用TLS</li><li>兼容性检测。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;映像加载器&quot;&gt;&lt;a href=&quot;#映像加载器&quot; class=&quot;headerlink&quot; title=&quot;映像加载器&quot;&gt;&lt;/a&gt;映像加载器&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当系统中的进程被启动的时候，内核创建一个内核对象表示该进程，并执行各种和内核相关的初始化任务。绝大部分的初始化任务是在内核之外完成的，这些工作是由&lt;strong&gt;映像加载器&lt;/strong&gt;完成的。映像加载器驻留在用户模式下的&lt;strong&gt;Ntdll.dll&lt;/strong&gt;中，映像加载器完成以下的初始化工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.初始化其他用户模式，包括堆栈的初始化，TLS和FLS的初始化&lt;/li&gt;
&lt;li&gt;2.解析执行文件的IAT，DLL的导出表&lt;/li&gt;
&lt;li&gt;3.加载卸载DLL，维护模块数据库&lt;/li&gt;
&lt;li&gt;4.启用API集和API重定向
    
    </summary>
    
      <category term="windows系统" scheme="http://yoursite.com/categories/windows%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>第三章：系统机制-全局标志和内核事件跟踪</title>
    <link href="http://yoursite.com/2018/04/26/%E3%80%8AWindows%20Internals%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0_%E5%85%A8%E5%B1%80%E6%A0%87%E5%BF%97%E5%92%8C%E5%86%85%E6%A0%B8%E4%BA%8B%E4%BB%B6%E8%B7%9F%E8%B8%AA/"/>
    <id>http://yoursite.com/2018/04/26/《Windows Internals》第三章_全局标志和内核事件跟踪/</id>
    <published>2018-04-26T07:02:11.000Z</published>
    <updated>2018-04-27T04:57:36.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-5-Windows全局标志"><a href="#3-5-Windows全局标志" class="headerlink" title="3.5 Windows全局标志"></a>3.5 Windows全局标志</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windows全局标志用于打开windows系统的内部调试，跟踪和验证，保存在HKLM\SYSTEM\CurrentControlSet\Control\Session Manage中的GlobalFlag中，默认值为0。如下是利用windbg查看的GlobalFlag情况<br>      <img src="https://i.imgur.com/pg5gK68.png" alt=""><br><a id="more"></a></p><h1 id="3-8-WOW64"><a href="#3-8-WOW64" class="headerlink" title="3.8 WOW64"></a>3.8 WOW64</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wow64是允许64位windows执行32位应用程序的软件，<strong>他的实现方式是一组用户模式DLL和一些来自内核的支持。</strong>内核支持主要体现在PEB和TEB等数据结构，存在以下几种wow64的dll：</p><ul><li>Wow64.dll：管理进程或者线程，钩取异常分发，基本系统调用，文件和注册表的重定向。</li><li>Wow64Cpu.dll：32位CPU和64位CPU环境的切换。</li><li>Wow64Win.dll: 钩取Win32k.sys导出的GUI系统调用</li><li>IA32Exec.bin和Wowia32.dll：IA环境下的软件仿真，以提高执行效率。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过查看印象文件头部设置的大地址空间感知标志，判断文件是在4GB内存空间还是在8GB内存空间运行。</li></ul><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wow64勾住了所有32位代码和64位代码的转化路径。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在创建进程的时候，经过一下步骤：</p><ul><li>进程管理器会将64位Ntdll.dll和wow64的32位Ntdll.dll装载入进程内存空间，</li><li>如果是32位代码，加载器初始化过程调用WOW64.dll内部的初始化代码，</li><li>然后建立其32位环境的模拟环境，</li><li>CPU切换到32位环境，然后继续执行。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ntdll.dll，User32.dll和Gdi32.dll的特殊32位版本位于\Windows\Syswow64文件夹下。它们调用到Wow64.dll中，而不是发出原生的32位系统调用指令。Wow64转变到原生的64位模式下，并捕获到与系统调用有关的参数（将32位指针转化为64位指针），并发出对应的原生64位系统调用。当原生的系统调用返回时，Wow64把任何输出参数，如果有必要的话，在返回至32位模式之前从64位转换成32位格式。</li></ul><h2 id="异常分发"><a href="#异常分发" class="headerlink" title="异常分发"></a>异常分发</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WOW64通过Ntdll中的KiUserExceptionDispatcher钩取了异常分发过程，</p><h2 id="文件系统重定向"><a href="#文件系统重定向" class="headerlink" title="文件系统重定向"></a>文件系统重定向</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在64位windows中 系统目录仍然是Windows/System32，因为WOw64.dll钩取了所有的系统调用，<strong>他会向所有和路径有关的API函数解释，把所有执行windows/system32的路径重定向位windows/syswow64，</strong>也就是Syswow64其实存放得是32位的应用程序，而system32其实是存放的是64位的应用程序。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是部分目录是不存在重定向的，例如：</p><ul><li>driver\etc</li><li>spool</li><li>catroot</li><li>catroot2</li><li>logfiles</li></ul><h2 id="注册表的重定向"><a href="#注册表的重定向" class="headerlink" title="注册表的重定向"></a>注册表的重定向</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为注册表中，注册的键值可能被后续添加的键值覆盖，这是注册表的重定向存在的必要性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在默认情况下，利用视图来构建一个安全的注册表环境。将64位和32为系统隔离开来。Wow64截获了打开注册表的关键调用，并且重新解释相关路径，并将它们指向注册表的WOW64视图</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;3-5-Windows全局标志&quot;&gt;&lt;a href=&quot;#3-5-Windows全局标志&quot; class=&quot;headerlink&quot; title=&quot;3.5 Windows全局标志&quot;&gt;&lt;/a&gt;3.5 Windows全局标志&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;windows全局标志用于打开windows系统的内部调试，跟踪和验证，保存在HKLM\SYSTEM\CurrentControlSet\Control\Session Manage中的GlobalFlag中，默认值为0。如下是利用windbg查看的GlobalFlag情况&lt;br&gt;      &lt;img src=&quot;https://i.imgur.com/pg5gK68.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="windows系统" scheme="http://yoursite.com/categories/windows%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令-文件相关</title>
    <link href="http://yoursite.com/2018/04/14/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4(1)%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2018/04/14/Linux常见命令(1)文件相关/</id>
    <published>2018-04-14T07:02:11.000Z</published>
    <updated>2018-05-16T10:08:12.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一部分：文件操作"><a href="#第一部分：文件操作" class="headerlink" title="第一部分：文件操作"></a>第一部分：文件操作</h2><ul><li><p>查看文件  <strong>ls [选项]</strong></p><ul><li>-a:查看隐藏文件<br><img src="https://i.imgur.com/kXUvm5N.png" alt=""></li><li>-l:查看详细信息<br><img src="https://i.imgur.com/y6Nk6KF.png" alt=""></li><li>-d:查看指定路径<br><img src="https://i.imgur.com/4ssnuiF.png" alt=""></li><li>-h:查看文件大小（非字节显示）[要和-l参数合用]<br><img src="https://i.imgur.com/OD734Dk.png" alt=""></li><li>-i:查看文件id<br><img src="https://i.imgur.com/WQa7g2f.png" alt=""></li></ul></li><li><p>创建目录  <strong>mkdir [目录名]</strong></p><ul><li>-p:递归创建<br><img src="https://i.imgur.com/KLZNntK.png" alt=""><br><img src="https://i.imgur.com/WCbgKOg.png" alt=""></li></ul></li><li><p>切换目录  <strong>cd [目录]</strong></p><ul><li>.. ：回到上级目录 </li></ul></li><li>删除目录  <strong>rmdir [目录]</strong><br>  <img src="https://i.imgur.com/IdQAxZw.png" alt=""><ul><li>-p： 递归删除空目录<br><img src="https://i.imgur.com/VYj8Fww.png" alt=""></li></ul></li><li><p>查看当前目录 <strong>pwd</strong></p></li><li><p>复制文件  <strong>cp [源文件/目录] [目标文件/目录]</strong></p><ul><li>-r:复制目录</li><li>-p:保存被复制文件的属性</li><li>可以改名，在目标文件中修改</li></ul></li><li><p>剪切或者改名   <strong>mv [源文件/目录] [目标文件/目录]</strong></p><ul><li>可以改名</li></ul></li><li><p>删除文件    <strong>rm [文件名称]</strong></p><ul><li>-r 删除目录</li><li>-f 强制执行</li></ul></li><li><p>创建文件   <strong>touch [文件]</strong></p><ul><li>创建带有空格的文件，可以使用“”把文件名引起来</li></ul></li><li><p>查看文件内容  <strong>cat [文件名]</strong></p><ul><li>-n :显示行数</li></ul></li><li><p>查看文件内容 wc [] [文件名]</p><ul><li>-l ：显示行数</li><li>-m ：显示字符数</li><li>-c : 显示字节数</li><li>-L ：显示最长行的长度</li></ul></li><li><p>反向查看文件 <strong>tac [文件名]</strong></p></li><li><p>分页查看文件 <strong> more [文件名]</strong></p><ul><li>空格/f 翻页</li><li>Enter 换行</li><li>Q/q   退出</li></ul></li><li><p>可向上翻页查看文件  <strong> less [文件名]</strong></p><ul><li>PageUp 向上翻页</li><li>上方向键 向上换行</li><li>/ 搜索</li><li>n 搜索下一个</li></ul></li><li><p>查看文件前几行  <strong>head [文件]</strong></p><ul><li>-n 规定行数（默认是10行）</li></ul></li><li><p>查看文件末尾几行 <strong>tail [文件]</strong></p><ul><li>-n 规定行数</li><li>-f 实时显示[查看日志文件]</li></ul></li><li><p>创建文件链接 **ln [选项] [链接目录文件] [链接名]</p><ul><li>-s:创建的是软连接（快捷方式）<br><img src="https://i.imgur.com/gGbO2yy.png" alt=""></li><li>默认：硬链接（读写操作和源文件一样） </li></ul></li></ul><h1 id="第二部分-文件权限"><a href="#第二部分-文件权限" class="headerlink" title="第二部分 文件权限"></a>第二部分 文件权限</h1><ul><li><p>chmod 修改文件或者目录权限</p><ul><li>chmod [{ugoa}{+-=}{rwx}] [目录]<br><img src="https://i.imgur.com/vtqOU5b.png" alt=""></li><li>-R 递归修改</li><li>chmod [{4(r)2(w)1(x)}] [目录/文件]<br><img src="https://i.imgur.com/Mf7UhJ9.png" alt=""></li><li>普通用户即使没有w权限也可以删除root用户创建的文件（对文件的删除的必要条件是对文件所处在目录具有写入权限）</li></ul></li><li><p>chown 修改文件所有者</p><ul><li><p>chown [用户名] [文件/目录]<br><img src="https://i.imgur.com/poHs1KY.png" alt=""></p></li><li><p>useradd [用户名] 创建用户</p></li><li>chgrp [组名] [文件/目录]</li></ul></li><li><p>umask 显示默认权限</p><ul><li>显示的数值是权限的掩码，真实权限是777-该数值，例如数值为022，权限则为755<br><img src="https://i.imgur.com/WfSX6U3.png" alt=""></li><li>-S ：显示具体的权限（rwx）</li><li>umask [权限掩码] ：修改默认的权限数值</li></ul></li></ul><h1 id="第三部分-文件查询"><a href="#第三部分-文件查询" class="headerlink" title="第三部分 文件查询"></a>第三部分 文件查询</h1><ul><li><p>find [范围] [搜索条件] 搜索文件</p><ul><li>-name <ul><li>-name “<em>init</em>”  :文件名中存在init<br><img src="https://i.imgur.com/Bldk7hu.png" alt=""></li><li>-name “inti??”  :文件名前四个为init，后面两个任意<br><img src="https://i.imgur.com/aWJP0MQ.png" alt=""></li><li>-iname：不分大小写</li></ul></li><li>-size 根据文件大小<ul><li>+n 大于n</li><li>-n 小于n</li><li>n 等于n</li></ul></li><li>-cmin -时间   根据修改时间<br><img src="https://i.imgur.com/PLL9v4O.png" alt=""></li><li>-amin -时间    根据访问时间</li><li>-mmin -时间    根据文件内容</li><li>-a ： 表示两个条件都符合</li><li>-o ： 表示多个条件只需要符合一个<br><img src="https://i.imgur.com/ee3VxCC.png" alt=""></li><li>-type  按照文件类型查找<ul><li>-f 文件<br><img src="https://i.imgur.com/Cuei40d.png" alt=""></li><li>-d 目录<br><img src="https://i.imgur.com/5aASlFG.png" alt=""></li><li>-l 链接<br><img src="https://i.imgur.com/N9l3WS3.png" alt=""></li></ul></li><li>-inum  根据i节点来查找</li><li>-exec/-ok   {}\;   调用其他命令。</li></ul></li><li><p>locate [目录/文件] 搜索（需要更新文件数据库）<br>  <img src="https://i.imgur.com/mQKqGiF.png" alt=""></p><ul><li>-i：不区分大小写</li><li>updatedb ：更新数据库</li></ul></li><li><p>which [文件/目录]  ：用于查找系统命令</p><ul><li>查看命令是否带有别名<br><img src="https://i.imgur.com/fKGDysQ.png" alt=""></li></ul></li><li>grep [关键词] [搜索路径]  ：搜索文件内容<ul><li>-i 不区分不大小写<br><img src="https://i.imgur.com/gUlksFp.png" alt=""></li><li>-v 排除指定字符<br><img src="https://i.imgur.com/rwBOdI1.png" alt=""></li></ul></li><li>whereis [命令]<ul><li>查看命令的所在位置，查看配置文件的位置，和帮助文件的文职。一般的文件名是1的是命令的帮助文件，文件名是5的是配置文件的帮助</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一部分：文件操作&quot;&gt;&lt;a href=&quot;#第一部分：文件操作&quot; class=&quot;headerlink&quot; title=&quot;第一部分：文件操作&quot;&gt;&lt;/a&gt;第一部分：文件操作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查看文件  &lt;strong&gt;ls [选项]&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术(8) ---芦苇病毒</title>
    <link href="http://yoursite.com/2018/04/14/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF(8)--%E8%8A%A6%E8%8B%87%E7%97%85%E6%AF%92/"/>
    <id>http://yoursite.com/2018/04/14/病毒分析技术(8)--芦苇病毒/</id>
    <published>2018-04-14T06:02:11.000Z</published>
    <updated>2018-04-25T10:50:52.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-目录："><a href="#一-目录：" class="headerlink" title="一 目录："></a>一 目录：</h1><ul><li>1.目录</li><li>2.样本信息</li><li>3.行为分析</li><li>4.样本分析</li><li>5.技术上的总结<a id="more"></a><h1 id="二-样本信息"><a href="#二-样本信息" class="headerlink" title="二 样本信息"></a>二 样本信息</h1></li><li>1.样本名称：芦苇病毒.exe</li><li>2.MD5:c71091507f731c203b6c93bc91adedb6</li><li>3.是否加壳：否</li><li>4.编写语言：Microsoft Visual C++ ver 5.0/6.0</li><li>5.样本来源：卡饭社区病毒样本专栏</li></ul><h1 id="三-行为分析"><a href="#三-行为分析" class="headerlink" title="三 行为分析"></a>三 行为分析</h1><ul><li>1.病毒将自身写入/run注册表项，实现自启</li><li>2.向c盘根目录写入三个文件</li><li>3.向样本同一目录下写入bmp文件，并设置隐藏</li><li>4.执行根目录下文件，error图标，随着鼠标移动而移动</li><li>5.加载windows音频驱动，播放音乐。</li><li>6.调用cmd，执行各种批处理</li><li>7.禁用系统安全选项</li><li>8.小结：这个病毒属于恶作剧病毒，没有采用常见的隐藏自身的行为，而是很大方的告诉用户本机已经中病毒了，也许是作者对自身病毒很有自信，执行大量批处理。</li></ul><h1 id="四-样本分析"><a href="#四-样本分析" class="headerlink" title="四 样本分析"></a>四 样本分析</h1><ul><li>1.省略前面的初始化工作，经过程序od跟踪，进入第一个可以用于病毒执行的函数<br>  <img src="https://i.imgur.com/FY1YLu0.png" alt=""><br>  <img src="https://i.imgur.com/l4KcSze.png" alt=""><br>  <img src="https://i.imgur.com/0nJRrMd.png" alt=""></li><li>2.先把1.bmp传入函数，调用004062F0函数，利用Cfile库来创建文件，其实这个库底层也是调用createfile函数实现的。<br>  <img src="https://i.imgur.com/3gZWzZa.png" alt=""></li><li>3.然后利用DistributeFun函数(自定义)进行函数的分发，原理是根据函数入口表，利用jmp去跳转到对应的函数入口。关于这部分内容文章后期介绍。<br>  <img src="https://i.imgur.com/VgKYU9B.png" alt=""></li><li>4.设置文件安全属性(主要是隐藏)，但是不明白的是为什么要把bmp文件设置隐藏。<br>  <img src="https://i.imgur.com/alHyrbp.png" alt=""></li><li>5.调用sub_463F60利用修改注册表的键值来修改桌面配置信息<br>  <img src="https://i.imgur.com/9v6U9LX.png" alt=""><br>  <img src="https://i.imgur.com/FHryWgf.png" alt=""><br>  <img src="https://i.imgur.com/eW9ZlR6.png" alt=""></li><li>6.加载wdmaud.drv等windows音频驱动文件<br>   <img src="https://i.imgur.com/cWqIOsV.png" alt=""><br>   <img src="https://i.imgur.com/NtqcLOk.png" alt=""></li><li>7.播放音乐<br>   <img src="https://i.imgur.com/53Ck3uI.png" alt=""></li><li>8.在c盘根目录下释放三个文件，分别是drawerror.exe。ghost.exe。main.cpp，<br>   <img src="https://i.imgur.com/hxk47VA.png" alt=""></li><li>9.执行前两个文件。drawerror.exe产生error图标，随着鼠标移动而移动。ghost文件没有实际的操作。<br>   <img src="https://i.imgur.com/X5SIkSb.png" alt=""></li><li>10.关闭windows的安全选项，这些函数都是通过删除注册表子项(如SYSTEM\CurrentControlSet\Control\SafeBoot\Minimal)的方法，阻止用户使用安全选项。<br>  <img src="https://i.imgur.com/5d778EX.png" alt=""></li><li>11.修改注册表，实现开机自启<br>  <img src="https://i.imgur.com/SmAtU9l.png" alt=""><br>  <img src="https://i.imgur.com/TIjRv1g.png" alt=""><br>  <img src="https://i.imgur.com/sdqxBTG.png" alt=""></li><li>12.通过消息分发函数调用cmd.exe 执行批处理（关于DispatchMessage函数的溯源放到本次分析的后续介绍）<ul><li>1）创建C:\cc.ico和1.bat</li><li>2）这是比较有意思的一步，程序通过向注册表HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom\中写入1.bat，同时释放了一个名为ascaris.dll的文件，这是一个关于过UAC的一个方法。原文来自：安全客<a href="http://bobao.360.cn/learning/detail/420.html" target="_blank" rel="external">http://bobao.360.cn/learning/detail/420.html</a></li><li>3）通过注册表HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\AppCertDlls实现隐藏。</li><li>调用cmd.exe执行操作</li><li>把所有exe格式的文件的图标全部替换成释放的cc.ico  </li></ul></li><li>13.关于1.bat功能的介绍<ul><li>assoc .exe=exefile 关联exe文件，使其可以运行。</li></ul></li><li>14.关于ascaris.bat的介绍<ul><li>根据上文，我们知道使用ascaris.bat和ascaris.dll来避开UAC机制，其中ascaris.bat是主要的执行部分//前面有注释。</li><li>1.复制自身</li><li>2.隐藏文件</li><li>3.制造大文件，破坏行为</li><li>4.监视U盘</li><li>5.隐藏文件等</li></ul></li><li>15.关于兵团.bat的介绍<ul><li>遍历磁盘</li><li>创建随机文件<br><img src="https://i.imgur.com/P8RN0yn.png" alt=""></li></ul></li></ul><h1 id="5-技术总结"><a href="#5-技术总结" class="headerlink" title="5 技术总结"></a>5 技术总结</h1><ul><li>1.关于DistributeFun分发函数的介绍<ul><li>首先函数先将目标函数的地址出传入ebx，然后利用跳转表跳入分发函数的入口地址<br><img src="https://i.imgur.com/6pWui9r.png" alt=""></li><li>继续跟入分发函数可以发现，函数内部，进行了一次调用call ebx，这样就把目标函数的实际调用隐藏起来了。<br><img src="https://i.imgur.com/H8L5nUn.png" alt=""></li></ul></li><li>2.关于DispatchMessage消息分发函数的介绍<ul><li>DispatchMessage函数是将消息派发给窗口函数，我们可以利用SPY++来查看消息对应的窗口处理函数，然后在目标的窗口进程下断点，然后就可以开始调试了。<br><img src="https://i.imgur.com/KYbGkF9.png" alt=""></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-目录：&quot;&gt;&lt;a href=&quot;#一-目录：&quot; class=&quot;headerlink&quot; title=&quot;一 目录：&quot;&gt;&lt;/a&gt;一 目录：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.目录&lt;/li&gt;
&lt;li&gt;2.样本信息&lt;/li&gt;
&lt;li&gt;3.行为分析&lt;/li&gt;
&lt;li&gt;4.样本分析&lt;/li&gt;
&lt;li&gt;5.技术上的总结
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>C++Primer 第六章：函数</title>
    <link href="http://yoursite.com/2018/04/11/C++%E7%AC%AC%E5%85%AD%E7%AB%A0_%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/04/11/C++第六章_函数/</id>
    <published>2018-04-11T08:02:11.000Z</published>
    <updated>2018-06-08T14:48:45.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h1><h2 id="6-1-1-局部变量"><a href="#6-1-1-局部变量" class="headerlink" title="6.1.1 局部变量"></a>6.1.1 局部变量</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static是静态修饰符，static变量存放在静态存储区，本次ret的数据对下次函数调用仍然有效。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; count_calls() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">size_t</span> count_calls()</div><div class="line">&#123;</div><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;  <span class="comment">//static局部变量的特点是它位于静态存贮区，</span></div><div class="line">                        <span class="comment">//在函数调用结束后，它的值仍然存在，并可能影响到下一次调用的过程。</span></div><div class="line"><span class="keyword">return</span> ++ctr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>   <img src="http://oxnvtxe03.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20180411194941.png" alt=""><br><a id="more"></a></p><h1 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h1><h2 id="6-2-0"><a href="#6-2-0" class="headerlink" title="6.2.0"></a>6.2.0</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次函数调用都会创建形参。并使用传入的实参对形式参数进行初始化。</p><h2 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a>6.2.1 传值参数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用传递：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拷贝传递，如果利用这种传参方法，不会改变实参的数值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指针传参：  </p><ul><li>练习6.10<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> count_calls();</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; count_calls() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">size_t</span> count_calls()</div><div class="line">&#123;</div><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;  <span class="comment">//static局部变量的特点是它位于静态存贮区，</span></div><div class="line">                        <span class="comment">//在函数调用结束后，它的值仍然存在，并可能影响到下一次调用的过程。</span></div><div class="line"><span class="keyword">return</span> ++ctr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="6-2-3-传引用参数"><a href="#6-2-3-传引用参数" class="headerlink" title="6.2.3 传引用参数"></a>6.2.3 传引用参数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用的操作是作用在引用的对象上面的，对于函数来说，如果形势参数是引用的话，对引用的更改就是对绑定在引用的对象的更改.</p><ul><li><p>练习6.11</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> Num;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; Num)</div><div class="line">&#123;</div><div class="line">reset(Num);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; Num &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> &amp;Num)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">Num = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>练习6.12</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> Num1, Num2;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; Num1 &gt;&gt; Num2)</div><div class="line">&#123;</div><div class="line">ExchangeNum(Num1, Num2);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; Num1 &lt;&lt; <span class="string">" "</span> &lt;&lt; Num2 &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExchangeNum</span><span class="params">(<span class="keyword">int</span> &amp;Num1, <span class="keyword">int</span> &amp;Num2)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> temp;   <span class="comment">//int</span></div><div class="line">temp = Num1;    <span class="comment">//*Num1Ϊint</span></div><div class="line">Num1 = Num2;</div><div class="line">Num2 = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="6-2-4-数组传参"><a href="#6-2-4-数组传参" class="headerlink" title="6.2.4 数组传参"></a>6.2.4 数组传参</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们为一个函数传入数组时，实际上传递的是一个指向数组首元素地址的指针。所以我们仍然可以把形参写成类似形式。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> [])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> [<span class="number">10</span>])</span></span>;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于数组引用型传参，形参必须是数组的引用，所以，引用形参必须要绑定到对应的实参上面。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//因为&amp;的优先级高。</span></div><div class="line"><span class="built_in">Type</span> Fun(<span class="built_in">int</span> &amp;arr[<span class="number">10</span>]);    <span class="comment">//错误，&amp;arr[]是指引用数组</span></div><div class="line"><span class="built_in">Type</span> Fun(<span class="built_in">int</span> (&amp;arr)[<span class="number">10</span>])   <span class="comment">//正确，对于10个整形变量数组的引用</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于多维数组，知道c++中多维数组是数组的数组，所以函数形参中真正传递的是数组首元素的指针，而这个数组中存放的是各个行的首地址。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printf</span>(<span class="params"><span class="keyword">int</span> (*matrix</span>)[10],<span class="keyword">int</span> RowSize)</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printf</span>(<span class="params"><span class="keyword">int</span> (*matrix</span>)[][10],<span class="keyword">int</span> RowSize)</span>;</div><div class="line"><span class="comment">//强调一下：matrix的两端括号必不可少</span></div><div class="line"><span class="keyword">int</span> *matrix[<span class="number">10</span>]；是<span class="number">10</span>个<span class="keyword">int</span> *的指针</div><div class="line"><span class="keyword">int</span> (*matrix)[<span class="number">10</span>];是指向含有<span class="number">10</span>个<span class="keyword">int</span>型的数组的指针</div></pre></td></tr></table></figure></p><ul><li><p>练习6.21</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> num1, num2,BigerNum;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; num1 &gt;&gt; num2)</div><div class="line">&#123;</div><div class="line">BigerNum=IsBig(num1, &amp;num2);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; BigerNum &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsBig</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> *num2)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">return</span> (num1 &gt; *num2) ? num1 : *num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>练习6.22</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> Num1, Num2;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; Num1 &gt;&gt; Num2)</div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> *pNum1 = &amp;Num1,*pNum2=&amp;Num2;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; pNum1 &lt;&lt; <span class="string">" "</span>&lt;&lt;pNum2&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">ExchangePoint(pNum1, pNum2);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; pNum1 &lt;&lt; <span class="string">" "</span> &lt;&lt; pNum2 &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> *<span class="title">ExchangePoint</span><span class="params">(<span class="keyword">int</span>* &amp;pNum1, <span class="keyword">int</span>* &amp;pNum2)</span>   <span class="comment">//利用引用,对于指针的引用</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> *temp = pNum1;</div><div class="line">pNum1 = pNum2;</div><div class="line">pNum2 = temp;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>练习6.24</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span>(<span class="params"><span class="keyword">const</span> <span class="keyword">int</span> (&amp;ia</span>)[10])  <span class="comment">//数组不能拷贝传入，但是可以利用引用的方法</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span>(size_t i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)</div><div class="line">cout&lt;&lt;ia[i]&lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="main函数的预处理选项"><a href="#main函数的预处理选项" class="headerlink" title="main函数的预处理选项"></a>main函数的预处理选项</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令行参数通过两个可选的形参传入main函数。<strong>可选的实参是从agrv[1]开始，agrv[0]存放的程序名称。</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>;</div></pre></td></tr></table></figure></p><ul><li>练习6.26<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">string</span> str;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != argc; ++i)</div><div class="line">&#123;</div><div class="line">str += argv[i];</div><div class="line">str += <span class="string">" "</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h1 id="6-3-返回类型和return-语句"><a href="#6-3-返回类型和return-语句" class="headerlink" title="6.3 返回类型和return 语句"></a>6.3 返回类型和return 语句</h1><h2 id="6-3-1-无返回值类型的函数"><a href="#6-3-1-无返回值类型的函数" class="headerlink" title="6.3.1 无返回值类型的函数"></a>6.3.1 无返回值类型的函数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void类型会默认函数体结尾隐式返回return。中部执行return作用类似于循环中的break</p><h2 id="6-3-2-有返回值的函数"><a href="#6-3-2-有返回值的函数" class="headerlink" title="6.3.2 有返回值的函数"></a>6.3.2 有返回值的函数</h2><h3 id="￥-值是如何被返回的"><a href="#￥-值是如何被返回的" class="headerlink" title="￥ 值是如何被返回的"></a>￥ 值是如何被返回的</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数的返回值用于初始化调用点的一个临时量，这个临时量是函数调用的结果。如果函数的<strong>返回值是一个非引用类型，</strong>这意味着返回值将被拷贝到调用点，函数会返回到一个临时副本或者临时对象。如果函数的<strong>返回值是一个引用类型，</strong>这意味着无论是调用函数或者返回数值都不会对对象进行拷贝。</p><h3 id="￥-不要返回局部变量的引用或者指针"><a href="#￥-不要返回局部变量的引用或者指针" class="headerlink" title="￥ 不要返回局部变量的引用或者指针"></a>￥ 不要返回局部变量的引用或者指针</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不要返回局部变量的指针或者引用，因为一旦函数执行完成，意味着局部变量的引用也指向不再有效的内存区域。</p><h3 id="￥-引用返回左值"><a href="#￥-引用返回左值" class="headerlink" title="￥ 引用返回左值"></a>￥ 引用返回左值</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果调用一个返回引用的函数调用，得到的是一个左值，其他都是得到右值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> &amp;<span class="title">get_val</span><span class="params">(<span class="built_in">string</span> &amp;str,<span class="built_in">string</span>::size_type ix)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">return</span> str[ix];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">get_val(s,<span class="number">0</span>)=<span class="string">'A'</span>;   <span class="comment">//将s[0]的值初始化为A，体现调用返回值是引用类型的函数得到的是左值</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>；</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是左值呢？左值广义是指既可以出现在表达式等号左边的变量(或者表达式)，右值是指只能出现在表达式右边的变量或者表达式。</p><h3 id="￥-列表初始化返回值"><a href="#￥-列表初始化返回值" class="headerlink" title="￥ 列表初始化返回值"></a>￥ 列表初始化返回值</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数可以返回包含花括号包含的值得列表。返回值需要采用类似于vector类型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; process()</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(exected==actual)</div><div class="line"><span class="keyword">return</span> &#123;<span class="string">"FunctionX"</span>,exected,actual&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>练习6.33<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</div><div class="line">Fun(nums,nums.size()<span class="number">-1</span>);</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,<span class="keyword">int</span> Count)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">if</span> (Count != <span class="number">-1</span>)</div><div class="line">&#123;</div><div class="line"><span class="comment">//Count--;                        他就是不能先减减</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; nums[Count] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">Count--;</div><div class="line">Fun(nums, Count);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="6-3-3-返回数组指针"><a href="#6-3-3-返回数组指针" class="headerlink" title="6.3.3 返回数组指针"></a>6.3.3 返回数组指针</h2><h3 id="￥-申明一个返回数组指针类型的函数"><a href="#￥-申明一个返回数组指针类型的函数" class="headerlink" title="￥ 申明一个返回数组指针类型的函数"></a>￥ 申明一个返回数组指针类型的函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先判断一下数组的声明区别<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//*的优先级高于[]</span></div><div class="line"><span class="selector-tag">int</span> <span class="selector-tag">arr</span><span class="selector-attr">[10]</span>;    <span class="comment">//定义了一个长度为10数组</span></div><div class="line"><span class="selector-tag">int</span> *<span class="selector-tag">arr</span><span class="selector-attr">[10]</span>;   <span class="comment">//定义了一个长度为10的int类型的指针的数组(指针数组)</span></div><div class="line"><span class="selector-tag">int</span> (*arr)<span class="selector-attr">[10]</span>; <span class="comment">//定义了一个指针，该指针指向的是含有10个int的数组(数组指针)</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们了解到了上述三种数组的区别，<strong>使用返回值是数组指针类型的函数我们还需要知道存放返回值数组的长度，而且形参列表需要紧跟函数名称，</strong>也就是说形参列表由于数组维度。所以我们做出如下函数声明.例如：int (*fun(int x))[10];<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> (*<span class="function"><span class="keyword">function</span><span class="params">(parameterlist)</span></span>)[<span class="keyword">dimension</span>]</div></pre></td></tr></table></figure></p><h3 id="￥-使用尾置返回类型"><a href="#￥-使用尾置返回类型" class="headerlink" title="￥ 使用尾置返回类型"></a>￥ 使用尾置返回类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原则上，在所有函数声明都可以使用尾置返回类型，但是尾置返回类型对于返回值比较复杂的函数有效，<strong>尾置返回类型跟在形参列表后面，并以一个-&gt;符号开头。在本应该是返回类型的函数声明开头使用auto关键字</strong><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> func(<span class="keyword">int</span> i)-&gt;<span class="keyword">int</span>（*）[<span class="number">10</span>];  <span class="comment">//返回一个指针，指向含有10个整数的数组。</span></div></pre></td></tr></table></figure></p><h3 id="￥使用decltype"><a href="#￥使用decltype" class="headerlink" title="￥使用decltype"></a>￥使用decltype</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们不知道函数返回那个数组可以使用decltype关键字，decltype表示他的返回值是一个指针，<strong>但是decltype关键字并不把数组类型转化成对应的指针所以decltype的结果是一个数组，需要在函数声明处加一个星号使函数返回指针</strong><br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> <span class="built_in">odd</span>[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</div><div class="line"><span class="built_in">int</span> <span class="built_in">even</span>[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</div><div class="line">decltype(<span class="built_in">odd</span>) *arrptr(<span class="built_in">int</span> i)</div><div class="line">&#123;</div><div class="line">return (i%<span class="number">2</span>!=<span class="number">0</span>)?&amp;o<span class="symbol">dd:</span>&amp;<span class="built_in">even</span>;   //采取引用类型</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>练习 6.36</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">string (*<span class="function"><span class="keyword">function</span><span class="params">(string (*str)</span><span class="params">[10]</span>))<span class="params">[10]</span></span></div></pre></td></tr></table></figure></li><li><p>练习 6.37</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*第一种方法：使用重名*/</span></div><div class="line">using ArrString = <span class="keyword">string</span>[];</div><div class="line">Arrstring &amp;func1(ArrString &amp;arr);   <span class="comment">//返回数组到string</span></div><div class="line"><span class="comment">/*第二种方法：尾置指针*/</span></div><div class="line">auto func2(<span class="keyword">string</span> &amp;arr)-&gt;<span class="keyword">string</span>(&amp;)[<span class="number">10</span>];  <span class="comment">//避免使用指针??</span></div><div class="line"><span class="comment">//auto func2(string &amp;arr)-&gt;string(*)[10]</span></div><div class="line"><span class="comment">/*第三种方法：decltype*/</span></div><div class="line"><span class="keyword">string</span> arrS[<span class="number">10</span>];</div><div class="line">decltype(arrS) &amp;<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span> &amp;arr)</span>;</span></div><div class="line"><span class="function">//<span class="title">decltype</span><span class="params">(arrS)</span> *<span class="title">func</span><span class="params">(<span class="keyword">string</span> &amp;arr)</span>;</span></div></pre></td></tr></table></figure></li></ul><h1 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h1><h3 id="￥定义重载函数"><a href="#￥定义重载函数" class="headerlink" title="￥定义重载函数"></a>￥定义重载函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果作用在<strong>同一个作用域内，</strong>几个函数名字相同，形参列表不同的函数，我们称之为重载函数。其中隐含了以下几种特点：</p><ul><li>必须处于同一个作用域中，一般的我们最好将函数的声明<strong>写在全局作用域</strong>，而不是局部作用域。</li><li>函数的名称相同</li><li>函数的形参个数或者<strong>数据类型</strong>不同。但可以允许类型相近/可以相互转化的数据类型的重载函数。</li></ul><h3 id="￥重载和const"><a href="#￥重载和const" class="headerlink" title="￥重载和const"></a>￥重载和const</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们需要了解一下前提知识。<strong>底层const和顶层const。</strong>，<strong>判断底层const和顶层const的最简单途径就是变量最接近哪个修饰符，最接近那个就是最先被修改的</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下是底层const。ptr最接近int，所以ptr指向的是一个int类型的数，但是在前面用了const去修饰ptr指向的变量的值，也就是说*ptr是被const修改的。此时通过修改ptr的值是无法修改num1变量中的值，只能修改num1本身才能改变里面的值。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> num1=<span class="number">5</span>；</div><div class="line"><span class="keyword">const</span> <span class="built_in">int</span> *<span class="keyword">ptr</span>=&amp;num1;</div><div class="line">*<span class="keyword">ptr</span>=<span class="number">6</span>;     //底层<span class="keyword">const</span>，无法通过指针修改num1的值</div><div class="line">num1=<span class="number">6</span>；    //修改成功</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下代码是顶层const。ptr最接近const，说明指针ptr优先被const修饰，说明ptr是一个常量，只可能指向同一个内存地址，但是我们可以利用ptr去修改内存地址所保存的数值。如下代码的三四行<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> num1=<span class="number">5</span>,num2；</div><div class="line"><span class="built_in">int</span> <span class="keyword">const</span> *<span class="built_in">ptr</span>=&amp;num1；</div><div class="line"><span class="built_in">ptr</span>=&amp;num2；//错误，<span class="built_in">ptr</span>是一个<span class="keyword">const</span>值，不能被修改</div><div class="line">*<span class="built_in">ptr</span>=<span class="number">6</span>；   //成功，通过<span class="built_in">ptr</span>修改num1的所在地址的值。</div></pre></td></tr></table></figure></p><p>参考自：<a href="https://blog.csdn.net/happyxieqiang/article/details/47759967" target="_blank" rel="external">https://blog.csdn.net/happyxieqiang/article/details/47759967</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顶层const不能被重载，如以下代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x)</span></span>;   <span class="comment">//非指针或者引用类型，对用户透明</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> *x)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span>* <span class="keyword">const</span> x)</span></span>;   <span class="comment">//顶层const</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;底层const可以被重载，如以下代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>;  <span class="comment">//底层const，引用类型</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> *x)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *x)</span></span>;   <span class="comment">//底层const，指针类型</span></div></pre></td></tr></table></figure></p><h1 id="6-6-函数最佳匹配"><a href="#6-6-函数最佳匹配" class="headerlink" title="6.6 函数最佳匹配"></a>6.6 函数最佳匹配</h1><h2 id="6-6-0-函数匹配"><a href="#6-6-0-函数匹配" class="headerlink" title="6.6.0 函数匹配"></a>6.6.0 函数匹配</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配原则是：</p><ul><li>1）优先考虑不需要强制类型转化的</li><li>2）其次是数量不统一的(实参小于形参)，因为可以采用函数默认值</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数二义性：对于函数整体来说，无论采用那个重载函数，最佳匹配出来的函数是多个，这样造成了函数的二义性。</p><ul><li>练习6.51<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">char</span>* argc[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">f(<span class="number">42</span>);</div><div class="line">f(<span class="number">25</span>, <span class="number">42</span>);</div><div class="line">f(<span class="number">1.2</span>, <span class="number">4.3</span>);</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"One Int"</span>&lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Two Int"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Two Double"</span>&lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="6-6-1-实参类型转换"><a href="#6-6-1-实参类型转换" class="headerlink" title="6.6.1 实参类型转换"></a>6.6.1 实参类型转换</h2><h3 id="￥函数匹配和const实参"><a href="#￥函数匹配和const实参" class="headerlink" title="￥函数匹配和const实参"></a>￥函数匹配和const实参</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>不能把普通引用绑定到const对象上。</strong>所以对于实参x，调用的是int Print(const int&amp;);<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> <span class="built_in">Print</span>(<span class="built_in">int</span>&amp;);</div><div class="line"><span class="built_in">int</span> <span class="built_in">Print</span>(const <span class="built_in">int</span>&amp;);</div><div class="line">const <span class="built_in">int</span> x;</div><div class="line"><span class="built_in">Print</span>(x);   //调用的是<span class="built_in">int</span> <span class="built_in">Print</span>(const <span class="built_in">int</span>&amp;);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于非常量的对象，我们可以先对非常量初始化常量引用(相当于变量可以转化成const类型，但是const对象不能转化成普通变量)，也直接初始化非常量引用。<strong>但是编译器会优先选择非常量版本的函数，因为非常量形参的版本和实参精确匹配，不需要利用非常量对象初始化常量引用而造成类型转化</strong><br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> <span class="built_in">Print</span>(<span class="built_in">int</span>&amp;);</div><div class="line"><span class="built_in">int</span> <span class="built_in">Print</span>(const <span class="built_in">int</span>&amp;);</div><div class="line"><span class="built_in">int</span> x;</div><div class="line"><span class="built_in">Print</span>(x);   //调用的是<span class="built_in">int</span> <span class="built_in">Print</span>(<span class="built_in">int</span>&amp;);</div></pre></td></tr></table></figure></p><h1 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h1><h2 id="6-7-0-函数指针简介"><a href="#6-7-0-函数指针简介" class="headerlink" title="6.7.0 函数指针简介"></a>6.7.0 函数指针简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数指针指向的是一个函数，而不是对象。如下声明，<strong>如果想到申明一个指向函数的指针，只需要用指针替换函数名即可！</strong>值得注意的是函数名两边的括号不能少，如果少了，表示的返回的是int指针的函数。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int (*<span class="function"><span class="keyword">fun</span>)<span class="params">(int x,int y)</span></span>;   <span class="comment">//函数指针</span></div><div class="line">int *<span class="function"><span class="title">fun</span><span class="params">(int x,int y)</span></span>;     <span class="comment">//返回值是int*的函数</span></div><div class="line">int* <span class="function"><span class="title">fun</span><span class="params">(int x,int y)</span></span>;     <span class="comment">//和第二个声明等价，int *a;int* a;等价</span></div></pre></td></tr></table></figure></p><h2 id="6-7-1-使用函数指针"><a href="#6-7-1-使用函数指针" class="headerlink" title="6.7.1 使用函数指针"></a>6.7.1 使用函数指针</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在将函数名作为一个值使用的时候，函数会自动转化为指针。<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pPrint=<span class="keyword">Print</span>;  <span class="comment">//pPrint指向Print函数</span></div><div class="line">pPrint1=&amp;<span class="keyword">Print</span>；  <span class="comment">//等价于pPrint</span></div></pre></td></tr></table></figure></p><h3 id="￥使用函数指针"><a href="#￥使用函数指针" class="headerlink" title="￥使用函数指针"></a>￥使用函数指针</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在直接使用指向函数的指针调用函数的时候，不需要解引用指针。<strong>在指向不同函数类型的指针不存在转化规则</strong>，使用指针函数的时候，函数和函数指针的返回值和形参列表必须完全匹配。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pPrint1=&amp;<span class="keyword">Print</span>；              <span class="comment">//等价于pPrint</span></div><div class="line"><span class="keyword">int</span> x=<span class="keyword">Print</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b);     <span class="comment">//直接调用函数</span></div><div class="line"><span class="keyword">int</span> y=pPrint1(<span class="keyword">int</span> a,<span class="keyword">int</span> b);   <span class="comment">//使用函数指针调用函数</span></div></pre></td></tr></table></figure></p><h3 id="￥重载函数的指针"><a href="#￥重载函数的指针" class="headerlink" title="￥重载函数的指针"></a>￥重载函数的指针</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用重载函数的指针时，最佳匹配函数必须精确匹配。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="keyword">Print</span>(<span class="keyword">int</span> x);</div><div class="line"><span class="keyword">void</span> <span class="keyword">Print</span>(<span class="keyword">int</span> *x);</div><div class="line"><span class="keyword">void</span> (*<span class="keyword">Print</span>)(<span class="keyword">int</span> x)=ff;     <span class="comment">//正确</span></div><div class="line"><span class="keyword">void</span> (*<span class="keyword">Print</span>)(<span class="keyword">double</span> x)=ff;  <span class="comment">//错误</span></div></pre></td></tr></table></figure></p><h3 id="￥函数指针形参"><a href="#￥函数指针形参" class="headerlink" title="￥函数指针形参"></a>￥函数指针形参</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数形参是不可以是函数类型，但是可以是指向函数的指针类型。但是在使用函数作为形参的时候，<strong>函数名会自动转化成指针类型。</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fun</span>(<span class="params"><span class="keyword">int</span> Fun1(<span class="keyword">int</span> x</span>),<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fun</span>(<span class="params"><span class="keyword">int</span> (*pFun</span>)(<span class="params"><span class="keyword">int</span> x</span>),<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span>;  <span class="comment">//等价</span></div></pre></td></tr></table></figure></p><h3 id="￥返回指向函数的指针"><a href="#￥返回指向函数的指针" class="headerlink" title="￥返回指向函数的指针"></a>￥返回指向函数的指针</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把函数指针作为函数的返回值。建议使用尾置返回类型的方式。<strong>和之前返回数组的指针一样，只是将尾置的返回类型改成函数类型。</strong><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> Fun(<span class="keyword">int</span> x) -&gt; <span class="keyword">int</span> (*）（<span class="keyword">int</span> *x,<span class="keyword">int</span> y);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用decltype指定返回的函数指针。这个的前提是知道返回的函数是那个。假如我们知道fun1，fun2，<strong>他们的返回值都是一样的(说明这两个函数的返回类型相同)</strong>，还有第三个函数fun3，参数是一个const string的引用类型，返回一个函数指针。这个指针指向的是这两个函数的其中一个。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; x)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; y)</span></span>;</div><div class="line">dectype(fun1) fun3(<span class="keyword">const</span> <span class="built_in">string</span>&amp; z);</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;6-1-函数基础&quot;&gt;&lt;a href=&quot;#6-1-函数基础&quot; class=&quot;headerlink&quot; title=&quot;6.1 函数基础&quot;&gt;&lt;/a&gt;6.1 函数基础&lt;/h1&gt;&lt;h2 id=&quot;6-1-1-局部变量&quot;&gt;&lt;a href=&quot;#6-1-1-局部变量&quot; class=&quot;headerlink&quot; title=&quot;6.1.1 局部变量&quot;&gt;&lt;/a&gt;6.1.1 局部变量&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static是静态修饰符，static变量存放在静态存储区，本次ret的数据对下次函数调用仍然有效。&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i != &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; ++i)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; count_calls() &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	system(&lt;span class=&quot;string&quot;&gt;&quot;pause&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; count_calls()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; ctr = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//static局部变量的特点是它位于静态存贮区，&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	                        &lt;span class=&quot;comment&quot;&gt;//在函数调用结束后，它的值仍然存在，并可能影响到下一次调用的过程。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ++ctr;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;http://oxnvtxe03.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20180411194941.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
  </entry>
  
</feed>
