<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>findream&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-19T13:16:09.224Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>findream</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法练习1--八皇后问题</title>
    <link href="http://yoursite.com/2017/10/19/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A01--%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/10/19/算法练习1--八皇后问题/</id>
    <published>2017-10-19T08:45:11.000Z</published>
    <updated>2017-10-19T13:16:09.224Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题概述：</strong><br><br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。计算机发明后，有多种计算机语言可以解决此问题</strong>。<br><br><a id="more"></a><br><strong>算法思路：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为每个皇后不能在同一行，同一列，以及主副斜对角线上，所以我们首先去掉行的这一限制，即：第一次放在第一行，第二次就不放在第一行了。每递归一次（即一行）考虑8列，即每个行，皇后有八个位置可以放置。利用循环，找个每行的不和以前的皇后相互攻击每个位置。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们利用一个一维数组表示每个皇后所在的位置，即：num[i]=j;表示皇后在第i行的第j列。因为出去了每行的因素，所以剩下的冲突的可能性是：每一列，主副对角线。同列：c[r]==c[j]; 同对角线有两种可能，即主对角线方向和副对角线方向。 主对角线方向满足:行之差等于列之差：r-j==c[r]-c[j]; 副对角线方向满足:行之差等于列之差的相反数：r-j==c[j]-c[r]。<br></p><p><pre><code><br>main.cpp<br>int n=8,count = 0,num[10];<br>void search(int n);   /<em>寻找八皇后的位置，递归算法</em>/<br>void print();     /<em>打印输出</em>/<br>int main(void)<br>{<br>    search(0);<br>    printf(“%d”, count);<br>    getchar();<br>    return 0;<br>}<br>void search(int r)<br>{<br>    int i,j;<br>    if (r == n)<br>    {<br>        print();<br>        count++;<br>        return;<br>    }<br>    for (i = 0; i &lt; 8; i++)<br>    {<br>        int ok = 1;     /<em>默认符合条件</em>/<br>        num[r] = i;     /<em>为num数组附上比较的初值</em>/<br>        for (j = 0; j &lt; r; j++)<br>        {<br>            if (num[j] == num[r] || num[r] - num[j] == r - j || num[r] - num[j] == j - r)<br>            {<br>                ok = 0;<br>                break;<br>            }<br>        }<br>        if (ok)<br>            search(r + 1);<br>    }<br>}<br>void print()<br>{<br>    int i, j;<br>    for (i = 0; i &lt; n; i++)<br>    {<br>        for (j = 0; j &lt; n; j++)<br>        {<br>            if (j == num[i])<br>                printf(“1”);<br>            else<br>                printf(“0”);<br>        }<br>        printf(“\n”);<br>    }<br>    printf(“\n”);<br>}<br></code></pre><br><img src="https://i.imgur.com/bhG4POb.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;问题概述：&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。计算机发明后，有多种计算机语言可以解决此问题&lt;/strong&gt;。&lt;br&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>堆与栈的区别（内存和数据结构角度）</title>
    <link href="http://yoursite.com/2017/10/17/%E5%A0%86%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%92%E5%BA%A6%EF%BC%89/"/>
    <id>http://yoursite.com/2017/10/17/堆栈的区别（内存和数据结构角度）/</id>
    <published>2017-10-17T11:00:11.000Z</published>
    <updated>2017-10-17T11:05:48.570Z</updated>
    
    <content type="html"><![CDATA[<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在计算机领域，堆栈是一个不容忽视的概念，我们编写的C语言程序基本上都要用到。但对于很多的初学着来说，堆栈是一个很模糊的概念。堆栈：一种数据结构、一个在程序运行时用于存放的地方，这可能是很多初学者的认识，因为我曾经就是这么想的和汇编语言中的堆栈一词混为一谈。我身边的一些编程的朋友以及在网上看帖遇到的朋友中有好多也说不清堆栈，所以我想有必要给大家分享一下我对堆栈的看法，有说的不对的地方请朋友们不吝赐教，这对于大家学习会有很大帮助。</strong><br><br><a id="more"></a></p><p>#<strong>数据结构的栈和堆:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DC143C">堆和栈都是一种数据项按序排列的数据结构。</font><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先从大家比较熟悉的栈说起吧，栈就像装数据的桶或箱子,它是一种具有<strong>后进先出性质</strong>的数据结构，也就是说后存放的先取，先存放的后取。这就如同我们要取出放在箱子里面底下的东西（放入的比较早的物体），我们首先要移开压在它上面的物体（放入的比较晚的物体）。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆像一棵倒过来的树。堆是一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。由于堆的这个特性，常用来实现优先队列，<font color="#DC143C">堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。<strong>（自由度大）</strong></font><br></p><p>#<strong>内存中的的栈和堆:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存中的栈区处于相对较高的地址以地址的增长方向为上的话，栈地址是向下增长的。栈中分配局部变量空间。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DC143C">堆区是向上增长的用于分配程序员申请的内存空间。</font>另外还有静态区是分配静态变量，全局变量空间的；只读区是分配常量和程序代码空间的；以及其他一些分区。<br><br><br><strong>来看一个网上很流行的经典例子：</strong><br></p><p><pre><code><br>main.cpp<br>int a = 0; 全局初始化区<br>char <em>p1; 全局未初始化区<br>main()<br>{<br>    int b; 栈<br>    char s[] = “abc”; 栈<br>    char </em>p2; 栈<br>    char <em>p3 = “123456”; 123456\0在常量区，p3在栈上。<br>    static int c =0； 全局（静态）初始化区<br>    p1 = (char </em>)malloc(10); 堆<br>    p2 = (char <em>)malloc(20); 堆  //自由度高<br>}<br></em></code></pre><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于栈的大小有限，所以用子函数还是有物理意义的，而不仅仅是逻辑意义。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈： 在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，<em>*在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，</em>也就是主函数中的下一条指令，程序由该点继续运行。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在计算机领域，堆栈是一个不容忽视的概念，我们编写的C语言程序基本上都要用到。但对于很多的初学着来说，堆栈是一个很模糊的概念。堆栈：一种数据结构、一个在程序运行时用于存放的地方，这可能是很多初学者的认识，因为我曾经就是这么想的和汇编语言中的堆栈一词混为一谈。我身边的一些编程的朋友以及在网上看帖遇到的朋友中有好多也说不清堆栈，所以我想有必要给大家分享一下我对堆栈的看法，有说的不对的地方请朋友们不吝赐教，这对于大家学习会有很大帮助。&lt;/strong&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySql基本操作</title>
    <link href="http://yoursite.com/2017/10/14/MySql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/10/14/MySql基本操作/</id>
    <published>2017-10-14T12:45:11.000Z</published>
    <updated>2017-10-22T11:22:33.040Z</updated>
    
    <content type="html"><![CDATA[<p>#数据库简介：<br><br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库(Database)是按照数据结构来组织、存储和管理数据的仓库，它产生于距今六十多年前，随着信息技术和市场的发展，特别是二十世纪九十年代以后，数据管理不再仅仅是存储和管理数据，而转变成用户所需要的各种数据管理的方式。数据库有很多种类型，从最简单的存储有各种数据的表格到能够进行海量数据存储的大型数据库系统都在各个方面得到了广泛的应用……</strong><br><a id="more"></a></p><ul><li><strong>第一部分：创建数据库及其使用</strong><ul><li><font color="#DC143C">1)创建数据库：  <strong>Create database [数据库名字];</strong></font></li><li><font color="#DC143C">2)使用数据库：  <strong>Use [数据库名];</strong></font></li><li><font color="#DC143C">3)查看数据库：  <strong>Show databases;</strong></font></li><li><font color="#DC143C">4)查看正在使用的数据库：<strong>select database();</strong></font><br><br><img src="https://i.imgur.com/aPE9qWN.png" alt=""><br><br></li></ul></li></ul><hr><ul><li><strong>第二部分：数据表的创建和使用</strong><ul><li><font color="#DC143C">1)数据表的创建：<strong>create table [表名]（列名 类型名，………）;</strong></font><br><img src="https://i.imgur.com/u6VhVYW.png" alt=""><br><img src="https://i.imgur.com/WXrp6DT.png" alt=""><br><img src="https://i.imgur.com/Z2E3xvd.png" alt=""></li><li><font color="#DC143C">2)外键约束：<strong>foreign key【（属性）】 references 【字表名】【（属性名）】;</strong></font><br><img src="http://oxnvtxe03.bkt.clouddn.com/4.png" alt=""><br><img src="http://oxnvtxe03.bkt.clouddn.com/5.png" alt=""></li><li><font color="#DC143C">3)数据表的查看：<strong>show tables；</strong></font></li><li><font color="#DC143C">4)查看表中每一列的元素：  <strong>show columns from【数据表名】;</strong></font><br><img src="http://oxnvtxe03.bkt.clouddn.com/6.png" alt=""></li><li><font color="#DC143C"> 5）建立索引: <strong>create unique/cluster index [索引名] on [表名][(列名，asc、desc)；</strong></font><br><img src="http://oxnvtxe03.bkt.clouddn.com/1.png" alt=""><br><br></li></ul></li></ul><hr><ul><li><strong>第三部分：数据表的修改：</strong><ul><li><font color="#DC143C"> 1）增加列: <strong>alter tabele [表名] add [属性/列名] 数据格式 【first/after+[列名]】</strong></font><br><img src="http://oxnvtxe03.bkt.clouddn.com/2.png" alt=""></li><li><font color="#DC143C"> 2）删除列：<strong>alter table [表名] drop<br>column [列名];</strong></font><br><br><img src="https://i.imgur.com/wPEr183.png" alt=""></li><li><font color="#DC143C"> 2) 修改列的属性:   <strong>alter table [表名] alter column [列名][数据类型]</strong></font></li><li><font color="#DC143C"> 给列添加主键约束:   <strong>alter table [表名] add  primary key/ unique key([列名]);</strong></font><br><img src="http://oxnvtxe03.bkt.clouddn.com/1111.png" alt=""><br><img src="http://oxnvtxe03.bkt.clouddn.com/1111.png" alt=""> </li><li><font color="#DC143C"> 3)删除默认约束：<strong>alter table [表名] alter [列名] drop default;</strong></font><br><img src="http://oxnvtxe03.bkt.clouddn.com/7.png" alt=""></li><li><font color="#DC143C"> 4)删除主键约束：<strong>alter table [表名] drop primary key;</strong></font><br><img src="http://oxnvtxe03.bkt.clouddn.com/8.png" alt=""></li><li><font color="#DC143C">5)删除唯一约束:<strong>alter table [表名] drop index [列名];</strong></font><br><br><img src="http://oxnvtxe03.bkt.clouddn.com/10.png" alt=""></li><li><font color="#DC143C">6)删除外键约束：<strong>alter table [表名] drop foreign key [约束名称，通过show create table [表名查看];</strong></font><br><img src="http://oxnvtxe03.bkt.clouddn.com/11.png" alt=""><br><img src="http://oxnvtxe03.bkt.clouddn.com/12.png" alt=""><br><img src="http://oxnvtxe03.bkt.clouddn.com/13.png" alt=""></li><li><font color="#DC143C">7)删除表:   <strong>drop table [表名];</strong></font><br><br><img src="http://oxnvtxe03.bkt.clouddn.com/14.png" alt=""><br><br></li></ul></li></ul><hr><ul><li><strong>第四部分：对数据的修改：</strong><ul><li><font color="#DC143C"> 1)插入全部数据：<strong>insert 【数据表名】values(数据1，数据2……)；</strong></font><br><br><img src="http://oxnvtxe03.bkt.clouddn.com/15.png" alt=""></li><li><font color="#DC143C"> 2)插入部分数据：<strong>Insert [数据表名]（属性名1，属性名2……）values(数据1，数据2);</strong></font><br><img src="http://oxnvtxe03.bkt.clouddn.com/16.png" alt=""></li><li><font color="#DC143C"> 3)修改数据：<strong>Insert [数据表名] set (列名1)=（表达式1）………；</strong></font><br><img src="http://oxnvtxe03.bkt.clouddn.com/17.png" alt=""></li><li><font color="#DC143C"> 4)复制表的数据：</font><br><br><img src="http://oxnvtxe03.bkt.clouddn.com/23.png" alt=""><br><img src="https://i.imgur.com/BMfOmdw.png" alt=""></li><li><font color="#DC143C"> 5)更新数据表单的数据：<strong>update table [数据表名] set [表达式]  where [条件] (条件语句为可选语句)</strong></font><br><img src="http://oxnvtxe03.bkt.clouddn.com/19.png" alt=""><br><img src="http://oxnvtxe03.bkt.clouddn.com/18.png" alt=""></li><li><font color="#DC143C"> 6)删除元组：<strong>delete from [表名] where[条件]</strong></font><br><br><img src="http://oxnvtxe03.bkt.clouddn.com/22.png" alt=""><br><br></li></ul></li></ul><hr><ul><li><strong>第五部分：查询语句：</strong><ul><li><font color="#DC143C"> 1)查询记录： <strong> select * from 【数据表名】;</strong></font><br><br><img src="http://oxnvtxe03.bkt.clouddn.com/20.png" alt=""> </li><li><font color="#DC143C"> 2）多表查询： <strong>select [表名].[列名]….from [数据表名]；</strong></font><br><img src="http://oxnvtxe03.bkt.clouddn.com/24.png" alt=""></li><li><font color="#DC143C"> 3)定义别名：<strong>select 【列名】as [别名] from [表名]；</strong><br><img src="http://oxnvtxe03.bkt.clouddn.com/25..png" alt=""></font></li><li><font color="#DC143C"> 4) 条件查询： <strong>select 【查询内容】from 【数据表名】where 【条件表达式】;</strong></font><br><img src="http://oxnvtxe03.bkt.clouddn.com/26.png" alt=""></li><li><font color="#DC143C"> 5） 分组：<strong>select 【查询内容】from 【数据表名】group by [列名表达式]</strong><br><img src="https://i.imgur.com/BVBjrbh.png" alt=""></font></li><li><font color="#DC143C"> 6）having语句：<strong>select 【查询内容】from 【数据表名】group by [列名表达式] having 【条件】</strong><br><img src="https://i.imgur.com/U3N8EHO.png" alt=""></font></li><li><font color="#DC143C"> 6）order by语句：<strong>select 【查询内容】from 【数据表名】order by [列名表达式]</strong><br><img src="https://i.imgur.com/e48tUT2.png" alt=""></font></li><li><font color="#DC143C"> 6）having语句：<strong>select 【查询内容】from 【数据表名】limit n(,m)</strong><br><img src="https://i.imgur.com/UzudAAh.png" alt=""><br><img src="https://i.imgur.com/mchgJk2.png" alt=""><br><br></font></li></ul></li></ul><hr><ul><li><strong>第六部分：高级查询语句</strong><ul><li><font color="#DC143C">子查询：<ul><li>不相关子查询：<ul><li>1.子查询语句不能使用order by。</li><li>2.内层查询不依赖外部查询。</li><li>3.子查询并不显示结果，只是返回给外部查询</li><li>4.返回多个结果可以用any或者all来表示。</li><li>5.也可以使用聚合函数（max，min等）。</li><li>6.谓词表和谓词和聚集函数及in谓词的等价关系<br><img src="https://i.imgur.com/1QiNhwo.png" alt=""><br><img src="https://i.imgur.com/3afujFC.png" alt=""></li><li>例子1：（in或者not in）<br><img src="https://i.imgur.com/fQQL2nH.jpg" alt=""></li><li>例子2： （比较运算符）<br><img src="https://i.imgur.com/J98u6i6.jpg" alt=""></li><li>例子3：  (谓词和聚集函数)<br><img src="https://i.imgur.com/FdpTiEX.jpg" alt=""></li></ul></li><li>相关子查询：<ul><li>依赖于外层查询</li><li>执行时子查询需要不断引用父查询中的列值</li></ul></li><li>Exists：<ul><li>子查询不返回具体数值，只返回逻辑值 </li><li>select 属性列表达式用*表示，因为exists不具有实际意义<br><img src="https://i.imgur.com/80mFy02.jpg" alt=""><br><br></li></ul></li></ul></font></li></ul></li></ul><hr><ul><li><strong>第七部分</strong><ul><li>新建视图： <strong>create view [视图名]（属性列）[select 子查询] with check option</strong><br><img src="https://i.imgur.com/7LDi4uv.png" alt=""><br><img src="https://i.imgur.com/mlqY7Jc.png" alt=""></li><li>删除视图：<strong>drop view [视图名]</strong><br><img src="https://i.imgur.com/PxuAVjI.png" alt=""></li><li>查询视图信息： <strong>与表一致</strong><br><img src="https://i.imgur.com/Tk4KWkz.png" alt=""></li><li>更新数据与表一致。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#数据库简介：&lt;br&gt;&lt;br&gt;&lt;strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;数据库(Database)是按照数据结构来组织、存储和管理数据的仓库，它产生于距今六十多年前，随着信息技术和市场的发展，特别是二十世纪九十年代以后，数据管理不再仅仅是存储和管理数据，而转变成用户所需要的各种数据管理的方式。数据库有很多种类型，从最简单的存储有各种数据的表格到能够进行海量数据存储的大型数据库系统都在各个方面得到了广泛的应用……&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>安全杂项例题</title>
    <link href="http://yoursite.com/2017/10/14/%E5%AE%89%E5%85%A8%E6%9D%82%E9%A1%B9%E4%BE%8B%E9%A2%98/"/>
    <id>http://yoursite.com/2017/10/14/安全杂项例题/</id>
    <published>2017-10-14T09:02:11.000Z</published>
    <updated>2017-10-22T05:59:34.530Z</updated>
    
    <content type="html"><![CDATA[<p>#安全杂项简介：<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>ISC即安全杂项，题目涉及流量分析、电子取证、人肉搜索、数据分析、大数据统计等等，覆盖面比较广，主要考查参赛选手的各种基础综合知识。本系列课程中你可以学到各种编码解码，社会工程学，流量分析，日志分析等知识。</strong><a id="more"></a></p><p>#例1：<br><br><strong>1.题目来源：<a href="http://http://www.shiyanbar.com/ctf/1887" target="_blank" rel="external">http://http://www.shiyanbar.com/ctf/1887</a></strong><br><br><strong>2.解题思路：</strong> </p><ul><li><p>步骤：</p><ul><li>1.得到一个kungfu.rar的包</li><li>2.在Ubuntu下跑得到一个png的图片<br> <img src="http://oxnvtxe03.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20171013215859.png" alt=""></li><li>3.把文件格式改为png</li><li>4.得到这样的图片，有hexedit打开，文件末尾出现字符<font color="#DC143C">“VF95c0s5XzVyaGtfX3VGTXR9M0Vse251QEUg”</font></li><li>5.发现这是一个基于base64编码的字符</li><li>6.通过解base64编码：得到<font color="#DC143C">“T_ysK9_5rhk__uFMt}3El{nu@E”</font>字符串</li><li>7.根据经验两个括号方向相反，得知这是栅栏密码</li><li>8.解栅栏密码得<font color="#DC143C">“Th3_kEy<em>ls</em>{Kun9Fu_M@5tEr}”</font></li><li>9.坑爹得是，提交括号里面的就行！<br><br></li></ul><hr><p>#例2：<br><br><strong>1.题目来源:<a href="http://http://www.shiyanbar.com/ctf/1886" target="_blank" rel="external">http://http://www.shiyanbar.com/ctf/1886</a></strong><br><br><strong>2.解题思路:</strong> </p></li><li><p>步骤：</p><ul><li>1.打开连接<a href="http://ctf5.shiyanbar.com/423/misc/code.txt" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/misc/code.txt</a>看到一群字符，得知这是base64编码。</li><li>2.如图所示：<br><img src="https://i.imgur.com/1ddK7Np.png" alt=""></li><li>3.利用base64解码：得到如下的东西<br><img src="https://i.imgur.com/oZhypVt.png" alt=""></li><li>4.这是二维码，但是我生成不了图片，所以在网上找到一个教程，得到如下的图片<br><img src="http://oxnvtxe03.bkt.clouddn.com/156462156066504801.png" alt="">)</li><li>5.扫描二维码即可。</li><li>备注：参照wp：<br><a href="http://www.shiyanbar.com/ctf/writeup/2661" target="_blank" rel="external">http://www.shiyanbar.com/ctf/writeup/2661</a><br><br></li></ul></li></ul><hr><p>#例3<br><strong>1.题目来源：<a href="http://www.shiyanbar.com/ctf/1879" target="_blank" rel="external">http://www.shiyanbar.com/ctf/1879</a></strong><br><br><strong>2.解题思路：</strong></p><ul><li>步骤：<ul><li>1.下载为zip文件，通过binwalk测试不存在隐写</li><li>2.打开出现密码，没办法只能跑，开始是暴力破解的方式，后来采用字典的形式跑出来结果：<br><img src="http://oxnvtxe03.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20171015194747.png" alt=""></li><li>3.得到图片，查看属性，得知flag。<br><br></li></ul></li></ul><hr><p>#例4<br><strong>1.题目来源：<a href="http://www.shiyanbar.com/ctf/1860" target="_blank" rel="external">http://www.shiyanbar.com/ctf/1860</a></strong><br><br><strong>2.解题思路：</strong></p><ul><li>步骤：<ul><li>1.下载zip，打开，出现一个txt文件，里面写的坐标，联系到题干，就容易想到这些坐标可能就是一个一个的像素点。</li><li>2.抄袭抄袭抄袭，我们猿类的事情能叫抄袭么？</li><li>3.写出一个py脚本：<br><br><img src="http://oxnvtxe03.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20171016205833.png" alt=""></li><li>4.得到一个图片，扫扫就行！<br><br><img src="http://oxnvtxe03.bkt.clouddn.com/img%252FOEErd2swdmxqZW5Ha252U2d2U1JvQllHdytib3FqQVRyR3hzRzg1cE16UmpDZ1p0Yi81UndnPT0.jpg" alt=""><br><br></li></ul></li></ul><hr><p>#例5<br><strong>1.题目来源：<a href="http://www.shiyanbar.com/ctf/1857" target="_blank" rel="external">http://www.shiyanbar.com/ctf/1857</a></strong><br><br><strong>2.解题思路</strong></p><ul><li>步骤：<ul><li>1.下载rar得到一个gif的文件，但是这个文件打不开，肯定改写了文件标志，使得软件无法读取，从网上找了一个gif的文件，修复标志头即可！<br><br><img src="https://i.imgur.com/bixIRO0.png" alt=""></li><li>2.得到gif图，本来我想用查图神器steg看看隐藏的信息！看了一遍没有发现！<br></li><li>3.脑洞来了，网上说记录小黄人走的信息，然后根据base64，得到flag！<br></li><li>4.利用Gifsplitter分解gif，然后根据如图的编号，记录编号的位置<br><br><img src="https://i.imgur.com/3p3hRgk.png" alt=""><br><br><br>记录编号：<br><br><img src="https://i.imgur.com/6giUfKi.png" alt=""><br></li><li>5.根据base64转化表得到flag<br><br><img src="https://i.imgur.com/3nNtigM.png" alt=""><br><br><img src="https://i.imgur.com/TKjmTH2.png" alt=""><br><br><img src="https://i.imgur.com/wBI07rc.png" alt=""><br><br><br></li></ul></li></ul><hr><p>#例6：<br><strong>1.题目来源：<a href="http://www.shiyanbar.com/ctf/1855" target="_blank" rel="external">http://www.shiyanbar.com/ctf/1855</a></strong><br><br><strong>2.解题思路：</strong></p><ul><li>步骤：<ul><li>1.得到两个txt文件，经过ubuntu的查看，发现都是32字节的文件<br><img src="https://i.imgur.com/95FLzfn.png" alt=""></li><li>2.脑洞：对他们进行异或操作。<br><br><img src="https://i.imgur.com/WmNCY1N.png" alt=""><br><br></li></ul></li></ul><hr><p>#例7：<br><strong>1.题目来源：<a href="http://www.shiyanbar.com/ctf/1851" target="_blank" rel="external">http://www.shiyanbar.com/ctf/1851</a></strong><br><br><strong>2.解题思路：</strong></p><ul><li>步骤:<ul><li>1.利用binwalk跑出，这是一个zip文件（错误思路：我直接用hex打开也能查到key，但是找不到下面所说的秘钥文件）</li><li>2.解压出来，得到一个公钥文件和一个秘钥文件。<br><img src="https://i.imgur.com/7hEsYjQ.png" alt=""></li><li>3.首先分析key文件。hex打开，发现这是一个base64加密的文件。解密得。<br><img src="https://i.imgur.com/GguGuNk.png" alt=""></li><li>4.根据百度答案，nicki的歌名为anaconda（蛇）</li><li>5.最难的是，没接触过加密算法不知道有一个serpent这个加密算法，百度了一下。<br><img src="https://i.imgur.com/rcc9fok.png" alt=""></li><li>6.找到一个serpent的解密网站<br><img src="https://i.imgur.com/qUjdIbS.png" alt=""><br><br></li></ul></li></ul><hr><p>#例8：<br><strong>题目来源：<a href="http://www.shiyanbar.com/ctf/1850" target="_blank" rel="external">http://www.shiyanbar.com/ctf/1850</a></strong><br><br><strong>解题思路：</strong></p><ul><li><p>步骤：</p><ul><li>1.放到ubuntu里面binwalk去跑。<br><img src="https://i.imgur.com/nY4BHfv.png" alt=""></li><li>2.发现这是很多个gzip压缩包构成</li><li>3.我们用binwalk的解压参数，对其进行解压缩操作<br><img src="https://i.imgur.com/m3zndVw.png" alt=""></li><li>4.查看属性是gzip属性，把文件格式换成zip继续解压，然后用hex打开</li><li>5.得到以下<br><img src="https://i.imgur.com/DZYnRa7.png" alt=""></li><li>6.由此，我们知道每个文件对应的是一个字符。</li><li>7.利用python，不断地去解压和读取十六进制字符可以得到flag。</li><li>注：binwalk的具体用法如下：<br><img src="https://i.imgur.com/s0AWbZG.png" alt=""><br><br></li></ul></li></ul><hr><p>#例10：<br><strong>题目来源：<a href="http://www.shiyanbar.com/ctf/1844" target="_blank" rel="external">http://www.shiyanbar.com/ctf/1844</a></strong><br><br><strong>解题思路：</strong></p><ul><li>步骤：<ul><li>1.音频文件，试听发现双音轨，且存在一条音道是摩尔斯电码。</li><li>2.上神器AU，打开发现：真的存在摩尔斯电码的脉冲形式。<br><img src="https://i.imgur.com/t0eLACH.png" alt=""></li><li>3.根据摩尔斯密码表，长的为-，短的为·，得到电码为：<br><img src="https://i.imgur.com/iqrSaGI.png" alt=""></li><li>4.flag是：MUZIKISG00D<br><br></li></ul></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#安全杂项简介：&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;ISC即安全杂项，题目涉及流量分析、电子取证、人肉搜索、数据分析、大数据统计等等，覆盖面比较广，主要考查参赛选手的各种基础综合知识。本系列课程中你可以学到各种编码解码，社会工程学，流量分析，日志分析等知识。&lt;/strong&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
